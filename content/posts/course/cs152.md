---
title: "课程笔记：cs152（计算机体系结构）"
tags: ["Course"]
categories: ["Course"]
date: 2024-04-05T19:28:12+08:00
---

## CISC的发展到RISC诞生

- 1940-1950
  - 冯诺依曼架构被提出：以存储器为中心，软件和硬件的设计分离，减少了系统中的硬连接，实现了可编程的计算机！
  - 用户程序（二进制指令）被存储到存储器中。存储器的容量，几k字，不能放下很大的程序。
  - 存储器有CRT磷光线存储器（支持随机存储），磁芯（Core memory）（[磁芯存储：统治存储领域20年 - 知乎](https://zhuanlan.zhihu.com/p/144628785)）。
- 1960-1970
  - PDP-6典型设计，16个通用寄存器，SP+FP，ISA逐渐变得复杂
  - 此时人们用汇编指令写程序，认为每个常见操作都应该实现为一条特殊的指令（三角函数、CRC...）。**（？？？与ROM和RAM的速度差异有关吗）**
  - 这么多种类的指令硬连线的方式太复杂 ==> 微码
  - 微码ROM是一张表：ISA指令和微操作之间的映射，一条指令对应多个微操作
  - 有了微码，创造一条新的指令很容易，使用不同微操作的组合即可
- 1980
  - 高级语言和编译器来了，不用再手写指令
  - 编译器很难利用到这么多复杂的指令，生成的汇编代码常用几条指令占95%，大量的不常用指令占据了微码ROM。
  - 发明出基于Mos的SRAM，比原先的快2-10倍！**？？？所以呢**
  - CISC不适合与流水线
    - decode时间不一致，边decode边取指，不确定的时间段
    - 寻址模式多，容易引发数据竞争，而且不容易检测

## 流水线 Pipeline
RISC的架构中出现的，旨在提高处理器处理效率，**争取在一个时钟周期中完成一条指令（CPI=1）**。

{{< notice tip CPI指标的意义 >}}
CPI 总是衡量大量指令的平均结果，单讨论一两个指令的CPI是没有意义的

Pipeline CPI计算：从第一条指令结束到最后一条指令结束的周期数/指令数

{{< figure src="/cs152_cpi.png" width="70%" >}}
￼
PS：为什么不从第一条指令的开始进行计算？==> 因为通常有大量的指令（百万），所以第一条指令开始到结束的时间段没什么实际意义，影响不大。
{{< /notice >}}


最经典的当属MIPS(无内部互锁的流水线处理器)的五级流水线技术。MIPS体系结构本身就是为了流水线而设计的，每条指令的执行过程都分成五级。每一级成为一个流水线阶段，每个阶段占用固定的时间，通常是一个时钟周期。

{{< notice info >}}
像是取指、访存阶段都比较耗时，超过了一个时钟周期。
{{< /notice >}}

{{< figure src="/cs152_mips.jpg" width="90%" >}}

有的微架构就使用超长的流水线（多级），将指令阶段进一步细分，有助于增加并行度。
但是呢，阶段分的太细，在微架构层面会比较复杂，因为各个阶段之间需要发送信号，会浪费一些时间。

### 数据竞争的三种解决方案

1. 等待。其他竞争的指令等着当前指令执行完再执行。
2. Bypass。需要额外硬件，
3. 预测。需要额外硬件，先猜一个值，如果错了再刷新流水线重退。

## 异常 Exception

流水线的各个阶段都会产生异常，怎么设计？

难道在每个时钟周期都检测流水线中有无异常吗？显然不行，因为假设指令B在Decode阶段产生了异常，如果此时就认定指令B触发异常。但殊不知上一条指令A会在回写阶段也触发异常。
而一般来说，按照程序员的视角我们认为指令一条一条的执行，所以也希望异常按照指令顺序产生。

进而，就提出了**在流水线的最后【提交】阶段才检查异常**。
- 流水线中多了3个额外的寄存器用于标记每个阶段是否产生异常。
- 前面指令产生的异常标记可以覆盖后面指令。这就使得异常按照指令顺序产生。
- 若一条指令在前面阶段已经产生异常，后续阶段Bubble。
- 在最后提交阶段之前，会检查是不是有异常或者异步中断？（如果两者都有，实现定义）之后下一个PC就是异常向量。

{{< figure src="/cs152_pipeline_exception.jpg" width="90%">}}