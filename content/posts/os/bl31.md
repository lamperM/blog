---
title: "ATF 解读：中断"
tags: ["Operating System"]
categories: ["Operating System"]
date: 2024-07-22T19:28:12+08:00
---

BL31 位于 EL3 安全世界， 提供运行时服务，并不像 BL1 和 BL2 一样 boot 后就释放空间，其他的子系统通过 SMC 调用向 BL31 发送请求，包括安全世界的切换。

BL31 不是必须得，如果实际没有实现 EL3，或者不需要 Secure Monitor，则可以不用 BL31.

## GIC 初始化

默认配置 GIC，其中 GIC 有一些配置在 secure state 才能配置，所以在这里配一下。

BL31 中，每个 platform 都有一个分配中断分组的全局变量`qemu_interrupt_props`（以 QEMU 为例），在 BL31 中可以将一些中断划分为 G1S 或 G0。当然，我猜测 BL32 也可以重设，毕竟 BL32 也要设定一些特殊中断，比如说安全 uart。

## EHF
配置完GIC后，紧接着就是可选的EHF功能。
默认 ATF 中关中断，这个我们可以想想，EL31负责安全世界的切换，有点像处于异常处理上下文中，也没有什么中断需要触发，所以关中断也是合理的。

EHF通过编译选项 `EL3_EXCEPTION_HANDLING` 控制开关，EHF 的功能就是让 EL3 能处理其他中断（除了原本的SMC）。EL3能处理中断的原理是利用 `SCR_EL3.IRQ/FIQ`，置1之后，IRQ/FIQ会被路由到EL3处理，原本的默认情况是在自己触发中断的EL处理。

EHF 的全称是 Exception Handling Framework，既然是 Framework，一个框架，就是提供注册的接口。
其他的子模块填充一个 `intr_type_descs` 成员，它是一个数组
- 下标type代表想要运行在哪个状态的中断Trap到EL3？是SEL1？EL3？还是Non-secure
- 我们知道，每种type下，都有三种类型的中断（G0、G1S、G1NS），有时我们只想让EL3 handle其一，或者都。
- EHF提供的粒度是IRQ和FIQ。知道当前运行的type，和你想要trap EL3的中断分组，就能唯一得到中断是IRQ/FIQ。
- 所以你可以单独设计这个IRQ/FIQ是否Trap，来达到你想要只trap一种分组的目的。当然这不是一一对应的，IRQ可能对应多个中断分组，这是没办法的事情。只能人为做更加严格的中断分组。
- 配置完成后，框架会将IRQ和FIQ置位的情况（成员 `scr_el3[2]`) 汇总，存到上下文中，返回时到该type时恢复。

```c
typedef struct intr_type_desc {
    interrupt_type_handler_t handler;
    u_register_t scr_el3[2];  // 2 => 两种安全状态下的scr_el3
    uint32_t flags; // bit[0]: routing model for interrupt from not EL3 but secure state
                    // bit[1]: routing modul for interrupt from not EL3 but non-secure state
                    // '1' => this interrupt will be routed to EL3
                    // '0' => this interrupt will be routed to current EL
} intr_type_desc_t;

#define INTR_TYPE_S_EL1			U(0)
#define INTR_TYPE_EL3			U(1)
#define INTR_TYPE_NS			U(2)
#define MAX_INTR_TYPES			U(3)
#define INTR_TYPE_INVAL			MAX_INTR_TYPES

static intr_type_desc_t intr_type_descs[MAX_INTR_TYPES];
```

ATF 中中断的注册(这三种类型的 handler 程序的注册)，以 INTR_TYPE_S_EL1 为例：

在开机 bl32_main 调用 opteed_setup()时，将 opteed_sel1_interrupt_handler()函数注册成了 INTR_TYPE_S_EL1 类型中断，同时也会将 REE(Linux)使用的 SCR_EL3.FIQ 配置成 1,也意味着当 CPU 运行在 REE 时，来了一个 secure group1 的中断，此中断在 REE 中被标记 FIQ 后将被 target 到 EL3，进入 EL3(ATF)的中断处理函数，也就是刚才注册的 opteed_sel1_interrupt_handler()函数，在该函数中，会将 cpu 切换到 TEE 中，去处理这个中断。这就是REE切换到TEE的一种方式。

{{< figure src="/interrupt_grp.jpg" caption="" attr="" attrlink="" width="70%">}}

由此我们再看 EHF 的实现原理。

```c
/*
    The ``flags`` field stores the routing model for the interrupt type in
    bits[1:0]. Bit[0] stores the routing model when execution is in the secure
    state. Bit[1] stores the routing model when execution is in the non-secure
    state. As mentioned in Section `Routing model`_, a value of ``0`` implies that
    the interrupt should be targeted to the FEL. A value of ``1`` implies that it
    should be targeted to EL3. The remaining bits are reserved and SBZ. The helper
    macro ``set_interrupt_rm_flag()`` should be used to set the bits in the
    ``flags`` parameter.
*/
// EL3 不是要处理中断吗，当SCR_EL3.IRQ/FIQ打开时，会进入EL3的异常处理函数，
// 现在要做的就是注入一个EL3的处理函数，在里面根据情况调用其他type的处理函数。
ehf_init()
    => set_interrupt_rm_flag(flags, NON_SECURE);  // flag | (1 << 1)
    => if SPMC is not present in S-EL2
        => set_interrupt_rm_flag(flags, SECURE); // flag | (1 << 0)
    => register_interrupt_type_handler(type=INTR_TYPE_EL3,,flags=flags)

register_interrupt_type_handler()
    => set_routing_model(INTR_TYPE_EL3, flags)

set_routing_model()
    => intr_type_descs[INTR_TYPE_EL3].flags = flags;
    // 两次调用分别将FIQ和IRQ的情况汇总到最终上下文中的SCR寄存器
    => set_scr_el3_from_rm(type=INTR_TYPE_EL3, flags, SECURE);
    => set_scr_el3_from_rm(type=INTR_TYPE_EL3, flags, NON_SECURE);

set_scr_el3_from_rm()
    // 看传入secure state在flag中对应的bit是1还是0
    => flag = get_interrupt_rm_flag(flags, security_state);
    // 计算SCR_ELx中对应secure state（FIQ/IRQ）的控制 bit
    => bit_ops = plat_interrupt_type_to_line(INTR_TYPE_EL3, security_state);

    => intr_type_descs[type].scr_el3[security_state] = (u_register_t)flag << bit_pos;
    /*
     * Update scr_el3 only if there is a context available. If not, it
     * will be updated later during context initialization which will obtain
     * the scr_el3 value to be used via get_scr_el3_from_routing_model()
     */
    =>  cm_write_scr_el3_bit(security_state, bit_pos, flag);

/*******************************************************************************
 * This function updates a single bit in the SCR_EL3 member of the 'cpu_context'
 * pertaining to the given security state using the value and bit position
 * specified in the parameters. It preserves all other bits.
 ******************************************************************************/
 cm_write_scr_el3_bit()
     => ctx = cm_get_context(security_state);
        scr_el3 = read_ctx_reg(state, CTX_SCR_EL3);
        scr_el3 &= ~(1UL << bit_pos);
        scr_el3 |= (u_register_t)value << bit_pos;
        write_ctx_reg(state, CTX_SCR_EL3, scr_el3);
```

## 运行时服务
