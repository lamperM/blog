---
title: "OS内核同步互斥机制 概述"
tags: ["Operating System"]
date: 2023-05-04T20:51:49+08:00
---

## 操作系统内核为何需要同步互斥机制

内核代码存在临界区，例如某个对内存区域的**引用计数**操作，或者对
调度队列的修改操作。

操作系统 必须保证当一个进程（内核进程）在临界区时不会有其他人（或者自己，
当被中断时）再去操作临界资源。

对于单 CPU 系统来说，保证上述行为的方式很简单: 关中断+关内核抢占

- 关中断能够保证，不会发生当一个内核进程正在操作调度队列时，发生中断
  ，恰好中断服务函数也会访问调度队列。
- 关内核抢占能够保证，不会发生当一个内核进程正在操作调度队列时，发生
  中断，中断返回时切换到了别的进程，这个进程的内核态也去操作了调度队列。

多 CPU 情况下，问题就变得负责，就需要配合各种同步互斥机制来实现上述行为要求。

## 常见的同步互斥机制

### per-cpu 变量

- 优点：多 CPU 之间互不干扰
- 缺点：
  - 要求逻辑独立， 极少数临界资源可以实现为 per-CPU 形式
  - 开内核抢占时仍有危险，因为不同进程可能在一个 CPU 上，
    使用同一个 per-cpu 变量

> per-cpu 变量通常被安排在不同的 cache line，避免 cache 的频繁刷新

### 原子操作

解决多个 CPU 同时修改一个内存值时出现覆盖的问题，当然，单 CPU 没必要用原子操作。

使用原子操作能够保证: 同时执行读操作总会有一个 CPU 先占据总线，此时将总线上锁，其他
CPU 的读写只能等待占领的 CPU 写入彻底完成后。

> [AArch64 实现原子操作]()

### 屏障

仅使用屏障不能直接保证同步，但是需要同步互斥机制都要用到屏障。
比如实现原子操作需要`ldrx`和`strx`组合（虽然有新的 CAS 指令, 暂不考虑）
，但 ARM 架构中编译器会 reorder 指令，CPU 会乱序执行。如果 `strx`在`ldrx`
之前执行了， 那么原子操作就必然不能实现。

架构支持的各类屏障用于解决这些问题。

#### 优化屏障

优化屏障是指在使用内敛汇编时的，`volatile`和`"memory"`关键字，如下示例:

```c
asm volatile("":::"memory");
```

- `volatile` 向**编译器**说明禁止内敛的语句与其他语句 reorder。但不能保证内部 reorder，
  那是下面*内存屏障*的任务
- `"memory"` 向**编译器**说明对于所有内存访问操作，不能使用 asm 之前预加载到寄存器中的值
  ，而必须在 asm 内部重新加载。保证其内部访问内存值具有可见性和正确性。

#### 内存屏障

类似于防火墙，保证：屏障之后的指令开始执行前，屏障之前的指令都已执行完毕！

在 ARMv8 架构中，还将内存屏障进行细分:

- ISB: 之后的指令重新 **fetch**, 常用于例如权限修改后，某些寄存器的读取指令就
  可能是非法的
- DMB: 防止**数据相关**的指令 reorder 越过 barrier 先执行
- DSB: DMB 的升级版，不只是数据相关指令，而是防止任何指令 reorder 越过 barrier 先执行

### 加锁

进入临界区时，加锁。 常使用的锁包括：

1. 自旋锁
2. 读写锁
3. 顺序锁
4. RCU

### 信号量

与锁类似且相对应:

1. 二值信号量 - 自旋锁
2. 读写信号量 - 读写锁
3. ...

区别是：进程若获取不到信号量，不会死等，而是被睡眠。

## 如何选择合适的同步互斥机制

(1) **避免使用自旋锁**: 获取不到锁的 CPU 会一直死等，浪费 CPU 资源

(2) 若临界区仅仅是一个共享的整数变量操作，那么用**原子操作**即可完成，不需要复杂的锁。
例如各类数据结构的引用计数通常声明为 `atomic_t`。
