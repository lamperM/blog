---
title: "Linux 进程地址空间 堆的管理"
tags: ["Operating System"]
categories: ["TODO"]
date: 2023-05-08T10:51:49+08:00
---

当进程被创建时，就预留了一块特殊的线性区，其开始地址和结束地址单独保存在
`mm_struct.start_brk`和`mm_strcut.brk`成员中，并不由`vm_area_struct`
链接，这块特殊的线性区就叫堆。

进程使用的`malloc()`和`free()`等相关 API 都是操纵的堆空间。

## 修改堆空间的接口

对用户态进程来说，提供`brk()`系统调用来修改自身的堆空间。

`brk()`: 参数`addr`, 效果是修改`mm_struct.brk`到 addr，即修改一个堆的结束地址。

`brk()` 系统调用的实现，在内核态是调用`do_mmap()`扩充堆，或者`do_unmap()`缩小堆。
并且移动`mm_struct.brk`的值而已，这是 `brk()`的实现。

> 用户态进程还有一个接口: `sbrk()`, 参数是字节，代表扩充的字节数。
> 其下层还是调用的 `brk()`。

## `malloc()`的实现

进程刚创建时，堆空间的大小为 0， 即`bkr`==`start_brk`。

调用`malloc()`，即对堆空间扩充，上面介绍了修改堆空间的接口，
所以我们可以使用`brk()`来实现`malloc()`.

对于进程本身来说，只能通过`brk()`简单的增加/减少堆的总大小，这样做的效率是比较低的。
比如连续执行了三次`malloc()`, 如果要将中间的地址 free 掉，其实是无法实现的。

而且这种最简单的情况下，每次`malloc()`都要使用`brk()`系统调用，效率也是很低的。

所以，通常在 C 库则一层，即`malloc()`和`brk()`之间，会有一层对堆内存的管理，
包含碎片回收，内存池等算法来避免频繁的使用系统调用。
