---
title: "OS信号 概述"
tags: ["Operating System"]
date: 2023-05-05T20:51:49+08:00
---

信号是内核通知用户态进程的一种方式，也可用于用户进程间**相互通知**。

我更愿称其为通知而不是通信，因为目标进程只能知道信号的 ID，发送方不能
附带更多的信息。

## 为什么要引入信号?

使用户态进程能够知道系统中某些事件发生了。

例如，系统定时器时间到会产生`SIGALRM` 信号，用户态程序可以捕获此信号做一些事。

当然有些信号的产生可能不会“轮到”用户态感知，比如`SIGKILL`信号，由
内核直接将进程给杀死。 但无论怎么说，**都是一种提醒该进程某件事发生了，
你该做点什么了的方式**。

## 信号的两个阶段

信号的生命周期可分为两个阶段:

- 信号生成
- 信号被处理

下面会详细介绍两个阶段的实现原理，但总体上来说，
信号生成即更新目标进程的数据结构，代表某个信号产生了。

> 注意：信号可以发送给处理任何状态的进程，发送给非运行状态的信号由内核保存
> 知道进程恢复运行状态。
>
> 而且，目标进程只能同时有一个同种类型的信号处于挂起状态，也就是说，如果
> 上一个同种信号没有被处理，那么之后到来的同类信号会被**忽略**。

信号被处理可能有三种不同的方式: 忽略、执行默认行为或者调用自定义的 handler。

## 信号相关的数据结构

(1) 一个信号可能同时存在多个不同类信号处于挂起状态，所以需要队列来记录它们。
实际上需要两个: **进程组共享**和**进程私有**的挂起队列。
因为某些信号是发送给整个进程组的，比如`kill()`，而一些是指定某个进程的，
比如`tkill()`.

(2) 另外，tcb 中还需要记录所有信号的处理函数，缺省的和自定义。

> 所有的数据结构都记录在进程的 tcb 中。

## 信号的产生过程

信号可能来自内核或者其他进程，后者是通过**系统调用**的形式，故最终都会
转化为内核函数，操作目标进程的数据结构来实现信号发送。

详细来说就是项目标进程的挂起队列中插入一个项。

## 信号的处理过程

信号的整个处理过程包括：内核检查进程上是否有挂起的信号，若有则执行相应操作(忽略、缺省、自定义)。 以上描述对应内核函数`do_signal()`.

> 注意： 这个检查过程仅发生在目标进程将**返回用户态时**。

有一个问题是，自定义的信号处理函数是在用户态的, 而`do_signal()`是发生在
内核态，所以内核要做一些特殊的操作：

1. 创建一个临时的用户栈，不能破坏保存的原来用户态环境
2. ELR(返回地址) = 自定义处理程序，和其他的用户态环境构建
3. 返回用户态，CPU 会执行处理函数
4. 执行完毕后，通过之前对用户栈的特殊构建，使得程序接下来会运行一个 syscall
   (`sys_sigreturn`), 返回内核态
5. 如上述操作检查完所有挂起的信号
6. 当所有信号都被处理完成后，则恢复用户进程的原有环境，继续执行
