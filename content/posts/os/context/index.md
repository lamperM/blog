---
title: "操作系统——上下文切换"
date: 2022-11-14T22:13:06+08:00
tags: [Operating System]
---

















本文基于**AArch64**执行环境, 介绍现代操作系统中上下文切换的相关内容.

## 什么是上下文？



上下文又称“现场”, 



## 为什么需要上下文切换?

(TODO: 为什么说线程是调度的单位?)

现代操作系统中同时存在着成千上百个线程, 但是一个CPU同一时刻只能运行一个线程, 他们是轮流的占用CPU, 也叫并发执行.  (TODO: 如何查看线程切换的间隔?) 线程高频率的切换, 操作系统是如何保证切换到下一个执行的线程时, 它能够继续上次的工作呢?

### 什么是上下文?

我们正在看一本书的时候如果被其他的事情打断, 返回时为了能够从上次被打断的位置继续读, 就要在被打断的时候记下来当前是读到了哪个第几页的第几行. 

操作系统对待线程也是如此,   需要保存的用于恢复线程执行的信息就称为线程的上下文.

那么对于线程来说需要记下的内容有什么呢? 寄存器和栈即可. 拿AArch64架构来距离, 线程的上下文就是:

1. 通用寄存器`x0-x29`: 函数调用的参数, 某些计算过程的中间值, 都要用到这些寄存器. **线程的执行流可能在任何时候被打断**, 当然这些内容也不能丢. 
2. 通用寄存器`lr(x30)`: `lr` 保存着返回地址, 即当前函数结束之后该返回到哪执行.
3. 栈顶指针 `sp`: 栈的重要性无需多言. 但是需要说明的是我们保存栈的方式**并非将栈中的所有内容保存, 而是保存栈的位置**即可. 因为操作系统有别的机制(TODO), 能够保证即便线程不在执行, 属于该线程的栈也不会被破坏.
4. 程序计数器 `pc`: 被打断的线程如果再次执行, 从哪里执行呢? 显然是被打断指令的下一条(或者重新执行当前). 这个指令的地址当然也需要被保存好. 
5. PSTATE: 想一下, 有了以上的内容就能够保证线程完整的恢复之前的环境吗? 其他的例如中断是开还是关, 有哪些标志位(NZCV)被设置了. 这些信息在AArch64中是保存在PSTATE的各个字段中.

如果我们能够有一个适当的逻辑, 在线程切换出去的时候将上下文保存起来, 然后恢复新线程的上下文, 是不是线程切换这件事就能做到了. 如何组织这个保存和恢复的过程在下面会介绍到.





## Linux 如何处理上下文切换





## 另一种处理上下文切换的思路



## 协程的上下文

协程是用户级别的线程,

* 协程之间的切换不进入内核
* 切换协程只能是某个协程**主动放弃控制权**

我们在这里讨论一下协程切换时需要保存的上下文是否与线程有所不同. 

首先, PC一定属于, 这个毋庸置疑. 其次是栈顶指针sp, **每个协程都有单独的栈**, 如果不保存栈的位置, 那么协程内部定义局部变量就没法访问了(局部变量的访问指令都是以sp为base的偏移来做的).

另外, 关于通用寄存器, 由于协程的切换需要主动调用某个函数(通常叫做`yield()`), 在函数的最后将PC设置为新协程的上下文PC. 保存当前协程上下文的操作也在这个函数中, 而其参数我们并不关心, 即`x0`-`x7`没必要保存. 同样的, **caller-saved寄存器也是没必要保存的**, 因为这些寄存器作为函数调用使用的临时变量, 当再次返回该协程时, PC=yield()返回地址, caller如果关心这些寄存器应当自己执行保存和恢复. 但是**callee-saved寄存器必须要保存到上下文中**, 因为在yield()中, 我们如果修改了callee-saved寄存器, 就需要在返回时(也就是再次调度到该协程时) 恢复, 这是callee该做的, 也就是上下文中应该有的唯一通用寄存器组.



