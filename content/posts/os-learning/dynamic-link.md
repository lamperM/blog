---
title: "动态链接"
tags: [Operating system, Dynamic link, PIC]
categories: [Operating system]
date: 2022-06-26T19:50:45+08:00
---

## 静态链接带来的问题
1. 像是`libc`这种几乎每个程序都要用到的库, 如果是静态的, 那么不仅意外着每个程序的
可执行文件很大, 浪费磁盘空间. 并且当程序加载到内存时, 可能许多程序都会用到`printf`
, 使得内存中会存在好多份的`printf`源码. 

2. 维护和更新难. 一旦静态链接的其中一个目标文件更新, 所有的可执行程序都要重新链接.

3. 不满足局部性原理. 上面提到, 内存中同时存在多份的`printf`源码会破坏*局部性原理*的.
显然如果所有的程序共享一份`printf`源码的想法更好. 即动态加载.

4. 可移植性差. 静态链接, 只要有一个依赖目标文件的实现不同, 软件厂商就得专门发布一个
版本. 而动态链接则信赖客户电脑上的*动态库*, 相当于一个中间层.

&nbsp;
## 动态链接的过程
对比静态链接使用`ld`链接器在编译后即执行链接, 动态链接则是将链接过程推迟到**运行时**,
即装载到内存时.

这样, 链接器在链接产生可执行文件时就有两种做法: 
* 对于静态符号, 按照静态链接的规则进行*地址引用重定位*
* 对于动态符号, 链接器则仅标记其为动态链接中的符号, 不进行处理. 而是等到装载时由
专门的*动态链接器*来完成动态符号的链接工作.

:interrobang: 链接器如何确定一个符号是静态的or动态的?

在动态共享对象(*.so)中保存了完整的*动态符号表*, 表中存在的符号即为动态的, 否则为静态.

> Linux的C语言运行库`glib`的动态链接版本叫`libc.so`. 它在外存上只保存一份, 所有的程序
> 都可以在运行时使用它. 所以千万不要删掉它.

> 动态链接有一定的性能损失, 因为每次运行程序时都要重新链接, 并不像静态链接是一劳永逸的.
> 也有例如`延迟绑定`对性能进行优化的方法, 大概仅有5%的损耗, 与带来的便利相比可以忽略不计.


&nbsp;
## 地址无关代码 PIC

GCC生成动态库时需要添加参数`-fPIC`, 含义就是生成地址无关码

地址无关码的含义是代码中**不包含任何的绝对地址引用**, 全都是**相对地址**.

- 对于**模块内**的跳转/数据引用, 使用相对的跳转/加载指令. 例如ARM指令集中的`B`, `ADR`, 经过汇编器之后, 目标的地址都会转为相对于该指令(PC)的偏移.
- 对于**模块间**的跳转/数据引用, 借用*GOT表*来间接实现地址无关.

而如果该动态库中全部使用相对地址, 那么加载时也就不需要进行重定位, 即所有的程序都可以
共享这些地址无关代码.

> 上面说PIC的动态库不需要重定位其实是错误的, 只不过它的重定位过程不需要修改代码段,
> 而是设置了一个放置在数据段的*GOT*表来实现代码段部分的地址无关特性.

> 现在貌似GCC  ARM版本在编译动态库时强制使用-fPIC选项, 否则会报错. 对此我不是
> 非常确定!

> 一般来说, 不将主程序编译为地址无关码. 因为主程序不需要共享, 而且地址无关码的调用
> 需要两个指令: `计算地址` + `跳转`. 多了一步根据偏移得到绝对地址.
