<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ReadingNotes on BLOG</title><link>https://wangloo.github.io/categories/readingnotes/</link><description>Recent content in ReadingNotes on BLOG</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 01 Feb 2024 16:30:35 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/categories/readingnotes/index.xml" rel="self" type="application/rss+xml"/><item><title>读书笔记：现代Cpu性能分析与优化</title><link>https://wangloo.github.io/posts/reading-notes/perf_analysis/</link><pubDate>Thu, 01 Feb 2024 16:30:35 +0800</pubDate><guid>https://wangloo.github.io/posts/reading-notes/perf_analysis/</guid><description>性能测量 当估计实际程序的性能优化效果时，不建议去除系统中的不确定性行为。 任何性能分析功能——包括采样，都应该在与实际部署最接近的系统下进行。
测量开销是生产环境监控的一个重要问题。由于任何监控都会影响正在运行的服务的性能，因此应该使用尽可能轻量的性能剖析方法。论文（Renet al.，2010）中提到，“如果对正在提供真实服务的服务器进行持续的性能剖析，极低的性能开销是至关重要的”。通常可以接受总体不超过1%的开销，减少监控开销的办法包括限制被监控的机器数量和使用更小的监控时间间隔。
经典的递归计算斐波那契数列，是测量性能的一个好用例。
强烈建议不能只进行一次测试，而是多次运行基准测试，这样基线程序有N个测量值，改动过的程序也有N个测量值。我们需要比较两组测试结果以确定哪一个程序更快。这本身就是一项很难处理的工作，在很多情况下，我们会被测量数据误导而得出错误的结论。如果你向任何数据科学家征求意见， 他们都会告诉你不能依赖单一指标（如最小值、均值、中位数等）， 画出分布图是一种更好的方法。
由于测量的不稳定性，调试性能通常比调试功能更为困难。
Cpu微架构 流水线的灵感来自汽车装配线，将指令的处理分为几个阶段： 取指、译码、执行、访存、回写。几个阶段并行运行。
理想情况下，启用N级流水线后，机器的指令执行效率提升N倍。 实际会存在流水线冒险，包括结构冒险、数据冒险和控制冒险。
乱序执行主要用于避免因依赖引起的停顿而导致CPU资源利用率不足的问题。 指令的动态调整通过硬件结构（如计分板）和诸如寄存器重命名技术实现。
超变量：一个时钟周期内可以发射多条指令。TODO：什么是发射？ 发射宽度是在同一个时钟周期内可以发射的最大指令数。 目前Cpu的典型发射宽度为2~6。
Intel Itanium等架构使用一种称为超长指令字（Very Long InstructionWord，VLIW）的技术， 将调度超标量和多执行单元处理器的负担从硬件转移到编译器。 它的基本原理是要求编译器选择正确的指令组合使得机器被充分利用， 从而简化硬件。编译器可以使用软件流水线、 循环展开等技术来发掘更多的ILP机会， 因为硬件受制于指令窗口长度的限制，而编译器可以获得全局信息。
Cache写操作 在缓存中处理写操作更困难，CPU会使用不同的技术来处理这种复杂情况。 软件开发人员应该特别注意硬件支持的缓存写操作的流程，以确保代码性能最佳。
两种处理Cache写入命中的情况：
写直通（Write-Through）；写入Cache立即同步到低层次的存储结构。 回写（Write-Back）；写Cache当前只修改Cache，设置脏位。 推迟同步操作到该CacheLine被替换出Cache时。 两种处理Cache写入未命中的情况：
写分配（Write-Allocate）；先把该位置的数据加载到Cache， 在执行上方写命中的流程。 写未分配（No-Write-Allocate）；不使用Cache，直接对低层次存储进行修改。 性能分析中的术语 指令和数据都可能发生缓存未命中。根据TMA分析方法（见6.1节）， 指令缓存未命中被归类为前端停滞，数据缓存未命中被归类为后端停滞。 当获取指令时发生指令缓存未命中，会被归类为前端问题。
性能分析【指标】 性能指标：
IPC：IPC=INST_RETIRED / CPU_CYCLES，IPC并不能单独判断 是否性能比较好，比如说在某个处理器上，前端最多一个Cycle发射4 条指令，那么IPC是不是越接近4越好呢？其实不是，还要结合CPU 此时正在做什么事情，如果是死循环，那么就不代表什么。 Pipeline Stalls Stall Front-end rate=STALL_FRONTEND/CPU_CYCLES Stall Back-end rate=STALL_BACKEND/CPU_CYCLES Frontend Bound ITLB events I-Cache events Backend Bound DTLB events Memory System related events D-Cache events Retiring Instruct Mix Bad Speculation Branch Effectiveness events 性能分析方法 性能的问题可能出在前端，称为前端Stall，在后端时则称为后端Stall。</description></item></channel></rss>