<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on BLOG</title><link>https://wangloo.github.io/categories/python/</link><description>Recent content in Python on BLOG</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sun, 06 Oct 2024 19:28:12 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/categories/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Python：Pytest框架学习</title><link>https://wangloo.github.io/posts/python/pytest/</link><pubDate>Sun, 06 Oct 2024 19:28:12 +0800</pubDate><guid>https://wangloo.github.io/posts/python/pytest/</guid><description>Config Marker 使用 Marker 对用例分类 Maker 帮助我们对用例进行分类，区分不同的场景和平台。
# 使用 @pytest.mark.smoke 标记一个冒烟测试 @pytest.mark.smoke def test_login(): ... # 使用 @pytest.mark.integration 标记一个集成测试 @pytest.mark.integration class TestPaymentSystem: 一个用例支持有多个 Marker，比如说某个用例可能 smoke 和 dailybuild 都要跑，就可以为它指定两个 maker。
Pytest 运行时，通过 -m/ --maker 参数来指定本次测试的 marker 表达式。支持与或非的组合。
# 执行所有标记为 smoke 的测试 pytest -m smoke # 执行标记为 smoke 或 integration 的测试 pytest -m &amp;#34;smoke or integration&amp;#34; # 执行既非 slow 也非 integration 的测试 pytest -m &amp;#34;not slow and not integration&amp;#34; # 运行同时带有 unit 和 integration 的测试 pytest -m &amp;#34;unit and integration&amp;#34; # 复杂组合筛选 pytest -m &amp;#34;(system or integration) and not unit&amp;#34; #运行system或integration，且不运行带有unit的测试 代码中也可以修改 Marker。比如说在 config 里加了一个属性，有这个属性的情况下就自动加上一个 marker，这样就不用在运行命令参数里写两遍了。</description></item><item><title>Python：三方库</title><link>https://wangloo.github.io/posts/python/libs/</link><pubDate>Tue, 30 Jul 2024 19:28:12 +0800</pubDate><guid>https://wangloo.github.io/posts/python/libs/</guid><description>jinja2 要了解jinja2，那么需要先理解模板的概念。 python中自带一个简单的模板，就是string提供的。
&amp;gt;&amp;gt;&amp;gt; import string &amp;gt;&amp;gt;&amp;gt; a = string.Template(&amp;#39;$who is $role&amp;#39;) &amp;gt;&amp;gt;&amp;gt; a.substitute(who=&amp;#39;daxin&amp;#39;,role=&amp;#39;Linux&amp;#39;) &amp;#39;daxin is Linux&amp;#39; &amp;gt;&amp;gt;&amp;gt; a.substitute(who=&amp;#39;daxin&amp;#39;,role=&amp;#39;cat&amp;#39;) &amp;#39;daxin is cat&amp;#39; &amp;gt;&amp;gt;&amp;gt; Python自带的模板功能极其有限，如果我们想要在模板中使用控制语句，和表达式，以及继承等功能的话，就无法实现了。
目前主流的模板系统，最常用的就是jinja2和mako
jinja2是Flask作者开发的一个模板系统，之所以被广泛使用是因为它具有以下优点：
相对于Template，jinja2更加灵活，它提供了控制结构，表达式和继承等。 相对于Mako，jinja2仅有控制结构，不允许在模板中编写太多的业务逻辑。 相对于Django模板，jinja2性能更好。 Jinja2模板的可读性很棒。</description></item></channel></rss>