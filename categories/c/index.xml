<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C on BLOG</title><link>https://wangloo.github.io/categories/c/</link><description>Recent content in C on BLOG</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 22 Dec 2023 18:51:49 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/categories/c/index.xml" rel="self" type="application/rss+xml"/><item><title>C++ 特性的底层原理</title><link>https://wangloo.github.io/posts/c/cpp/</link><pubDate>Fri, 22 Dec 2023 18:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/c/cpp/</guid><description>const 修饰成员函数 C++允许将成员函数添加const修饰符，代表此成员函数不会对成员变量进行修改， 否则会发生编译错误。在下面的示例中，set函数用const修饰就会出错， 而get函数用const修饰就能清楚的告诉别人这个函数不会修改类的成员。
对于一个声明为const的类实例，C++规定它只能调用const修饰的成员函数， 也就是说明这个类的成员是不允许被修改的。
class A { int num; public: void set_num(int x) { num = x; } int get_num(void) const { return num; } }; const A a; a.set_num(10); // Compile error a.get_num(); // Success 说起a为什么不允许调用set函数，我这里尝试从C的角度去进行解释， 毕竟C和C++本是同根生。C++定义的成员函数会有一个隐形的参数叫this指针， this总是指向这个类的示例，所以实际上我理解调用成员函数的时候会将成员地址作为参数也传递给成员函数，毕竟这样才能用this指针嘛。然后就说为什么不能调用set函数呢？ 我猜测对于一般的成员函数，规定接受的隐形参数this的类型是 A*， 而const修饰的成员函数接受的this类型为 const A*， 这样做就能限制用const修饰的类实例在将其自身地址传递给普通成员函数的时候出错， 即const A * 不能传递给参数类型为 A* 的函数哦，导致编译错误。
// 猜测C实现C++类 struct A { int num; void (*set_num)(struct A *a, int x){...} void (*get_num)(const struct A *a) {.</description></item><item><title>C/C++ 符号管理的区别</title><link>https://wangloo.github.io/posts/c/linker_symbol/</link><pubDate>Thu, 14 Dec 2023 12:21:27 +0800</pubDate><guid>https://wangloo.github.io/posts/c/linker_symbol/</guid><description>背景 今天在写 C 代码时，遇到一个问题，我忘记 include 头文件而调用某个函数， 一般情况下在编译时会报警告 ⚠，然后也会链接成功，所以我这次就没管它因为只是暂时测试一下。 然而令我费解的是函数的执行结果异常，检查汇编后发现，我声明的函数返回 u64 类型， 而编译后的代码在返回前裁切成了 32 位，就是这里导致的错误！
这与我之前的理解不同，我以为要么就链接找不到符号，要不就成功链接， 为什么会有这种返回类型识别错误呢？
思考 我忽然想起，会不会是因为编译器将返回值识别为了默认的 int 类型， 进而，我的猜想是：
链接时能用符号名找到符号的地址，所以能成功调用 但因为没有参数和返回类型的说明（没有 include），所以导致类型出错 简单验证之后，确实我的猜想是正确的，我调用时多传入一个参数， 还是能够成功编译，汇编只是把参数寄存器赋值，内部用不用得到无法判定。 返回类型则统一认定为默认的int类型。
由此，我又产生了一个想法，既然C语言只使用符号名作为匹配的标准， 那么必然不支持同名函数（参数、返回类型不同）。然而C++明确是支持的， 那么C与C++的符号管理有什么不同吗？
进一步验证 我写了内容相同的C和C++两个文件来尝试解答问题：
// Same code in demo.c/demo.cpp void func(int a, int b) { func(b, a); } 对他们进行编译，查看大小仅相差8字节，猜测是符号的管理有所不同。
$ ls -al total 8 drwxr-xr-x 1 loo loo 512 Dec 14 14:09 . drwxr-xr-x 1 loo loo 512 Dec 14 12:03 .</description></item><item><title>Good Design: 抽象消息参数</title><link>https://wangloo.github.io/posts/c/good_design_proto/</link><pubDate>Sun, 26 Nov 2023 16:21:27 +0800</pubDate><guid>https://wangloo.github.io/posts/c/good_design_proto/</guid><description>在设计一个消息传递类似的子系统时，消息经常需要各种参数， 通常消息的个数和类型是根据消息自身的类型决定的。
void handle_open(..., int flags, int mode); void handle_read(..., size_t len, int offset); // ... 有的消息/命令参数比较多，不想写这么长的参数那就把这些参数封装到struct里
struct arg_open { int flag; int mode; }; struct arg_read { size_t len; int offset; }; // 这里用结构体还是结构体指针都可以，不是重点! void handle_open(..., struct arg_open *arg); void handle_read(..., struct arg_read *arg); 这种方法有什么缺点呢?
不具有通用性；无法用函数指针来实现进一步抽象，即跳表。 &amp;hellip;（暂时没想到） 所以说，一个更好的抽象方式来了，将所有的参数利用union放到一个结构体中。
struct proto_open { int flag; int mode; }; struct proto_read { size_t len; int offset; }; // GOOD DESIGN struct proto { // .</description></item><item><title>Byte/Bit Order</title><link>https://wangloo.github.io/posts/c/byte_bit_order/</link><pubDate>Sat, 25 Nov 2023 16:21:27 +0800</pubDate><guid>https://wangloo.github.io/posts/c/byte_bit_order/</guid><description>字节序与比特序 字节序又称大小段，网络中传输的是大端，在CPU上处理的一般是小端。
字节序与比特序转换 字节序转换 比特序转换 两种方法，一种直接法，另外有一种优化的技巧。
（1）
// Bit reverse unsigned char bit_reverse(unsigned char x) { unsigned char newx = 0; for (int i = 0; i &amp;lt; 8; i++) { newx |= (((x &amp;gt;&amp;gt; i) &amp;amp; 1) &amp;lt;&amp;lt; (7-i)); } return newx; } (2) https://mp.weixin.qq.com/s/KNUH_RmIhUHhuSZLSmN4LQ
// Bit reverse(faster) // 碟式交换法 unsigned char bit_reverse_faster(unsigned char x) { x = (x&amp;lt;&amp;lt;4) | (x&amp;gt;&amp;gt;4); // [ 5678 1234 ] x = ((x&amp;lt;&amp;lt;2)&amp;amp;0xcc) | ((x&amp;gt;&amp;gt;2)&amp;amp;0x33); // [ 78 56 34 12 ] x = ((x&amp;lt;&amp;lt;1)&amp;amp;0xaa) | ((x&amp;gt;&amp;gt;1)&amp;amp;0x55); // [ 8 7 6 5 4 3 2 1 ] return x; } 测试工具函数:</description></item></channel></rss>