<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C on BLOG</title><link>https://wangloo.github.io/categories/c/</link><description>Recent content in C on BLOG</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sun, 26 Nov 2023 16:21:27 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/categories/c/index.xml" rel="self" type="application/rss+xml"/><item><title>Good Design: 抽象消息参数</title><link>https://wangloo.github.io/posts/c/good_design_proto/</link><pubDate>Sun, 26 Nov 2023 16:21:27 +0800</pubDate><guid>https://wangloo.github.io/posts/c/good_design_proto/</guid><description>在设计一个消息传递类似的子系统时，消息经常需要各种参数， 通常消息的个数和类型是根据消息自身的类型决定的。
1void 2handle_open(..., int flags, int mode); 3void 4handle_read(..., size_t len, int offset); 5// ... 有的消息/命令参数比较多，不想写这么长的参数那就把这些参数封装到struct里
1struct arg_open { 2 int flag; 3 int mode; 4}; 5struct arg_read { 6 size_t len; 7 int offset; 8}; 9 10// 这里用结构体还是结构体指针都可以，不是重点! 11void 12handle_open(..., struct arg_open *arg); 13void 14handle_read(..., struct arg_read *arg); 这种方法有什么缺点呢?
不具有通用性；无法用函数指针来实现进一步抽象，即跳表。 &amp;hellip;（暂时没想到） 所以说，一个更好的抽象方式来了，将所有的参数利用union放到一个结构体中。
1struct proto_open { 2 int flag; 3 int mode; 4}; 5struct proto_read { 6 size_t len; 7 int offset; 8}; 9 10// GOOD DESIGN 11struct proto { 12 // .</description></item><item><title>Byte/Bit Order</title><link>https://wangloo.github.io/posts/c/byte_bit_order/</link><pubDate>Sat, 25 Nov 2023 16:21:27 +0800</pubDate><guid>https://wangloo.github.io/posts/c/byte_bit_order/</guid><description>字节序与比特序 字节序又称大小段，网络中传输的是大端，在CPU上处理的一般是小端。
字节序与比特序转换 字节序转换 比特序转换 两种方法，一种直接法，另外有一种优化的技巧。
（1）
1// Bit reverse 2unsigned char 3bit_reverse(unsigned char x) 4{ 5 unsigned char newx = 0; 6 for (int i = 0; i &amp;lt; 8; i++) { 7 newx |= (((x &amp;gt;&amp;gt; i) &amp;amp; 1) &amp;lt;&amp;lt; (7-i)); 8 } 9 return newx; 10} (2) https://mp.weixin.qq.com/s/KNUH_RmIhUHhuSZLSmN4LQ
1// Bit reverse(faster) 2// 碟式交换法 3unsigned char 4bit_reverse_faster(unsigned char x) 5{ 6 x = (x&amp;lt;&amp;lt;4) | (x&amp;gt;&amp;gt;4); // [ 5678 1234 ] 7 x = ((x&amp;lt;&amp;lt;2)&amp;amp;0xcc) | ((x&amp;gt;&amp;gt;2)&amp;amp;0x33); // [ 78 56 34 12 ] 8 x = ((x&amp;lt;&amp;lt;1)&amp;amp;0xaa) | ((x&amp;gt;&amp;gt;1)&amp;amp;0x55); // [ 8 7 6 5 4 3 2 1 ] 9 return x; 10} 测试工具函数:</description></item></channel></rss>