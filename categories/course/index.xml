<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Course on BLOG</title><link>https://wangloo.github.io/categories/course/</link><description>Recent content in Course on BLOG</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 16 Apr 2024 19:28:12 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/categories/course/index.xml" rel="self" type="application/rss+xml"/><item><title>课程笔记：NJU ICS2022</title><link>https://wangloo.github.io/posts/course/nju-ics2022/</link><pubDate>Tue, 16 Apr 2024 19:28:12 +0800</pubDate><guid>https://wangloo.github.io/posts/course/nju-ics2022/</guid><description>ISA: RISCV32
构建系统 编译Guest程序流程分析 编译dummy可执行文件的命令如下，很好奇是如何实现的。
1 2 cd am-kernels/am-kernels/tests/cpu-tests make ARCH=riscv32-nemu ALL=dummy 既然在当前目录执行make，自然先从 am-kernels/am-kernels/tests/cpu-tests/Makefile开始看起。
ALL默认是所有test的集合，参数指定会覆盖它。 ALL的生成规则属于 静态规则 ，通配符%代表ALL的全称即依赖Makefile.dummy。更多关于静态规则 Makefile.dummy的生成规则也就在下面，这个文件默认是不存在的，需要临时生成 生成的规则是 echo -e &amp;quot;NAME = dummy\nSRCS = tests/dummy.c\ninclude $${AM_HOME}/Makefile&amp;quot; &amp;gt; $@。包含了AM_HOME下的Makefile AM是各个平台版本可执行文件的“制造机”，理念是将平台信息传入，生成指定格式的镜像。运行时库也包含在内。 最后就是执行 make -f 去调用刚才生成的临时Makefile.dummy，传入指定参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ALL = $(basename $(notdir $(shell find tests/. -name &amp;#34;*.c&amp;#34;))) all: $(addprefix Makefile., $(ALL)) @echo &amp;#34;test list [$(words $(ALL))item(s)]:&amp;#34; $(ALL) $(ALL): %: Makefile.</description></item><item><title>课程笔记：cs152（计算机体系结构）</title><link>https://wangloo.github.io/posts/course/cs152/</link><pubDate>Fri, 05 Apr 2024 19:28:12 +0800</pubDate><guid>https://wangloo.github.io/posts/course/cs152/</guid><description>CISC的发展到RISC诞生 1940-1950 冯诺依曼架构被提出：以存储器为中心，软件和硬件的设计分离，减少了系统中的硬连接，实现了可编程的计算机！ 用户程序（二进制指令）被存储到存储器中。存储器的容量，几k字，不能放下很大的程序。 存储器有CRT磷光线存储器（支持随机存储），磁芯（Core memory）（磁芯存储：统治存储领域20年 - 知乎）。 1960-1970 PDP-6典型设计，16个通用寄存器，SP+FP，ISA逐渐变得复杂 此时人们用汇编指令写程序，认为每个常见操作都应该实现为一条特殊的指令（三角函数、CRC&amp;hellip;）。（？？？与ROM和RAM的速度差异有关吗） 这么多种类的指令硬连线的方式太复杂 ==&amp;gt; 微码 微码ROM是一张表：ISA指令和微操作之间的映射，一条指令对应多个微操作 有了微码，创造一条新的指令很容易，使用不同微操作的组合即可 1980 高级语言和编译器来了，不用再手写指令 编译器很难利用到这么多复杂的指令，生成的汇编代码常用几条指令占95%，大量的不常用指令占据了微码ROM。 发明出基于Mos的SRAM，比原先的快2-10倍！？？？所以呢 CISC不适合与流水线 decode时间不一致，边decode边取指，不确定的时间段 寻址模式多，容易引发数据竞争，而且不容易检测 流水线 Pipeline RISC的架构中出现的，旨在提高处理器处理效率，争取在一个时钟周期中完成一条指令（CPI=1）。
.notice { --root-color: #444; --root-background: #eff; --title-color: #fff; --title-background: #7bd; --warning-title: #c33; --warning-content: #fee; --info-title: #fb7; --info-content: #fec; --note-title: #6be; --note-content: #e7f2fa; --tip-title: #5a5; --tip-content: #efe } @media (prefers-color-scheme:dark) { .</description></item><item><title>课程学习：cs61a</title><link>https://wangloo.github.io/posts/course/cs61a/</link><pubDate>Mon, 17 Jul 2023 19:28:12 +0800</pubDate><guid>https://wangloo.github.io/posts/course/cs61a/</guid><description>学习日历 - 激励自己学习 因为最近在写论文，所以每两天能学习一次，并记录每次学习的事件
2024年1月4日22点09分 配置环境
lab00目录的组成：
lab00.py: The template file you&amp;rsquo;ll be adding your code to ok: A program used to test and submit assignments lab00.ok: A configuration file for ok What Would Python Do? (WWPD)
python3 ok -q python-basics -u --local 结尾的--local避免输入伯克利邮箱。
解释一个函数的组成：
The lines in the triple-quotes &amp;quot;&amp;quot;&amp;quot; are called a docstring, which is a description of what the function is supposed to do.</description></item></channel></rss>