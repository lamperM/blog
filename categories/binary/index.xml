<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Binary on BLOG</title><link>https://wangloo.github.io/categories/binary/</link><description>Recent content in Binary on BLOG</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 16 Dec 2023 15:51:49 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/categories/binary/index.xml" rel="self" type="application/rss+xml"/><item><title>Dwarf: Stack Unwinding</title><link>https://wangloo.github.io/posts/binary/dwarf/frame/</link><pubDate>Sat, 16 Dec 2023 15:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/binary/dwarf/frame/</guid><description>前言 栈回溯是调试代码常用的功能之一，Gdb 中对应的命令是bt,info frame等。 这篇文件将介绍利用 Dwarf 生成的调试信息实现栈回溯的方法。
原理 Dwarf v2 开始提供一种叫做 Call Frame Information（简称 CFI）的信息， 它存储在.debug_frame中，调试器可以通过解析这个 Section 完成栈回溯。 .debug_frame里的内容可以看做是一张二维表格，一列是 pc， 另一列是对于此 Pc 如何查找上一个 Frame。
Demo 例如，对于以下的 C 代码和对应的汇编（通过object -S生成)， 汇编代码有一点长，但没关系我们不需要关注每一条汇编指令。 这段代码共有两个函数，main()和fibonacci()， 由 main 函数调用 fibonacci 来计算第 10 个 bibonacci 数。 目前暂时不需要看汇编。
选择 fibonacci()作为例子的原因是模拟一个非叶子函数， 因为 Arm64 下对叶子函数可能不会生成正确的 CFI 信息， 因为这种情况不常见，所以我们先讨论普通的情况。 另外，我知道这个计算 fibonacci 数的算法不是最优的， 但是我们毕竟不是算法优化的主题，所以能够说明问题即可。
1int fiboncci(int n) 2{ 3 if (n &amp;lt;= 2) 4 return 1; 5 else 6 return fiboncci(n-1) + fiboncci(n-2); 7} 8 9int main(void) 10{ 11 int result; 12 13 result = fiboncci(10); 14 return 0; 15} 1int fiboncci(int n) 2{ 3 400594: a9bd7bfd stp x29, x30, [sp, #-48]!</description></item><item><title>Weapon: GNU Binutils</title><link>https://wangloo.github.io/posts/binary/gnu_binutils/</link><pubDate>Thu, 14 Dec 2023 13:21:27 +0800</pubDate><guid>https://wangloo.github.io/posts/binary/gnu_binutils/</guid><description>1# 输出 section header table 2readelf -S xxx.elf 3 4# 输出 program header table 5readelf -l xxx.elf 6 7# 输出 ELF header 8readelf -h xxx.elf 9 10# 输出 elf header，section header table，program header table(常用） 11readelf -e xxx.elf 12 13# 查看符号 14nm xxx.elf 15readelf -s xxx.elf # detailed 16 17# 打印某个section的内容 18readelf -p .strtab xxx.elf</description></item><item><title>Design a Elf Loader</title><link>https://wangloo.github.io/posts/binary/elf_load/</link><pubDate>Fri, 24 Nov 2023 16:21:27 +0800</pubDate><guid>https://wangloo.github.io/posts/binary/elf_load/</guid><description>分析Elf文件 映射 Segments 对栈进行预处理 1int main(int argc, char **argv, char **envp) {...} 见到一个main函数的定义，你是否考虑过:
main函数使用这些参数的作用分别是什么? Elf运行前，他们是如何被正确放置的? 我们又如何正确的访问? 内核中的Elf加载器还需要将辅助向量和其他信息(argc,argv,envp)一起放在栈上。 初始化后，进程的堆栈如下所示(64位架构下):
1position content size (bytes) + comment 2 ------------------------------------------------------------------------ 3 [ free used for process ] 4 stack pointer -&amp;gt; [ argc = number of args ] 8 5 [ argv[0] (pointer) ] 8 (program name) 6 [ argv[1] (pointer) ] 8 7 [ argv[..] (pointer) ] 8 * x 8 [ argv[n - 1] (pointer) ] 8 9 [ argv[n] (pointer) ] 8 (= NULL) 10 11 [ envp[0] (pointer) ] 8 12 [ envp[1] (pointer) ] 8 13 [ envp[.</description></item><item><title>DWARF(2): basetype类型</title><link>https://wangloo.github.io/posts/binary/dwarf/1_basetype/</link><pubDate>Tue, 09 May 2023 16:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/binary/dwarf/1_basetype/</guid><description>想要描述一个变量，必须知道它类型信息，才能知道变量的大小、输出的格式等。
Dwarf 为 C 语言定义了一些描述数据类型的 DIE，包括 basetype, array,pointer, structure&amp;hellip;
basetype 今天我们先介绍最简单的 basetype。
basetype 是指那些 C 语言自身定义的基础类型，像int, double这些。
basetype 类型的 DIE 通常有属性:
DW_AT_name: basetype 的名称 DW_AT_byte_size: 该 basetype 占空间大小 下面给出描述int和double的 DIE 展示(还是通过objdump工具输出）：
1 &amp;lt;1&amp;gt;&amp;lt;43&amp;gt;: Abbrev Number: 3 (DW_TAG_base_type) 2 &amp;lt;44&amp;gt; DW_AT_byte_size : 4 3 &amp;lt;45&amp;gt; DW_AT_encoding : 5 (signed) 4 &amp;lt;46&amp;gt; DW_AT_name : int 5 6 &amp;lt;1&amp;gt;&amp;lt;60&amp;gt;: Abbrev Number: 4 (DW_TAG_base_type) 7 &amp;lt;61&amp;gt; DW_AT_byte_size : 8 8 &amp;lt;62&amp;gt; DW_AT_encoding : 4 (float) 9 &amp;lt;63&amp;gt; DW_AT_name : (indirect string, offset: 0x9): double Array 数组表示为 DW_TAG_array 的 DIE，通常含有属性:</description></item><item><title>DWARF(1): 基础</title><link>https://wangloo.github.io/posts/binary/dwarf/0_basic/</link><pubDate>Tue, 09 May 2023 15:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/binary/dwarf/0_basic/</guid><description>Dwarf 把源文件中每个可描述的模块（例如函数，变量，结构体的声明等）描述为一个 DIE (Debugging Information Entry)，所以每个源文件可以描述为若干 DIE 的组合。
每个 DIE 由一个 tag 和若干 attribute-val 键值对构成:
tag: 描述此 DIE 的类型 attribute-val: 描述此 DIE 的一些细节属性，项目根据 DIE 的类型不同而有差别 各个 DIE 之间会相互联系，一个 DIE 可能含有 parent，若干的 child 和 sibling， 它们之间组成树的结构。
查看一个 ELF 的所有 DIE ELF 文件中的所有 DIE 存储在.debug_info section 中，通过 GNU utils 中的objdump工具 可以解析为可阅读的结构:
1objdump --dwarf=info &amp;lt;file&amp;gt; 若我们有一个 demo.c 如下:
1void func(void) { 2 int var_local; 3} 编译为可执行文件后， 执行上述的objdump命令， 可以得到如下的输出（节选）：
1 &amp;lt;1&amp;gt;&amp;lt;68&amp;gt;: Abbrev Number: 5 (DW_TAG_subprogram) 2 &amp;lt;69&amp;gt; DW_AT_external : 1 3 &amp;lt;69&amp;gt; DW_AT_name : (indirect string, offset: 0x32): func 4 &amp;lt;6d&amp;gt; DW_AT_decl_file : 1 5 &amp;lt;6e&amp;gt; DW_AT_decl_line : 3 6 &amp;lt;6f&amp;gt; DW_AT_decl_column : 6 7 &amp;lt;70&amp;gt; DW_AT_prototyped : 1 8 &amp;lt;70&amp;gt; DW_AT_low_pc : 0x1129 9 &amp;lt;78&amp;gt; DW_AT_high_pc : 0xb 10 &amp;lt;80&amp;gt; DW_AT_frame_base : 1 byte block: 9c (DW_OP_call_frame_cfa) 11 &amp;lt;82&amp;gt; DW_AT_GNU_all_call_sites: 1 12 &amp;lt;2&amp;gt;&amp;lt;82&amp;gt;: Abbrev Number: 6 (DW_TAG_variable) 13 &amp;lt;83&amp;gt; DW_AT_name : (indirect string, offset: 0x28): var_local 14 &amp;lt;87&amp;gt; DW_AT_decl_file : 1 15 &amp;lt;88&amp;gt; DW_AT_decl_line : 4 16 &amp;lt;89&amp;gt; DW_AT_decl_column : 9 17 &amp;lt;8a&amp;gt; DW_AT_type : &amp;lt;0x43&amp;gt; 上述例子中节选了两个 DIE，分别是函数func()和局部变量var_local, 可以看到它们的 tag 是不同的，且都具有一系列属性。</description></item></channel></rss>