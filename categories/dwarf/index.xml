<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dwarf on BLOG</title><link>https://wangloo.github.io/categories/dwarf/</link><description>Recent content in Dwarf on BLOG</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 16 Dec 2023 15:51:49 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/categories/dwarf/index.xml" rel="self" type="application/rss+xml"/><item><title>Dwarf: Stack Unwinding</title><link>https://wangloo.github.io/posts/binary/dwarf/frame/</link><pubDate>Sat, 16 Dec 2023 15:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/binary/dwarf/frame/</guid><description>前言 栈回溯是调试代码常用的功能之一，Gdb 中对应的命令是bt,info frame等。 这篇文件将介绍利用 Dwarf 生成的调试信息实现栈回溯的方法。
原理 Dwarf v2 开始提供一种叫做 Call Frame Information（简称 CFI）的信息， 它存储在.debug_frame中，调试器可以通过解析这个 Section 完成栈回溯。 .debug_frame里的内容可以看做是一张二维表格，一列是 pc， 另一列是对于此 Pc 如何查找上一个 Frame。
Demo 例如，对于以下的 C 代码和对应的汇编（通过object -S生成)， 汇编代码有一点长，但没关系我们不需要关注每一条汇编指令。 这段代码共有两个函数，main()和fibonacci()， 由 main 函数调用 fibonacci 来计算第 10 个 bibonacci 数。 目前暂时不需要看汇编。
选择 fibonacci()作为例子的原因是模拟一个非叶子函数， 因为 Arm64 下对叶子函数可能不会生成正确的 CFI 信息， 因为这种情况不常见，所以我们先讨论普通的情况。 另外，我知道这个计算 fibonacci 数的算法不是最优的， 但是我们毕竟不是算法优化的主题，所以能够说明问题即可。
int fiboncci(int n) { if (n &amp;lt;= 2) return 1; else return fiboncci(n-1) + fiboncci(n-2); } int main(void) { int result; result = fiboncci(10); return 0; } int fiboncci(int n) { 400594: a9bd7bfd stp x29, x30, [sp, #-48]!</description></item><item><title>Dwarf(2): basetype类型</title><link>https://wangloo.github.io/posts/binary/dwarf/1_basetype/</link><pubDate>Tue, 09 May 2023 16:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/binary/dwarf/1_basetype/</guid><description>想要描述一个变量，必须知道它类型信息，才能知道变量的大小、输出的格式等。
Dwarf 为 C 语言定义了一些描述数据类型的 DIE，包括 basetype, array,pointer, structure&amp;hellip;
basetype 今天我们先介绍最简单的 basetype。
basetype 是指那些 C 语言自身定义的基础类型，像int, double这些。
basetype 类型的 DIE 通常有属性:
DW_AT_name: basetype 的名称 DW_AT_byte_size: 该 basetype 占空间大小 下面给出描述int和double的 DIE 展示(还是通过objdump工具输出）：
&amp;lt;1&amp;gt;&amp;lt;43&amp;gt;: Abbrev Number: 3 (DW_TAG_base_type) &amp;lt;44&amp;gt; DW_AT_byte_size : 4 &amp;lt;45&amp;gt; DW_AT_encoding : 5 (signed) &amp;lt;46&amp;gt; DW_AT_name : int &amp;lt;1&amp;gt;&amp;lt;60&amp;gt;: Abbrev Number: 4 (DW_TAG_base_type) &amp;lt;61&amp;gt; DW_AT_byte_size : 8 &amp;lt;62&amp;gt; DW_AT_encoding : 4 (float) &amp;lt;63&amp;gt; DW_AT_name : (indirect string, offset: 0x9): double Array 数组表示为 DW_TAG_array 的 DIE，通常含有属性:</description></item><item><title>Dwarf(1): 基础</title><link>https://wangloo.github.io/posts/binary/dwarf/0_basic/</link><pubDate>Tue, 09 May 2023 15:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/binary/dwarf/0_basic/</guid><description>Dwarf 把源文件中每个可描述的模块（例如函数，变量，结构体的声明等）描述为一个 DIE (Debugging Information Entry)，所以每个源文件可以描述为若干 DIE 的组合。
每个 DIE 由一个 tag 和若干 attribute-val 键值对构成:
tag: 描述此 DIE 的类型 attribute-val: 描述此 DIE 的一些细节属性，项目根据 DIE 的类型不同而有差别 各个 DIE 之间会相互联系，一个 DIE 可能含有 parent，若干的 child 和 sibling， 它们之间组成树的结构。
查看一个 ELF 的所有 DIE ELF 文件中的所有 DIE 存储在.debug_info section 中，通过 GNU utils 中的objdump工具 可以解析为可阅读的结构:
objdump --dwarf=info &amp;lt;file&amp;gt; 若我们有一个 demo.c 如下:
void func(void) { int var_local; } 编译为可执行文件后， 执行上述的objdump命令， 可以得到如下的输出（节选）：
&amp;lt;1&amp;gt;&amp;lt;68&amp;gt;: Abbrev Number: 5 (DW_TAG_subprogram) &amp;lt;69&amp;gt; DW_AT_external : 1 &amp;lt;69&amp;gt; DW_AT_name : (indirect string, offset: 0x32): func &amp;lt;6d&amp;gt; DW_AT_decl_file : 1 &amp;lt;6e&amp;gt; DW_AT_decl_line : 3 &amp;lt;6f&amp;gt; DW_AT_decl_column : 6 &amp;lt;70&amp;gt; DW_AT_prototyped : 1 &amp;lt;70&amp;gt; DW_AT_low_pc : 0x1129 &amp;lt;78&amp;gt; DW_AT_high_pc : 0xb &amp;lt;80&amp;gt; DW_AT_frame_base : 1 byte block: 9c (DW_OP_call_frame_cfa) &amp;lt;82&amp;gt; DW_AT_GNU_all_call_sites: 1 &amp;lt;2&amp;gt;&amp;lt;82&amp;gt;: Abbrev Number: 6 (DW_TAG_variable) &amp;lt;83&amp;gt; DW_AT_name : (indirect string, offset: 0x28): var_local &amp;lt;87&amp;gt; DW_AT_decl_file : 1 &amp;lt;88&amp;gt; DW_AT_decl_line : 4 &amp;lt;89&amp;gt; DW_AT_decl_column : 9 &amp;lt;8a&amp;gt; DW_AT_type : &amp;lt;0x43&amp;gt; 上述例子中节选了两个 DIE，分别是函数func()和局部变量var_local, 可以看到它们的 tag 是不同的，且都具有一系列属性。</description></item><item><title>Libdwarf 函数介绍及其实现方法</title><link>https://wangloo.github.io/posts/binary/dwarf/libdwarf_func/</link><pubDate>Sun, 07 May 2023 14:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/binary/dwarf/libdwarf_func/</guid><description>Function dwarf_alloc.c _dwarf_get_alloc() char * _dwarf_get_alloc(Dwarf_Debug dbg, Dwarf_Small alloc_type, Dwarf_Unsigned count) 函数功能: 根据类型申请一块空间
注意, 申请时大小会多DW_RESERVE, 此函数返回的地址是 mem_alloc()返回的地址+DW_RESERVE
_dwarf_error() void _dwarf_error(Dwarf_Debug dbg, Dwarf_Error * error, Dwarf_Sword errval) 函数功能 错误处理的函数
函数流程 判断传入参数error是否为空, 如果为空则跳转到 step 4. 分配一个新的Dwarf_Error空间 将传入的错误信息存入Dwarf_Error, 并将其作为指针返回 error为空时, 一般要在出错时执行一些方法,即 dbg-&amp;gt;de_errhand() 所以, 此时dbg 和 dbg-&amp;gt;de_errhand 必须非空. dwarf_elf_access.c dwarf_elf_object_access_init() int dwarf_elf_object_access_init(u64 elf_base_addr, int libdwarf_owns_elf, Dwarf_Obj_Access_Interface** ret_obj, int *err) 函数功能 初始化 Dwarf_Obj_Access_Interface 结构
函数流程 初始化其成员object, 使用的是dwarf_elf_object_access_internals_init方法 申请空间 为成员赋值 为全局变量_dwarf_get_elf_flags_func_ptr赋值, 为获取elf section flags的方法 _dwarf_get_elf_flags_func() static int _dwarf_get_elf_flags_func( void* obj_in, Dwarf_Half section_index, Dwarf_Unsigned *flags_out, Dwarf_Unsigned *addralign_out, int *error) 函数功能 获取elf指定section的flags</description></item></channel></rss>