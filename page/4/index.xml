<?xml-stylesheet href="/rss.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Homepage 🌈 on Wangloo's BLOG</title><link>https://wangloo.github.io/</link><description>Recent content in Homepage 🌈 on Wangloo's BLOG</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>@2019 Notepadium.</copyright><lastBuildDate>Thu, 15 Sep 2022 15:14:05 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>写高质量的C语言工程的技巧</title><link>https://wangloo.github.io/posts/codestyle/improve_quality/</link><pubDate>Tue, 14 Jun 2022 17:59:22 +0800</pubDate><guid>https://wangloo.github.io/posts/codestyle/improve_quality/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/codestyle/improve_quality/ -&lt;h2 id="添加更多的编译选项comiler-options来防止bug">添加更多的编译选项(comiler options)来防止bug&lt;/h2>
&lt;p>对于我常用的&lt;code>GCC&lt;/code>, 推荐开启一下的compiler options:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>-Wall&lt;/code>: enable a lot of common warnings&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-Wno-format-truncation&lt;/code>: warns about the snprintf output buffer not being
large enough for a corresponding “%s” in the format string.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-Werror&lt;/code>: turn warnings into errors.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p> &lt;/p>
&lt;h2 id="动态申请的空间到底要不要释放">动态申请的空间到底要不要释放&lt;/h2>
&lt;p>When using a barebones embedded OS, you absolutely need to tightly manage your memory.&lt;/p>
&lt;p>但是, 如果你是写应用业务的代码, 特别是在内存足够的场景下. 最好不要手动释放内存,
因为当线程/进程退出时, 操作系统会自动帮我们释放. &lt;strong>某些情况下, 释放内存的操作会很大程度上增加逻辑的复杂度&lt;/strong>.&lt;/p>
&lt;blockquote>
&lt;p>如果你是一个内核程序员, 则必须手动的释放. 不用怀疑.&lt;/p>
&lt;/blockquote>
&lt;p> &lt;/p>
&lt;h2 id="尽可能在创建变量时赋初值">尽可能在创建变量时赋初值&lt;/h2>
&lt;p>放置某些变量创建后是 &lt;code>magic value&lt;/code>. 而使用这些变量可能不会立马导致错误, 但是这是一个隐患.&lt;/p>
&lt;p>但这会产生一个问题, 有时我们定义变量之后的不久之后就会对其赋予正确的值, 这时候初值就是
多余的. 而且维护者可能认为这个值是meaningful, 这就要求我们如果要赋初值, 就要说明这个值
仅仅是&lt;strong>无意义的&lt;/strong>初值.&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="使用define-enum">使用&lt;code>#define&lt;/code>, &lt;code>enum&lt;/code>&lt;/h2>
&lt;p>对于代码在不同地方使用的同一个值, 应使用&lt;code>#define&lt;/code>来声明使得代码&lt;strong>maintainable&lt;/strong>.&lt;/p>
&lt;p>如果这些值有多个且能规划为同一类别, 则还可将&lt;code>#define&lt;/code>的方式换为&lt;code>enum&lt;/code>. 这会使代码更加&lt;strong>meaningful&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>使用&lt;code>enum&lt;/code>使还要注意其所占内存空间在不同架构中可能不同的问题, see &lt;a href="https://www.cnblogs.com/bluettt/p/16041867.html">enum的优势和漏洞&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p> &lt;/p>
&lt;h3 id="使用typedef优化function-pointer">使用&lt;code>typedef&lt;/code>优化function pointer&lt;/h3>
&lt;p> &lt;/p>
&lt;h2 id="重定义一套自己的类型">重定义一套自己的类型&lt;/h2>
&lt;p>在开发&lt;em>大项目&lt;/em>时, 需要考虑可移植性的情况下, 最好利用&lt;code>typedef&lt;/code>对类型进行重定义.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#if SYSTEM1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span> &lt;span style="color:#ff79c6">typedef&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> INT32;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#else
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span> &lt;span style="color:#ff79c6">typedef&lt;/span> &lt;span style="color:#8be9fd">long&lt;/span> INT32;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如上, 对于某些架构&lt;code>int&lt;/code>类型可能不是32bit, 此时就要使用&lt;code>long&lt;/code>. 这种定义的方式会保证我们的系统
在任何架构中都不会出现类型的bug. 而且也增加了代码的&lt;strong>readability&lt;/strong>.&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="善用0">善用&lt;code>~0&lt;/code>&lt;/h2>
&lt;p>在做嵌入式编程时, 有时在设置掩码(mask)或者其他情况会要用到&lt;strong>全1&lt;/strong>的变量值, 你是否经常这样声明?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> mask &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">0xffff&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>暂且不谈&lt;code>int&lt;/code>类型到底占多少字节的问题. 就像上面一样, 我们程序员经常忘记某个类型的大小,
而少添加了&lt;code>f&lt;/code>. 会导致变量&lt;code>mask&lt;/code>的值不是全1(32位情况下).&lt;/p>
&lt;p>这是要变换一下思维, 使用&lt;code>~0&lt;/code>的定义方法就可轻松化解, 无需管变量的类型是什么.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> mask &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">~&lt;/span>&lt;span style="color:#bd93f9">0&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="合理的使用goto语句">合理的使用&lt;code>goto&lt;/code>语句&lt;/h2>
&lt;p>在大学课堂中, 我们老师说过禁止使用&lt;code>goto&lt;/code>语句, 但却没有给出明确的原因.&lt;/p>
&lt;p>实际上, &lt;strong>合理的&lt;/strong>使用&lt;code>goto&lt;/code>能够极大的减少程序的冗余度.&lt;/p>
&lt;p>&lt;code>goto&lt;/code>语句常用于程序出现错误要退出时, 可能有多个情况会使用重复的代码处理,
例如释放一些allocated memory. 相较于使用&lt;code>flag&lt;/code>, 使用&lt;code>goto&lt;/code>显然更加clearly and readability.&lt;/p>
&lt;p>所以, 在面对重复的错误处理代码时, 想想能不能用&lt;code>goto&lt;/code>进行优化. 当然, &lt;strong>避免过早优化&lt;/strong>.&lt;/p>
&lt;blockquote>
&lt;p>注意, &lt;code>goto&lt;/code>出现的场景其实很受限. Never use a backward &lt;code>goto&lt;/code> or jump into control statements.&lt;/p>
&lt;/blockquote>
&lt;p> &lt;/p>
&lt;h2 id="定义合理-正确的结构体">定义合理, 正确的结构体&lt;/h2>
&lt;p>结构体是C语言编程应用中常用的数据结构, 关于结构体也有许多要注意的点.&lt;/p>
&lt;h3 id="1-flexible-array-member">#1 Flexible Array Member&lt;/h3>
&lt;p>C99开始支持&lt;em>Flexible Array Member&lt;/em>. 且看我&lt;a href="">lstring&lt;/a>库的结构体定义:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">struct&lt;/span> str {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> length;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">char&lt;/span> data[]; &lt;span style="color:#6272a4">// Flexible array member - C99 only
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于这种不定长的数组元素, 我之前都是定义一个指针, 占用一个&lt;code>sizeof(char *)&lt;/code>的空间. 而Flexible Array Member本身不占用空间. 需要在malloc时为他单独声明空间.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> n &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">struct&lt;/span> str &lt;span style="color:#ff79c6">*&lt;/span>s &lt;span style="color:#ff79c6">=&lt;/span> malloc(&lt;span style="color:#ff79c6">sizeof&lt;/span>(&lt;span style="color:#ff79c6">struct&lt;/span> str) &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#ff79c6">sizeof&lt;/span>(&lt;span style="color:#8be9fd">char&lt;/span>[n]));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>这里也有一个小trick, 使用&lt;code>sizeof(char[n])&lt;/code> 比 &lt;code>sizeof(char) * n&lt;/code> 更简洁!&lt;/p>
&lt;/blockquote>
&lt;h3 id="-2-padding-and-packed"># 2 Padding and Packed&lt;/h3>
&lt;p>有关结构体的大小, 和地址对齐的问题. 假设我有一个结构体如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">struct&lt;/span> mystruct_A
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">char&lt;/span> a; &lt;span style="color:#8be9fd">int&lt;/span> b; &lt;span style="color:#8be9fd">char&lt;/span> c;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} x;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Padding是编译器对结构体&lt;strong>默认&lt;/strong>做的事情. 它会在成员之间插入一些 gap 来保证地址对齐:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">struct&lt;/span> mystruct_A {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">char&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">char&lt;/span> gap_0[&lt;span style="color:#bd93f9">3&lt;/span>]; &lt;span style="color:#6272a4">/* inserted by compiler: for alignment of b */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> b; &lt;span style="color:#6272a4">/* int 在32位上其地址是4字节对齐的 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">char&lt;/span> c;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">char&lt;/span> gap_1[&lt;span style="color:#bd93f9">3&lt;/span>]; &lt;span style="color:#6272a4">/* -&amp;#34;-: for alignment of the whole struct in an array */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} x;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>除了保证每个成员的地址是对齐的, &lt;strong>整个结构体&lt;/strong>的地址也是按照其最大的成员类型来对齐, 即对齐到&lt;code>int&lt;/code>(4字节).&lt;/p>
&lt;/blockquote>
&lt;p>如果你&lt;strong>不想要这些 gap&lt;/strong>, 那么可以对结构体声明使用 &lt;code>__attribute__((__packed__))&lt;/code>关键字. 整个结构体大小仅为6个字节.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">struct&lt;/span> &lt;span style="color:#50fa7b">__attribute__&lt;/span>((__packed__)) mystruct_A {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">char&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">char&lt;/span> c;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="永远为你的函数设置error-return-value">永远为你的函数设置error return value&lt;/h2>
&lt;p>一旦你的函数可能被其他人调用, 那么养成设置return value的习惯. 即便你现在的实现
并不会产生任何错误, 也请返回&lt;code>success&lt;/code>.&lt;/p>
&lt;p>这样做的原因是, caller可以根据你的定义做错误判断, 即便以后你的实现加上了出错情况,
上层的代码也不需要修改.&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="变量类型的选择">变量类型的选择&lt;/h2>
&lt;ul>
&lt;li>名字, 特定不变的字符串使用&lt;code>const char *&lt;/code>, 甚至&lt;code>const char const*&lt;/code>&lt;/li>
&lt;li>长度使用&lt;code>size_t&lt;/code>&lt;/li>
&lt;li>表示类型的参数尽可能使用&lt;code>enum&lt;/code>&lt;/li>
&lt;li>循环变量i使用&lt;code>signed&lt;/code>, 避免溢出后出错&lt;/li>
&lt;/ul>
&lt;p> &lt;/p>
&lt;h2 id="reference">Reference&lt;/h2>
&lt;p>&lt;a href="https://www.msweet.org/blog/2020-12-31-how-i-improve-my-c-code-quality.html">How I Improve My (C) Code Quality&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.codeproject.com/Articles/357065/Ten-Fallacies-of-Good-C-Code">Ten Fallacies of Good C Code&lt;/a>&lt;/p>
- https://wangloo.github.io/posts/codestyle/improve_quality/ - @2019 Notepadium.</description></item><item><title>MicroKernel Learning: SeL4</title><link>https://wangloo.github.io/posts/microkernel/sel4/</link><pubDate>Sat, 04 Jun 2022 11:52:51 +0800</pubDate><guid>https://wangloo.github.io/posts/microkernel/sel4/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/microkernel/sel4/ -&lt;h2 id="sel4-capabilities">seL4 Capabilities&lt;/h2>
&lt;p>In seL4, capabilities are stored in &lt;strong>C-space&lt;/strong>. C-space is a hierarchical data structure very similar to &lt;strong>page table&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>page table is a mapping from virtual address to physical address.&lt;/li>
&lt;li>C-space is a mapping from &lt;strong>object ID&lt;/strong> to &lt;strong>capability&lt;/strong>.&lt;/li>
&lt;li>Kernel object is made up of several &lt;strong>C-nodes&lt;/strong>, just like a page table made up of individual page tables.&lt;/li>
&lt;li>Each C-nodes is an array of cap &lt;em>slots&lt;/em>, which contain capability.&lt;/li>
&lt;/ul>
&lt;p>Inaccessible to userland, you can never hold an &lt;strong>actual capability&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>You can only hold a reference to capability, which pointers into C-space(slot addresses)&lt;/li>
&lt;li>These C-space addresses are called &lt;strong>CPTRs&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>You don&amp;rsquo;t need to do the transform, because this is typically extracted in some libs.&lt;/p>
&lt;/blockquote>
&lt;p>Capabilities convey specific privilege (acces rights)&lt;/p>
&lt;ul>
&lt;li>Read, Write, Execute, GrantReply(&lt;code>call&lt;/code>), Grant(&lt;code>cap transfer&lt;/code>)&lt;/li>
&lt;/ul>
&lt;p>Main operations on capabilities:&lt;/p>
&lt;ul>
&lt;li>&lt;code>Invoke&lt;/code>perform operation on object referred to by cap.
&lt;ul>
&lt;li>For example, map some frame into memory. You need to have capabilities to both the frame and address space.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>Copy&lt;/code>|&lt;code>Mint&lt;/code>|&lt;code>Grant&lt;/code>: create copy of cap with &lt;strong>same/lesser&lt;/strong> privilege.&lt;/li>
&lt;li>&lt;code>Move&lt;/code>|&lt;code>Mutate&lt;/code>: transfer to different address with &lt;strong>same/lesser&lt;/strong> privilege.
&lt;ul>
&lt;li>Between C-space or within C-space.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>Delete&lt;/code>: invalidate slot(cleans up object if this is the only cap to it)&lt;/li>
&lt;li>&lt;code>Revoke&lt;/code>: delete any derived(eg. copied or minted) caps&lt;/li>
&lt;/ul>
&lt;h3 id="capability-derivation">Capability Derivation&lt;/h3>
&lt;h4 id="mint-operation">MINT OPERATION&lt;/h4>
&lt;p>The &lt;strong>Mint&lt;/strong> operation creates a new, less powerful cap&lt;/p>
&lt;ul>
&lt;li>Can add badge&lt;/li>
&lt;li>Can strip access rights, eg &lt;code>RW-&amp;gt;RO&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>mint(dest, src, rights, badge)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>The first two arguement are &lt;strong>capability pointers(CPTR)&lt;/strong> to a C-space(represented by C-node), which are references inside C-node.&lt;/li>
&lt;li>The &lt;strong>destination C-node cap&lt;/strong> must allow modification&lt;/li>
&lt;li>Then you have the rights and the &lt;em>batch&lt;/em> of the new cap.&lt;/li>
&lt;/ul>
&lt;p>📌 This is an alternative of sending addressed capabilities by &lt;strong>IPC operation&lt;/strong>.
That is what operating system do to set up protection domains for &lt;strong>user level process&lt;/strong>.&lt;/p>
&lt;h4 id="copy-operation">COPY OPERATION&lt;/h4>
&lt;blockquote>
&lt;p>Copy as a version of &lt;em>Mint&lt;/em>.&lt;/p>
&lt;/blockquote>
&lt;p> &lt;/p>
&lt;h2 id="sel4-kernel-objects">seL4 Kernel Objects&lt;/h2>
&lt;p>In file &lt;code>libsel4\include\sel4\objecttype.h&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">typedef&lt;/span> &lt;span style="color:#ff79c6">enum&lt;/span> api_object {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seL4_UntypedObject,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seL4_TCBObject,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seL4_EndpointObject,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seL4_NotificationObject,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seL4_CapTableObject,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#ifdef CONFIG_KERNEL_MCS
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span> seL4_SchedContextObject,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seL4_ReplyObject,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span> seL4_NonArchObjectTypeCount,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} seL4_ObjectType;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="sel4-system-calls">seL4 System Calls&lt;/h2>
&lt;p>seL4 has &lt;code>11&lt;/code> syscalls:&lt;/p>
&lt;p>&lt;code>Yield()&lt;/code>: invokes scheduler&lt;/p>
&lt;ul>
&lt;li>does NOT require a capability!&lt;/li>
&lt;/ul>
&lt;p>&lt;code>Send()&lt;/code>,&lt;code>Recv()&lt;/code> and variants/combinations thereof: IPC operations&lt;/p>
&lt;ul>
&lt;li>&lt;code>Call()&lt;/code>,&lt;code>ReplyRecv()&lt;/code>: usually invokes by client/server&lt;/li>
&lt;li>&lt;code>Send()&lt;/code>, &lt;code>NBSend()&lt;/code>: send-only and non-blocking version of it.&lt;/li>
&lt;li>&lt;code>Recv()&lt;/code>, &lt;code>NBRecv()&lt;/code>, &lt;code>NBSendRecv()&lt;/code>&lt;/li>
&lt;li>&lt;code>Wait()&lt;/code>, &lt;code>NBWait()&lt;/code>, &lt;code>NBSendWait()&lt;/code>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>We just use &lt;code>Call()&lt;/code> normally, the others are only for bootstrapping protocols and exception handling.&lt;/p>
&lt;/blockquote>
&lt;p>Call() is atomic Send() + reply-object setup + Wait()&lt;/p>
&lt;ul>
&lt;li>cannot be simulated with one-way operations!&lt;/li>
&lt;/ul>
&lt;p>ReplyRecv() is NBSend() + Recv()&lt;/p>
&lt;h3 id="different-object-support-different-operations">Different object support different operations&lt;/h3>
&lt;h4 id="endpoints">ENDPOINTS&lt;/h4>
&lt;p>Endpoints support all 10 IPC variants.&lt;/p>
&lt;h4 id="notifications">NOTIFICATIONS&lt;/h4>
&lt;p>Notifications support:&lt;/p>
&lt;ul>
&lt;li>NBSend() - aliased as Signal()&lt;/li>
&lt;li>Wait()&lt;/li>
&lt;li>NBWait() - aliased as Poll()&lt;/li>
&lt;/ul>
&lt;h4 id="other-objects">OTHER OBJECTS&lt;/h4>
&lt;p>Other objects only supports &lt;code>Call()&lt;/code> operation.&lt;/p>
&lt;ul>
&lt;li>Appear as (kernel-implemented) servers. If you invoking a method on an object, this is done by treating the object as a kernel-implemented server. And you invoke it with a &lt;code>call()&lt;/code> operation just as you do a normal server invocation.&lt;/li>
&lt;li>Each of these kernel objects has a different kernel-defined protocol
&lt;ul>
&lt;li>operations encoded in message tag&lt;/li>
&lt;li>parameters passed in message words&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Mostly hidden behind &lt;strong>syscall&lt;/strong> wrappers, user do not need to know this details.&lt;/li>
&lt;/ul>
&lt;p> &lt;/p>
&lt;h2 id="sel4-ipc">seL4 IPC&lt;/h2>
&lt;blockquote>
&lt;p>IPC in seL4 is a way to realize &lt;strong>cross-domain&lt;/strong> invocation.&lt;/p>
&lt;/blockquote>
&lt;p>seL4 IPC is not a mechanism for shipping data. Transfering data is axillary but not the primary purpose.&lt;/p>
&lt;p>seL4 IPC is a protected procedure call, a user-controlled context switch(from clients context into server context).&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="sel4-threads">seL4 Threads&lt;/h2>
&lt;h3 id="creating-a-thread">Creating a thread&lt;/h3>
&lt;ol>
&lt;li>Obtain a TCB object&lt;/li>
&lt;li>Set attributes: V-space, C-space, fault endpoint, IPC buffer&lt;/li>
&lt;li>Set Scheduling parameters:
&lt;ul>
&lt;li>priority, scheduling context, timeout endpoint(maybe MCP)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Set architecture-related registers&lt;/li>
&lt;/ol>
&lt;h3 id="threads-and-stacks">Threads and Stacks&lt;/h3>
&lt;p>Stacks are completely user-managed, kernel doesn&amp;rsquo;t care!&lt;/p>
&lt;blockquote>
&lt;p>Kernel only preserves SP.. on context switch&lt;/p>
&lt;/blockquote>
&lt;p>Stack location, allocation, size must be managed by &lt;strong>userland&lt;/strong>.&lt;/p>
&lt;p>Kernel beware of stack overflow&lt;/p>
- https://wangloo.github.io/posts/microkernel/sel4/ - @2019 Notepadium.</description></item><item><title>使用 HuGo 搭建个人网站</title><link>https://wangloo.github.io/posts/hugo/</link><pubDate>Sat, 21 May 2022 17:39:42 +0800</pubDate><guid>https://wangloo.github.io/posts/hugo/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/hugo/ -&lt;h1 id="hugo-基础学习">HuGo 基础学习&lt;/h1>
&lt;p>本章将解答Hugo是什么, 以及Hugo是如何工作的. 只有了解Hugo的工作机制之后, 才能发挥想象力进行DIY.&lt;/p>
&lt;p>本章内容大多来自&lt;a href="https://gohugo.io/documentation/">官方手册&lt;/a>或者搜索引擎提供的结果.&lt;/p>
&lt;h2 id="hugo-项目目录结构">Hugo 项目目录结构&lt;/h2>
&lt;p>一个hugo 项目通常包含以下内容:&lt;/p>
&lt;pre tabindex="0">&lt;code>.
├── archetypes
├── config.toml
├── content
├── data
├── layouts
├── public
├── static
└── themes
&lt;/code>&lt;/pre>&lt;p>这里面有些是必须的, 有些是可选的.&lt;/p>
&lt;p>&lt;strong>archetypes&lt;/strong>&lt;/p>
&lt;p>定义新创建post时, header的格式.&lt;/p>
&lt;p>&lt;strong>asserts&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>Note: assets directory is not created by default.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>config&lt;/strong>&lt;/p>
&lt;p>Hugo uses the &lt;code>config.toml&lt;/code>, &lt;code>config.yaml&lt;/code>, or &lt;code>config.json&lt;/code> (if found in the site root) as the default site config file.&lt;/p>
&lt;p>The user can choose to override that default with one or more site config files using the command-line &lt;code>--config&lt;/code> switch.&lt;/p>
&lt;pre tabindex="0">&lt;code>hugo --config debugconfig.toml
hugo --config a.toml,b.toml,c.toml
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>Note: config directory is not created by default.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>content&lt;/strong>&lt;/p>
&lt;p>显然, 存储所有的post.&lt;/p>
&lt;p>&lt;strong>data&lt;/strong>&lt;/p>
&lt;p>This directory is used to store configuration files that can be used by Hugo when generating your website.&lt;/p>
&lt;p>像是你 website 的一个mini 数据库, 你可以放置 toml, yaml, json格式的文件.&lt;/p>
&lt;p>&lt;strong>layouts&lt;/strong>&lt;/p>
&lt;p>Stores templates in the form of &lt;code>.html&lt;/code> files that specify how views of your content will be rendered into a static website. Templates include &lt;a href="https://gohugo.io/templates/list/">list pages&lt;/a>, your &lt;a href="https://gohugo.io/templates/homepage/">homepage&lt;/a>, &lt;a href="https://gohugo.io/templates/taxonomy-templates/">taxonomy templates&lt;/a>, &lt;a href="https://gohugo.io/templates/partials/">partials&lt;/a>, &lt;a href="https://gohugo.io/templates/single-page-templates/">single page templates&lt;/a>, and more.&lt;/p>
&lt;p>&lt;strong>public&lt;/strong>&lt;/p>
&lt;p>保存build生成的站点. 当运行&lt;code>hugo [flag]&lt;/code>时生成.&lt;/p>
&lt;p>拷贝该目录下的内容, 可以部署到web 服务器上了.&lt;/p>
&lt;p>&lt;strong>static&lt;/strong>&lt;/p>
&lt;p>Stores all the static content: images, CSS, JavaScript, etc. 当Hugo构建您的站点时，静态目录中的所有资源都会按原样复制。&lt;/p>
&lt;p>即当构建website时, &lt;code>static/&lt;/code>下的所有文件都会复制到 &lt;code>public/&lt;/code>下.&lt;/p>
&lt;p>The static files are served on the site root path (eg. if you have the file &lt;code>static/image.png&lt;/code> you can access it using &lt;code>http://{server-url}/image.png&lt;/code>, to include it in a document you can use &lt;code>![Example image](/image.png) )&lt;/code>.&lt;/p>
&lt;p>&lt;strong>resources&lt;/strong>&lt;/p>
&lt;p>一些缓存文件&lt;/p>
&lt;blockquote>
&lt;p>Note: resources directory is not created by default.&lt;/p>
&lt;/blockquote>
&lt;h2 id="hugo-cli-命令">Hugo CLI 命令&lt;/h2>
&lt;p>hugo 支持的所有命令可以通过 &lt;code>hugo help&lt;/code> 命令来查看. 每一条命令的具体用法, 可以执行 &lt;code>hugo [command] help&lt;/code> 来查看&lt;/p>
&lt;pre tabindex="0">&lt;code>Usage:
hugo [flags]
hugo [command]
&lt;/code>&lt;/pre>&lt;h3 id="hugo-completion">Hugo completion&lt;/h3>
&lt;p>用来配置补全 hugo command 和 flag 的. 该命令会输出一段脚本, 将该脚本复制到你的 shell 的配置文件中就可以使用 hugo tab 补全了.&lt;/p>
&lt;h3 id="hugo-config">hugo config&lt;/h3>
&lt;p>打印hugo的配置文件, 即根目录下的 &lt;code>config.toml&lt;/code>.&lt;/p>
&lt;h3 id="hugo-env">hugo env&lt;/h3>
&lt;p>打印 hugo 的版本和环境信息&lt;/p>
&lt;h3 id="hugo-list">hugo list&lt;/h3>
&lt;p>打印所有post的info, 包含标题, 发布日志, 链接等.&lt;/p>
&lt;h3 id="hugo-new">hugo new&lt;/h3>
&lt;p>非常重要的命令, 可以用来新建一个 website, 主题, 或者一篇post(常用). 带有许多 flag可以使用.&lt;/p>
&lt;h3 id="hugo-server">hugo server&lt;/h3>
&lt;p>执行&lt;code>hugo server&lt;/code>之后, 首先构建了你的网站(但是默认并不在本地创建文件, 而是放在内存), 然后启动hugo 自带的 web服务器让我们能看见网站的效果.&lt;/p>
&lt;p>同时, 默认情况下, server 会同步你的本地更改, 然后实时的reload你的页面. 这样你就能同时看到修改的效果.&lt;/p>
&lt;p>hugo server 的常用flag:&lt;/p>
&lt;pre tabindex="0">&lt;code>-D 包含标记为草稿的post. 默认不构建草稿.
--theme strings 使用[strings]主题进行构建
&lt;/code>&lt;/pre>&lt;h3 id="hugo-flags">hugo [flags]&lt;/h3>
&lt;p>&lt;code>hugo&lt;/code> 自身就是一个命令, 用于build website, 放到 &lt;code>public/&lt;/code>目录下.&lt;/p>
&lt;p>常用 Flag(&lt;a href="https://gohugo.io/getting-started/usage/#test-installation:~:text=The%20output%20you%20see%20in%20your%20console%20should%20be%20similar%20to%20the%20following%3A">All supported flags&lt;/a>):&lt;/p>
&lt;pre tabindex="0">&lt;code>--gc 在build后会清除一些cache文件. 与 resource/有关
--minify minify any supported output format (HTML, XML etc.)
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>&lt;code>hugo&lt;/code> 命令不会删除之前的文件. 而是仅新增改动. 所以每次build时需要你手动删除 &lt;code>public/&lt;/code> 目录.&lt;/p>
&lt;/blockquote>
&lt;h2 id="hugo-内容管理">Hugo 内容管理&lt;/h2>
&lt;p>hugo build 后的website页面的布局和你源文件的布局相同, 所有源文件都放置在 &lt;code>content/&lt;/code> 目录下.&lt;/p>
&lt;pre tabindex="0">&lt;code>└── content
├── _index.md // &amp;lt;- https://example.com
|
├── about
| └── index.md // &amp;lt;- https://example.com/about/
├── posts
| ├── _index.md // https://example.com/posts/
| ├── firstpost.md // &amp;lt;- https://example.com/posts/firstpost/
| ├── happy
| | └── ness.md // &amp;lt;- https://example.com/posts/happy/ness/
| └── secondpost.md // &amp;lt;- https://example.com/posts/secondpost/
└── quote
├── first.md // &amp;lt;- https://example.com/quote/first/
└── second.md // &amp;lt;- https://example.com/quote/second/
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>hugo 将content/ 下的那级目录(例如 content/posts)特殊看待, 称为 &lt;em>section&lt;/em>.&lt;/p>
&lt;/blockquote>
&lt;h3 id="页面资源page-resources">页面资源(Page Resources)&lt;/h3>
&lt;p>页面资源指每个页面&lt;strong>私有的&lt;/strong>图片, 文档等静态资源. 与&lt;code>static/&lt;/code> 中全局的资源不同.&lt;/p>
&lt;p>页面资源放在&lt;code>content/&lt;/code>下的任意位置, 但不是所有页面都能访问. page bundles 中的&lt;code>index.md&lt;/code> or &lt;code>_index.md&lt;/code> 能够访问该 bundles 下的资源.&lt;/p>
&lt;pre tabindex="0">&lt;code>content
└── post
├── first-post
│ ├── images
│ │ ├── a.jpg
│ │ ├── b.jpg
│ │ └── c.jpg
│ ├── index.md (root of page bundle, 能够访问first-post/下的所有资源)
│ ├── notice.md 不能访问任何资源, 但其自身作为一个资源可被index.md访问
│ ├── office.mp3
│ ├── pocket.mp4
│ ├── rating.pdf
│ └── safety.txt
└── second-post
└── index.md (root of page bundle, 但不能访问first-post/下的资源)
&lt;/code>&lt;/pre>&lt;h3 id="内容分类taxonomy">内容分类(Taxonomy)&lt;/h3>
&lt;p>Taxonomy: How to group the content together. Two default taxonomies are &lt;em>tags&lt;/em> and &lt;em>categories&lt;/em>.&lt;/p>
&lt;h3 id="代码高亮syntax-highlighter">代码高亮(Syntax Highlighter)&lt;/h3>
&lt;p>&lt;a href="https://gohugo.io/getting-started/configuration-markup/#configure-markup:~:text=anchorize%20template%20func.-,Highlight,-This%20is%20the">代码高亮的配置&lt;/a>(in &lt;code>config.toml&lt;/code>):&lt;/p>
&lt;h3 id="页面分类">页面分类&lt;/h3>
&lt;p>从布局上来看, 页面可以分为两类: List page 和 single page.&lt;/p>
&lt;p>显而易见, list page比较特殊, 它负责列出当前目录下的所有post. 所以一个目录地址必然是一个list page.&lt;/p>
&lt;p>在下面的例子中, &lt;code>https://example.com&lt;/code> , &lt;code>https://example.com/posts/happy/&lt;/code> 都可以叫做 list page.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>https://example.com/posts/happy/&lt;/code> 是list page, 目录下的&lt;code>_index.md&lt;/code> 不是必须的, hugo 会默认仅显示所有post的title. &lt;a href="https://gohugo.io/templates/lists/#list-pages-without-_indexmd">详见&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>https://example.com/about/&lt;/code> 不是list page, 因为其目录下有&lt;code>index.md&lt;/code>, 强制表明这是一个 single page. &lt;a href="https://gohugo.io/content-management/page-bundles/#:~:text=CONTENT%20MANAGEMENT-,Page%20Bundles,-Content%20organization%20using">详见&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>└── content
├── _index.md // &amp;lt;- https://example.com
|
├── about
| └── index.md // &amp;lt;- https://example.com/about/
└── posts
├── _index.md // https://example.com/posts/
├── firstpost.md // &amp;lt;- https://example.com/posts/firstpost/
├── happy
| └── ness.md // &amp;lt;- https://example.com/posts/happy/ness/
└── secondpost.md // &amp;lt;- https://example.com/posts/secondpost/
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>Homepage 和 section page 都属于特殊的 list page.&lt;/p>
&lt;ul>
&lt;li>homepage 特指 &lt;code>content/_index.md&lt;/code>&lt;/li>
&lt;li>section page 特指 &lt;code>content/[section]/_index.md&lt;/code>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="shortcodes">shortcodes&lt;/h3>
&lt;p>shortcode 可以理解为 hugo 为了封装了一些代码块, 通过 shortcode 来调用.&lt;/p>
&lt;h2 id="模板template">模板(Template)&lt;/h2>
&lt;p>模板是hugo的一个高级用法, 用来定义你网站的style. 模板不等同与主题(themes), 可以理解为主题是一套模板的集合. 我们可以在使用模板的同时添加DIY的 style. 😎 Hugo 会有优先级的判断.&lt;/p>
&lt;p>不同的页面类型需要定义不同的模板. List page 的模板称为 List template, single page 的模板称为 single template. 同理还有 homepage template, section template.&lt;/p>
&lt;p>存储模板的目录为&lt;code>layout/&lt;/code>, 上面介绍hugo的目录结构时已经说过. 如果你使用了一个 theme, 那么&lt;code>themes/[your-theme]/layout/&lt;/code>就是该theme的模板.&lt;/p>
&lt;h3 id="homepage-模板">homepage 模板&lt;/h3>
&lt;h3 id="base-模板">Base 模板&lt;/h3>
&lt;p>对应&lt;code>layouts/_default/baseof.html&lt;/code>&lt;/p>
&lt;p>base 模板是整个website的核心. 所有的模板包括 list template, single template, homepage template&amp;hellip; 都是独立的, base template 将其他的模板联系到一起.&lt;/p>
&lt;h3 id="partial-模板">partial 模板&lt;/h3>
&lt;p>包含网站的许多元素, 增加模块化. 我可以为网站的 header 或者 footer 写一个模板(html), 这些HTML可以嵌入其他的模板.&lt;/p>
&lt;h3 id="模板优先级">模板优先级&lt;/h3>
&lt;p>既然同一种页面的模板可以定义在多个位置, 如果他们同时存在时, 优先级规则必然存在. 常见的情况比如我们使用了某个模板, 然而, 我们对模板中的一些布局不满意, 直接修改模板中的文件显然不是一个好方法, 那么该怎么做呢?&lt;/p>
&lt;p>&lt;strong>一般来说&lt;/strong>, 如果你只想重写theme中的某个模板, 例如section template. 那么你只需要新建 &lt;code>layout/_default/section.html&lt;/code> 即可, hugo 构建你的网站时, 如果检测到本地和theme的&lt;code>layout/_default&lt;/code>下都有 &lt;code>section.html&lt;/code>, 它会使用我们自己定义的那个.&lt;/p>
&lt;blockquote>
&lt;p>完整的, 多级的优先级规则: &lt;a href="https://gohugo.io/templates/lookup-order/">Hugo&amp;rsquo;s Lookup Order | Hugo (gohugo.io)&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="变量variables">变量(Variables)&lt;/h2>
&lt;p>❗ Hugo 变量仅设计给模板使用, 即在&lt;code>layouts/&lt;/code>下的html文件.&lt;/p>
&lt;h3 id="page-variables">Page Variables&lt;/h3>
&lt;p>与post相关的变量, 定义在post 的 front matter中.&lt;/p>
&lt;pre tabindex="0">&lt;code>// Define Page variables in front matter of post
----------------
title: &amp;#34;使用 HuGo 搭建个人网站&amp;#34;
description: 学习正确的 Hugo 食用方式, DIY 属于自己的 website~
Myvar: &amp;#34;my value&amp;#34;
----------------
// Use Page Variables
{{.Description}} // Get the description of the post
{{.Params.Myvar}} // Get the value of Myvar, that is, &amp;#34;my value&amp;#34;
&lt;/code>&lt;/pre>&lt;h3 id="site-variables">Site Variables&lt;/h3>
&lt;p>站点层面的变量大部分是网站配置相关.&lt;/p>
&lt;h2 id="函数functions">函数(Functions)&lt;/h2>
&lt;p>函数是hugo为你封装的一些方法你可以直接调用.&lt;/p>
&lt;p>❗ Hugo 函数仅设计给模板使用, 即在&lt;code>layouts/&lt;/code>下的html文件. Same as variables.&lt;/p>
&lt;h2 id="hugo-pipes">Hugo pipes&lt;/h2>
&lt;h1 id="diy-my-own-website">DIY My Own Website&lt;/h1>
&lt;h2 id="支持-emoji">支持 Emoji&lt;/h2>
&lt;p>&lt;a href="https://stackoverflow.com/questions/41047920/adding-emoji-to-a-hugo-page-variable">Adding emoji tutorial&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.webfx.com/tools/emoji-cheat-sheet/">Emoji chart&lt;/a>&lt;/p>
&lt;h2 id="todo-list">TODO List&lt;/h2>
&lt;ol>
&lt;li>深色和浅色模式使用 不同的代码高亮 格式&lt;/li>
&lt;li>Post section page 添加简介&lt;/li>
&lt;li>Single template 调整 Header&amp;rsquo;s margin&lt;/li>
&lt;/ol>
- https://wangloo.github.io/posts/hugo/ - @2019 Notepadium.</description></item><item><title>2019 Stanford Commencement Timcook</title><link>https://wangloo.github.io/posts/motivation/2019-stanford-commencement-timcook/</link><pubDate>Wed, 18 May 2022 19:32:38 +0800</pubDate><guid>https://wangloo.github.io/posts/motivation/2019-stanford-commencement-timcook/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/motivation/2019-stanford-commencement-timcook/ -&lt;h1 id="content">Content&lt;/h1>
&lt;p>Fourteen years ago, Steve stood on this stage and told your predecessors &amp;ldquo;Your time is limited. So don&amp;rsquo;t waste is living someone else&amp;rsquo;s life.&amp;rdquo;&lt;/p>
&lt;p>So what is true then is true now. Don&amp;rsquo;t waste your time living someone else&amp;rsquo;s life.
Don&amp;rsquo;t try to emulate the people who came before you to the exclusion of
everything else, contorting into a shape that doesn&amp;rsquo;t fit.&lt;/p>
&lt;p>Graduates, the fact is, when your time comes, and it will, you will never be ready.
But you&amp;rsquo;re not suppposed to be. Find the hope in the unexpected. Find the hope
int the challenge. Find your vision on the solitary road. Don&amp;rsquo;t get distracted.
There are too many people who want credit without responsibility. Too many who
show up for the ribbon cutting without building anything worth a damn.&lt;/p>
&lt;p>Be different. Leave something worthy. And always remember that you can&amp;rsquo;t take it
with you. You&amp;rsquo;re going to have to pass it on.&lt;/p>
&lt;p>Thank you very much. And Congratulations to the Class of 2019!&lt;/p>
&lt;p>&lt;a href="https://www.youtube.com/watch?v=2C2VJwGBRRw&amp;amp;t=80s">YouTube vidio&lt;/a>&lt;/p>
- https://wangloo.github.io/posts/motivation/2019-stanford-commencement-timcook/ - @2019 Notepadium.</description></item><item><title>Html Css Learning note (0)</title><link>https://wangloo.github.io/posts/html-css/0/</link><pubDate>Tue, 17 May 2022 11:02:04 +0800</pubDate><guid>https://wangloo.github.io/posts/html-css/0/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/html-css/0/ -&lt;h1 id="get-start">Get start&lt;/h1>
&lt;h2 id="what-is-htmlcss">What is HTML&amp;amp;CSS?&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>HTML is resonsible for the content of the page. That&amp;rsquo;s the text, images, buttons, etc.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CSS is resonsible for the presentation of the content. That&amp;rsquo;s the color, layout, etc.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Web &lt;strong>designers&lt;/strong> create the overall look and fell of a website.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Web &lt;strong>developers&lt;/strong> implement the design using &lt;strong>HTML, CSS and JavaScript code&lt;/strong>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="configure-vim-as-html-code-editor">Configure VIM as HTML code-editor&lt;/h2>
&lt;blockquote>
&lt;p>Finally in the arms of &lt;code>vscode&lt;/code> 🙉&lt;/p>
&lt;/blockquote>
&lt;p>Add vim plugin:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://emmet.io/">emmet&lt;/a>: Coding HTML faster.&lt;/li>
&lt;/ul>
&lt;p>CSS autocomplete key: &lt;code>&amp;lt;C-x&amp;gt; &amp;lt;C-o&amp;gt;&lt;/code>&lt;/p>
&lt;p>HTML and CSS live previes plugin: &lt;a href="https://github.com/turbio/bracey.vim">bracey&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/turbio/bracey.vim/issues/21">urlopen error solution&lt;/a>&lt;/li>
&lt;/ul>
&lt;p> &lt;/p>
&lt;h1 id="html-fundamentals">HTML Fundamentals&lt;/h1>
&lt;h2 id="anatomy-of-an-html-element">Anatomy of an HTML element&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#ff79c6">p&lt;/span>&amp;gt; THML is a markup language&amp;lt;/&lt;span style="color:#ff79c6">p&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The HTML element is composed of &lt;code>opening tag&lt;/code>, &lt;code>content&lt;/code>, &lt;code>closing tag&lt;/code>.&lt;/p>
&lt;h2 id="html-good-styles">HTML good styles&lt;/h2>
&lt;ul>
&lt;li>&lt;code>&amp;lt;img/&amp;gt;&lt;/code> element should add &lt;code>alt&lt;/code> attritube at all time, for the convenience of the blind.&lt;/li>
&lt;li>An important principle in web design is &lt;code>making the HTML elements meaningful&lt;/code>. That is &lt;a href="https://www.thoughtco.com/why-use-semantic-html-3468271">semantic HTML&lt;/a>.&lt;/li>
&lt;/ul>
&lt;p> &lt;/p>
&lt;h1 id="css-fundamentals">CSS Fundamentals&lt;/h1>
&lt;p>CSS describes the visual style and presentation of the contend in HTML.&lt;/p>
&lt;h2 id="anatomy-of-an-html-element-1">Anatomy of an HTML element&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-css" data-lang="css">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">h1&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">color&lt;/span>: &lt;span style="color:#ff79c6">blue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">text-align&lt;/span>: &lt;span style="color:#ff79c6">center&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">font-size&lt;/span>: &lt;span style="color:#bd93f9">20&lt;/span>&lt;span style="color:#8be9fd">px&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>h1 is &lt;code>Seletor&lt;/code>, every &lt;code>style&lt;/code> has &lt;code>proporty&lt;/code> and &lt;code>value&lt;/code>.&lt;/p>
&lt;h2 id="css-good-styles">CSS good styles&lt;/h2>
&lt;ul>
&lt;li>Class selector is more commonly used than ID selector, as &lt;code>ID&lt;/code> is &lt;em>unique&lt;/em> in HTML. For scalability, &lt;strong>remember always using class selector&lt;/strong>.&lt;/li>
&lt;li>We should always specify all the four state of &lt;code>&amp;lt;a&amp;gt;&lt;/code> element in order, which including &lt;code>link&lt;/code>, &lt;code>visited&lt;/code>, &lt;code>hover&lt;/code> and &lt;code>active&lt;/code>.&lt;/li>
&lt;/ul>
&lt;h2 id="priority-conflicts-between-selectors">Priority conflicts between selectors&lt;/h2>
&lt;p>CSS style priority from high to low:&lt;/p>
&lt;ol>
&lt;li>Inline style(style attribute in HTML)&lt;/li>
&lt;li>ID selector&lt;/li>
&lt;li>class or pseudo-class selector&lt;/li>
&lt;li>element selector&lt;/li>
&lt;li>universal element selector&lt;/li>
&lt;/ol>
&lt;p> &lt;/p>
&lt;h1 id="the-css-box-model">The CSS box model&lt;/h1>
&lt;p>The box model defines how elements are displayed on a webpage and how they are sized.&lt;br>
In the box model, every element on a webpage can be seen as a rectangular box.&lt;/p>
&lt;p> &lt;/p>
&lt;h1 id="universal-element--body-element">Universal element &amp;amp; &lt;code>&amp;lt;body&amp;gt;&lt;/code> element&lt;/h1>
&lt;p>Styles in &lt;code>&amp;lt;body&amp;gt;&lt;/code> selector take effect because of inheritance. But the text-independent elements do not support inheritance.&lt;br>
That is where &lt;em>universal element&lt;/em> selector is needed. It&amp;rsquo;s styles take effect on all element.&lt;/p>
&lt;p>When we want to set padding and margin of all elements to &lt;code>0&lt;/code>. Must put the code in universal element selector.&lt;/p>
&lt;p> &lt;/p>
&lt;h1 id="inline-elements--block-elements">Inline elements &amp;amp; Block elements&lt;/h1>
&lt;p>Inline elements:&lt;/p>
&lt;ul>
&lt;li>Occupies only the space necessary for its content.&lt;/li>
&lt;li>Box model applies in different way: &lt;strong>heights and widths do no apply&lt;/strong>.&lt;/li>
&lt;li>Paddings and margins are applied &lt;strong>only horizontally&lt;/strong>(left and right).&lt;/li>
&lt;/ul>
&lt;p>Block elements:&lt;/p>
&lt;ul>
&lt;li>100% of parent&amp;rsquo;s width&lt;/li>
&lt;li>vertivally, one after another&lt;/li>
&lt;/ul>
&lt;p>Inline-Block elements:&lt;/p>
&lt;ul>
&lt;li>Good example is &lt;code>&amp;lt;img&amp;gt;&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p> &lt;/p>
&lt;h1 id="the-3-ways-of-building-layouts-with-css">The 3 ways of building layouts with CSS&lt;/h1>
&lt;p>&lt;code>Float Layouts&lt;/code>: The &lt;strong>old way of building layouts&lt;/strong>, using the float CSS property. Still used, but getting outdated fase.&lt;/p>
&lt;ul>
&lt;li>Element is removed from the normal flow: &lt;em>out of&lt;/em> flow. Like absolutely positioning.&lt;/li>
&lt;li>Text and inline elements will wrap around the floated elements. Different from absolutely elements.&lt;/li>
&lt;li>The container will &lt;em>NOT&lt;/em> adjust its height to the elements.&lt;/li>
&lt;/ul>
&lt;p>&lt;code>FlexBox&lt;/code>: Modern way of laying out elements in a &lt;strong>1-dimensional row&lt;/strong> without using floats. Prefect for &lt;strong>component layouts&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>One of its most useful applications is &lt;strong>vertical centering&lt;/strong>.&lt;/li>
&lt;li>Flex container property:
&lt;ul>
&lt;li>&lt;code>gap&lt;/code>: To create space between items.&lt;/li>
&lt;li>&lt;code>justify-content&lt;/code>: To align items along main axis(&lt;strong>horizontally&lt;/strong>, by default)&lt;/li>
&lt;li>&lt;code>align-items&lt;/code>: To align items along cross axis(&lt;strong>vertically&lt;/strong>, by dedauly)&lt;/li>
&lt;li>&lt;code>flex-wrap&lt;/code>: To allow items to &lt;strong>wrap into a new line&lt;/strong> if they are too large&lt;/li>
&lt;li>&lt;code>align-content&lt;/code>: Only applies when there are multiple lines(flex-wrap: wrap)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Flex Items property:
&lt;ul>
&lt;li>&lt;code>align-self&lt;/code>: To overwrite align-items for individual flex items.&lt;/li>
&lt;li>&lt;code>flex-grow&lt;/code>: To allow an element to &lt;strong>grow&lt;/strong>.&lt;/li>
&lt;li>&lt;code>flex-shrink&lt;/code>: To allow an element to &lt;strong>shrink&lt;/strong>.&lt;/li>
&lt;li>&lt;code>flex-basis&lt;/code>: To define an item&amp;rsquo;s width, &lt;strong>instead of the width&lt;/strong> property.&lt;/li>
&lt;li>&lt;code>flex&lt;/code>: &lt;strong>Recommended shorthand&lt;/strong> for flex-grow, -shrink, -basis.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;code>CSS Grid&lt;/code>: For laying out elements in a fully-fledged &lt;strong>2-dimensional grid&lt;/strong>. Perfect for page layouts and complex components.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>CSS grid is a set of &lt;strong>CSS properties&lt;/strong> for building &lt;strong>2-dimensional&lt;/strong> layouts&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The main idea behind CSS Grid is that we &lt;strong>divide a container element into rows and columns&lt;/strong> that can be filled with its child elements&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CSS grid is &lt;strong>not meant to replace flexbox!&lt;/strong>. Instead, they work perfectly together. Need a &lt;strong>1D&lt;/strong> layouts? Use flexbox. Need a &lt;strong>2D&lt;/strong> layout? Use CSS grid&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Grid container&lt;/p>
&lt;ul>
&lt;li>grid-template-rows/grid-template-columns: To establish the grid &lt;strong>row and column tracks&lt;/strong>. One length uniit for each track. Any unit can be used, new &lt;strong>fr&lt;/strong> fills unused space&lt;/li>
&lt;li>row-gap/colum-gap: To &lt;strong>create empty space&lt;/strong> between tracks&lt;/li>
&lt;li>justify-items/align-items: To align items inside rows/columns(&lt;strong>horizontally/vertically&lt;/strong>)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Grid items&lt;/p>
&lt;ul>
&lt;li>grid-column/grid-row: To &lt;strong>place a grid item&lt;/strong> into a specific cell, based on line numbers. span keyword can be used to span an item across more cells&lt;/li>
&lt;li>justify-self/align-self: To &lt;strong>overwrite&lt;/strong> justify-items/align-items for single items&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
- https://wangloo.github.io/posts/html-css/0/ - @2019 Notepadium.</description></item><item><title>我的 vim 调教随笔</title><link>https://wangloo.github.io/posts/vim/basic/</link><pubDate>Mon, 09 May 2022 19:28:12 +0800</pubDate><guid>https://wangloo.github.io/posts/vim/basic/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/vim/basic/ -&lt;p>Search a word quickly: put cursor on the word, press &lt;code>/&lt;/code> and press &lt;code>&amp;lt;C-R&amp;gt;&lt;/code> &lt;code>&amp;lt;C-W&amp;gt;&lt;/code>.&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="缩写的含义meaning-of-abbreviations">缩写的含义(Meaning of abbreviations)&lt;/h2>
&lt;p>Operation&lt;/p>
&lt;ul>
&lt;li>d - delete&lt;/li>
&lt;li>y - yank(copy, 因为c被占了)&lt;/li>
&lt;li>c - change&lt;/li>
&lt;li>r - replace&lt;/li>
&lt;li>v - visual select&lt;/li>
&lt;/ul>
&lt;p>Scope or location&lt;/p>
&lt;ul>
&lt;li>i - inside&lt;/li>
&lt;li>a - around&lt;/li>
&lt;li>f - forward&lt;/li>
&lt;li>t - to&lt;/li>
&lt;/ul>
&lt;p>Object&lt;/p>
&lt;ul>
&lt;li>w - word&lt;/li>
&lt;li>s - sentence&lt;/li>
&lt;li>p - paragraph&lt;/li>
&lt;/ul>
&lt;p> &lt;/p>
&lt;h2 id="书签-bookmark">书签: Bookmark&lt;/h2>
&lt;p>&lt;code>ma&lt;/code>: create bookmark &lt;code>a&lt;/code> inside file.&lt;br>
&lt;code>mA&lt;/code>: create global bookmark &lt;code>A&lt;/code>.&lt;br>
&lt;code>`a&lt;/code>: jump to bookmark &lt;code>a&lt;/code>.&lt;/p>
&lt;p>&lt;code>:marks&lt;/code>: display all bookmarks&lt;/p>
&lt;h2 id="缩进-indent">缩进: indent&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;code>&amp;gt;&lt;/code>: increase indent , &lt;code>&amp;lt;&lt;/code>: decrease indent ,&lt;code>=&lt;/code>: auto indent&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>&amp;gt;&amp;gt;&lt;/code>: 增加当前行的缩进&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>gg=G&lt;/code>: 缩进全文, 无论当前光标在哪&lt;/p>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>以上命令都可以配合visual mode使用&lt;/p>
&lt;/blockquote>
&lt;h3 id="自动缩进的规则">自动缩进的规则&lt;/h3>
&lt;p>主要有四种可用缩进的方式, 分别是:&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;#39;autoindent&amp;#39; 沿用上一行的缩进。
&amp;#39;smartindent&amp;#39; 类似 &amp;#39;autoindent&amp;#39;，但是可以识别一些 C 语法以能在合适的地方
增加 / 减少缩进。
&amp;#39;cindent&amp;#39; 比上面两个更聪明；可以设置不同的缩进风格。
&amp;#39;indentexpr&amp;#39; 最灵活的一个: 根据表达式来计算缩进。若此选项非空，则优先于其它
选项覆盖。参见 indent-expression 。
&lt;/code>&lt;/pre>&lt;p>自定义的快速命令:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-vimrc" data-lang="vimrc">&lt;span style="display:flex;">&lt;span>command IndentOff setl noai nocin nosi indentexpr=&lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>command IndentOn setl ai cin si &lt;span style="color:#6272a4">&amp;#34;indentexpr can&amp;#39;t be re-enabled.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>command IndentStatus set ai? si? cin? indentexpr?
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>&lt;code>cindent&lt;/code> 不一定对所有的语言都有效果. 只是 C-like 风格, 其中一个要求是顶层函数必须在第一列中含有 &lt;code>{&lt;/code>.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>只有当&lt;code>indentexpr&lt;/code>计算不出当前需要缩进几格时(return -1), 才使用上面的三个规则. 它是优先级最高的.&lt;/p>
&lt;/blockquote>
&lt;h2 id="find-and-tail">&lt;code>F&lt;/code>ind and &lt;code>T&lt;/code>ail&lt;/h2>
&lt;p>&lt;code>f(&lt;/code>: 从当前cursor处向右查找下一个&lt;code>(&lt;/code>, 并将光标移动到&lt;code>(&lt;/code>处.&lt;br>
&lt;code>F(&lt;/code>: Like &lt;code>f(&lt;/code>, but 向左查找.&lt;br>
&lt;code>t(&lt;/code>: Like &lt;code>f(&lt;/code>, but 将cursor移动到&lt;code>(&lt;/code>的前一个.&lt;br>
&lt;code>T(&lt;/code>: You can guess.&lt;/p>
&lt;h4 id="trick">Trick&lt;/h4>
&lt;p>&lt;code>vt(c&lt;/code>: With visual, 删除当前光标到下一个&lt;code>(&lt;/code>前的所有内容.&lt;/p>
&lt;p>&lt;code>;&lt;/code>/&lt;code>,&lt;/code>: 查找下一个/上一个 &lt;code>f/F/t/T&lt;/code> 的内容.&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="substitute-and-global">&lt;code>S&lt;/code>ubstitute and &lt;code>G&lt;/code>lobal&lt;/h2>
&lt;blockquote>
&lt;p>See: &lt;code>:help :s&lt;/code> and &lt;code>:help :g&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>这两个都属于vim的命令. vim 的替换和sed 的&lt;code>s&lt;/code>命令使用方式基本一致. 就不多介绍了.&lt;/p>
&lt;p>而 vim 的 global 命令和sed有些许差别. 使用Sed删除包含个字符串的行的指令为: &lt;code>sed '/STRING/d' input_file&lt;/code>, 而在vim中则多了一个&lt;strong>g&lt;/strong>前缀, &lt;code>:g/STRING/d&lt;/code>.&lt;/p>
&lt;p>global 可以和 substitute 结合使用, 例如想要在包含某个字符串的行中替换&lt;code>good&lt;/code>为&lt;code>excellent&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>:g/STRING/s/good/excellent/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>TODO:&lt;/p>
&lt;ol>
&lt;li>More [cmd] in global. &lt;a href="https://vim.fandom.com/wiki/Power_of_g">Power of g | Vim Tips Wiki | Fandom&lt;/a>&lt;/li>
&lt;li>vim subtitute使用的正则表达式集包含 &lt;code>\zs&lt;/code>和&lt;code>\ze&lt;/code>, 然而 sed 没有(Sed 为 POSIX Basic Regular Expression).&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p> &lt;/p>
&lt;h2 id="大小写转换">大小写转换&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>cmd&lt;/th>
&lt;th>description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>g~&lt;/code>&lt;/td>
&lt;td>翻转大小写&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gu&lt;/code>&lt;/td>
&lt;td>转换为小写&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gU&lt;/code>&lt;/td>
&lt;td>转换为大写&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>以上命令(严格来说叫操作符)需要配合&lt;strong>动作命令&lt;/strong>来使用.&lt;/p>
&lt;ul>
&lt;li>&lt;code>gUaw&lt;/code>: 将光标所在位置的&lt;em>单词&lt;/em>转为大写&lt;/li>
&lt;li>&lt;code>gUap&lt;/code>: 将光标所在位置的&lt;em>段落&lt;/em>转为大写&lt;/li>
&lt;/ul>
&lt;p> &lt;/p>
&lt;h2 id="search-and-replace">Search and replace&lt;/h2>
&lt;h3 id="case-1-search-and-convert-to-uppercaselowercase">case 1: search and convert to uppercase/lowercase&lt;/h3>
&lt;p>我直觉想到的方式是&lt;code>%s/html/HTML/gc&lt;/code>&lt;/p>
&lt;p>这种方式在简单情况下也行, 比较灵活且直观, 但是对于复杂文件不够通用且容易出错&lt;/p>
&lt;p>还有一种方式是先搜索, 然后一步步替换&lt;/p>
&lt;ul>
&lt;li>搜索: &lt;code>/\vhtml\C&lt;/code>&lt;/li>
&lt;li>替换: 执行命令&lt;code>gUgn&lt;/code>, 然后使用&lt;code>n&lt;/code>和&lt;code>.&lt;/code>来重复操作下一个选中项.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;code>gn&lt;/code>命令进对于sreach的匹配项使用, 类似于&lt;code>n&lt;/code>, 但会将下一个匹配项(若光标停在match上, 那则选中当前匹配项)
转为visual模式选中的状态.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>其实对于简单的文本, &lt;code>n&lt;/code>和&lt;code>.&lt;/code>也可以简化为&lt;code>.&lt;/code>. 唯一的坏处就是如果两个匹配的距离太大,
你不能确认是否search了你想要的内容.&lt;/p>
&lt;/blockquote>
&lt;h3 id="case-2-search-the-text-seleted-in-visual-mode">case 2: search the text seleted in &lt;em>visual mode&lt;/em>&lt;/h3>
&lt;blockquote>
&lt;p>vim 本身并未提供这个功能, 需要借助一个脚本来完成&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="#search-text-selected-in-visual-mode">search the text selected in visual mode&lt;/a>&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="visual-block-模式">Visual Block 模式&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>选中后, 编辑所有行: &lt;code>I&lt;/code>(captial i), 编辑完成后按两次&lt;code>ESC&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>重复visual 选中上次的 block: Normal模式下&lt;code>gv&lt;/code>即可.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p> &lt;/p>
&lt;h2 id="单词间跳转">单词间跳转&lt;/h2>
&lt;p>&lt;code>w&lt;/code>: Move cursor to begin of next word.&lt;br>
&lt;code>b&lt;/code>: Move cursor to begin of last word.&lt;br>
&lt;code>e&lt;/code>: Move cursor to end of next word.&lt;/p>
&lt;h3 id="trick-1">Trick&lt;/h3>
&lt;p>&lt;code>w&lt;/code>/&lt;code>b&lt;/code>配合&lt;code>ce&lt;/code>使用可达到在某一行中快速移动到某个单词, 然后删除该单词开始edit.&lt;/p>
&lt;p>&lt;code>daw&lt;/code>: 即 Delete A Word, 可以删除一个完整的单词, 无论当前光标的位置在哪.&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="编辑二进制十六进制文件">编辑二进制/十六进制文件&lt;/h2>
&lt;p>可以使用&lt;code>xxd&lt;/code>命令将一个文件中的文本转换为hex格式显示. 在vim中键入&lt;code>:%!xxd&lt;/code> 即可. 得到的效果如下:&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-xxd" data-lang="xxd">0000000: 5468 6973 2069 7320 6120 7465 7374 0a41 This is a test.A
0000010: 6e6f 7468 6572 206c 696e 650a 416e 6420 nother line.And
0000020: 7965 7420 616e 6f74 6865 720a yet another.
&lt;/code>&lt;/pre>&lt;p>后面的对应文本是自动生成的, 仅需要修改十六进制的部分即可. 修改完成后, 要返回原本的模式, 键入&lt;code>:%!xxd -r&lt;/code>.&lt;/p>
&lt;blockquote>
&lt;p>可通过设置文本格式对十六进制内存高亮显示 &lt;code>set ft=xxd&lt;/code>.&lt;/p>
&lt;/blockquote>
&lt;p> &lt;/p>
&lt;h2 id="删除光标前后的所有字符">删除光标前/后的所有字符&lt;/h2>
&lt;ol>
&lt;li>&lt;code>d^&lt;/code> &amp;ndash; delete to first non-whitespace character in the line&lt;/li>
&lt;li>&lt;code>d0&lt;/code> &amp;ndash; delete to beginning of the line&lt;/li>
&lt;li>&lt;code>c-u&lt;/code> in &lt;strong>insert mode&lt;/strong>. Same as bash command shortkeys, see &lt;a href="https://ss64.com/bash/syntax-keyboard.html">here&lt;/a>&lt;/li>
&lt;/ol>
&lt;p> &lt;/p>
&lt;h2 id="文件恢复swp文件">文件恢复/swp文件&lt;/h2>
&lt;p>正确对待swp文件的姿势:&lt;/p>
&lt;ol>
&lt;li>vim 打开原文件, 此时会提示&lt;code>Found a swap file the name .xxx.swp&lt;/code>, 显然选择&lt;code>(R)ecover&lt;/code> 来恢复未保存的内容.&lt;/li>
&lt;li>使用&lt;code>:w&lt;/code>将恢复的内容保存下来&lt;/li>
&lt;li>但是此时原本的swp文件还是存在, 此时我们执行&lt;code>:e&lt;/code>刷新一下当前bufffer, 仍然会提示恢复的选项, 但此时文件内容已经恢复, 选择&lt;code>(D)elete&lt;/code> 就可将对应的swp文件删除了&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>删除当前目录中所有swp file的脚本?&lt;/p>
&lt;p>需要确保:&lt;/p>
&lt;ul>
&lt;li>所有文件内容已恢复&lt;/li>
&lt;li>当前窗口或者其他窗口没有vim正在打开文件(会生成swp file)&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>find . -type f -name &lt;span style="color:#f1fa8c">&amp;#34;.*.sw[klmnop]&amp;#34;&lt;/span> -delete
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/blockquote>
&lt;p>&lt;a href="https://www.cs.longwood.edu/VimSwap.html">How to handle swapfiles in Vim (longwood.edu)&lt;/a>&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="debug-vim-key-mapping">Debug VIM key mapping&lt;/h2>
&lt;p>&lt;a href="https://vi.stackexchange.com/a/7723/43494">https://vi.stackexchange.com/a/7723/43494&lt;/a>&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="如何同步-vim-dotfiles">如何同步 VIM Dotfiles&lt;/h2>
&lt;p>vim 的 dotfiles 主要包含&lt;code>.vimrc&lt;/code>和&lt;code>.vim/&lt;/code>中的插件.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对于&lt;code>.vimrc&lt;/code>, 我选择使用mackup 软件和其他system dotfiles 一起备份. &lt;a href="https://github.com/wangloo/dotfiles">Git repo&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于 plugins, 传统的管理插件的方式(使用&lt;code>vim-plug&lt;/code>), 也就是放在&lt;code>~/.vim/plugged/&lt;/code>目录中的, 可以通过&lt;code>:PlugInstall&lt;/code>命令在新机器上重新从网上克隆. 能够保证使用的是新版本.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>VIM 8.0 之后, 引入 &lt;em>pack system&lt;/em> 新的插件管理方式. 对于这类的插件, 我们直接利用&lt;code>submodule&lt;/code>加入另一个备份的 &lt;a href="https://github.com/wangloo/vimpack">Git repo&lt;/a>. 使用方法见&lt;code>README&lt;/code>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p> &lt;/p>
&lt;h2 id="good-plugins">Good plugins&lt;/h2>
&lt;blockquote>
&lt;p>Reference: &lt;a href="https://github.com/amix/vimrc">The Ultimate vimrc&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h3 id="todo">TODO&lt;/h3>
&lt;h3 id="installed">Installed&lt;/h3>
&lt;p>&lt;a href="https://github.com/preservim/nerdcommenter#settings">NERD Commneter - 快速注释&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://github.com/preservim/nerdtree">NERD Tree - 目录树&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://github.com/amix/open_file_under_cursor.vim">Open File Under Cursor - 打开光标处的文件目录&lt;/a>&lt;/p>
&lt;ul>
&lt;li>不支持&lt;code>vim-plug&lt;/code>安装. 直接clone源码到&lt;code>plugged&lt;/code>目录即可.&lt;/li>
&lt;li>Usage: &lt;code>gf&lt;/code>: 在当前window打开文件. &lt;code>&amp;lt;C-w&amp;gt;&amp;lt;C-f&amp;gt;&lt;/code>: &lt;strong>new vertical windows&lt;/strong>中打开文件.&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/mileszs/ack.vim">Ack.vim - 快速定位内容&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://github.com/Yggdroot/LeaderF">LeaderF - Like Ctrlp but better?&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://github.com/rlue/vim-barbaric">barbaric - normal模式切换英文输入法&lt;/a>&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="helpful-script">Helpful script&lt;/h2>
&lt;h3 id="search-text-selected-in-visual-mode">search text selected in visual mode&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-vimrc" data-lang="vimrc">&lt;span style="display:flex;">&lt;span>xnoremap * :&amp;lt;C-u&amp;gt;call &amp;lt;SID&amp;gt;VSetSearch(&lt;span style="color:#f1fa8c">&amp;#39;/&amp;#39;&lt;/span>)&amp;lt;CR&amp;gt;&lt;span style="color:#f1fa8c">/&amp;lt;C-R&amp;gt;=@/&lt;/span>&amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>xnoremap # :&amp;lt;C-u&amp;gt;call &amp;lt;SID&amp;gt;VSetSearch(&lt;span style="color:#f1fa8c">&amp;#39;?&amp;#39;&lt;/span>)&amp;lt;CR&amp;gt;?&amp;lt;C-R&amp;gt;=@/&amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">function&lt;/span>! s:VSetSearch(cmdtype)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">let&lt;/span> temp = @s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>norm! gv&amp;#34;sy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">let&lt;/span> @/ = &lt;span style="color:#f1fa8c">&amp;#39;\V&amp;#39;&lt;/span> . substitute(escape(@s, a:cmdtype.&lt;span style="color:#f1fa8c">&amp;#39;\&amp;#39;&lt;/span>), &lt;span style="color:#f1fa8c">&amp;#39;\n&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;\\n&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;g&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">let&lt;/span> @s = temp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">endfunction&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>- https://wangloo.github.io/posts/vim/basic/ - @2019 Notepadium.</description></item><item><title>reveal.js Tutorial</title><link>https://wangloo.github.io/posts/revealjs/</link><pubDate>Sun, 08 May 2022 19:34:44 +0800</pubDate><guid>https://wangloo.github.io/posts/revealjs/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/revealjs/ -&lt;h1 id="change-code-theme">Change code theme&lt;/h1>
&lt;p>Default use &lt;code>monokai.css&lt;/code>. see &lt;a href="https://revealjs.com/code/">官方文档&lt;/a>&lt;/p>
&lt;p>修改需要下载新的&lt;code>css&lt;/code>放到&lt;code>plugin/highlight/&lt;/code>目录下.&lt;/p>
&lt;p>其他可用的&lt;code>css&lt;/code>在&lt;a href="https://github.com/highlightjs/highlight.js/tree/main/src/styles">highlight.js仓库&lt;/a>中下载.&lt;/p>
&lt;h1 id="align">Align&lt;/h1>
&lt;h2 id="slide-align">Slide Align&lt;/h2>
&lt;p>取消center对齐方式:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>Reveal.initialize({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> center&lt;span style="color:#ff79c6">:&lt;/span> &lt;span style="color:#ff79c6">false&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ... })
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所有slide左对齐: &lt;a href="https://github.com/hakimel/reveal.js/issues/1897">https://github.com/hakimel/reveal.js/issues/1897&lt;/a>&lt;/p>
&lt;p>用markdown写的方式下使某一幻灯片左对齐: &lt;a href="https://github.com/hakimel/reveal.js/issues/890#issuecomment-129735291">https://github.com/hakimel/reveal.js/issues/890#issuecomment-129735291&lt;/a>&lt;/p>
- https://wangloo.github.io/posts/revealjs/ - @2019 Notepadium.</description></item><item><title>A64 指令集</title><link>https://wangloo.github.io/posts/armv8/a64_isa/</link><pubDate>Sat, 07 May 2022 21:19:01 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/a64_isa/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/armv8/a64_isa/ -&lt;h2 id="loadstore-指令">Load/Store 指令&lt;/h2>
&lt;h3 id="1-basic-loadstore">#1 Basic Load/Store&lt;/h3>
&lt;h4 id="addressing-mode">Addressing mode&lt;/h4>
&lt;ol>
&lt;li>Base register - &lt;code>w0=[x1]&lt;/code>&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>ldr w0, [x1]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>Offset addressing mode - &lt;code>w0=[x1+12]&lt;/code>&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>ldr w0, [x1, &lt;span style="color:#bd93f9">12&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>Pre-index addressing mode - &lt;code>x1+=12; w0=[x1]&lt;/code>&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>ldr w0, [x1, &lt;span style="color:#bd93f9">12&lt;/span>]&lt;span style="color:#ff79c6">!&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>Post-index addressing mode - &lt;code>w0=[x1]; x1+=12&lt;/code>&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>ldr w0, [x1], &lt;span style="color:#bd93f9">12&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="loadstore-instruction-example">Load/store instruction example&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// load a byte from x1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>ldrb w0, [x1]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// load a signed byte from x1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>ldrsb w0, [x1]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// store a 32-bit word to address in x1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>str w0, [x1]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// load two 32-bit words from stack, then add 8-byte to sp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>ldp w0, w1, [sp], &lt;span style="color:#bd93f9">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// store two 64-bit words at [sp-96] and subtract 96-byte from sp.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>stp x1, x2, [sp, &lt;span style="color:#ff79c6">-&lt;/span>&lt;span style="color:#bd93f9">96&lt;/span>]&lt;span style="color:#ff79c6">!&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// LDR伪指令. load 32-bit immediate from literal pool(addr: 0x12345678)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>ldr w0, &lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#bd93f9">0x12345678&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="数据处理指令">数据处理指令&lt;/h2>
&lt;h3 id="bitfield-操作指令">Bitfield 操作指令&lt;/h3>
&lt;p>Bitfield指令常用于设置/提取寄存器的某个字段.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-assembly" data-lang="assembly">;BFI(Bit Field Insert)
BFI w0, w0, #9, #6 ;w0[0, 5] = w0[9, 14]
;BFC(Bit Field Clear)
BFC w0, #4, #2 ;w0[4, 5] = 0
;UBFX(Unsigned Bit Field Extract)
UBFX w1, w0, #18, #7 ;w1=w0[18, 24]
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>与UBFX相对的是SBFX, 若提取后的字段高位为1, 会进行符号扩展&lt;/p>
&lt;/blockquote>
&lt;p> &lt;/p>
&lt;h2 id="分支控制指令">分支/控制指令&lt;/h2>
&lt;h2 id="其他指令">其他指令&lt;/h2>
&lt;h3 id="1-adradrp-指令">#1 ADR/ADRP 指令:&lt;/h3>
&lt;blockquote>
&lt;p>既然有了LDR伪指令, 为什么需要ADR指令呢?&lt;/p>
&lt;/blockquote>
&lt;p> &lt;/p>
&lt;h2 id="有趣特性常见误区">有趣特性/常见误区&lt;/h2>
&lt;h3 id="-before-the-immediate-value">&amp;lsquo;#&amp;rsquo; before the immediate value&lt;/h3>
&lt;ul>
&lt;li>A64 assembly language does not require the &lt;code>#&lt;/code> to introduce constant immediate value. But the assembler can also indentify the &lt;code>#&lt;/code>.&lt;/li>
&lt;li>In armv7, there must be a &lt;code>#&lt;/code> or &lt;code>$&lt;/code> before other than using &lt;code>.syntax unified&lt;/code>. &lt;a href="https://sourceware.org/binutils/docs/as/ARM_002dInstruction_002dSet.html#ARM_002dInstruction_002dSet">About syntax unified&lt;/a>.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;a href="https://stackoverflow.com/questions/21652884/is-the-hash-required-for-immediate-values-in-arm-assembly">Agreed Recommendation&lt;/a>&lt;/p>
&lt;p>Use &lt;code>.syntax unified&lt;/code> in v7 code, and never use &lt;code>#&lt;/code> on any literal on either v7 or v8.
Unified syntax is newer and better, and those &lt;code>#&lt;/code> and &lt;code>$&lt;/code> signs are just more code noise.&lt;/p>
&lt;/blockquote>
- https://wangloo.github.io/posts/armv8/a64_isa/ - @2019 Notepadium.</description></item><item><title>ARMv8-A 寄存器</title><link>https://wangloo.github.io/posts/armv8/register/</link><pubDate>Sat, 07 May 2022 20:19:44 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/register/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/armv8/register/ -&lt;h1 id="寄存器分类">寄存器分类&lt;/h1>
&lt;h2 id="通用寄存器">通用寄存器&lt;/h2>
&lt;ol>
&lt;li>&lt;code>x0-x7&lt;/code> 参数寄存器: Restore function parameters and return vaule.&lt;/li>
&lt;li>&lt;code>x9-x15&lt;/code> caller-saved 临时寄存器: callee 默认可以直接使用来保存临时变量, 不需要保存和恢复. 如果 caller 在里面存储了非临时信息, 那么在函数调用之前应当由 caller 负责保存.&lt;/li>
&lt;li>&lt;code>x19-x28&lt;/code> callee-saved 寄存器: callee 应该避免使用. 如果必须要使用，那么在返回前必须恢复.&lt;/li>
&lt;li>special registers:
&lt;ul>
&lt;li>&lt;code>x8&lt;/code> restore indirect result. Commonly used when returning a struct.&lt;/li>
&lt;li>&lt;code>x18&lt;/code> platform reserved register.&lt;/li>
&lt;li>&lt;code>x29&lt;/code> frame pointer register(FP).&lt;/li>
&lt;li>&lt;code>x30&lt;/code> link register(LR).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>All general-purpose register &lt;code>xN&lt;/code> is 64-bit width. They all have corresponding &lt;code>wN&lt;/code> register using the lower 32-bit of &lt;code>xN&lt;/code>. And write to &lt;code>wN&lt;/code> will clear the upper 32bit of &lt;code>xN&lt;/code>.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>💫 The different between &lt;strong>Caller-saved&lt;/strong> and &lt;strong>callee-saved&lt;/strong> registers&lt;/p>
&lt;ul>
&lt;li>Caller-saved 寄存器又称为&lt;em>临时寄存器&lt;/em>, 常用来存放临时变量. 例如A() 调用 B(), 那么 B() 可以直接使用 caller-saved 寄存器, 也就是说 A() 在调用 B() 之前不会在这些寄存器里保存重要信息(编译器实现), 不能保证调用 B() 前后其值不变. 如果必须要保证, 那么保存和恢复(利用栈)这件事是 A() 来做.&lt;/li>
&lt;li>Callee-saved 寄存器则相反, 通常持续使用的值会保存到这些寄存器中. 还是拿 A() call B() 来举例. 如果 A() 中的一个变量需要在调用 B() 前后持续有效, 那么它应当保存到 callee-saved 寄存器中. 而且 B() 正常来说不应该动这些寄存器, 如果非得动(例如寄存器不够用), 那么 B() 需要在使用他们的前后进行保存和恢复(利用栈).&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="每个el的特殊寄存器">每个EL的特殊寄存器&lt;/h2>
&lt;ol>
&lt;li>&lt;code>sp_el0/1/2/3&lt;/code> stack pointer register of each EL.&lt;/li>
&lt;li>&lt;code>elr_el1/2/3&lt;/code> exception link register of each EL except EL0.&lt;/li>
&lt;li>&lt;code>spsr_el1/2/3&lt;/code> save program status register of each EL except EL0.&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>&lt;code>sp&lt;/code> is an alias of &lt;code>sp_el0&lt;/code>. Do NOT treat &lt;code>sp&lt;/code> as general-purpose register.&lt;/p>
&lt;/blockquote>
- https://wangloo.github.io/posts/armv8/register/ - @2019 Notepadium.</description></item><item><title>Numberical Analysis Exam</title><link>https://wangloo.github.io/posts/numberical-analysis/</link><pubDate>Sat, 07 May 2022 18:04:58 +0800</pubDate><guid>https://wangloo.github.io/posts/numberical-analysis/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/numberical-analysis/ -&lt;p>&lt;img src="qingdao-tzjt.JPG" alt="qingdao">&lt;/p>
&lt;h1 id="考试大纲">考试大纲&lt;/h1>
&lt;p>🎯 To Reader:&lt;/p>
&lt;p>This blog is JUST FOR EXAMINATION! If you are interested in numberical analysis, please quit this web.
I try to sort out the knowledge points of the course, just to pass the exam.&lt;/p>
&lt;p>Based on the course of Professor Zhong Erjie of UESTC.&lt;/p>
&lt;p>💢 &lt;strong>I hate mathematics!&lt;/strong>&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="第二章-非线性方程方程组的求解">第二章 非线性方程/方程组的求解&lt;/h2>
&lt;h3 id="1-二分法及迭代">1. 二分法及迭代&lt;/h3>
&lt;ul>
&lt;li>二分法误差估计定理&lt;/li>
&lt;/ul>
&lt;h3 id="2-不动点迭代">2. 不动点迭代&lt;/h3>
&lt;ul>
&lt;li>不动点及不动点迭代的概念&lt;/li>
&lt;li>迭代格式的选择? 是否收敛?&lt;/li>
&lt;li>迭代的初值是否合适?&lt;/li>
&lt;/ul>
&lt;h3 id="3-牛顿法解非线性方程">3. 牛顿法解非线性方程&lt;/h3>
&lt;blockquote>
&lt;p>背景: 如果函数&lt;code>f(x)&lt;/code>是线性的, 那么它的求根问题就会简化. 牛顿法实质上是一种线性化方法, 将非线性方程逐步归结为某种线性方程来求解.&lt;/p>
&lt;/blockquote>
&lt;p>牛顿法的迭代格式:
$$
x^{k+1} = x^k - \frac{f(x^k)}{f^&amp;rsquo;(x^k)}
$$&lt;/p>
&lt;h3 id="4-弦截法">4. 弦截法&lt;/h3>
&lt;blockquote>
&lt;p>背景: 弦截法是牛顿法的一个改进. 牛顿法求根时需要计算&lt;code>f'(x)&lt;/code>, 而导数的计算往往困难. 弦截法使用&lt;em>差商&lt;/em>来回避导数的计算.&lt;/p>
&lt;/blockquote>
&lt;h3 id="5-收敛阶">5. 收敛阶&lt;/h3>
&lt;h3 id="6-非线性方程组的牛顿迭代格式">6. 非线性方程组的牛顿迭代格式&lt;/h3>
&lt;ul>
&lt;li>雅可比矩阵是什么?&lt;/li>
&lt;/ul>
&lt;p> &lt;/p>
&lt;h2 id="第三章-直接法解线性方程组">第三章 直接法解线性方程组&lt;/h2>
&lt;h3 id="1-gauss消元法">1. Gauss消元法&lt;/h3>
&lt;p>求解过程的算法复杂度为&lt;code>O(n^2)&lt;/code>, 消元过程的算法复杂度为&lt;code>O(n^3)&lt;/code>.&lt;/p>
&lt;h3 id="2-直接三角分解法doolittle分解法">2. 直接三角分解法(Doolittle分解法)&lt;/h3>
&lt;blockquote>
&lt;p>背景: &lt;code>直接&lt;/code>意味着可以由A的元素直接计算L和U, 不需要任何的中间步骤.&lt;/p>
&lt;/blockquote>
&lt;p>一旦L和U得到, 求解&lt;code>Ax=b&lt;/code>就可以等价表示为求解两个三角形方程组:&lt;/p>
&lt;ol>
&lt;li>Ly=b, 求y&lt;/li>
&lt;li>Ux=y. 求x&lt;/li>
&lt;/ol>
&lt;p> &lt;/p>
&lt;h2 id="第四章-迭代法解线性方程组">第四章 迭代法解线性方程组&lt;/h2>
&lt;blockquote>
&lt;p>背景: 对于线性方程组&lt;code>Ax=b&lt;/code>, 当A为低阶稠密矩阵时, [选主元消去法]是求解的有效方法.&lt;br>
但是实际情况中A大都是&lt;em>巨型的稀疏矩阵&lt;/em>, 这是采用迭代法来求解是合适的. 迭代法可以利用A中有大量零元素的特点.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>迭代法&lt;em>不一定&lt;/em>最终能够逼近方程组的解, 认识误差向量的概念.&lt;/li>
&lt;/ul>
&lt;h3 id="1-jacobi迭代">1. Jacobi迭代&lt;/h3>
&lt;p>&lt;a href="https://www.bilibili.com/video/BV14F411e7Ji?p=2&amp;amp;spm_id_from=pageDriver">雅可比迭代格式和收敛性的判别&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.bilibili.com/video/BV14F411e7Ji?p=4&amp;amp;t=76.0">快速计算Bj的特征值&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.bilibili.com/video/BV14F411e7Ji?p=4&amp;amp;t=268.1">Jacobi迭代由A直接看出Bj&lt;/a>&lt;/p>
&lt;h3 id="2-seidel迭代">2. Seidel迭代&lt;/h3>
&lt;p>&lt;a href="https://www.bilibili.com/video/BV14F411e7Ji?p=6">Seidel迭代收敛格式和收敛性的判别&lt;/a>&lt;/p>
&lt;p>Seidel迭代独有的判断收敛性的方式: 若A为&lt;code>对称阵&lt;/code>, 且A&lt;code>正定&lt;/code>, 那么迭代收敛.&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="第五章-插值法">第五章 插值法&lt;/h2>
&lt;h3 id="1-插值方法与插值问题">1. 插值方法与插值问题&lt;/h3>
&lt;blockquote>
&lt;p>背景: 仅已知某些点和该点的函数值的情况下, 如何模拟一个插值函数&lt;code>P(x)&lt;/code>, 使得误差最小.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>什么是插值函数P(x)? 被插函数? 插值节点? 插值余项?&lt;/li>
&lt;/ul>
&lt;h3 id="2-多项式插值">2. 多项式插值&lt;/h3>
&lt;ul>
&lt;li>可证明多项式P(x)存在唯一.&lt;/li>
&lt;li>多项式插值通过解方程组就能得到解&lt;code>(a0, a1,..., an)&lt;/code>.&lt;/li>
&lt;/ul>
&lt;h3 id="3-拉格朗日插值公式">3. 拉格朗日插值公式&lt;/h3>
&lt;blockquote>
&lt;p>背景: 虽然上面的多项式插值能否解决n+1个点的光滑函数, 且解是唯一的. 但是&lt;strong>解方程组是很麻烦的&lt;/strong>.&lt;/p>
&lt;/blockquote>
&lt;p>拉格朗日插值公式:
$$
L_n(x) = l_0(x)y_0 + l_1(x)y_1 + \dots + l_n(x)y_n
$$
插值基函数:&lt;/p>
&lt;p>插值条件(插值系数):
$$
y_0 = f(x_0), y_1 = f(x_1), \dots,y_n = f(x_n)
$$&lt;/p>
&lt;p>误差余项Rn(x)&lt;/p>
&lt;h3 id="4-牛顿插值公式">4. 牛顿插值公式&lt;/h3>
&lt;blockquote>
&lt;p>背景: 给定5个插值节点及其函数值, 可以得到L4(x); 由于某种原因, 需要加入一个新的插值节点. Lagrange插值法之前的计算结果(l)均失效, 需要重新计算. 非常的不方便.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>牛顿法是基于&lt;strong>差商&lt;/strong>的概念. 导数是差商的极限.&lt;/li>
&lt;li>差商的差商是高阶差商.&lt;/li>
&lt;/ul>
&lt;p>牛顿插值法的插值函数(以二次插值举例):
$$
P(x) = a_0 + a_1(x-x_0) + a_2(x-x_0)(x-x_1)
$$
需要做的就是解出系数&lt;code>a0,a1,...&lt;/code>.&lt;/p>
&lt;p>所以引入差商的符号:
$$
a_1=f[x_0,x_1]=\frac{f(x_1)-f(x_0)}{x_1-x_0}
$$
$$
a_2=f[x_0,x_1,x_2]=\frac{f[x_1,x_2]-f[x_0,x_1]}{x_2-x_0}
$$&lt;/p>
&lt;h3 id="5-hermite插值">5. Hermite插值&lt;/h3>
&lt;blockquote>
&lt;p>背景: 有时我们已知的条件不都是函数值, 也有导数值. 例如已知两个点的函数值和两个点的导数值, 可以应用Heimite插值法得到三次多项式.&lt;/p>
&lt;/blockquote>
&lt;p>求Hermite插值函数的方法: 构造差商表, &lt;strong>重复节点特殊处理&lt;/strong>.&lt;/p>
&lt;p>Hermite插值方法的余项证明与Langrange插值法相同.&lt;/p>
&lt;h3 id="6-分段低次插值">6. 分段低次插值&lt;/h3>
&lt;blockquote>
&lt;p>背景: 次数太高的多项式插值的效果不好. 比如龙格现象.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>分段: 把被插值函数所在的大区间分成一个个的小区间.&lt;/li>
&lt;li>低次: 每个小区间上用次数不超过&lt;code>3&lt;/code>的函数来逼近&lt;/li>
&lt;/ul>
&lt;h4 id="61-分段线性插值">6.1 分段线性插值&lt;/h4>
&lt;p>就是分段折线&lt;/p>
&lt;p>分段线性插值的优点:&lt;/p>
&lt;ol>
&lt;li>简单&lt;/li>
&lt;li>当二阶导数趋近0时, 一定收敛&lt;/li>
&lt;/ol>
&lt;p>分段线性插值的缺点:&lt;/p>
&lt;ol>
&lt;li>分段折线不光滑, 分段点处不能求导.&lt;/li>
&lt;/ol>
&lt;h4 id="62-分段hermite插值">6.2 分段Hermite插值&lt;/h4>
&lt;blockquote>
&lt;p>背景: 为了解决分段线性插值的缺点(存在尖点).&lt;/p>
&lt;/blockquote>
&lt;p>已知函数在(n+1)个点的函数值值以及其导数值, 去构造一阶连续可导函数.&lt;/p>
&lt;p>分段Hermite插值根据(n+1)个已知点划分为(n+1)个区间. 这样在每个小区间上都已知&lt;code>4&lt;/code>个条件, 可以使用&lt;code>3&lt;/code>次Hermite插值.&lt;/p>
&lt;p>结论: 已知(2n+2)个条件的情况下, 居然只得到&lt;strong>一阶连续可微函数&lt;/strong>. 结论太差!&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="第六章-拟合">第六章 拟合&lt;/h2>
&lt;p>🔍 &lt;strong>插值, 拟合, 逼近的区别&lt;/strong>&lt;/p>
&lt;h4 id="1-最佳平方逼近">1. 最佳平方逼近&lt;/h4>
&lt;h4 id="2-最小二乘法">2. 最小二乘法&lt;/h4>
&lt;blockquote>
&lt;p>背景: 已知不共线的三点, 如何确定一条&lt;strong>可信&lt;/strong>的直线.&lt;/p>
&lt;/blockquote>
&lt;p>三个点可以用插值来模拟二次多项式, 但题目要求了用一次多项式, 这是插值无法做到的.&lt;/p>
&lt;p>不共线的三点不可能同时经过一条直线, 所以要用逼近的思想. 找一条近似的直线, 使得&lt;strong>误差&lt;/strong>最小.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>与插值的区别&lt;/strong>: 插值是明确给出&lt;code>n+1&lt;/code>个插值条件, 得到&lt;code>n&lt;/code>次多项式.&lt;/li>
&lt;li>&lt;strong>如何定义误差最小?&lt;/strong>: 函数间的距离.&lt;/li>
&lt;/ul>
&lt;h3 id="1-线性拟合">1. 线性拟合&lt;/h3>
&lt;p>拟合的函数是&lt;code>n&lt;/code>次多项式, 可转化为超定方程&lt;code>GX&lt;/code>.&lt;/p>
&lt;ul>
&lt;li>其中规定&lt;code>G&lt;/code>为系数矩阵, &lt;code>X&lt;/code>为变量的列向量.&lt;/li>
&lt;li>同时定义列向量&lt;code>F&lt;/code>为给出的函数值.&lt;/li>
&lt;li>&lt;code>GX=F&lt;/code>是超定方程组, 没有准确解. 得到残差最小的解的方法即&lt;strong>最小二乘法&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;p>所以线性拟合的残差&lt;code>r = |GX - F|&lt;/code>, 而找到目标函数的宗旨就是使&lt;code>r&lt;/code>最小. 使用&lt;strong>初等变分原理&lt;/strong>将这个问题转化为&lt;strong>正规方程组&lt;/strong>求解的问题.&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="第七章-数值积分">第七章 数值积分&lt;/h2>
&lt;blockquote>
&lt;p>背景: 定积分的计算中可能无法找到原函数的情况. 考虑定积分的本质是一句具体的数, 我们的目标就是找到这个数的近似值, 越接近越好.&lt;/p>
&lt;/blockquote>
&lt;p>解决的两种思路: &lt;code>积分中值定理&lt;/code> 和 &lt;code>插值型求积公式(近似被积函数)&lt;/code>.&lt;/p>
&lt;h3 id="1-积分中值定理">1. 积分中值定理&lt;/h3>
&lt;p>基本的积分中值定理:
$$
\int_{a}^{b}f(x)dx = f(\xi)(b-a)
$$&lt;/p>
&lt;p>将一个区域的面积转化为矩形的面积. 如何确定矩形的高呢? &lt;code>左矩阵&lt;/code>, &lt;code>右矩阵&lt;/code>, &lt;code>中间矩阵&lt;/code>, &lt;code>梯形公式&lt;/code>.&lt;/p>
&lt;p>更常用的积分公式是 在乘积函数积分中, 如果&lt;code>g(x)&lt;/code>不变号, 则有:
$$
\int_{a}^{b}g(x)f(x)dx =f(\xi)\int_{a}^{b}g(x)dx
$$&lt;/p>
&lt;h3 id="2-插值型求积公式">2. 插值型求积公式&lt;/h3>
&lt;p>在被积函数很复杂的情况下, 可以对其进行近似处理, 例如使用&lt;code>Lagrange插值法&lt;/code>.&lt;/p>
&lt;h4 id="二次插值-simpson公式">二次插值: Simpson公式&lt;/h4>
&lt;p>取二次插值的步长&lt;code>h=(b-a)/2&lt;/code>, 即增加一个插值节点&lt;code>(b-a)/2&lt;/code>, Simpson公式化简的结果为:
$$
\int_{a}^{b}f(x)dx = \frac{b-a}{6}[f(a)+4f(\frac{a+b}{2})+f(b)]+R[f]
$$&lt;/p>
&lt;p>📌 Simpson公式满足&lt;code>3&lt;/code>阶代数精度. 虽然它只是二次插值得到的.&lt;/p>
&lt;h3 id="3-余项">3. 余项&lt;/h3>
&lt;ul>
&lt;li>插值型求积公式的余项, 即对应的插值方法(如Lagrange, Newton)的余项在区间上的积分.&lt;/li>
&lt;li>梯形公式方法的余项可以用&lt;strong>积分中值定理&lt;/strong>来优化.&lt;/li>
&lt;li>Simpson公式的余项&lt;strong>不能&lt;/strong>使用积分中值定理来优化, 因为不满足保号的条件.&lt;/li>
&lt;/ul>
&lt;h3 id="4-衡量求积公式的好坏">4. 衡量求积公式的好坏&lt;/h3>
&lt;p>&lt;strong>代数精度&lt;/strong>: 不是一种误差, 而是对误差的描述.&lt;/p>
&lt;p>如何得知某个公式的代数精度: 只要带入一个m次多项式验证余项是否为0即可.&lt;/p>
&lt;h3 id="5复合求积公式">5.复合求积公式&lt;/h3>
&lt;p>为了提高精度通常把积分区间分为若干个子区间, 再在每个子区间上应用低阶求积公式.&lt;/p>
&lt;ul>
&lt;li>&lt;code>复合梯形公式&lt;/code>: 将区间等分.&lt;/li>
&lt;li>&lt;code>复合simpson公式&lt;/code>: 将区间偶数等分.&lt;/li>
&lt;/ul>
&lt;p> &lt;/p>
&lt;h2 id="第八章-常微分方程初值问题数值解法">第八章 常微分方程初值问题数值解法&lt;/h2>
&lt;p>将研究的内容进一步限定为: &lt;code>一阶初值问题&lt;/code>, &lt;code>单步法&lt;/code>.&lt;/p>
&lt;blockquote>
&lt;p>背景: 在无法给出解析表达式时如果利用数值方法求出&lt;code>y&lt;/code>的近似解?&lt;/p>
&lt;/blockquote>
&lt;h3 id="1-简单的数值方法">1. 简单的数值方法&lt;/h3>
&lt;h4 id="11-euler公式">1.1 Euler公式&lt;/h4>
&lt;p>使用&lt;code>一阶向前差商&lt;/code>近似替代&lt;code>y'&lt;/code>. 得到递推的数列表达式:
$$
y_{n+1} = y_{n} + hf(x_n,y_n), n=0,1,2,&amp;hellip;
$$&lt;/p>
&lt;p>&lt;strong>误差&lt;/strong>: Euler法使用的近似代替只有&lt;code>一阶精度&lt;/code>, 所以误差很大. 此时有两种解决方案:&lt;/p>
&lt;ol>
&lt;li>加细步长&lt;code>h&lt;/code>, 若不行再加细. 总是能得到正确的, 如果你不嫌弃带来的计算变得缓慢的问题.&lt;/li>
&lt;li>换方法.&lt;/li>
&lt;/ol>
&lt;h4 id="12-梯形公式">1.2 梯形公式&lt;/h4>
&lt;blockquote>
&lt;p>背景:为得到比Euler法精度更高的计算公式. 梯形公式具有&lt;code>二阶&lt;/code>精度.&lt;/p>
&lt;/blockquote>
&lt;p>对&lt;code>y' = f(x,y)&lt;/code>的两端进行&lt;strong>局部的&lt;/strong>积分, 然后用梯形公式近似计算右边.&lt;/p>
&lt;h4 id="13-改进euler公式">1.3 改进Euler公式&lt;/h4>
&lt;p>先用欧拉公式求得一个&lt;code>近似的yn+1&lt;/code>, 带入梯形公式, 得到&lt;code>矫正的yn+1&lt;/code>.&lt;/p>
- https://wangloo.github.io/posts/numberical-analysis/ - @2019 Notepadium.</description></item></channel></rss>