<?xml-stylesheet href="/rss.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Homepage 🌈 on Soben's Secret Base</title><link>https://wangloo.github.io/</link><description>Recent content in Homepage 🌈 on Soben's Secret Base</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>@2019 Notepadium.</copyright><lastBuildDate>Thu, 15 Sep 2022 15:14:05 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>GNU C内联汇编学习笔记</title><link>https://wangloo.github.io/posts/c/inline-asm/</link><pubDate>Sat, 24 Sep 2022 16:48:58 +0800</pubDate><guid>https://wangloo.github.io/posts/c/inline-asm/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/c/inline-asm/ -&lt;h3 id="语句结构">语句结构&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">asm&lt;/span> &lt;span style="color:#ff79c6">asm&lt;/span>&lt;span style="color:#ff79c6">-&lt;/span>qualifiers ( &lt;span style="color:#8be9fd;font-style:italic">AssemblerTemplate&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : &lt;span style="color:#8be9fd;font-style:italic">OutputOperands&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : &lt;span style="color:#8be9fd;font-style:italic">InputOperands&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : &lt;span style="color:#8be9fd;font-style:italic">Clobbers&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : GotoLabels)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>asm&lt;/code> keyword is a GNU extension. 当使用编译选项 &lt;code>-ansi&lt;/code> 或 &lt;code>-std&lt;/code> 时, 使用 &lt;code>__asm__&lt;/code>代替 &lt;code>asm&lt;/code>.&lt;/p>
&lt;h4 id="qualifiers">Qualifiers&lt;/h4>
&lt;ul>
&lt;li>volatile: 避免编译器的过分优化&lt;/li>
&lt;li>goto&lt;/li>
&lt;li>inline&lt;/li>
&lt;/ul>
&lt;h4 id="parameters">Parameters&lt;/h4>
&lt;p>&lt;em>AssemblerTemplate&lt;/em>: 字符串, 汇编代码的模板&lt;/p>
&lt;p>&lt;em>OutputOperands&lt;/em>: 输出操作数; 指令将会修改的变量集合&lt;/p>
&lt;p>&lt;em>InputOperands&lt;/em>: 输入操作数; 指令将读取的变量集合&lt;/p>
&lt;p>&lt;em>Clobbers&lt;/em>: ???TODO&lt;/p>
&lt;p>&lt;em>GotoLabels&lt;/em>: 仅当 qualifiers 使用&lt;code>goto&lt;/code>时, 声明label集合.&lt;/p>
&lt;blockquote>
&lt;p>The total number of input + output + goto operands is limited to 30.&lt;/p>
&lt;/blockquote>
&lt;p> &lt;/p>
&lt;h3 id="param-1-assemblertemplate">Param #1: AssemblerTemplate&lt;/h3>
&lt;p>多条语句可以放在一个asm字符串中, 但是更常见的是每条汇编语句使用一个字符串, 并在结束时使用换行符和制表符(&lt;code>\n&lt;/code>, &lt;code>\t&lt;/code>)来表示换行.&lt;/p>
&lt;blockquote>
&lt;p>貌似对于 arm 汇编, 只用 &lt;code>\n&lt;/code> 也OK?&lt;/p>
&lt;/blockquote>
&lt;p> &lt;/p>
&lt;h3 id="param-2-outputoperands">Param #2: OutputOperands&lt;/h3>
&lt;p>多个 OutputOperands 之间使用&lt;code>,&lt;/code>隔开, 每个 OutputOperands 的格式如下:&lt;/p>
&lt;pre tabindex="0">&lt;code>[ [asmSymbolicName] ] constraint (cvariablename)
&lt;/code>&lt;/pre>&lt;p>&lt;em>asmSymbolicName&lt;/em>: 指定该操作数的名称&lt;/p>
&lt;p>&lt;em>constraint&lt;/em>: 对该操作数的一些限制&lt;/p>
&lt;pre tabindex="0">&lt;code>// 描述操作数的权限, 输出操作数的约束必须以此开头
= 忽略现有值
+ 读写, 当原先值有意义时用它
&amp;amp; 禁止编译器将该操作数与不相关的输入操作数分配同一个寄存器
// 描述输出操作数所在位置, 如果你不知道, 可以同时设置, 编译器会帮你决定
r 寄存器
m 内存
&lt;/code>&lt;/pre>&lt;p>&lt;em>cvariablename&lt;/em>: 输出到的 C 语言变量名&lt;/p>
&lt;p> &lt;/p>
&lt;h3 id="param-3-input-operands">Param #3: Input Operands&lt;/h3>
&lt;p>输入操作数的格式与输出操作数基本一致:&lt;/p>
&lt;pre tabindex="0">&lt;code>[ [asmSymbolicName] ] constraint (cexpression)
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>对于输入操作数, 一般没有别的限制, 仅使用&lt;code>&amp;quot;r&amp;quot;(val)&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p> &lt;/p>
&lt;h3 id="param-4-clobbers">Param #4: Clobbers&lt;/h3>
&lt;p>每个 clobber 都是用双引号括起来, 并用逗号分隔的字符串常量.&lt;/p>
&lt;p>常用的 clobber 参数:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&amp;ldquo;memory&amp;rdquo;&lt;br>
告诉编译器, 这段内联汇编代码对输入和输出操作数中列出的项以外的内存读取或写入操作(例如，访问输入参数之一指向的内存). 为确保内存包含正确的值，GCC可能需要在执行ASM之前将特定寄存器值刷新到内存。此外, 阻止编译器越过该 ASM 语句进行 reorder, 形成针对编译器的 memory barrier. 注意, 此 clobber 不会阻止处理器在ASM语句之后执行推测性读取。为了防止出现这种情况，您需要特定于处理器的防护指令。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&amp;ldquo;cc&amp;rdquo;&lt;br>
This stands for &amp;ldquo;condition codes&amp;rdquo;. Since the add instruction will affect the carry flag amongst other things, we need to tell gcc about it. Otherwise it might want to split a test-and-branch around our code. If it did so, the branch might go the wrong way due to the condition codes being corrupted. Basically, any inline asm that does arithmetic should explicitly clobber the flags like this.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p> &lt;/p>
&lt;h3 id="param-5-gotolabels">Param #5: GotoLabels&lt;/h3>
&lt;p>尽量不使用, 可以在ASM的内部直接定义 label&lt;/p>
&lt;p>TODO&lt;/p>
&lt;p> &lt;/p>
&lt;h3 id="样例">样例&lt;/h3>
&lt;h4 id="最简单的模板">最简单的模板&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> src &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> dst;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">asm&lt;/span> (&lt;span style="color:#f1fa8c">&amp;#34;mov %1, %0&lt;/span>&lt;span style="color:#f1fa8c">\n\t&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;add $1, %0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;=r&amp;#34;&lt;/span> (dst)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;r&amp;#34;&lt;/span> (src));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printf(&lt;span style="color:#f1fa8c">&amp;#34;%d&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, dst);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="操作数使用-asmsymbolicname">操作数使用 asmSymbolicName&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">uint32_t&lt;/span> c &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">uint32_t&lt;/span> d;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">uint32_t&lt;/span> &lt;span style="color:#ff79c6">*&lt;/span>e &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">&amp;amp;&lt;/span>c;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">asm&lt;/span> (&lt;span style="color:#f1fa8c">&amp;#34;mov %[e], %[d]&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">:&lt;/span> [d] &lt;span style="color:#f1fa8c">&amp;#34;=rm&amp;#34;&lt;/span> (d)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">:&lt;/span> [e] &lt;span style="color:#f1fa8c">&amp;#34;rm&amp;#34;&lt;/span> (&lt;span style="color:#ff79c6">*&lt;/span>e));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="内部定义-label">内部定义 label&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">long&lt;/span> temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">long&lt;/span> ret;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">asm&lt;/span> &lt;span style="color:#50fa7b">volatile&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;1: &lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;ldxr %0, [%2]&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;sub %0, %0, %3&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;stxr %w1, %0, [%2]&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;cbnz %w1, 1b&lt;/span>&lt;span style="color:#f1fa8c">\n\t&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;=&amp;amp;r&amp;#34;&lt;/span>(ret), &lt;span style="color:#f1fa8c">&amp;#34;=&amp;amp;r&amp;#34;&lt;/span>(temp)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;r&amp;#34;&lt;/span>(p), &lt;span style="color:#f1fa8c">&amp;#34;r&amp;#34;&lt;/span>(val)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;memory&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="reference">Reference&lt;/h2>
&lt;p>&lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Extended-Asm">Extended Asm (Using the GNU Compiler Collection (GCC))&lt;/a>&lt;/p>
- https://wangloo.github.io/posts/c/inline-asm/ - @2019 Notepadium.</description></item><item><title>GICv3 介绍</title><link>https://wangloo.github.io/posts/armv8/gicv3/</link><pubDate>Sat, 10 Sep 2022 21:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/gicv3/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/armv8/gicv3/ -&lt;h1 id="gicv3generic-interrupt-controller---version-3">GICV3(Generic Interrupt Controller - version 3)&lt;/h1>
&lt;h2 id="关于gic">关于GIC&lt;/h2>
&lt;p>GIC即中断控制器, 负责管理中断的接收, 屏蔽, 路由等相关任务, 并向系统程序员提供配置的接口.&lt;/p>
&lt;p>GIC与异常模型协作完成中断的整个生命周期, GIC主要负责&lt;code>中断源-产生IRQ/FIQ信号&lt;/code>这段路, 关于处理IRQ/FIQ则是由CPU内部的&lt;em>异常模型&lt;/em>来完成.&lt;/p>
&lt;h2 id="对比-gicv2">对比 GICv2&lt;/h2>
&lt;ul>
&lt;li>支持更多的处理器, 用&lt;code>affinity routing&lt;/code> 方案来做中断路由.&lt;/li>
&lt;li>支持中断分组, 为了配合ARMv8的异常等级模型&lt;/li>
&lt;li>新增中断类型: SGI, 软件生成中断&lt;/li>
&lt;li>新增中断类型: SPI, Shared Peripheral Interrupts&lt;/li>
&lt;li>对于CPU interface的寄存器, 可直接使用系统寄存器接口(system register interface)来访问, 比memory-mapped的方式快.&lt;/li>
&lt;li>ITS, Interrupt Translation Service 暂不介绍&lt;/li>
&lt;li>LPI, Locality-specific Peripheral Interrupts . 暂不介绍&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>GICv3支持ARMv8-A或ARMv8-R系列处理器, 但没有必然的绑定关系. ARMv8-A也可以使用GICv2.&lt;/p>
&lt;/blockquote>
&lt;h2 id="中断类型">中断类型&lt;/h2>
&lt;h3 id="locality-specific-peripheral-interrupt-lpi">Locality-specific Peripheral Interrupt (LPI)&lt;/h3>
&lt;p>LPIs are always &lt;a href="https://en.wikipedia.org/wiki/Message_Signaled_Interrupts">message-based interrupts&lt;/a> interrupts. 这里不做介绍.&lt;a href="https://en.wikipedia.org/wiki/Message_Signaled_Interrupts">wiki&lt;/a>&lt;/p>
&lt;h3 id="private-peripheral-interrupt-ppi">Private Peripheral Interrupt (PPI)&lt;/h3>
&lt;p>PPI是路由到&lt;strong>单个CPU&lt;/strong>的外设中断, 不同的CPU可以使用相同的中断号. 例如, 所有CPU都可以使用中断号16表示私有的定时器中断.&lt;/p>
&lt;h3 id="shared-peripheral-interrupt-spi">Shared Peripheral Interrupt (SPI)&lt;/h3>
&lt;p>SPI是可路由到&lt;strong>一组CPU&lt;/strong>的外设中断, Distributor 负责SPI路由.&lt;/p>
&lt;h3 id="software-generated-interrupt-sgi">Software Generated Interrupt (SGI)&lt;/h3>
&lt;p>SGI是由某个CPU产生, 路由到系统中的一个或多个CPU, 通常用于处理器间通信.&lt;/p>
&lt;h2 id="gicv3-的组件">GICv3 的组件&lt;/h2>
&lt;p>GICv3架构由以下逻辑组件构成:&lt;/p>
&lt;ul>
&lt;li>A Distributor&lt;/li>
&lt;li>A Redistributor for each CPU&lt;/li>
&lt;li>A CPU interface for each CPU&lt;/li>
&lt;li>Interrupt Translation Service components (ITS). 可选, 暂不介绍&lt;/li>
&lt;/ul>
&lt;p>The Distributor, Redistributor 一起组成了 &lt;em>IRI(Interrupt Routing Infrastructure)&lt;/em>.&lt;/p>
&lt;p>&lt;img src="./IRI.png" alt="iri">{width=&amp;ldquo;10px&amp;rdquo;}&lt;/p>
&lt;h3 id="distributor">Distributor&lt;/h3>
&lt;p>控制SPI和SGI的路由. 对于 SPI, 提供了一下接口:&lt;/p>
&lt;ul>
&lt;li>启动/禁用 SPI&lt;/li>
&lt;li>设置 SPI 的优先级&lt;/li>
&lt;li>配置对于 SPI 的路由&lt;/li>
&lt;li>设置 SPI 的触发方式&lt;/li>
&lt;li>生成 message-based SPI&lt;/li>
&lt;li>为每个 SPI 分组&lt;/li>
&lt;li>控制 SPI 的 &lt;code>pending and active&lt;/code> 状态&lt;/li>
&lt;/ul>
&lt;p>对于&lt;code>Distributor&lt;/code>的大部分配置通过&lt;code>GICD_CTLR&lt;/code>实现. 包括:&lt;/p>
&lt;ul>
&lt;li>启用 Affinity routing&lt;/li>
&lt;li>禁用安全性&lt;/li>
&lt;li>中断分组的配置.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>关于Distributor 寄存器都含有 &lt;code>GICD_&lt;/code> 前缀, 通过 &lt;code>memory-mapped&lt;/code> 方式访问.&lt;/p>
&lt;/blockquote>
&lt;h3 id="redistributor">Redistributor&lt;/h3>
&lt;ul>
&lt;li>启动/禁用 SGI 和 PPI&lt;/li>
&lt;li>设置 SGI 和 PPI 的优先级&lt;/li>
&lt;li>设置 SGI 和 PPI 的触发方式&lt;/li>
&lt;li>为 SGI 和 PPI 分配组&lt;/li>
&lt;li>控制 SGI 和 PPI 的 &lt;code>pending&lt;/code> 状态和 &lt;code>active&lt;/code> 状态&lt;/li>
&lt;li>与之链接的 CPU 的电源管理.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>关于Redistributor 寄存器都含有 &lt;code>GICR_&lt;/code> 前缀, 通过 &lt;code>memory-mapped&lt;/code> 方式访问.&lt;/p>
&lt;/blockquote>
&lt;h3 id="cpu-interface">CPU interface&lt;/h3>
&lt;ul>
&lt;li>Acknowledge 一个中断&lt;/li>
&lt;li>执行 End Of Interrupt&lt;/li>
&lt;li>Deactivate 一个中断&lt;/li>
&lt;li>设置 CPU 的优先级Mask&lt;/li>
&lt;li>配置中断抢占&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>关于 CPU interface 寄存器是以 &lt;code>ICC_&lt;/code> 为前缀, 还有 &lt;code>ICV&lt;/code> for vitual interrupt, &lt;code>ICH&lt;/code> for hypervisor configuration.&lt;/p>
&lt;/blockquote>
&lt;h2 id="中断的状态转换">中断的状态转换&lt;/h2>
&lt;p>&lt;img src="./int-lifestyle.png" alt="">&lt;/p>
&lt;ol>
&lt;li>生成中断. 中断可能来自外部信号, 或者软件生成(SGI)&lt;/li>
&lt;li>Distribute. IRI 负责中断的分组, 优先级屏蔽等. 将合适的中断发送到CPU Interface.&lt;/li>
&lt;li>Deliver. CPU interface 将中断发送到连接的CPU.&lt;/li>
&lt;li>Activate. CPU读取IAR寄存器, 即发送ACK. 该中断的状态转为active.&lt;/li>
&lt;li>Priority drop. 处理程序结束之后, 写&lt;code>ICC_EOIR&lt;/code>寄存器, end of interrupt&lt;/li>
&lt;li>Deactivation. 写&lt;code>ICC_DIR&lt;/code>寄存器清除中断的active标志位. 一般来说, end of interrupt 和 deactivation 可配置成同时发生.&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>&lt;code>ICC_CTLR_ELx.EOImode&lt;/code> 位控制是否 end of interrupt 同时导致 deactivation.&lt;/p>
&lt;p>❓ EOI 和 deactivated 分开进行暂时还不知道应用场景.&lt;/p>
&lt;/blockquote>
&lt;h2 id="中断id-intid">中断ID: INTID&lt;/h2>
&lt;p>INTID 是中断的标识符, 它的最大值是&lt;em>实现定义&lt;/em>的, 可以在&lt;code>GICD_TYPER.IDbits&lt;/code>中读取。&lt;/p>
&lt;p>INTID按照中断类型分类的, 对照表如下:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>INTID&lt;/th>
&lt;th>中断类型&lt;/th>
&lt;th>Note&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0-15&lt;/td>
&lt;td>SGI&lt;/td>
&lt;td>本地的, 不同CPU可使用同一中断号代表不同中断&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>16-31&lt;/td>
&lt;td>PPI&lt;/td>
&lt;td>本地的&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>32-1019&lt;/td>
&lt;td>SPI&lt;/td>
&lt;td>全局的&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1020-1023&lt;/td>
&lt;td>特殊中断&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1056-1119&lt;/td>
&lt;td>扩展的PPI&lt;/td>
&lt;td>本地的&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4096 – 5119&lt;/td>
&lt;td>扩展的SPI&lt;/td>
&lt;td>全局的&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="特殊中断号">特殊中断号&lt;/h3>
&lt;blockquote>
&lt;p>These INTIDs do not require an end of interrupt or deactivation.&lt;/p>
&lt;/blockquote>
&lt;p>1020:&lt;/p>
&lt;p>1021:&lt;/p>
&lt;p>1022:&lt;/p>
&lt;p>1023: 读&lt;code>ICC_IAR1_EL1&lt;/code> 返回该值表明当前的CPU上没有待处理的中断.&lt;/p>
&lt;h2 id="中断分组">中断分组&lt;/h2>
&lt;p>为了配合 ARMv8 的异常模型和安全模型, GICv3 支持为每个中断配置不同的组. 不同组的中断只能路由到特定的异常等级和安全状态进行处理.&lt;/p>
&lt;p>共包含三个分组: Gourp 0, Secure Group 1, Non-secure Group 1.&lt;/p>
&lt;ul>
&lt;li>Group 0的中断需要在EL3 处理.&lt;/li>
&lt;li>Secure Group1 的中断需要在 Secure EL1 或者 Secure EL2(如果启用了虚拟化)处理.&lt;/li>
&lt;li>Non-secure Group 1 的中断需要在 Non-secure EL2 or Non-secure EL1 if not using virtualization&lt;/li>
&lt;/ul>
&lt;p>同时, 中断位于哪个组也决定了其触发的是FIQ还是IRQ. 对于 AArch64 来说, 对应关系可见下表:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>当前异常等级&lt;/th>
&lt;th>Group 0 的中断&lt;/th>
&lt;th>Secure Group 1 的中断&lt;/th>
&lt;th>Non-secure Group 1&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Secure EL1/0/2&lt;/td>
&lt;td>FIQ&lt;/td>
&lt;td>IRQ&lt;/td>
&lt;td>FIQ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Non-secure EL1/0/2&lt;/td>
&lt;td>FIQ&lt;/td>
&lt;td>FIQ&lt;/td>
&lt;td>IRQ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>EL3&lt;/td>
&lt;td>FIQ&lt;/td>
&lt;td>FIQ&lt;/td>
&lt;td>FIQ&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>Group 0 的中断, 需要在EL3处理, 其优先级较高, 所以均属于 FIQ&lt;/li>
&lt;/ul>
&lt;h2 id="中断路由">中断路由&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>PPIs are routed directly from the source to the local Redistributor .&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SPIs are routed from the source through the Distributor to the target Redistributor and the associated CPU interface.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SGIs are generated by software through the CPU interface and Redistributor. They are then routed through the Distributor to one or more target Redistributors and the associated CPU interfaces&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="what-is-affinity-routing">What is Affinity Routing?&lt;/h3>
&lt;p>Affinity routing 是一种基于地址的标识多个CPU的方法, 用于中断的路由. Affinity value 由4个8bit字段组成, 结构是&lt;code>aff3.aff2.aff1.aff0&lt;/code>.&lt;/p>
&lt;p>由于 PPI 的中断源是直连 Redistributor 的, 所以仅 SPI 和 SGI 可以使用 Affinity routing.&lt;/p>
&lt;ul>
&lt;li>对于 SPI, 目标CPU的 affinity value 通过&lt;code>GICD_IROUTER&amp;lt;n&amp;gt;&lt;/code> 设置.&lt;/li>
&lt;li>对于 SGI, 在生成时即可同时配置, 详见 &lt;code>ICC_SGI0R_EL1&lt;/code> 和 &lt;code>ICC_SGI1R_EL1&lt;/code>.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Aff3.Aff2.Aff1.Aff0 与 Aff3.Aff2.Aff2.TargetList&lt;/p>
&lt;p>对于SPI, 目标的CPU只能是一个, 故&lt;code>Aff0&lt;/code>表示该CPU的ID. 而SGI可以配置同时发给多个CPU, 所以&lt;code>TargetList&lt;/code>是基于位操作的, 每个位表示一个CPU.&lt;/p>
&lt;/blockquote>
&lt;h2 id="编程指导">编程指导&lt;/h2>
&lt;h3 id="初始化">初始化&lt;/h3>
&lt;p>由于 &lt;em>Distributor&lt;/em> 整个系统共享的, 所以必须在其他核启动之前, 由主核完成初始化. 然后当所有核都启动后, 各自完成各自 &lt;em>Redistributor&lt;/em> 和 &lt;em>CPU interface&lt;/em> 的初始化工作.&lt;/p>
- https://wangloo.github.io/posts/armv8/gicv3/ - @2019 Notepadium.</description></item><item><title>武器库: shell scripts</title><link>https://wangloo.github.io/posts/shell/shell-script/</link><pubDate>Wed, 20 Jul 2022 11:54:13 +0800</pubDate><guid>https://wangloo.github.io/posts/shell/shell-script/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/shell/shell-script/ -&lt;p>ℹ️ 以下命令/脚本的执行环境均为 &lt;em>Bash&lt;/em>.&lt;/p>
&lt;h2 id="统计代码量">统计代码量&lt;/h2>
&lt;blockquote>
&lt;p>使用到的命令包含: find, wc, xargs, sort等&lt;/p>
&lt;/blockquote>
&lt;p>列出&lt;em>所有的文件及其代码行数&lt;/em>, 只统计.c和.h, 过滤&lt;code>./scripts&lt;/code>目录.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>find -name &lt;span style="color:#f1fa8c">&amp;#39;*.[c|h]&amp;#39;&lt;/span> ! -path &lt;span style="color:#f1fa8c">&amp;#39;./scripts/*&amp;#39;&lt;/span> | xargs wc -l
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>+将内容按照代码行数降序排列&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>find -name &lt;span style="color:#f1fa8c">&amp;#39;*.[c|h]&amp;#39;&lt;/span> ! -path &lt;span style="color:#f1fa8c">&amp;#39;./scripts/*&amp;#39;&lt;/span> | xargs wc -l | sort -rn
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>若仅列出&lt;em>总的代码行数&lt;/em>, 去除&lt;strong>空行&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">(&lt;/span>find ./ -name &lt;span style="color:#f1fa8c">&amp;#39;*.[c|h]&amp;#39;&lt;/span> -print0 | xargs -0 cat&lt;span style="color:#ff79c6">)&lt;/span> | sed &lt;span style="color:#f1fa8c">&amp;#39;/^\s*$/d&amp;#39;&lt;/span> | wc -l
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="判断执行脚本时带的参数">判断执行脚本时带的参数&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">$#&lt;/span> -ne &lt;span style="color:#bd93f9">1&lt;/span> &lt;span style="color:#ff79c6">]&lt;/span>; &lt;span style="color:#ff79c6">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;ONE parameter is needed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">exit&lt;/span> -1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">$1&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;build&amp;#39;&lt;/span> &lt;span style="color:#ff79c6">]&lt;/span>; &lt;span style="color:#ff79c6">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4"># do something&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">elif&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">$1&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;run&amp;#39;&lt;/span> &lt;span style="color:#ff79c6">]&lt;/span>; &lt;span style="color:#ff79c6">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4"># do something&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">elif&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">$1&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;gdb&amp;#39;&lt;/span> &lt;span style="color:#ff79c6">]&lt;/span>; &lt;span style="color:#ff79c6">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4"># do something&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Not supported command&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="自动拷贝文件到sd-card">自动拷贝文件到SD Card&lt;/h2>
&lt;blockquote>
&lt;p>TODO&lt;/p>
&lt;ol>
&lt;li>添加进度条&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">sd_path&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#ff79c6">$(&lt;/span>find /media/&lt;span style="color:#8be9fd;font-style:italic">$USER&lt;/span> -maxdepth &lt;span style="color:#bd93f9">1&lt;/span> -type d -name &lt;span style="color:#f1fa8c">&amp;#34;*-*&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">while&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span> ! -d &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">sd_path&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sleep &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;waiting for inserting SD-Card&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;SD-Card is inserted&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cp ./output/kernel/kernel.bin &lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">sd_path&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Copy completely&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="获取所有文件信息可递归进入子目录">获取所有文件信息(可递归进入子目录)&lt;/h2>
&lt;p>获取&lt;code>dir&lt;/code>路径下的所有文件的信息, 这里获取的是文件的&lt;strong>完整路径&lt;/strong>.&lt;/p>
&lt;blockquote>
&lt;p>TODO&lt;/p>
&lt;ol>
&lt;li>操作数组下标的方式可能有待改进? &lt;code>filenum&lt;/code>感觉没必要, 暂时还不会改&lt;/li>
&lt;li>通过拼接获得文件信息(路径)的方式也有点怪异&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">dir&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>./
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">files&lt;/span>&lt;span style="color:#ff79c6">=()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">filenum&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">function&lt;/span> getfiles&lt;span style="color:#ff79c6">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> file in &lt;span style="color:#f1fa8c">`&lt;/span>ls &lt;span style="color:#8be9fd;font-style:italic">$dir&lt;/span>&lt;span style="color:#f1fa8c">`&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span> -d &lt;span style="color:#8be9fd;font-style:italic">$file&lt;/span> &lt;span style="color:#ff79c6">]&lt;/span>; &lt;span style="color:#ff79c6">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">cd&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">$file&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> getfiles
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">cd&lt;/span> ..
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> files&lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$filenum&lt;/span>&lt;span style="color:#ff79c6">]=&lt;/span>&lt;span style="color:#ff79c6">$(&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">pwd&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">$file&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span>/&lt;span style="color:#ff79c6">$(&lt;/span>basename &lt;span style="color:#8be9fd;font-style:italic">$file&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4"># echo file=$(pwd $file)/$(basename $file)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> filenum++
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="带颜色的输出">带颜色的输出&lt;/h2>
&lt;p>使用&lt;a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape code&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>Black 0;30 Dark Gray 1;30
Red 0;31 Light Red 1;31
Green 0;32 Light Green 1;32
Brown/Orange 0;33 Yellow 1;33
Blue 0;34 Light Blue 1;34
Purple 0;35 Light Purple 1;35
Cyan 0;36 Light Cyan 1;36
Light Gray 0;37 White 1;37
&lt;/code>&lt;/pre>&lt;p>Code example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">RED&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;\033[0;31m&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">GREEN&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;\033[0;32m&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">YELLOW&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;\033[1;33m&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">BLUE&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;\033[0;34m&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">CYAN&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;\033[0;36m&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">NC&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;\033[0m&amp;#39;&lt;/span> &lt;span style="color:#6272a4"># No Color&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> -e &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">YELLOW&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">HELLO, YELLOW&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">NC&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> -e &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">GREEN&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">HELLO, GREEN&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">NC&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> -e &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">RED&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">HELLO, RED&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">NC&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> -e &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">BLUE&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">HELLO, BLUE&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">NC&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> -e &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">CYAN&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">HELLO, CYAN&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">NC&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">#########################################################&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># generic functions #####################################&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">function&lt;/span> ERROR&lt;span style="color:#ff79c6">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> -e &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">RED&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">[error] &lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$*&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">NC&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">exit&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">function&lt;/span> INFO &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> -e &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">BLUE&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">[info] &lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$*&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">NC&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">function&lt;/span> WARN &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> -e &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">YELLOW&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">[warn] &lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$*&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">NC&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">function&lt;/span> LOG &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> -e &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">GREEN&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">[log] &lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$*&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">NC&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> &amp;gt;&amp;gt; &lt;span style="color:#8be9fd;font-style:italic">$LOG&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INFO &lt;span style="color:#f1fa8c">&amp;#34;This is an infomation&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WARN &lt;span style="color:#f1fa8c">&amp;#34;This is a log&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>- https://wangloo.github.io/posts/shell/shell-script/ - @2019 Notepadium.</description></item><item><title>C 语言位操作技巧</title><link>https://wangloo.github.io/posts/codestyle/bit-operation-hacks/</link><pubDate>Sun, 03 Jul 2022 09:44:13 +0800</pubDate><guid>https://wangloo.github.io/posts/codestyle/bit-operation-hacks/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/codestyle/bit-operation-hacks/ -&lt;h2 id="判断一个数是否为2的幂">判断一个数是否为2的幂&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">unsigned&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> v;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> ((v &lt;span style="color:#ff79c6">&amp;amp;&lt;/span> (v &lt;span style="color:#ff79c6">-&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>)) &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#f1fa8c">&amp;#34;v is a power of 2&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">printf&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;v is not a power of 2&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="统计一个数的二进制中1的数量">统计一个数的二进制中1的数量&lt;/h2>
&lt;p>依然是利用&lt;code>v &amp;amp; (v -1)&lt;/code>的运算结果会将v的最低位的&lt;code>1&lt;/code>(如果有的话)置&lt;code>0&lt;/code>.&lt;/p>
&lt;p>循环执行此操作就可统计v中&lt;code>1&lt;/code>的数量.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#50fa7b">numberof1&lt;/span>(&lt;span style="color:#8be9fd">int&lt;/span> v) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> count &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">while&lt;/span>(v) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count&lt;span style="color:#ff79c6">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v &lt;span style="color:#ff79c6">=&lt;/span> v &lt;span style="color:#ff79c6">&amp;amp;&lt;/span> (v &lt;span style="color:#ff79c6">-&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> count;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="将一个数向上取整为2的幂">将一个数向上取整为2的幂&lt;/h2>
&lt;p>用一个&lt;code>1&lt;/code>一直左移, 直到比这个数大为止.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">uint32_t&lt;/span> &lt;span style="color:#50fa7b">roundup_pow_of_two&lt;/span>(&lt;span style="color:#ff79c6">const&lt;/span> &lt;span style="color:#8be9fd">uint32_t&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">uint32_t&lt;/span> ret &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">while&lt;/span> (ret &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ret &lt;span style="color:#ff79c6">=&lt;/span> ret &lt;span style="color:#ff79c6">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> ret;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Linux内核中使用了一种更快的方案, amazing!!!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">static&lt;/span> __inline__ &lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#50fa7b">generic_fls&lt;/span>(&lt;span style="color:#8be9fd">int&lt;/span> x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> r &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">32&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#ff79c6">!&lt;/span>x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#ff79c6">!&lt;/span>(x &lt;span style="color:#ff79c6">&amp;amp;&lt;/span> &lt;span style="color:#bd93f9">0xffff0000u&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#ff79c6">&amp;lt;&amp;lt;=&lt;/span> &lt;span style="color:#bd93f9">16&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#ff79c6">-=&lt;/span> &lt;span style="color:#bd93f9">16&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#ff79c6">!&lt;/span>(x &lt;span style="color:#ff79c6">&amp;amp;&lt;/span> &lt;span style="color:#bd93f9">0xff000000u&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#ff79c6">&amp;lt;&amp;lt;=&lt;/span> &lt;span style="color:#bd93f9">8&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#ff79c6">-=&lt;/span> &lt;span style="color:#bd93f9">8&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#ff79c6">!&lt;/span>(x &lt;span style="color:#ff79c6">&amp;amp;&lt;/span> &lt;span style="color:#bd93f9">0xf0000000u&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#ff79c6">&amp;lt;&amp;lt;=&lt;/span> &lt;span style="color:#bd93f9">4&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#ff79c6">-=&lt;/span> &lt;span style="color:#bd93f9">4&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#ff79c6">!&lt;/span>(x &lt;span style="color:#ff79c6">&amp;amp;&lt;/span> &lt;span style="color:#bd93f9">0xc0000000u&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#ff79c6">&amp;lt;&amp;lt;=&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#ff79c6">-=&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#ff79c6">!&lt;/span>(x &lt;span style="color:#ff79c6">&amp;amp;&lt;/span> &lt;span style="color:#bd93f9">0x80000000u&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#ff79c6">&amp;lt;&amp;lt;=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#ff79c6">-=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>;&lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> r;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">static&lt;/span> &lt;span style="color:#ff79c6">inline&lt;/span> &lt;span style="color:#8be9fd">unsigned&lt;/span> &lt;span style="color:#8be9fd">long&lt;/span> __attribute_const__ &lt;span style="color:#50fa7b">roundup_pow_of_two&lt;/span>(&lt;span style="color:#8be9fd">unsigned&lt;/span> &lt;span style="color:#8be9fd">long&lt;/span> x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> (&lt;span style="color:#bd93f9">1UL&lt;/span> &lt;span style="color:#ff79c6">&amp;lt;&amp;lt;&lt;/span> generic_fls(x &lt;span style="color:#ff79c6">-&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="向上向下对齐-检查是否对齐">向上/向下对齐, 检查是否对齐&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">/* uintptr_t 代表指针的位数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * 加uintptr_t转换的原因是: (void *)不能进行运算
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define IS_ALIGNED(X, align) (((uintptr_t)(const void *)(X)) % (align) == 0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define ALIGN_UP(X, align) (((X) + ((align) - 1)) &amp;amp; ~((align) - 1))
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define ALIGN_DOWN(x, align) ((X) &amp;amp; ~((align) - 1))
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define X (0x12345675)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define align (1 &amp;lt;&amp;lt; 2)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> v &lt;span style="color:#ff79c6">=&lt;/span> IS_ALIGNED(X, align);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#bd93f9">0&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> v) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#f1fa8c">&amp;#34;Given X(0x%x) is not align to 0x%08x&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, X, align);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#f1fa8c">&amp;#34;After align up, new X = 0x%x&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, ALIGN_UP(X, align));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#f1fa8c">&amp;#34;After align down, new X = 0x%x&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, ALIGN_DOWN(X, align));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#f1fa8c">&amp;#34;Give X(0x%x) is aligned to 0x%08x&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, X, align);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#f1fa8c">&amp;#34;After align up, new X = 0x%x&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, ALIGN_UP(X, align));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#f1fa8c">&amp;#34;After align down, new X = 0x%x&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, ALIGN_DOWN(X, align));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="检查两个有符号数是否异号">检查两个有符号数是否异号&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> x,y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> ((x &lt;span style="color:#ff79c6">^&lt;/span> y) &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#f1fa8c">&amp;#34;They have opposite signs&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">printf&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;They have same signs&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="大小端转换">大小端转换&lt;/h2>
&lt;p> &lt;/p>
&lt;h2 id="对某个位的getsetclear操作">对某个位的get/set/clear操作&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define GET_BIT(x, bit) ( ((x) &amp;amp; (1ULL &amp;lt;&amp;lt; (bit))) &amp;gt;&amp;gt; (bit) )
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define SET_BIT(x, bit) ( (x) |= (1ULL &amp;lt;&amp;lt; (bit)) )
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define CLEAR_BIT(x, bit) ( (x) &amp;amp;= ~(1ULL &amp;lt;&amp;lt; (bit)) )
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>Release note:&lt;/p>
&lt;ol>
&lt;li>添加对&lt;code>unsigned long long&lt;/code>长度的支持&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p> &lt;/p>
&lt;h2 id="sign-extending-from-a-varaiable-bit-width">Sign extending from a varaiable bit-width&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> bits &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">*&lt;/span> &lt;span style="color:#bd93f9">8&lt;/span>; &lt;span style="color:#6272a4">// number of bits representing the number in x
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> x &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">0xFFC1&lt;/span>; &lt;span style="color:#6272a4">// ready to get sign-extended
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> rst; &lt;span style="color:#6272a4">// resulting sign-extended number
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#ff79c6">const&lt;/span> mask &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">1U&lt;/span> &lt;span style="color:#ff79c6">&amp;lt;&amp;lt;&lt;/span> (bits &lt;span style="color:#ff79c6">-&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>); &lt;span style="color:#6272a4">// mask can be pre-computed if bits if fixed.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#ff79c6">=&lt;/span> x &lt;span style="color:#ff79c6">&amp;amp;&lt;/span> ((&lt;span style="color:#bd93f9">1U&lt;/span> &lt;span style="color:#ff79c6">&amp;lt;&amp;lt;&lt;/span> bits) &lt;span style="color:#ff79c6">-&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>); &lt;span style="color:#6272a4">// cut x if it holds more bits
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> rst &lt;span style="color:#ff79c6">=&lt;/span> (x &lt;span style="color:#ff79c6">^&lt;/span> mask) &lt;span style="color:#ff79c6">-&lt;/span> mask; &lt;span style="color:#6272a4">// excellent trick!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#f1fa8c">&amp;#34;INPUT: 0x%x, RESULT: 0x%x&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, x, rst);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="字符字符数组的大小写转换">字符/字符数组的大小写转换&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define TO_LOWER(c) (unsigned char)((c &amp;gt;= &amp;#39;A&amp;#39; &amp;amp;&amp;amp; c &amp;lt;= &amp;#39;Z&amp;#39;) ? (c | 0x20) : c)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define TO_UPPER(c) (unsigned char)((c &amp;gt;= &amp;#39;a&amp;#39; &amp;amp;&amp;amp; c &amp;lt;= &amp;#39;z&amp;#39;) ? (c &amp;amp; ~0x20) : c)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define TO_LOWER_STR(s, len) { \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6"> for (int i = 0; i &amp;lt; len &amp;amp;&amp;amp; s[i] != &amp;#39;\0&amp;#39;; i++) { \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6"> s[i] = TO_LOWER(s[i]); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6"> } \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define TO_UPPER_STR(s, len) {\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6"> for (int i = 0; i &amp;lt; len &amp;amp;&amp;amp; s[i] != &amp;#39;\0&amp;#39;; i++) { \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6"> s[i] = TO_UPPER(s[i]); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6"> } \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>- https://wangloo.github.io/posts/codestyle/bit-operation-hacks/ - @2019 Notepadium.</description></item><item><title>Stack and Heap</title><link>https://wangloo.github.io/posts/os/stack-and-heap/</link><pubDate>Tue, 28 Jun 2022 16:41:54 +0800</pubDate><guid>https://wangloo.github.io/posts/os/stack-and-heap/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/os/stack-and-heap/ -&lt;p> &lt;/p>
&lt;h2 id="堆的含义">堆的含义&lt;/h2>
&lt;p>我们都知道&lt;code>malloc&lt;/code>动态申请的变量是存放在堆中. 所以相比栈来说, 堆是动态的.&lt;/p>
&lt;p>堆占据进程虚拟地址空间的大部分, 我们可能通过堆来申请&lt;code>1GB&lt;/code>的数组, 但是栈通常不行
, 大多也就几兆的空间.&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="堆空间的管理">堆空间的管理&lt;/h2>
&lt;p>进程中堆空间的管理是&lt;code>运行库&lt;/code>负责的, 在Linux中是&lt;code>GLIBC&lt;/code>.&lt;/p>
&lt;p>运行库在初始化时会像操作系统申请一大块的堆空间, 再为每个进行分别分配需求. 当然,
如果某些程序的需求过大, 运行库也可以使用&lt;code>mmap&lt;/code>系统调用直接向操作系统申请, 然后
返回给用户进程.&lt;/p>
&lt;blockquote>
&lt;p>GLIBC的&lt;code>malloc&lt;/code>函数的处理方式是: 对于小于&lt;code>128KB&lt;/code>的申请, 会从运行库&amp;quot;批发的&amp;quot;堆空间
里分出一块来; 但若申请的空间过大, 则使用&lt;code>mmap&lt;/code>系统调用来创建匿名空间分配给用户.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Linux中虚拟地址块(VMA)的管理使用了红黑树, 可以用于运行库管理自己向操作系统
&amp;ldquo;批发&amp;quot;的堆空间. 使得用户程序动态申请和释放内存性能提高.&lt;/p>
&lt;/blockquote>
- https://wangloo.github.io/posts/os/stack-and-heap/ - @2019 Notepadium.</description></item><item><title>动态链接</title><link>https://wangloo.github.io/posts/os/dynamic-link/</link><pubDate>Sun, 26 Jun 2022 19:50:45 +0800</pubDate><guid>https://wangloo.github.io/posts/os/dynamic-link/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/os/dynamic-link/ -&lt;h2 id="静态链接带来的问题">静态链接带来的问题&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>像是&lt;code>libc&lt;/code>这种几乎每个程序都要用到的库, 如果是静态的, 那么不仅意外着每个程序的
可执行文件很大, 浪费磁盘空间. 并且当程序加载到内存时, 可能许多程序都会用到&lt;code>printf&lt;/code>
, 使得内存中会存在好多份的&lt;code>printf&lt;/code>源码.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>维护和更新难. 一旦静态链接的其中一个目标文件更新, 所有的可执行程序都要重新链接.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不满足局部性原理. 上面提到, 内存中同时存在多份的&lt;code>printf&lt;/code>源码会破坏&lt;em>局部性原理&lt;/em>的.
显然如果所有的程序共享一份&lt;code>printf&lt;/code>源码的想法更好. 即动态加载.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可移植性差. 静态链接, 只要有一个依赖目标文件的实现不同, 软件厂商就得专门发布一个
版本. 而动态链接则信赖客户电脑上的&lt;em>动态库&lt;/em>, 相当于一个中间层.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p> &lt;/p>
&lt;h2 id="动态链接的过程">动态链接的过程&lt;/h2>
&lt;p>对比静态链接使用&lt;code>ld&lt;/code>链接器在编译后即执行链接, 动态链接则是将链接过程推迟到&lt;strong>运行时&lt;/strong>,
即装载到内存时.&lt;/p>
&lt;p>这样, 链接器在链接产生可执行文件时就有两种做法:&lt;/p>
&lt;ul>
&lt;li>对于静态符号, 按照静态链接的规则进行&lt;em>地址引用重定位&lt;/em>&lt;/li>
&lt;li>对于动态符号, 链接器则仅标记其为动态链接中的符号, 不进行处理. 而是等到装载时由
专门的&lt;em>动态链接器&lt;/em>来完成动态符号的链接工作.&lt;/li>
&lt;/ul>
&lt;p>⁉️ 链接器如何确定一个符号是静态的or动态的?&lt;/p>
&lt;p>在动态共享对象(&lt;em>.so)中保存了完整的&lt;/em>动态符号表*, 表中存在的符号即为动态的, 否则为静态.&lt;/p>
&lt;blockquote>
&lt;p>Linux的C语言运行库&lt;code>glib&lt;/code>的动态链接版本叫&lt;code>libc.so&lt;/code>. 它在外存上只保存一份, 所有的程序
都可以在运行时使用它. 所以千万不要删掉它.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>动态链接有一定的性能损失, 因为每次运行程序时都要重新链接, 并不像静态链接是一劳永逸的.
也有例如&lt;code>延迟绑定&lt;/code>对性能进行优化的方法, 大概仅有5%的损耗, 与带来的便利相比可以忽略不计.&lt;/p>
&lt;/blockquote>
&lt;p> &lt;/p>
&lt;h2 id="地址无关代码-pic">地址无关代码 PIC&lt;/h2>
&lt;p>GCC生成动态库时需要添加参数&lt;code>-fPIC&lt;/code>, 含义就是生成地址无关码&lt;/p>
&lt;p>地址无关码的含义是代码中&lt;strong>不包含任何的绝对地址引用&lt;/strong>, 全都是&lt;strong>相对地址&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>对于&lt;strong>模块内&lt;/strong>的跳转/数据引用, 使用相对的跳转/加载指令. 例如ARM指令集中的&lt;code>B&lt;/code>, &lt;code>ADR&lt;/code>, 经过汇编器之后, 目标的地址都会转为相对于该指令(PC)的偏移.&lt;/li>
&lt;li>对于&lt;strong>模块间&lt;/strong>的跳转/数据引用, 借用&lt;em>GOT表&lt;/em>来间接实现地址无关.&lt;/li>
&lt;/ul>
&lt;p>而如果该动态库中全部使用相对地址, 那么加载时也就不需要进行重定位, 即所有的程序都可以
共享这些地址无关代码.&lt;/p>
&lt;blockquote>
&lt;p>上面说PIC的动态库不需要重定位其实是错误的, 只不过它的重定位过程不需要修改代码段,
而是设置了一个放置在数据段的&lt;em>GOT&lt;/em>表来实现代码段部分的地址无关特性.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>现在貌似GCC ARM版本在编译动态库时强制使用-fPIC选项, 否则会报错. 对此我不是
非常确定!&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>一般来说, 不将主程序编译为地址无关码. 因为主程序不需要共享, 而且地址无关码的调用
需要两个指令: &lt;code>计算地址&lt;/code> + &lt;code>跳转&lt;/code>. 多了一步根据偏移得到绝对地址.&lt;/p>
&lt;/blockquote>
- https://wangloo.github.io/posts/os/dynamic-link/ - @2019 Notepadium.</description></item><item><title>ELF 文件的链接与加载</title><link>https://wangloo.github.io/posts/os/elf-format/</link><pubDate>Mon, 20 Jun 2022 16:21:27 +0800</pubDate><guid>https://wangloo.github.io/posts/os/elf-format/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/os/elf-format/ -&lt;h2 id="elf-is-a-file-format">&lt;code>ELF&lt;/code> is a file format&lt;/h2>
&lt;p>Files in &lt;code>ELF&lt;/code> format includes:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Type&lt;/th>
&lt;th>description&lt;/th>
&lt;th>实例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Relocatable File&lt;/td>
&lt;td>这些文件包含了代码和data, 可以被用来链接成可执行文件或共享目标文件.&lt;/td>
&lt;td>&lt;code>.o&lt;/code>, &lt;code>.a&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Executable File&lt;/td>
&lt;td>直接可执行的文件&lt;/td>
&lt;td>&lt;code>/bin/ls&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Shared Object File&lt;/td>
&lt;td>Including code and data. 链接器可将其与其他Relocatable File或Shared Object File结合, 生成新的目标文件. 动态链接器可将其与Executable File结合, 作为进程映像的一部分来运行.&lt;/td>
&lt;td>&lt;code>.so&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Core Dump File&lt;/td>
&lt;td>Restore critical infomation when process is terminated unexpectedly&lt;/td>
&lt;td>&lt;code>core dump&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>📌 &lt;code>file&lt;/code> command in Linux can output the format of a file.&lt;/p>
&lt;/blockquote>
&lt;p> &lt;/p>
&lt;h2 id="elf-文件组成的结构">ELF 文件组成的结构&lt;/h2>
&lt;pre tabindex="0">&lt;code>+---------------------------------+
| ELF Header | 包含描述整个ELF的基本信息, 如版本, 入口地址...
+---------------------------------+
| .text |
+---------------------------------+
| .data |
+---------------------------------+ 紧接着是各个段
| .bss |
+---------------------------------+
| ... |
| other sections |
+---------------------------------+
| | 段表: 与段相关最重要的结构
| Section Header table | 描述了每个段的name, length, authority...
| |
+---------------------------------+
| String tables |
| Symbol tables |
+---------------------------------+
&lt;/code>&lt;/pre>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>字段&lt;/th>
&lt;th>含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>e_machine&lt;/td>
&lt;td>目标架构&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>e_entry&lt;/td>
&lt;td>入口地址&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>e_machine&lt;/td>
&lt;td>目标架构&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>e_phnum&lt;/td>
&lt;td>number of entries in the &lt;strong>program header table&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>e_shnum&lt;/td>
&lt;td>number of entries in the &lt;strong>section header table&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>e_shoff&lt;/td>
&lt;td>offset, in bytes, of the section header table&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>e_phoff&lt;/td>
&lt;td>offset, in bytes, of the program header table&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>e_machine&lt;/td>
&lt;td>目标架构&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>e_machine&lt;/td>
&lt;td>目标架构&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="段表">段表&lt;/h3>
&lt;p>ELF文件中的各个段的基本属性就是保存在&lt;strong>段表&lt;/strong>中，是分析ELF文件最重要的字段。存放了每个段的信息，例如，段名，段的长度，在文件中的偏移，读写权限以及其他属性。&lt;/p>
&lt;p>编译器、链接器都是依靠段表来定位和访问各个段的属性的。&lt;/p>
&lt;p>如何找到段表？ &lt;strong>&lt;code>e_shoff&lt;/code>字段&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>使用&lt;code>readelf -S &amp;lt;elfname&amp;gt;&lt;/code> 就能查看ELF文件的段表&lt;/p>
&lt;/blockquote>
&lt;h3 id="程序头表">程序头表&lt;/h3>
&lt;p> &lt;/p>
&lt;h2 id="分析elf文件的工具">分析ELF文件的工具&lt;/h2>
&lt;h3 id="1-objdump">1. objdump&lt;/h3>
&lt;h3 id="2-readelf">2. readelf&lt;/h3>
&lt;p> &lt;/p>
&lt;h2 id="为什么目标文件中代码和数据要分开放">为什么目标文件中代码和数据要分开放?&lt;/h2>
&lt;p>一方面, 程序被加载进内存后, 代码段和数据段分别被映射到&lt;strong>两个virtual memory region&lt;/strong>.
通过MMU的支持, 可以将代码段的区域设置为只读, 防止恶意篡改.&lt;/p>
&lt;p>另一方面, 当下CPU Cache多划分为&lt;em>Instruction Cache&lt;/em>和&lt;em>Data Cache&lt;/em>, 再配合互相独立的
地址区域能够提高&lt;strong>局部性原理&lt;/strong>的效果.&lt;/p>
&lt;p>最后, 代码段可以被多个进程共享(例如都调用同一外部函数), 节省内存空间.&lt;/p>
&lt;blockquote>
&lt;p>针对嵌入式设备, 如果内存空间不够大, 只读的代码段可存放在ROM中&lt;/p>
&lt;/blockquote>
&lt;p> &lt;/p>
&lt;h2 id="关于静态库">关于静态库&lt;/h2>
&lt;p>一个静态库可以简单的看作是 a set of object file.&lt;br>
这些 object file 可能包括: 输入输出相关的&lt;code>printf.o&lt;/code>, &lt;code>scanf.o&lt;/code>, 日期时间相关的&lt;code>time.o&lt;/code>, &lt;code>date.o&lt;/code>等.&lt;/p>
&lt;p>❓ 为什么不直接提供这些&lt;em>目标文件&lt;/em>呢?&lt;/p>
&lt;p>这些&lt;strong>零散的&lt;/strong>文件若直接提供给使用者, 很大程度上造成文件传输, 管理等方面的不便.&lt;br>
于是人们通常使用&lt;code>ar&lt;/code>压缩程序将这些目标文件压缩到一起.&lt;/p>
&lt;p>❓ 如何查看一个静态库是由哪些object file压缩到一起的?&lt;/p>
&lt;p>Shell command&lt;code>ar -t libc.a&lt;/code> 可以查看&lt;code>libc.a&lt;/code>中包含的所有object files.&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="elf文件加载-运行流程">ELF文件加载-运行流程&lt;/h2>
&lt;blockquote>
&lt;p>废了半天劲编译生成的ELF文件, 想要最终跑起来则包含的instruction and data必须要在内存中.&lt;/p>
&lt;/blockquote>
&lt;h3 id="静态加载与动态加载">静态加载与动态加载&lt;/h3>
&lt;p>我们能想到的最简单的办法是: 把整个ELF的&lt;strong>所有指令和数据&lt;/strong>在运行之前就全部load到内存中. 这就是&lt;em>静态加载&lt;/em>.&lt;/p>
&lt;p>更加高效的做法是: 充分利用&lt;em>局部性原理&lt;/em>, 将指令和数据划分为&lt;strong>模块&lt;/strong>, 只有当该模块被使用时, 才load进内存,
否则就在外存中老老实实呆着. 这就是&lt;em>动态加载&lt;/em>.&lt;/p>
&lt;h3 id="动态加载的步骤">动态加载的步骤&lt;/h3>
&lt;p>借助&lt;em>虚拟内存&lt;/em>技术, 上面提到的&lt;strong>模块&lt;/strong>的概念可以自然的被&lt;strong>页&lt;/strong>(page)代替.
我们将所有的指令和数据按照page为单位划分.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>运行该ELF的线程被创建时, 其virtual space范围被划定, 但其页表是空的, 没有任何映射.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>OS读取ELF Header, 建立virtual space与&lt;strong>ELF文件&lt;/strong>的映射关系. 这个映射关系的表达方式是一个特殊的&lt;strong>数据结构&lt;/strong>.
建立该映射关系的原因是: 当程序运行到某个地址发现该页表项是空的(例如 &lt;code>call 0x1234&lt;/code>), 那么必然触发&lt;code>page fault&lt;/code>.
由OS负责到&lt;em>特定的外存地址&lt;/em>将页面加载到physical memory中.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>OS要想知道缺失的内容在ELF文件的哪个位置, 就是利用该映射, 即某个数据结构
&lt;/code>&lt;/pre>&lt;ol start="3">
&lt;li>physical memory中有了所需的指令或数据后, 还需建立visual memory到physical memory的映射, 即在&lt;em>页表项&lt;/em>中写入.
随着程序的运行, 会继续触发&lt;code>page fault&lt;/code>, 从ELF中不断load page到physical memory, 建立缺页visual addr处的页表映射,
最终填补成一个完整的pagetable.&lt;/li>
&lt;/ol>
&lt;p> &lt;/p>
&lt;h2 id="段地址对齐技术">段地址对齐技术&lt;/h2>
&lt;blockquote>
&lt;p>由前面动态加载的步骤可知, ELF文件中的代码和数据被按page划分. 并只有在用到时才被加载到内存,
并建立&lt;code>虚拟内存-物理内存&lt;/code>的映射.&lt;/p>
&lt;/blockquote>
&lt;p>假设一个ELF有三个段需要被&lt;code>LOAD&lt;/code>, ELF段表如下:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Segment&lt;/th>
&lt;th>Length&lt;/th>
&lt;th>offset&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>SEG 0&lt;/td>
&lt;td>127 B&lt;/td>
&lt;td>34 B&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SEG 1&lt;/td>
&lt;td>9899 B&lt;/td>
&lt;td>164 B&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SEG 2&lt;/td>
&lt;td>1988 B&lt;/td>
&lt;td>0 B&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="-这三个段在elf文件中的布局如何">❓ 这三个段在ELF文件中的布局如何?&lt;/h3>
&lt;p>根据前面ELF文件格式的介绍, 这三个段必然是挨着的(简单考虑, ELF中仅有这三个段).&lt;/p>
&lt;h3 id="-这三个段在物理内存中的布局">❓ 这三个段在物理内存中的布局?&lt;/h3>
&lt;p>发生&lt;code>page fault&lt;/code>之后, OS会为页面分配合适的物理页面, 如利用&lt;code>buddy system&lt;/code>等.&lt;/p>
&lt;p>可以保证&lt;em>段内&lt;/em>的连续, 不能保证&lt;em>段与段&lt;/em>是连续的.&lt;/p>
&lt;blockquote>
&lt;p>未使用段对齐技术之前, &lt;code>SEG0&lt;/code>的长度不足一页, 但是也给它分配一页的空间. 同理为&lt;code>SEG1&lt;/code>分配两页, &lt;code>SEG2&lt;/code>分配一页.
总共占用 &lt;code>1+2+1=5&lt;/code>个物理页.&lt;/p>
&lt;/blockquote>
&lt;h3 id="-这三个段在用户virtual-addrspace下的布局如何">❓ 这三个段在用户virtual addrspace下的布局如何?&lt;/h3>
&lt;p>todo&lt;/p>
&lt;h3 id="-何为段地址对齐技术">❓ 何为段地址对齐技术?&lt;/h3>
&lt;p>上面说了, 在为这三个段分配物理内存时, 虽然他们的真实大小远小于5个页面, 但由于简单采用: &lt;code>每个段的开头必须是page align&lt;/code>,
导致实际上产生了巨大的&lt;strong>内部碎片&lt;/strong>.&lt;/p>
&lt;p>段地址对齐实际上就是在为ELF文件中的段分配物理内存时, 不考虑其段的独立性, 强制按照&lt;code>page&lt;/code>来划分. 划分的行为如下图所示.
结果就是仅需占用&lt;code>3&lt;/code>个物理页面.&lt;/p>
&lt;pre tabindex="0">&lt;code>+---+---------------+
| P | SEG0 |
| A +---------------+
| G | |
| E | |
+---+ |
| P | SEG1 |
| A | |
| G | |
| E | |
+---+ |
| P +---------------+
| A | |
| G | SEG2 |
| E | |
+---+---------------+
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>目前, gcc(更准确是说是GUN ld)默认启用段对齐技术. 各个段的虚拟地址并不是&lt;code>page align&lt;/code>.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>🍀 物理页面到虚拟页面的映射阶段, 那些&lt;em>同时包含&lt;/em>两个段的页面会被映射两次, 即一个物理页面对应两个
虚拟页.&lt;/p>
&lt;p>原因是: 在一个页面的不同段可能&lt;strong>权限不同&lt;/strong>, 所以不能使用同一映射.&lt;/p>
&lt;/blockquote>
- https://wangloo.github.io/posts/os/elf-format/ - @2019 Notepadium.</description></item><item><title>写高质量的C语言工程的技巧</title><link>https://wangloo.github.io/posts/codestyle/improve_quality/</link><pubDate>Tue, 14 Jun 2022 17:59:22 +0800</pubDate><guid>https://wangloo.github.io/posts/codestyle/improve_quality/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/codestyle/improve_quality/ -&lt;h2 id="添加更多的编译选项comiler-options来防止bug">添加更多的编译选项(comiler options)来防止bug&lt;/h2>
&lt;p>对于我常用的&lt;code>GCC&lt;/code>, 推荐开启一下的compiler options:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>-Wall&lt;/code>: enable a lot of common warnings&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-Wno-format-truncation&lt;/code>: warns about the snprintf output buffer not being
large enough for a corresponding “%s” in the format string.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-Werror&lt;/code>: turn warnings into errors.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p> &lt;/p>
&lt;h2 id="动态申请的空间到底要不要释放">动态申请的空间到底要不要释放&lt;/h2>
&lt;p>When using a barebones embedded OS, you absolutely need to tightly manage your memory.&lt;/p>
&lt;p>但是, 如果你是写应用业务的代码, 特别是在内存足够的场景下. 最好不要手动释放内存,
因为当线程/进程退出时, 操作系统会自动帮我们释放. &lt;strong>某些情况下, 释放内存的操作会很大程度上增加逻辑的复杂度&lt;/strong>.&lt;/p>
&lt;blockquote>
&lt;p>如果你是一个内核程序员, 则必须手动的释放. 不用怀疑.&lt;/p>
&lt;/blockquote>
&lt;p> &lt;/p>
&lt;h2 id="尽可能在创建变量时赋初值">尽可能在创建变量时赋初值&lt;/h2>
&lt;p>放置某些变量创建后是 &lt;code>magic value&lt;/code>. 而使用这些变量可能不会立马导致错误, 但是这是一个隐患.&lt;/p>
&lt;p>但这会产生一个问题, 有时我们定义变量之后的不久之后就会对其赋予正确的值, 这时候初值就是
多余的. 而且维护者可能认为这个值是meaningful, 这就要求我们如果要赋初值, 就要说明这个值
仅仅是&lt;strong>无意义的&lt;/strong>初值.&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="使用define-enum">使用&lt;code>#define&lt;/code>, &lt;code>enum&lt;/code>&lt;/h2>
&lt;p>对于代码在不同地方使用的同一个值, 应使用&lt;code>#define&lt;/code>来声明使得代码&lt;strong>maintainable&lt;/strong>.&lt;/p>
&lt;p>如果这些值有多个且能规划为同一类别, 则还可将&lt;code>#define&lt;/code>的方式换为&lt;code>enum&lt;/code>. 这会使代码更加&lt;strong>meaningful&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>使用&lt;code>enum&lt;/code>使还要注意其所占内存空间在不同架构中可能不同的问题, see &lt;a href="https://www.cnblogs.com/bluettt/p/16041867.html">enum的优势和漏洞&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p> &lt;/p>
&lt;h3 id="使用typedef优化function-pointer">使用&lt;code>typedef&lt;/code>优化function pointer&lt;/h3>
&lt;p> &lt;/p>
&lt;h2 id="重定义一套自己的类型">重定义一套自己的类型&lt;/h2>
&lt;p>在开发&lt;em>大项目&lt;/em>时, 需要考虑可移植性的情况下, 最好利用&lt;code>typedef&lt;/code>对类型进行重定义.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#if SYSTEM1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span> &lt;span style="color:#ff79c6">typedef&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> INT32;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#else
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span> &lt;span style="color:#ff79c6">typedef&lt;/span> &lt;span style="color:#8be9fd">long&lt;/span> INT32;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如上, 对于某些架构&lt;code>int&lt;/code>类型可能不是32bit, 此时就要使用&lt;code>long&lt;/code>. 这种定义的方式会保证我们的系统
在任何架构中都不会出现类型的bug. 而且也增加了代码的&lt;strong>readability&lt;/strong>.&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="善用0">善用&lt;code>~0&lt;/code>&lt;/h2>
&lt;p>在做嵌入式编程时, 有时在设置掩码(mask)或者其他情况会要用到&lt;strong>全1&lt;/strong>的变量值, 你是否经常这样声明?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> mask &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">0xffff&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>暂且不谈&lt;code>int&lt;/code>类型到底占多少字节的问题. 就像上面一样, 我们程序员经常忘记某个类型的大小,
而少添加了&lt;code>f&lt;/code>. 会导致变量&lt;code>mask&lt;/code>的值不是全1(32位情况下).&lt;/p>
&lt;p>这是要变换一下思维, 使用&lt;code>~0&lt;/code>的定义方法就可轻松化解, 无需管变量的类型是什么.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> mask &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">~&lt;/span>&lt;span style="color:#bd93f9">0&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="合理的使用goto语句">合理的使用&lt;code>goto&lt;/code>语句&lt;/h2>
&lt;p>在大学课堂中, 我们老师说过禁止使用&lt;code>goto&lt;/code>语句, 但却没有给出明确的原因.&lt;/p>
&lt;p>实际上, &lt;strong>合理的&lt;/strong>使用&lt;code>goto&lt;/code>能够极大的减少程序的冗余度.&lt;/p>
&lt;p>&lt;code>goto&lt;/code>语句常用于程序出现错误要退出时, 可能有多个情况会使用重复的代码处理,
例如释放一些allocated memory. 相较于使用&lt;code>flag&lt;/code>, 使用&lt;code>goto&lt;/code>显然更加clearly and readability.&lt;/p>
&lt;p>所以, 在面对重复的错误处理代码时, 想想能不能用&lt;code>goto&lt;/code>进行优化. 当然, &lt;strong>避免过早优化&lt;/strong>.&lt;/p>
&lt;blockquote>
&lt;p>注意, &lt;code>goto&lt;/code>出现的场景其实很受限. Never use a backward &lt;code>goto&lt;/code> or jump into control statements.&lt;/p>
&lt;/blockquote>
&lt;p> &lt;/p>
&lt;h2 id="定义合理-正确的结构体">定义合理, 正确的结构体&lt;/h2>
&lt;p>结构体是C语言编程应用中常用的数据结构, 关于结构体也有许多要注意的点.&lt;/p>
&lt;h3 id="1-flexible-array-member">#1 Flexible Array Member&lt;/h3>
&lt;p>C99开始支持&lt;em>Flexible Array Member&lt;/em>. 且看我&lt;a href="">lstring&lt;/a>库的结构体定义:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">struct&lt;/span> str {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> length;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">char&lt;/span> data[]; &lt;span style="color:#6272a4">// Flexible array member - C99 only
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于这种不定长的数组元素, 我之前都是定义一个指针, 占用一个&lt;code>sizeof(char *)&lt;/code>的空间. 而Flexible Array Member本身不占用空间. 需要在malloc时为他单独声明空间.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> n &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">struct&lt;/span> str &lt;span style="color:#ff79c6">*&lt;/span>s &lt;span style="color:#ff79c6">=&lt;/span> malloc(&lt;span style="color:#ff79c6">sizeof&lt;/span>(&lt;span style="color:#ff79c6">struct&lt;/span> str) &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#ff79c6">sizeof&lt;/span>(&lt;span style="color:#8be9fd">char&lt;/span>[n]));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>这里也有一个小trick, 使用&lt;code>sizeof(char[n])&lt;/code> 比 &lt;code>sizeof(char) * n&lt;/code> 更简洁!&lt;/p>
&lt;/blockquote>
&lt;h3 id="-2-padding-and-packed"># 2 Padding and Packed&lt;/h3>
&lt;p>有关结构体的大小, 和地址对齐的问题. 假设我有一个结构体如下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">struct&lt;/span> mystruct_A
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">char&lt;/span> a; &lt;span style="color:#8be9fd">int&lt;/span> b; &lt;span style="color:#8be9fd">char&lt;/span> c;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} x;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Padding是编译器对结构体&lt;strong>默认&lt;/strong>做的事情. 它会在成员之间插入一些 gap 来保证地址对齐:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">struct&lt;/span> mystruct_A {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">char&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">char&lt;/span> gap_0[&lt;span style="color:#bd93f9">3&lt;/span>]; &lt;span style="color:#6272a4">/* inserted by compiler: for alignment of b */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> b; &lt;span style="color:#6272a4">/* int 在32位上其地址是4字节对齐的 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">char&lt;/span> c;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">char&lt;/span> gap_1[&lt;span style="color:#bd93f9">3&lt;/span>]; &lt;span style="color:#6272a4">/* -&amp;#34;-: for alignment of the whole struct in an array */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} x;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>除了保证每个成员的地址是对齐的, &lt;strong>整个结构体&lt;/strong>的地址也是按照其最大的成员类型来对齐, 即对齐到&lt;code>int&lt;/code>(4字节).&lt;/p>
&lt;/blockquote>
&lt;p>如果你&lt;strong>不想要这些 gap&lt;/strong>, 那么可以对结构体声明使用 &lt;code>__attribute__((__packed__))&lt;/code>关键字. 整个结构体大小仅为6个字节.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">struct&lt;/span> &lt;span style="color:#50fa7b">__attribute__&lt;/span>((__packed__)) mystruct_A {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">char&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">char&lt;/span> c;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="永远为你的函数设置error-return-value">永远为你的函数设置error return value&lt;/h2>
&lt;p>一旦你的函数可能被其他人调用, 那么养成设置return value的习惯. 即便你现在的实现
并不会产生任何错误, 也请返回&lt;code>success&lt;/code>.&lt;/p>
&lt;p>这样做的原因是, caller可以根据你的定义做错误判断, 即便以后你的实现加上了出错情况,
上层的代码也不需要修改.&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="变量类型的选择">变量类型的选择&lt;/h2>
&lt;ul>
&lt;li>名字, 特定不变的字符串使用&lt;code>const char *&lt;/code>, 甚至&lt;code>const char const*&lt;/code>&lt;/li>
&lt;li>长度使用&lt;code>size_t&lt;/code>&lt;/li>
&lt;li>表示类型的参数尽可能使用&lt;code>enum&lt;/code>&lt;/li>
&lt;li>循环变量i使用&lt;code>signed&lt;/code>, 避免溢出后出错&lt;/li>
&lt;/ul>
&lt;p> &lt;/p>
&lt;h2 id="reference">Reference&lt;/h2>
&lt;p>&lt;a href="https://www.msweet.org/blog/2020-12-31-how-i-improve-my-c-code-quality.html">How I Improve My (C) Code Quality&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.codeproject.com/Articles/357065/Ten-Fallacies-of-Good-C-Code">Ten Fallacies of Good C Code&lt;/a>&lt;/p>
- https://wangloo.github.io/posts/codestyle/improve_quality/ - @2019 Notepadium.</description></item><item><title>MicroKernel Learning: SeL4</title><link>https://wangloo.github.io/posts/microkernel/sel4/</link><pubDate>Sat, 04 Jun 2022 11:52:51 +0800</pubDate><guid>https://wangloo.github.io/posts/microkernel/sel4/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/microkernel/sel4/ -&lt;h2 id="sel4-capabilities">seL4 Capabilities&lt;/h2>
&lt;p>In seL4, capabilities are stored in &lt;strong>C-space&lt;/strong>. C-space is a hierarchical data structure very similar to &lt;strong>page table&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>page table is a mapping from virtual address to physical address.&lt;/li>
&lt;li>C-space is a mapping from &lt;strong>object ID&lt;/strong> to &lt;strong>capability&lt;/strong>.&lt;/li>
&lt;li>Kernel object is made up of several &lt;strong>C-nodes&lt;/strong>, just like a page table made up of individual page tables.&lt;/li>
&lt;li>Each C-nodes is an array of cap &lt;em>slots&lt;/em>, which contain capability.&lt;/li>
&lt;/ul>
&lt;p>Inaccessible to userland, you can never hold an &lt;strong>actual capability&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>You can only hold a reference to capability, which pointers into C-space(slot addresses)&lt;/li>
&lt;li>These C-space addresses are called &lt;strong>CPTRs&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>You don&amp;rsquo;t need to do the transform, because this is typically extracted in some libs.&lt;/p>
&lt;/blockquote>
&lt;p>Capabilities convey specific privilege (acces rights)&lt;/p>
&lt;ul>
&lt;li>Read, Write, Execute, GrantReply(&lt;code>call&lt;/code>), Grant(&lt;code>cap transfer&lt;/code>)&lt;/li>
&lt;/ul>
&lt;p>Main operations on capabilities:&lt;/p>
&lt;ul>
&lt;li>&lt;code>Invoke&lt;/code>perform operation on object referred to by cap.
&lt;ul>
&lt;li>For example, map some frame into memory. You need to have capabilities to both the frame and address space.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>Copy&lt;/code>|&lt;code>Mint&lt;/code>|&lt;code>Grant&lt;/code>: create copy of cap with &lt;strong>same/lesser&lt;/strong> privilege.&lt;/li>
&lt;li>&lt;code>Move&lt;/code>|&lt;code>Mutate&lt;/code>: transfer to different address with &lt;strong>same/lesser&lt;/strong> privilege.
&lt;ul>
&lt;li>Between C-space or within C-space.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>Delete&lt;/code>: invalidate slot(cleans up object if this is the only cap to it)&lt;/li>
&lt;li>&lt;code>Revoke&lt;/code>: delete any derived(eg. copied or minted) caps&lt;/li>
&lt;/ul>
&lt;h3 id="capability-derivation">Capability Derivation&lt;/h3>
&lt;h4 id="mint-operation">MINT OPERATION&lt;/h4>
&lt;p>The &lt;strong>Mint&lt;/strong> operation creates a new, less powerful cap&lt;/p>
&lt;ul>
&lt;li>Can add badge&lt;/li>
&lt;li>Can strip access rights, eg &lt;code>RW-&amp;gt;RO&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>mint(dest, src, rights, badge)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>The first two arguement are &lt;strong>capability pointers(CPTR)&lt;/strong> to a C-space(represented by C-node), which are references inside C-node.&lt;/li>
&lt;li>The &lt;strong>destination C-node cap&lt;/strong> must allow modification&lt;/li>
&lt;li>Then you have the rights and the &lt;em>batch&lt;/em> of the new cap.&lt;/li>
&lt;/ul>
&lt;p>📌 This is an alternative of sending addressed capabilities by &lt;strong>IPC operation&lt;/strong>.
That is what operating system do to set up protection domains for &lt;strong>user level process&lt;/strong>.&lt;/p>
&lt;h4 id="copy-operation">COPY OPERATION&lt;/h4>
&lt;blockquote>
&lt;p>Copy as a version of &lt;em>Mint&lt;/em>.&lt;/p>
&lt;/blockquote>
&lt;p> &lt;/p>
&lt;h2 id="sel4-kernel-objects">seL4 Kernel Objects&lt;/h2>
&lt;p>In file &lt;code>libsel4\include\sel4\objecttype.h&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">typedef&lt;/span> &lt;span style="color:#ff79c6">enum&lt;/span> api_object {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seL4_UntypedObject,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seL4_TCBObject,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seL4_EndpointObject,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seL4_NotificationObject,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seL4_CapTableObject,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#ifdef CONFIG_KERNEL_MCS
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span> seL4_SchedContextObject,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seL4_ReplyObject,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span> seL4_NonArchObjectTypeCount,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} seL4_ObjectType;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="sel4-system-calls">seL4 System Calls&lt;/h2>
&lt;p>seL4 has &lt;code>11&lt;/code> syscalls:&lt;/p>
&lt;p>&lt;code>Yield()&lt;/code>: invokes scheduler&lt;/p>
&lt;ul>
&lt;li>does NOT require a capability!&lt;/li>
&lt;/ul>
&lt;p>&lt;code>Send()&lt;/code>,&lt;code>Recv()&lt;/code> and variants/combinations thereof: IPC operations&lt;/p>
&lt;ul>
&lt;li>&lt;code>Call()&lt;/code>,&lt;code>ReplyRecv()&lt;/code>: usually invokes by client/server&lt;/li>
&lt;li>&lt;code>Send()&lt;/code>, &lt;code>NBSend()&lt;/code>: send-only and non-blocking version of it.&lt;/li>
&lt;li>&lt;code>Recv()&lt;/code>, &lt;code>NBRecv()&lt;/code>, &lt;code>NBSendRecv()&lt;/code>&lt;/li>
&lt;li>&lt;code>Wait()&lt;/code>, &lt;code>NBWait()&lt;/code>, &lt;code>NBSendWait()&lt;/code>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>We just use &lt;code>Call()&lt;/code> normally, the others are only for bootstrapping protocols and exception handling.&lt;/p>
&lt;/blockquote>
&lt;p>Call() is atomic Send() + reply-object setup + Wait()&lt;/p>
&lt;ul>
&lt;li>cannot be simulated with one-way operations!&lt;/li>
&lt;/ul>
&lt;p>ReplyRecv() is NBSend() + Recv()&lt;/p>
&lt;h3 id="different-object-support-different-operations">Different object support different operations&lt;/h3>
&lt;h4 id="endpoints">ENDPOINTS&lt;/h4>
&lt;p>Endpoints support all 10 IPC variants.&lt;/p>
&lt;h4 id="notifications">NOTIFICATIONS&lt;/h4>
&lt;p>Notifications support:&lt;/p>
&lt;ul>
&lt;li>NBSend() - aliased as Signal()&lt;/li>
&lt;li>Wait()&lt;/li>
&lt;li>NBWait() - aliased as Poll()&lt;/li>
&lt;/ul>
&lt;h4 id="other-objects">OTHER OBJECTS&lt;/h4>
&lt;p>Other objects only supports &lt;code>Call()&lt;/code> operation.&lt;/p>
&lt;ul>
&lt;li>Appear as (kernel-implemented) servers. If you invoking a method on an object, this is done by treating the object as a kernel-implemented server. And you invoke it with a &lt;code>call()&lt;/code> operation just as you do a normal server invocation.&lt;/li>
&lt;li>Each of these kernel objects has a different kernel-defined protocol
&lt;ul>
&lt;li>operations encoded in message tag&lt;/li>
&lt;li>parameters passed in message words&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Mostly hidden behind &lt;strong>syscall&lt;/strong> wrappers, user do not need to know this details.&lt;/li>
&lt;/ul>
&lt;p> &lt;/p>
&lt;h2 id="sel4-ipc">seL4 IPC&lt;/h2>
&lt;blockquote>
&lt;p>IPC in seL4 is a way to realize &lt;strong>cross-domain&lt;/strong> invocation.&lt;/p>
&lt;/blockquote>
&lt;p>seL4 IPC is not a mechanism for shipping data. Transfering data is axillary but not the primary purpose.&lt;/p>
&lt;p>seL4 IPC is a protected procedure call, a user-controlled context switch(from clients context into server context).&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="sel4-threads">seL4 Threads&lt;/h2>
&lt;h3 id="creating-a-thread">Creating a thread&lt;/h3>
&lt;ol>
&lt;li>Obtain a TCB object&lt;/li>
&lt;li>Set attributes: V-space, C-space, fault endpoint, IPC buffer&lt;/li>
&lt;li>Set Scheduling parameters:
&lt;ul>
&lt;li>priority, scheduling context, timeout endpoint(maybe MCP)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Set architecture-related registers&lt;/li>
&lt;/ol>
&lt;h3 id="threads-and-stacks">Threads and Stacks&lt;/h3>
&lt;p>Stacks are completely user-managed, kernel doesn&amp;rsquo;t care!&lt;/p>
&lt;blockquote>
&lt;p>Kernel only preserves SP.. on context switch&lt;/p>
&lt;/blockquote>
&lt;p>Stack location, allocation, size must be managed by &lt;strong>userland&lt;/strong>.&lt;/p>
&lt;p>Kernel beware of stack overflow&lt;/p>
- https://wangloo.github.io/posts/microkernel/sel4/ - @2019 Notepadium.</description></item><item><title>使用 HuGo 搭建个人网站</title><link>https://wangloo.github.io/posts/hugo/</link><pubDate>Sat, 21 May 2022 17:39:42 +0800</pubDate><guid>https://wangloo.github.io/posts/hugo/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/hugo/ -&lt;h1 id="hugo-基础学习">HuGo 基础学习&lt;/h1>
&lt;p>本章将解答Hugo是什么, 以及Hugo是如何工作的. 只有了解Hugo的工作机制之后, 才能发挥想象力进行DIY.&lt;/p>
&lt;p>本章内容大多来自&lt;a href="https://gohugo.io/documentation/">官方手册&lt;/a>或者搜索引擎提供的结果.&lt;/p>
&lt;h2 id="hugo-项目目录结构">Hugo 项目目录结构&lt;/h2>
&lt;p>一个hugo 项目通常包含以下内容:&lt;/p>
&lt;pre tabindex="0">&lt;code>.
├── archetypes
├── config.toml
├── content
├── data
├── layouts
├── public
├── static
└── themes
&lt;/code>&lt;/pre>&lt;p>这里面有些是必须的, 有些是可选的.&lt;/p>
&lt;p>&lt;strong>archetypes&lt;/strong>&lt;/p>
&lt;p>定义新创建post时, header的格式.&lt;/p>
&lt;p>&lt;strong>asserts&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>Note: assets directory is not created by default.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>config&lt;/strong>&lt;/p>
&lt;p>Hugo uses the &lt;code>config.toml&lt;/code>, &lt;code>config.yaml&lt;/code>, or &lt;code>config.json&lt;/code> (if found in the site root) as the default site config file.&lt;/p>
&lt;p>The user can choose to override that default with one or more site config files using the command-line &lt;code>--config&lt;/code> switch.&lt;/p>
&lt;pre tabindex="0">&lt;code>hugo --config debugconfig.toml
hugo --config a.toml,b.toml,c.toml
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>Note: config directory is not created by default.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>content&lt;/strong>&lt;/p>
&lt;p>显然, 存储所有的post.&lt;/p>
&lt;p>&lt;strong>data&lt;/strong>&lt;/p>
&lt;p>This directory is used to store configuration files that can be used by Hugo when generating your website.&lt;/p>
&lt;p>像是你 website 的一个mini 数据库, 你可以放置 toml, yaml, json格式的文件.&lt;/p>
&lt;p>&lt;strong>layouts&lt;/strong>&lt;/p>
&lt;p>Stores templates in the form of &lt;code>.html&lt;/code> files that specify how views of your content will be rendered into a static website. Templates include &lt;a href="https://gohugo.io/templates/list/">list pages&lt;/a>, your &lt;a href="https://gohugo.io/templates/homepage/">homepage&lt;/a>, &lt;a href="https://gohugo.io/templates/taxonomy-templates/">taxonomy templates&lt;/a>, &lt;a href="https://gohugo.io/templates/partials/">partials&lt;/a>, &lt;a href="https://gohugo.io/templates/single-page-templates/">single page templates&lt;/a>, and more.&lt;/p>
&lt;p>&lt;strong>public&lt;/strong>&lt;/p>
&lt;p>保存build生成的站点. 当运行&lt;code>hugo [flag]&lt;/code>时生成.&lt;/p>
&lt;p>拷贝该目录下的内容, 可以部署到web 服务器上了.&lt;/p>
&lt;p>&lt;strong>static&lt;/strong>&lt;/p>
&lt;p>Stores all the static content: images, CSS, JavaScript, etc. 当Hugo构建您的站点时，静态目录中的所有资源都会按原样复制。&lt;/p>
&lt;p>即当构建website时, &lt;code>static/&lt;/code>下的所有文件都会复制到 &lt;code>public/&lt;/code>下.&lt;/p>
&lt;p>The static files are served on the site root path (eg. if you have the file &lt;code>static/image.png&lt;/code> you can access it using &lt;code>http://{server-url}/image.png&lt;/code>, to include it in a document you can use &lt;code>![Example image](/image.png) )&lt;/code>.&lt;/p>
&lt;p>&lt;strong>resources&lt;/strong>&lt;/p>
&lt;p>一些缓存文件&lt;/p>
&lt;blockquote>
&lt;p>Note: resources directory is not created by default.&lt;/p>
&lt;/blockquote>
&lt;h2 id="hugo-cli-命令">Hugo CLI 命令&lt;/h2>
&lt;p>hugo 支持的所有命令可以通过 &lt;code>hugo help&lt;/code> 命令来查看. 每一条命令的具体用法, 可以执行 &lt;code>hugo [command] help&lt;/code> 来查看&lt;/p>
&lt;pre tabindex="0">&lt;code>Usage:
hugo [flags]
hugo [command]
&lt;/code>&lt;/pre>&lt;h3 id="hugo-completion">Hugo completion&lt;/h3>
&lt;p>用来配置补全 hugo command 和 flag 的. 该命令会输出一段脚本, 将该脚本复制到你的 shell 的配置文件中就可以使用 hugo tab 补全了.&lt;/p>
&lt;h3 id="hugo-config">hugo config&lt;/h3>
&lt;p>打印hugo的配置文件, 即根目录下的 &lt;code>config.toml&lt;/code>.&lt;/p>
&lt;h3 id="hugo-env">hugo env&lt;/h3>
&lt;p>打印 hugo 的版本和环境信息&lt;/p>
&lt;h3 id="hugo-list">hugo list&lt;/h3>
&lt;p>打印所有post的info, 包含标题, 发布日志, 链接等.&lt;/p>
&lt;h3 id="hugo-new">hugo new&lt;/h3>
&lt;p>非常重要的命令, 可以用来新建一个 website, 主题, 或者一篇post(常用). 带有许多 flag可以使用.&lt;/p>
&lt;h3 id="hugo-server">hugo server&lt;/h3>
&lt;p>执行&lt;code>hugo server&lt;/code>之后, 首先构建了你的网站(但是默认并不在本地创建文件, 而是放在内存), 然后启动hugo 自带的 web服务器让我们能看见网站的效果.&lt;/p>
&lt;p>同时, 默认情况下, server 会同步你的本地更改, 然后实时的reload你的页面. 这样你就能同时看到修改的效果.&lt;/p>
&lt;p>hugo server 的常用flag:&lt;/p>
&lt;pre tabindex="0">&lt;code>-D 包含标记为草稿的post. 默认不构建草稿.
--theme strings 使用[strings]主题进行构建
&lt;/code>&lt;/pre>&lt;h3 id="hugo-flags">hugo [flags]&lt;/h3>
&lt;p>&lt;code>hugo&lt;/code> 自身就是一个命令, 用于build website, 放到 &lt;code>public/&lt;/code>目录下.&lt;/p>
&lt;p>常用 Flag(&lt;a href="https://gohugo.io/getting-started/usage/#test-installation:~:text=The%20output%20you%20see%20in%20your%20console%20should%20be%20similar%20to%20the%20following%3A">All supported flags&lt;/a>):&lt;/p>
&lt;pre tabindex="0">&lt;code>--gc 在build后会清除一些cache文件. 与 resource/有关
--minify minify any supported output format (HTML, XML etc.)
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>&lt;code>hugo&lt;/code> 命令不会删除之前的文件. 而是仅新增改动. 所以每次build时需要你手动删除 &lt;code>public/&lt;/code> 目录.&lt;/p>
&lt;/blockquote>
&lt;h2 id="hugo-内容管理">Hugo 内容管理&lt;/h2>
&lt;p>hugo build 后的website页面的布局和你源文件的布局相同, 所有源文件都放置在 &lt;code>content/&lt;/code> 目录下.&lt;/p>
&lt;pre tabindex="0">&lt;code>└── content
├── _index.md // &amp;lt;- https://example.com
|
├── about
| └── index.md // &amp;lt;- https://example.com/about/
├── posts
| ├── _index.md // https://example.com/posts/
| ├── firstpost.md // &amp;lt;- https://example.com/posts/firstpost/
| ├── happy
| | └── ness.md // &amp;lt;- https://example.com/posts/happy/ness/
| └── secondpost.md // &amp;lt;- https://example.com/posts/secondpost/
└── quote
├── first.md // &amp;lt;- https://example.com/quote/first/
└── second.md // &amp;lt;- https://example.com/quote/second/
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>hugo 将content/ 下的那级目录(例如 content/posts)特殊看待, 称为 &lt;em>section&lt;/em>.&lt;/p>
&lt;/blockquote>
&lt;h3 id="页面资源page-resources">页面资源(Page Resources)&lt;/h3>
&lt;p>页面资源指每个页面&lt;strong>私有的&lt;/strong>图片, 文档等静态资源. 与&lt;code>static/&lt;/code> 中全局的资源不同.&lt;/p>
&lt;p>页面资源放在&lt;code>content/&lt;/code>下的任意位置, 但不是所有页面都能访问. page bundles 中的&lt;code>index.md&lt;/code> or &lt;code>_index.md&lt;/code> 能够访问该 bundles 下的资源.&lt;/p>
&lt;pre tabindex="0">&lt;code>content
└── post
├── first-post
│ ├── images
│ │ ├── a.jpg
│ │ ├── b.jpg
│ │ └── c.jpg
│ ├── index.md (root of page bundle, 能够访问first-post/下的所有资源)
│ ├── notice.md 不能访问任何资源, 但其自身作为一个资源可被index.md访问
│ ├── office.mp3
│ ├── pocket.mp4
│ ├── rating.pdf
│ └── safety.txt
└── second-post
└── index.md (root of page bundle, 但不能访问first-post/下的资源)
&lt;/code>&lt;/pre>&lt;h3 id="内容分类taxonomy">内容分类(Taxonomy)&lt;/h3>
&lt;p>Taxonomy: How to group the content together. Two default taxonomies are &lt;em>tags&lt;/em> and &lt;em>categories&lt;/em>.&lt;/p>
&lt;h3 id="代码高亮syntax-highlighter">代码高亮(Syntax Highlighter)&lt;/h3>
&lt;p>&lt;a href="https://gohugo.io/getting-started/configuration-markup/#configure-markup:~:text=anchorize%20template%20func.-,Highlight,-This%20is%20the">代码高亮的配置&lt;/a>(in &lt;code>config.toml&lt;/code>):&lt;/p>
&lt;h3 id="页面分类">页面分类&lt;/h3>
&lt;p>从布局上来看, 页面可以分为两类: List page 和 single page.&lt;/p>
&lt;p>显而易见, list page比较特殊, 它负责列出当前目录下的所有post. 所以一个目录地址必然是一个list page.&lt;/p>
&lt;p>在下面的例子中, &lt;code>https://example.com&lt;/code> , &lt;code>https://example.com/posts/happy/&lt;/code> 都可以叫做 list page.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>https://example.com/posts/happy/&lt;/code> 是list page, 目录下的&lt;code>_index.md&lt;/code> 不是必须的, hugo 会默认仅显示所有post的title. &lt;a href="https://gohugo.io/templates/lists/#list-pages-without-_indexmd">详见&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>https://example.com/about/&lt;/code> 不是list page, 因为其目录下有&lt;code>index.md&lt;/code>, 强制表明这是一个 single page. &lt;a href="https://gohugo.io/content-management/page-bundles/#:~:text=CONTENT%20MANAGEMENT-,Page%20Bundles,-Content%20organization%20using">详见&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>└── content
├── _index.md // &amp;lt;- https://example.com
|
├── about
| └── index.md // &amp;lt;- https://example.com/about/
└── posts
├── _index.md // https://example.com/posts/
├── firstpost.md // &amp;lt;- https://example.com/posts/firstpost/
├── happy
| └── ness.md // &amp;lt;- https://example.com/posts/happy/ness/
└── secondpost.md // &amp;lt;- https://example.com/posts/secondpost/
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>Homepage 和 section page 都属于特殊的 list page.&lt;/p>
&lt;ul>
&lt;li>homepage 特指 &lt;code>content/_index.md&lt;/code>&lt;/li>
&lt;li>section page 特指 &lt;code>content/[section]/_index.md&lt;/code>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="shortcodes">shortcodes&lt;/h3>
&lt;p>shortcode 可以理解为 hugo 为了封装了一些代码块, 通过 shortcode 来调用.&lt;/p>
&lt;h2 id="模板template">模板(Template)&lt;/h2>
&lt;p>模板是hugo的一个高级用法, 用来定义你网站的style. 模板不等同与主题(themes), 可以理解为主题是一套模板的集合. 我们可以在使用模板的同时添加DIY的 style. 😎 Hugo 会有优先级的判断.&lt;/p>
&lt;p>不同的页面类型需要定义不同的模板. List page 的模板称为 List template, single page 的模板称为 single template. 同理还有 homepage template, section template.&lt;/p>
&lt;p>存储模板的目录为&lt;code>layout/&lt;/code>, 上面介绍hugo的目录结构时已经说过. 如果你使用了一个 theme, 那么&lt;code>themes/[your-theme]/layout/&lt;/code>就是该theme的模板.&lt;/p>
&lt;h3 id="homepage-模板">homepage 模板&lt;/h3>
&lt;h3 id="base-模板">Base 模板&lt;/h3>
&lt;p>对应&lt;code>layouts/_default/baseof.html&lt;/code>&lt;/p>
&lt;p>base 模板是整个website的核心. 所有的模板包括 list template, single template, homepage template&amp;hellip; 都是独立的, base template 将其他的模板联系到一起.&lt;/p>
&lt;h3 id="partial-模板">partial 模板&lt;/h3>
&lt;p>包含网站的许多元素, 增加模块化. 我可以为网站的 header 或者 footer 写一个模板(html), 这些HTML可以嵌入其他的模板.&lt;/p>
&lt;h3 id="模板优先级">模板优先级&lt;/h3>
&lt;p>既然同一种页面的模板可以定义在多个位置, 如果他们同时存在时, 优先级规则必然存在. 常见的情况比如我们使用了某个模板, 然而, 我们对模板中的一些布局不满意, 直接修改模板中的文件显然不是一个好方法, 那么该怎么做呢?&lt;/p>
&lt;p>&lt;strong>一般来说&lt;/strong>, 如果你只想重写theme中的某个模板, 例如section template. 那么你只需要新建 &lt;code>layout/_default/section.html&lt;/code> 即可, hugo 构建你的网站时, 如果检测到本地和theme的&lt;code>layout/_default&lt;/code>下都有 &lt;code>section.html&lt;/code>, 它会使用我们自己定义的那个.&lt;/p>
&lt;blockquote>
&lt;p>完整的, 多级的优先级规则: &lt;a href="https://gohugo.io/templates/lookup-order/">Hugo&amp;rsquo;s Lookup Order | Hugo (gohugo.io)&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="变量variables">变量(Variables)&lt;/h2>
&lt;p>❗ Hugo 变量仅设计给模板使用, 即在&lt;code>layouts/&lt;/code>下的html文件.&lt;/p>
&lt;h3 id="page-variables">Page Variables&lt;/h3>
&lt;p>与post相关的变量, 定义在post 的 front matter中.&lt;/p>
&lt;pre tabindex="0">&lt;code>// Define Page variables in front matter of post
----------------
title: &amp;#34;使用 HuGo 搭建个人网站&amp;#34;
description: 学习正确的 Hugo 食用方式, DIY 属于自己的 website~
Myvar: &amp;#34;my value&amp;#34;
----------------
// Use Page Variables
{{.Description}} // Get the description of the post
{{.Params.Myvar}} // Get the value of Myvar, that is, &amp;#34;my value&amp;#34;
&lt;/code>&lt;/pre>&lt;h3 id="site-variables">Site Variables&lt;/h3>
&lt;p>站点层面的变量大部分是网站配置相关.&lt;/p>
&lt;h2 id="函数functions">函数(Functions)&lt;/h2>
&lt;p>函数是hugo为你封装的一些方法你可以直接调用.&lt;/p>
&lt;p>❗ Hugo 函数仅设计给模板使用, 即在&lt;code>layouts/&lt;/code>下的html文件. Same as variables.&lt;/p>
&lt;h2 id="hugo-pipes">Hugo pipes&lt;/h2>
&lt;h1 id="diy-my-own-website">DIY My Own Website&lt;/h1>
&lt;h2 id="支持-emoji">支持 Emoji&lt;/h2>
&lt;p>&lt;a href="https://stackoverflow.com/questions/41047920/adding-emoji-to-a-hugo-page-variable">Adding emoji tutorial&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.webfx.com/tools/emoji-cheat-sheet/">Emoji chart&lt;/a>&lt;/p>
&lt;h2 id="todo-list">TODO List&lt;/h2>
&lt;ol>
&lt;li>深色和浅色模式使用 不同的代码高亮 格式&lt;/li>
&lt;li>Post section page 添加简介&lt;/li>
&lt;li>Single template 调整 Header&amp;rsquo;s margin&lt;/li>
&lt;/ol>
- https://wangloo.github.io/posts/hugo/ - @2019 Notepadium.</description></item></channel></rss>