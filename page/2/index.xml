<?xml-stylesheet href="/rss.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Homepage 🌈 on Soben's Secret Base</title><link>https://wangloo.github.io/</link><description>Recent content in Homepage 🌈 on Soben's Secret Base</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>@2019 Notepadium.</copyright><lastBuildDate>Thu, 15 Sep 2022 15:14:05 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>C语言 'inline' 关键字</title><link>https://wangloo.github.io/posts/c/inline/</link><pubDate>Thu, 24 Nov 2022 01:35:24 +0800</pubDate><guid>https://wangloo.github.io/posts/c/inline/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/c/inline/ -&lt;p>TODO: inline 的发展历程: &lt;a href="https://gustedt.wordpress.com/2010/11/29/myth-and-reality-about-inline-in-c99/">Myth and reality about inline in C99 – Jens Gustedt&amp;rsquo;s Blog (wordpress.com)&lt;/a>&lt;/p>
&lt;h2 id="gnu89">GNU89:&lt;/h2>
&lt;p>函数的&lt;strong>实现&lt;/strong>之前添加不同的关键字:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>inline&lt;/code>: 表明这个函数可能被优化. 如果没有被优化, 编译器就会视为一个常规函数的定义.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>extern inline&lt;/code>: 表明这个函数可能被优化. 如果没有被优化, 编译器就将这个函数的定义&lt;strong>转换为该函数的声明&lt;/strong>, 即 &lt;code>extern inline func();&lt;/code> 因此当此函数被调用时, 可以调用一个外部的函数来替代. 如果没有函数调用它, 那么也可以没有外部的替代函数实现.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>static inline&lt;/code>: 表明这个函数可能被优化. 如果没有被优化, 编译器就会视为一个&lt;strong>常规静态函数&lt;/strong>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="c99">C99:&lt;/h2>
&lt;p>函数的实现之前添加不同的关键字:&lt;/p>
&lt;ul>
&lt;li>&lt;code>inline&lt;/code>: 等效于gnu89中的&lt;code>extern inline&lt;/code>&lt;/li>
&lt;li>&lt;code>extern inline&lt;/code>: 等效于gnu89中的&lt;code>inline&lt;/code>&lt;/li>
&lt;li>&lt;code>static inline&lt;/code>: 与gnu89相同含义.&lt;/li>
&lt;/ul>
&lt;h2 id="c">C++:&lt;/h2>
&lt;p>只有&lt;code>inline&lt;/code>一个关键字, 如果不能优化就定义为普通函数&lt;/p>
&lt;blockquote>
&lt;p>Ref:&lt;/p>
&lt;p>&lt;a href="https://stackoverflow.com/questions/216510/what-does-extern-inline-do/216546#216546">c++ - What does extern inline do? - Stack Overflow&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://gustedt.wordpress.com/2010/11/29/myth-and-reality-about-inline-in-c99/">Myth and reality about inline in C99 – Jens Gustedt&amp;rsquo;s Blog (wordpress.com)&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>&lt;a href="https://github.com/wangloo/inline-c99-gnu89-demo">C demo&lt;/a> 关于以上的各种情况&lt;/p>
&lt;/blockquote>
- https://wangloo.github.io/posts/c/inline/ - @2019 Notepadium.</description></item><item><title>C语言工具宏</title><link>https://wangloo.github.io/posts/c/c-macros/</link><pubDate>Thu, 24 Nov 2022 01:35:24 +0800</pubDate><guid>https://wangloo.github.io/posts/c/c-macros/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/c/c-macros/ -&lt;h3 id="计算数组元素的个数">计算数组元素的个数&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define nelem(array) sizeof(array)/sizeof(array[0])
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>- https://wangloo.github.io/posts/c/c-macros/ - @2019 Notepadium.</description></item><item><title>x86/ARMv8 函数调用约定</title><link>https://wangloo.github.io/posts/os/function-call-conventions/</link><pubDate>Mon, 21 Nov 2022 10:30:35 +0800</pubDate><guid>https://wangloo.github.io/posts/os/function-call-conventions/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/os/function-call-conventions/ -&lt;p>符合调用约定使得调用函数能够正常获取参数, callee结束之后能够回到原来位置继续执行.&lt;/p>
&lt;h2 id="x86-调用约定">X86 调用约定&lt;/h2>
&lt;h3 id="函数调用">函数调用&lt;/h3>
&lt;p>x86架构中, 函数调用以一条&lt;code>call&lt;/code>指令为分界.&lt;/p>
&lt;p>在&lt;code>call&lt;/code>指令执行之前, 所有的参数必须都躺在栈中, 参数入栈的规则是: &lt;strong>第一个参数最后入栈&lt;/strong>.&lt;/p>
&lt;p>另外, 执行&lt;code>call&lt;/code>指令之前, 必须确保栈指针&lt;code>esp&lt;/code>是16-byte对齐. 这项工作是&lt;strong>编译器&lt;/strong>完成的, 如果它判断参数入栈之后的&lt;code>esp&lt;/code> 不满足对齐条件, 则会手动调整&lt;code>esp&lt;/code>使之对齐. 实现方式见下面例子.&lt;/p>
&lt;p>&lt;code>call&lt;/code> 指令的语义是:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">push&lt;/span> pc+&lt;span style="color:#bd93f9">1&lt;/span> &lt;span style="color:#6272a4">;push next insttuction
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>mov pc, func &lt;span style="color:#6272a4">;set pc = new function
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>call&lt;/code> 指令之后的下一条指令就是callee的内容了, 至此就算是进入新函数的地盘.&lt;/p>
&lt;p>但是在执行新的任务之前, callee还需要完成&lt;strong>栈的转换&lt;/strong>, 因为此时使用的栈还是caller的.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">push&lt;/span> ebp &lt;span style="color:#6272a4">;preserve location of caller&amp;#39;s stack
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>mov ebp, esp &lt;span style="color:#6272a4">;new ebp is old esp
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>此时&lt;code>esp&lt;/code>也就是栈指针等于&lt;code>ebp&lt;/code>, 这是callee栈的初始条件&lt;/strong>. 万事俱备, 可以开始执行callee的实际任务了.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>ebp&lt;/code>在整个函数执行过程中是固定的, 好处是: 能够&lt;strong>快速的或者函数参数, 返回地址&lt;/strong>.&lt;/p>
&lt;/blockquote>
&lt;h3 id="函数返回">函数返回&lt;/h3>
&lt;p>callee执行完毕后, 需要返回到caller继续执行. 刚才说过, callee的返回地址在栈中, 所以我们要做的是找到返回地址所在的位置, 然后使&lt;code>pc = 返回地址&lt;/code>. 当然, 还有另一个重要的任务就是&lt;strong>恢复caller的栈&lt;/strong>.&lt;/p>
&lt;p>上述任务的实现使用两条汇编语句就可完成: &lt;code>leave&lt;/code> 和 &lt;code>ret&lt;/code>.&lt;/p>
&lt;p>&lt;code>leave&lt;/code> 负责搞定栈, 其语义为:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">mov&lt;/span> esp, ebp &lt;span style="color:#6272a4">;回滚栈空间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>pop ebp &lt;span style="color:#6272a4">;恢复caller的ebp
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>ret&lt;/code> 负责搞定&lt;code>pc&lt;/code>, 其语义为:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">pop&lt;/span> ebx &lt;span style="color:#6272a4">;取出返回地址
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>mov pc, ebx &lt;span style="color:#6272a4">;jmp to 返回地址
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>ret&lt;/code> 之后, 就算是返回caller的地盘了. 还有一件小事别忘了做: &lt;strong>用于保存参数的栈空间还没有回收&lt;/strong>, 回到caller之后需要先将&lt;code>esp&lt;/code>的位置进行调整.&lt;/p>
&lt;h3 id="example-函数的调用和返回">Example: 函数的调用和返回&lt;/h3>
&lt;p>一个关于函数调用和返回实现的完整例子.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">caller&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Func(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">Func&lt;/span>(&lt;span style="color:#8be9fd">int&lt;/span> a, &lt;span style="color:#8be9fd">int&lt;/span> b, &lt;span style="color:#8be9fd">int&lt;/span> c)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">/* Do something */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>(以下汇编是&lt;strong>AT&amp;amp;T&lt;/strong>格式的, 请见谅).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">; Caller
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#50fa7b">sub&lt;/span> $0x4,&lt;span style="color:#8be9fd;font-style:italic">%esp&lt;/span> &lt;span style="color:#6272a4">;make 16-bytes align before call. 0x4 是由编译器计算的
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>push $0x3 &lt;span style="color:#6272a4">;push 参数, 顺序是从右到左
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>push $0x2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">push&lt;/span> $0x1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">call&lt;/span> &lt;span style="color:#bd93f9">f01000ad&lt;/span> &amp;lt;Func&amp;gt; &lt;span style="color:#6272a4">;Func()&amp;#39;addr is f01000ad
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">;===========&amp;gt;&amp;gt; Turn to callee
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">;Func()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> push &lt;span style="color:#8be9fd;font-style:italic">%ebp&lt;/span> &lt;span style="color:#6272a4">;preserve old ebp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> mov &lt;span style="color:#8be9fd;font-style:italic">%esp&lt;/span>,&lt;span style="color:#8be9fd;font-style:italic">%ebp&lt;/span> &lt;span style="color:#6272a4">;set new ebp, ebp=esp now
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> /* Do something */
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">leave&lt;/span> &lt;span style="color:#6272a4">;restore stack
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> ret &lt;span style="color:#6272a4">;restore instruction point
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">;&amp;lt;&amp;lt;=========== Back to caller
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>add $0x10,&lt;span style="color:#8be9fd;font-style:italic">%esp&lt;/span> &lt;span style="color:#6272a4">;recycle stack(12 bytes parameters plus 4 bytes alignment)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="armv8-调用约定">Armv8 调用约定&lt;/h2>
&lt;p>大体的思想与x86相似, 只是细节有些许不同&lt;/p>
&lt;h3 id="函数调用-1">函数调用&lt;/h3>
&lt;p>ARMv8架构中, 函数调用以一条&lt;code>bl&lt;/code>指令为分界.&lt;/p>
&lt;p>执行&lt;code>bl&lt;/code>指令之前, 需要将参数准备好. 注意, &lt;strong>ARMv8中, 少于8个参数的函数在传参时, 参数是放在x0-x7中&lt;/strong>, 最左边的参数先使用x0, 以此类推. 参数超过8个的情况下才使用栈, 这与x86的方式不同.&lt;/p>
&lt;p>&lt;code>bl&lt;/code>指令保存返回地址, 并跳转到callee执行, 其语义是:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">mov&lt;/span> lr, pc+&lt;span style="color:#bd93f9">1&lt;/span> &lt;span style="color:#6272a4">;preserve return address
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#6272a4">;lr specially used for preservering return addr
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>mov pc, new_func &lt;span style="color:#6272a4">;set pc = new function
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>与x86相同, 跳转到callee之后必须先进行栈的设置, &lt;strong>Arm与x86不同的是它不需要管理栈底寄存器&lt;/strong>. 因为参数大部分是通过寄存器来传递, 返回地址也是存储在&lt;code>lr(x30)&lt;/code>寄存器中, 没必要为了极少的情况来做优化.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">sub&lt;/span> sp, sp, &lt;span style="color:#6272a4">#enough-space
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="函数返回-1">函数返回&lt;/h3>
&lt;p>要完成两件事: (1) 恢复栈 (2)返回原来位置执行&lt;/p>
&lt;p>先说(2), 由于&lt;code>lr&lt;/code>寄存器始终保存返回地址, 直接 &lt;code>mov sp, lr&lt;/code> 就能返回caller继续执行. &lt;strong>这也就是&lt;code>ret&lt;/code>指令的语义&lt;/strong>.&lt;/p>
&lt;p>(1)恢复栈的这件事同x86一样由callee完成,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">add&lt;/span> sp, sp, &lt;span style="color:#6272a4">#enough-space
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>x86 call 指令执行前需要esp对齐到 16-byte: &lt;a href="https://stackoverflow.com/questions/41971481/what-are-the-following-instructions-after-this-call-assembly">x86 - What are the following instructions after this call (assembly) - Stack Overflow&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/290689333">x86栈帧原理 - 知乎 (zhihu.com)&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>能够正确达到函数调用和返回的实现方式有很多, &lt;strong>不是仅有这一种方式&lt;/strong>, 约定仅仅是一个约定, 大家都这样去做降低了开发的难度.&lt;/p>
- https://wangloo.github.io/posts/os/function-call-conventions/ - @2019 Notepadium.</description></item><item><title>二级指针操作链表</title><link>https://wangloo.github.io/posts/c/pointers-pointers-list/</link><pubDate>Sun, 20 Nov 2022 23:40:30 +0800</pubDate><guid>https://wangloo.github.io/posts/c/pointers-pointers-list/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/c/pointers-pointers-list/ -&lt;p>问题源于我在知乎刷到的一个回答: &lt;a href="https://www.zhihu.com/question/477832027/answer/2044206446">能分享你C指针用得最灵活（飘）的一次吗?&lt;/a>&lt;/p>
&lt;p>文中提到了Linus关于&lt;strong>无头节点单项链表的删除操作&lt;/strong>给出的一种新的思路, 我觉得对理解指针非常有帮助, 所以在这里详细描述一下这件事.&lt;/p>
&lt;p>从我学习数据结构起, 对不含头节点的单向链表的删除操作, 做法常是: 借用&lt;strong>pre指针&lt;/strong>搜索. 这种情况下避免不了对于链表中第一个节点的特判(第一个节点没有pre).&lt;/p>
&lt;p>Linus提到了一种借助&lt;strong>二级指针避免该分支&lt;/strong>的方法.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">remove_if&lt;/span>(node &lt;span style="color:#ff79c6">**&lt;/span> head, remove_fn rm)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> (node&lt;span style="color:#ff79c6">**&lt;/span> curr &lt;span style="color:#ff79c6">=&lt;/span> head; &lt;span style="color:#ff79c6">*&lt;/span>curr; )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node &lt;span style="color:#ff79c6">*&lt;/span> entry &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">*&lt;/span>curr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (rm(entry))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">*&lt;/span>curr &lt;span style="color:#ff79c6">=&lt;/span> entry&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> free(entry);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">&amp;amp;&lt;/span>entry&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>指针的内容就是地址, &lt;code>int *p = a&lt;/code> 也就意味着变量&lt;code>p&lt;/code> 中保存着变量&lt;code>a&lt;/code>的地址. 所以参数&lt;code>head&lt;/code>在内存中的含义为:&lt;/p>
&lt;p>&lt;img src="./mem.png" alt="list的内存布局">&lt;/p>
&lt;p>假如要删除node2, 那么改变&lt;code>*curr&lt;/code>实际上就是&lt;strong>改了node1的&lt;code>next&lt;/code>成员&lt;/strong>.&lt;/p>
- https://wangloo.github.io/posts/c/pointers-pointers-list/ - @2019 Notepadium.</description></item><item><title>大小端问题</title><link>https://wangloo.github.io/posts/os/big-little-endian/</link><pubDate>Thu, 17 Nov 2022 10:30:35 +0800</pubDate><guid>https://wangloo.github.io/posts/os/big-little-endian/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/os/big-little-endian/ -&lt;hr>
&lt;h2 id="大小端问题的由来">大小端问题的由来&lt;/h2>
&lt;p>为什么计算机世界需要区分大小端? &lt;strong>内存里存取的单位是字节&lt;/strong>, 如果所有的数据类型长度都是一个字节, 那就完全不需要大小端了, 每个变量都仅占据单独一个字节.&lt;/p>
&lt;p>例如, 三个变量 &lt;code>a=10, b=20, c=30&lt;/code>, 在内存中的布局可能就是:&lt;/p>
&lt;pre tabindex="0">&lt;code> ┌────────────┐
│ │
│ 10 │ a
├────────────┤
│ │
│ 20 │ b
├────────────┤
│ │
│ 30 │ c
├────────────┤
│ │
│ │
│ │
│ │
│ │
└────────────┘
&lt;/code>&lt;/pre>&lt;p>但是我们最常使用的数据类型肯定有超过一个字节的, &lt;code>int&lt;/code>类型在64位的系统中就占&lt;strong>4个字节&lt;/strong>. 例如变量&lt;code>a=0xaabbccdd&lt;/code>&lt;/p>
&lt;p>一个变量的大小一旦超过4个字节, &lt;strong>内存的存取又是以字节位单位的&lt;/strong>, 那么要把它塞到内存里就必然会产生两种不同存放方式: &lt;strong>先放&lt;code>0xaa&lt;/code>还是先放&lt;code>0xdd&lt;/code>&lt;/strong>&lt;/p>
&lt;p>首先, &lt;code>0xdd&lt;/code>是变量a的低8位, &lt;code>0xaa&lt;/code>是最高8位, 这是确定的.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果先放&lt;code>0xaa&lt;/code>, 即低地址放高位, 就叫做&lt;em>大端&lt;/em>, 如左图;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果先放&lt;code>0xdd&lt;/code>, 即低地址放低位, 就叫&lt;em>小端&lt;/em>, 如右图.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>
start addr of `a` start addr of `a`
┌────────────┐ ┌────────────┐
│ │ │ │
│ aa │ │ dd │
├────────────┤ ├────────────┤
│ │ │ │
│ bb │ │ cc │
├────────────┤ ├────────────┤
│ │ │ │
│ cc │ │ bb │
├────────────┤ ├────────────┤
│ │ │ │
│ dd │ │ aa │
├────────────┤ ├────────────┤
│ │ │ │
│ │ │ │
└────────────┘ └────────────┘
&lt;/code>&lt;/pre>&lt;h2 id="什么情况">什么情况?&lt;/h2>
&lt;p>看下面的代码, 猜测输出的结果&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">unsigned&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> i &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">0x00646c72&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printf(&lt;span style="color:#f1fa8c">&amp;#34;Hello Wo%s&amp;#34;&lt;/span>, &lt;span style="color:#ff79c6">&amp;amp;&lt;/span>i);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>%s&lt;/code> 会按字节一直打印内存中的字符, 直到遇到&lt;code>\0&lt;/code>. 首先打印的字符便是变量&lt;code>i&lt;/code>的地址处的内容.&lt;/p>
&lt;p>如果是小端存储方式, 变量&lt;code>i&lt;/code>的地址处的一个字节值是0x72, 即字符&lt;code>r&lt;/code>. 以此类推, 所以如果CPU的字节序是小端形式, 那么&lt;code>printf&lt;/code>的结果是: Hello world&lt;/p>
&lt;h2 id="大小端形式的优缺点">大小端形式的优缺点&lt;/h2>
&lt;p>小端的优势:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>以不同的长度读取变量非常方便, 不用计算地址. 例如&lt;code>u64 a=0x1234&lt;/code>, 当&lt;code>(u16)a&lt;/code>时, CPU不需要重新计算读取的起始位置, 永远都是变量a的起始地址.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Easily to do mathematical computations “because of the 1:1 relationship between address offset and byte number (offset 0 is byte 0), multiple precision math routines are correspondingly easy to write.”&lt;/p>
&lt;/li>
&lt;/ol>
- https://wangloo.github.io/posts/os/big-little-endian/ - @2019 Notepadium.</description></item><item><title>操作系统——上下文切换</title><link>https://wangloo.github.io/posts/os/context/</link><pubDate>Mon, 14 Nov 2022 22:13:06 +0800</pubDate><guid>https://wangloo.github.io/posts/os/context/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/os/context/ -&lt;p>本文基于&lt;strong>AArch64&lt;/strong>执行环境, 介绍现代操作系统中上下文切换的相关内容.&lt;/p>
&lt;h2 id="什么是上下文">什么是上下文？&lt;/h2>
&lt;p>上下文又称“现场”,&lt;/p>
&lt;h2 id="为什么需要上下文切换">为什么需要上下文切换?&lt;/h2>
&lt;p>(TODO: 为什么说线程是调度的单位?)&lt;/p>
&lt;p>现代操作系统中同时存在着成千上百个线程, 但是一个CPU同一时刻只能运行一个线程, 他们是轮流的占用CPU, 也叫并发执行. (TODO: 如何查看线程切换的间隔?) 线程高频率的切换, 操作系统是如何保证切换到下一个执行的线程时, 它能够继续上次的工作呢?&lt;/p>
&lt;h3 id="什么是上下文-1">什么是上下文?&lt;/h3>
&lt;p>我们正在看一本书的时候如果被其他的事情打断, 返回时为了能够从上次被打断的位置继续读, 就要在被打断的时候记下来当前是读到了哪个第几页的第几行.&lt;/p>
&lt;p>操作系统对待线程也是如此, 需要保存的用于恢复线程执行的信息就称为线程的上下文.&lt;/p>
&lt;p>那么对于线程来说需要记下的内容有什么呢? 寄存器和栈即可. 拿AArch64架构来距离, 线程的上下文就是:&lt;/p>
&lt;ol>
&lt;li>通用寄存器&lt;code>x0-x29&lt;/code>: 函数调用的参数, 某些计算过程的中间值, 都要用到这些寄存器. &lt;strong>线程的执行流可能在任何时候被打断&lt;/strong>, 当然这些内容也不能丢.&lt;/li>
&lt;li>通用寄存器&lt;code>lr(x30)&lt;/code>: &lt;code>lr&lt;/code> 保存着返回地址, 即当前函数结束之后该返回到哪执行.&lt;/li>
&lt;li>栈顶指针 &lt;code>sp&lt;/code>: 栈的重要性无需多言. 但是需要说明的是我们保存栈的方式&lt;strong>并非将栈中的所有内容保存, 而是保存栈的位置&lt;/strong>即可. 因为操作系统有别的机制(TODO), 能够保证即便线程不在执行, 属于该线程的栈也不会被破坏.&lt;/li>
&lt;li>程序计数器 &lt;code>pc&lt;/code>: 被打断的线程如果再次执行, 从哪里执行呢? 显然是被打断指令的下一条(或者重新执行当前). 这个指令的地址当然也需要被保存好.&lt;/li>
&lt;li>PSTATE: 想一下, 有了以上的内容就能够保证线程完整的恢复之前的环境吗? 其他的例如中断是开还是关, 有哪些标志位(NZCV)被设置了. 这些信息在AArch64中是保存在PSTATE的各个字段中.&lt;/li>
&lt;/ol>
&lt;p>如果我们能够有一个适当的逻辑, 在线程切换出去的时候将上下文保存起来, 然后恢复新线程的上下文, 是不是线程切换这件事就能做到了. 如何组织这个保存和恢复的过程在下面会介绍到.&lt;/p>
&lt;h2 id="linux-如何处理上下文切换">Linux 如何处理上下文切换&lt;/h2>
&lt;h2 id="另一种处理上下文切换的思路">另一种处理上下文切换的思路&lt;/h2>
&lt;h2 id="协程的上下文">协程的上下文&lt;/h2>
&lt;p>协程是用户级别的线程,&lt;/p>
&lt;ul>
&lt;li>协程之间的切换不进入内核&lt;/li>
&lt;li>切换协程只能是某个协程&lt;strong>主动放弃控制权&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>我们在这里讨论一下协程切换时需要保存的上下文是否与线程有所不同.&lt;/p>
&lt;p>首先, PC一定属于, 这个毋庸置疑. 其次是栈顶指针sp, &lt;strong>每个协程都有单独的栈&lt;/strong>, 如果不保存栈的位置, 那么协程内部定义局部变量就没法访问了(局部变量的访问指令都是以sp为base的偏移来做的).&lt;/p>
&lt;p>另外, 关于通用寄存器, 由于协程的切换需要主动调用某个函数(通常叫做&lt;code>yield()&lt;/code>), 在函数的最后将PC设置为新协程的上下文PC. 保存当前协程上下文的操作也在这个函数中, 而其参数我们并不关心, 即&lt;code>x0&lt;/code>-&lt;code>x7&lt;/code>没必要保存. 同样的, &lt;strong>caller-saved寄存器也是没必要保存的&lt;/strong>, 因为这些寄存器作为函数调用使用的临时变量, 当再次返回该协程时, PC=yield()返回地址, caller如果关心这些寄存器应当自己执行保存和恢复. 但是&lt;strong>callee-saved寄存器必须要保存到上下文中&lt;/strong>, 因为在yield()中, 我们如果修改了callee-saved寄存器, 就需要在返回时(也就是再次调度到该协程时) 恢复, 这是callee该做的, 也就是上下文中应该有的唯一通用寄存器组.&lt;/p>
- https://wangloo.github.io/posts/os/context/ - @2019 Notepadium.</description></item><item><title>基于ARM64实现setjmp/longjmp</title><link>https://wangloo.github.io/posts/c/setjmp_and_longjmp/</link><pubDate>Tue, 01 Nov 2022 23:38:54 +0800</pubDate><guid>https://wangloo.github.io/posts/c/setjmp_and_longjmp/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/c/setjmp_and_longjmp/ -&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>setjmp() and longjmp() 是一对组合使用的函数, 可以实现&lt;strong>全局的goto&lt;/strong>.&lt;/p>
&lt;p>setjmp() 构造一个运行环境, 调用longjmp() 则将执行流切换到该环境.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">/* setjmp() 保存当前的运行环境(上下文)到 env 参数中 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#50fa7b">setjmp&lt;/span>(jmp_buf env);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">/* longjmp() 将控制流切换到 env 指定的运行环境 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">longjmp&lt;/span>(jmp_buf env, &lt;span style="color:#8be9fd">int&lt;/span> val);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="使用方法">使用方法&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#include&lt;/span> &lt;span style="color:#ff79c6">&amp;lt;setjmp.h&amp;gt;&lt;/span>&lt;span style="color:#ff79c6">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#include&lt;/span> &lt;span style="color:#ff79c6">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#ff79c6">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jmp_buf e;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">foo&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> longjmp(e, &lt;span style="color:#bd93f9">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>(&lt;span style="color:#8be9fd">void&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> ret;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">/* After calling longjmp(), the execution flow back to setjmp(),
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> and setjmp() will return not 0. */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ret &lt;span style="color:#ff79c6">=&lt;/span> setjmp(e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (ret &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#f1fa8c">&amp;#34;Return from setjmp&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> foo();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#f1fa8c">&amp;#34;Return from longjmp&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="基于-aarch64-的实现">基于 AArch64 的实现&lt;/h2>
&lt;p>需要保存的上下文包括&lt;/p>
&lt;ul>
&lt;li>&lt;strong>callee-saved 通用寄存器&lt;/strong>, 因为可能第一次调用 &lt;code>setjmp()&lt;/code> 之后的执行流修改了这些寄存器, 从第二次回到 &lt;code>setjmp()&lt;/code> 的角度来看, 就是执行setjmp() 中破坏的. caller-saved 寄存器则不必, 因为本来即便看作是 &lt;code>setjmp()&lt;/code> 破坏的, 也是正常的.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">.macro&lt;/span> func _name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">.global&lt;/span> \_name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">.type&lt;/span> \_name, %function
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>\&lt;span style="color:#8be9fd;font-style:italic">_name:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">.endm&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">.macro&lt;/span> endfunc _name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">.size&lt;/span> \_name, .-\_name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">.endm&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/**
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * &lt;span style="color:#50fa7b">setjmp&lt;/span> (jmp_buf env)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> *
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * &lt;span style="color:#50fa7b">See&lt;/span> also:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * &lt;span style="color:#50fa7b">longjmp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> *
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * @&lt;span style="color:#50fa7b">return&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> - if returns from direct call,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * &lt;span style="color:#50fa7b">nonzero&lt;/span> - if returns after longjmp.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> */
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">func&lt;/span> setjmp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">stp&lt;/span> x19, x20, [x0], &lt;span style="color:#6272a4">#16
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> stp x21, x22, [x0], &lt;span style="color:#6272a4">#16
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> stp x23, x24, [x0], &lt;span style="color:#6272a4">#16
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> stp x25, x26, [x0], &lt;span style="color:#6272a4">#16
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> stp x27, x28, [x0], &lt;span style="color:#6272a4">#16
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> stp x29, x18, [x0], &lt;span style="color:#6272a4">#16
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> mov x9, sp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">stp&lt;/span> lr, x9, [x0], &lt;span style="color:#6272a4">#16
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> mov x0, &lt;span style="color:#6272a4">#0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">endfunc&lt;/span> setjmp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/**
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * &lt;span style="color:#50fa7b">longjmp&lt;/span> (jmp_buf env, int val)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> *
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * &lt;span style="color:#8be9fd;font-style:italic">Note:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * &lt;span style="color:#50fa7b">if&lt;/span> val is not &lt;span style="color:#bd93f9">0&lt;/span>, then it would be returned from setjmp,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * &lt;span style="color:#50fa7b">otherwise&lt;/span> - &lt;span style="color:#bd93f9">1&lt;/span> would be returned.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> *
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * &lt;span style="color:#50fa7b">See&lt;/span> also:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * &lt;span style="color:#50fa7b">setjmp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> */
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">func&lt;/span> longjmp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">ldp&lt;/span> x19, x20, [x0], &lt;span style="color:#6272a4">#16
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> ldp x21, x22, [x0], &lt;span style="color:#6272a4">#16
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> ldp x23, x24, [x0], &lt;span style="color:#6272a4">#16
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> ldp x25, x26, [x0], &lt;span style="color:#6272a4">#16
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> ldp x27, x28, [x0], &lt;span style="color:#6272a4">#16
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> ldp x29, x18, [x0], &lt;span style="color:#6272a4">#16
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> ldp lr, x9, [x0], &lt;span style="color:#6272a4">#16
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> mov sp, x9
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">mov&lt;/span> x0, x1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">cbnz&lt;/span> x0, &lt;span style="color:#bd93f9">1&lt;/span>f
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">add&lt;/span> x0, x0, &lt;span style="color:#6272a4">#1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">ret&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">endfunc&lt;/span> longjmp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="setjmp-实现-try-catch">setjmp() 实现 try-catch&lt;/h2>
- https://wangloo.github.io/posts/c/setjmp_and_longjmp/ - @2019 Notepadium.</description></item><item><title>Armv8 Kernel Monitor</title><link>https://wangloo.github.io/posts/os/monitor/</link><pubDate>Fri, 28 Oct 2022 22:56:19 +0800</pubDate><guid>https://wangloo.github.io/posts/os/monitor/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/os/monitor/ -&lt;p> &lt;/p>
&lt;h2 id="kernel-monitor-是什么">Kernel Monitor 是什么&lt;/h2>
&lt;p>Kernel Monitor 是一个适配我们微内核操作系统的 Kernel 调试和监控系统. 它能实现内核的动态调试和监控. 同时, 它还接管内核的同步异常和系统错误, 使开发者能够了解发生异常时系统的状态.&lt;/p>
&lt;p>Kernel Monitor 具有一定的可扩展性, 例如通过统计内核中存储的 TCB 来实时监控系统中所有线程的状态. 可根据开发者的需求添加统计的对象, 如 Endpoint, Capability等.&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="kernel-monitor-总体设计">Kernel Monitor 总体设计&lt;/h2>
&lt;p>Kernel Monitor 系统包含 Clinet 和 Server 两个部分. 简单来说, Client 负责处理用户输入, 并将输入进行解析, 封装为 一系列基础命令. 发送给 Server. Server 负责执行这些 基础的命令, 如设置断点, 查看某个地址的值等.&lt;/p>
&lt;p>整个系统有&lt;em>两种架构&lt;/em>: 本地 Monitor 和远程 Monitor.&lt;/p>
&lt;p>本地monitor 和远程 monitor 的区别是: &lt;strong>Monitor Client 的位置在哪, 是否与 Server 在同一个机器上&lt;/strong>.&lt;/p>
&lt;blockquote>
&lt;p>先说 Monitor Server, 它必须嵌入要调试的 Kernel 中, &lt;strong>位于一个地址空间&lt;/strong>, 方便操作 Kernel 的内存.&lt;/p>
&lt;/blockquote>
&lt;h3 id="本地-monitor">本地 Monitor&lt;/h3>
&lt;p>在本地 Monitor 中, client 和 sever 都位于目标机(Target)上, 目标机通常是开发板.&lt;/p>
&lt;p>对于 AArch64 体系结构来说, 最多有四个异常等级(EL0-EL3). &lt;!-- raw HTML omitted -->Client 可以运行在EL2.&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>&lt;img src="./%E6%9C%AC%E5%9C%B0monitor.png" alt="image-20221029141414942">&lt;/p>
&lt;h3 id="远程-monitor">远程 Monitor&lt;/h3>
&lt;p>远程 Monitor 架构则不同, &lt;!-- raw HTML omitted -->Clinet 运行在宿主机(Host)上&lt;!-- raw HTML omitted -->, 通常是Linux. 它与 Server 的通信是通过网络/UART实现的.&lt;/p>
&lt;p>&lt;img src="./%E8%BF%9C%E7%A8%8Bmonitor.png" alt="image-20221029142002468">&lt;/p>
&lt;blockquote>
&lt;p>Monitor Client 运行在本地和远程对于实现的难度和用户体验有影响.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果 Client 实现在本地, 则 Client 无需实现网口和串口的驱动, 但Monitor 输入输出的串口与操作系统本身的串口相同, 信息冗杂在一起不易查看; 同时, 如果 Client 实现在本地, 那么对于ELF的解析需要在无操作系统提供的库支持下完成, 可能比较复杂.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果 Client 实现在远程, 即为 Linux 上的一个APP. 那么它和 Server 的通信就需要通过外部的网口或者串口(对于我们使用的64位开发板只引出了一个串口, 所以只能使用网口). 需要在 Server 上实现网口的驱动, 这部分比较复杂. 但是好处是 Client 的实现简单很多, 因为有 Linux APP 运行环境的支持. 同时, 远程 Monitor 架构下, Monitor 和 操作系统自身的输入输出分开, 用户可读性更好.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Server 是嵌入到Kernel的代码中, 与Client进行交互. 它是整个 Monitor 系统的后端, 负责实现基础的调试操作. 例如, 设置断点, 内存的读写, 寄存器的读写等.&lt;/p>
&lt;ul>
&lt;li>由于Server与 Kernel 位于同一个地址空间, 所以查看/修改内存的值是非常方便的. 对于寄存器也是同理.&lt;/li>
&lt;li>断点(Breakpoint), 监视点(Watchpoint), 单步执行(Soft step)的实现依赖与 ARMv8 提供的的 &lt;a href="https://developer.arm.com/-/media/Arm%20Developer%20Community/PDF/Learn%20the%20Architecture/V8A%20Self-hosted%20debug.pdf?revision=5eff4cc6-b4ca-4017-a07d-2957307058cb">self-hosted debug&lt;/a> 支持.&lt;/li>
&lt;/ul>
&lt;p>同时, Server 还负责监视系统中所有的 同步异常和系统错误. 一旦发生, 可在 Monitor 中查看某些内存, 寄存器的值定位问题发生的原因.&lt;/p>
&lt;h3 id="monitor-client-设计">Monitor Client 设计&lt;/h3>
&lt;p>Client 的构成可分为三个模块 :&lt;/p>
&lt;ul>
&lt;li>用户交互模块&lt;/li>
&lt;li>符号处理模块&lt;/li>
&lt;li>消息收发模块&lt;/li>
&lt;/ul>
&lt;p>用户交互模块负责处理用户的输入输出, 调用其他两个模块完成调试命令.&lt;/p>
&lt;p>符号处理模块负责解析可执行文件(ELF), 并建立静态符号表, 存储符号和地址的对应关系. 将用户输入的符号解析为虚拟地址, 或者反向解析.&lt;/p>
&lt;p>消息收发模块负责处理用户的输入, 将其转化为基础, 标准的命令, 发送给Server执行. Client 和 Server之间通信的数据包协议可以使用 &lt;a href="https://sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html">GDB Remote Serial Protocol&lt;/a> (以下简称RSP协议), 或者自己规定一个协议也是可行的.&lt;/p>
&lt;blockquote>
&lt;p>RSP协议支持三种基础命令:&lt;/p>
&lt;ol>
&lt;li>寄存器相关&lt;/li>
&lt;li>内存相关&lt;/li>
&lt;li>程序控制命令&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;h3 id="启用-monitor-时-kernel-启动流程">启用 Monitor 时 Kernel 启动流程&lt;/h3>
&lt;ol>
&lt;li>Kernel 首先做必要的初始化, GIC, 异常向量表, MMU等.&lt;/li>
&lt;li>将控制权交给 Monitor, 等待用户输入.&lt;/li>
&lt;/ol>
&lt;p> &lt;/p>
&lt;h2 id="kernel-debug-过程示例">Kernel debug 过程示例&lt;/h2>
&lt;h3 id="示例一-查看变量-var-的值">示例一: 查看变量 &lt;code>var&lt;/code> 的值&lt;/h3>
&lt;ol>
&lt;li>用户输入 &lt;code>print var&lt;/code> 指令.&lt;/li>
&lt;li>由符号处理模块, 将&lt;code>var&lt;/code>符号转为var 虚拟地址.&lt;/li>
&lt;li>由消息收发指令将请求封装为RSP协议包格式, 并发送到 Monitor Server.&lt;/li>
&lt;li>执行流程交给 Monitor Server, 它访问该地址, 将内容封装发回 Monitor Client.&lt;/li>
&lt;li>Client 输出&lt;code>var&lt;/code>的值, 继续等待用户输入&lt;/li>
&lt;/ol>
&lt;h3 id="示例二-添加断点到-main-函数">示例二: 添加断点到 &lt;code>main&lt;/code> 函数&lt;/h3>
&lt;ol>
&lt;li>用户输入 &lt;code>break main&lt;/code> 指令&lt;/li>
&lt;li>由符号处理模块, 解析得到 &lt;code>main&lt;/code> 函数的地址.&lt;/li>
&lt;li>消息收发模块将请求封装为RSP包格式, 发送到Monitor Server.&lt;/li>
&lt;li>执行流程交给 Server. 它执行 &lt;em>breakpoint exception 指令&lt;/em>, 并设置相关软件断点相关寄存器&lt;/li>
&lt;li>执行流交给 Kernel, 直到达到断点处(可使用地址+ContextID双重验证), 触发Debug异常&lt;/li>
&lt;li>Debug异常属于同步异常, 由 Monitor 系统接管, 回到 Client 继续等待用户输入&lt;/li>
&lt;/ol>
&lt;h3 id="示例三-单步执行">示例三: 单步执行&lt;/h3>
&lt;ol>
&lt;li>用户输入 &lt;code>step&lt;/code> 指令&lt;/li>
&lt;li>消息收发模块将请求封装为RSP包格式, 发送到 Monitor Server.&lt;/li>
&lt;li>执行流程交给 Server, 启用 software step. 然执行一次异常返回, 回到Kernel 继续执行.&lt;/li>
&lt;li>因为启用了 Software step, 回到 Kernel 执行完一条指令后, 就会触发 Debug异常&lt;/li>
&lt;li>Debug 异常属于同步异常, 由 Monitor 系统接管, 回到 Client 继续等待用户输入&lt;/li>
&lt;/ol>
&lt;p> &lt;/p>
&lt;h2 id="其他拓展功能">其他拓展功能&lt;/h2>
&lt;p>back trace&lt;/p>
&lt;p>性能分析&lt;/p>
- https://wangloo.github.io/posts/os/monitor/ - @2019 Notepadium.</description></item><item><title>ARMv8-A MMU介绍</title><link>https://wangloo.github.io/posts/armv8/mmu/</link><pubDate>Thu, 29 Sep 2022 08:01:33 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/mmu/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/armv8/mmu/ -&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>MMU: 专用于将虚拟地址转换为物理地址. 通常配合分页机制来工作.&lt;/p>
&lt;p>页表: 页表中的表项包含提供虚拟地址和物理地址之间的映射.&lt;/p>
&lt;p>MMU就是直接访问页表, 并且通过将频繁使用的映射缓存到TLB中.&lt;/p>
&lt;h3 id="mmu-的结构">MMU 的结构&lt;/h3>
&lt;p>MMU是一种硬件, 可以通过在适当的安全状态下对其进行配置. 每个Core都有自己的MMU, 每个MMU包括:&lt;/p>
&lt;ol>
&lt;li>一个TLB, 缓存最近访问的映射.&lt;/li>
&lt;li>一个Table Walk Unit, 从内存中查询页表, 得到最终的虚拟地址-物理地址的映射.&lt;/li>
&lt;/ol>
&lt;p>MMU 控制着整个系统的缓存策略, 内存属性和访问权限. MMU开启后, 软件发出的所有内存访问都使用虚拟地址, 要求MMU为每次访问进行地址转换.&lt;/p>
&lt;h3 id="mmu-的配置">MMU 的配置&lt;/h3>
&lt;p>在启用MMU前, 必须告知其页表存放的位置.&lt;/p>
&lt;h3 id="mmu-地址转换的过程">MMU 地址转换的过程&lt;/h3>
&lt;p>对于每个转换请求, MMU首先检查TLB是否已经对该地址缓存, 如果该地址未缓存, 则需要遍历页表.&lt;/p>
&lt;p>页表遍历单元在页表中搜索相关的映射表项.&lt;/p>
&lt;ul>
&lt;li>一旦找到映射, MMU就会检查权限和属性. 决定允许本次访问, 或者发出故障信号.&lt;/li>
&lt;li>若未找到映射, 则触发缺页异常.&lt;/li>
&lt;/ul>
&lt;h3 id="页表的工作原理">页表的工作原理&lt;/h3>
&lt;p>页表的工作方式是将虚拟地址空间和物理地址空间划分为大小相等的块, 称为页面.&lt;/p>
&lt;p>页表中的每个表项对应着一块虚拟地址空间中的块, 表项的值就是这块虚拟地址空间对应的物理地址块, 以及访问物理地址时要使用的属性.&lt;/p>
&lt;p>在查表过程中, 将虚拟地址分为两部分:&lt;/p>
&lt;ul>
&lt;li>高阶位用作页表的索引. 用来找到对应的物理块&lt;/li>
&lt;li>低地址是块内的偏移量, 不会因为映射而改变. 页表项中的物理地址与该偏移组合形成用于访问内存的物理地址.&lt;/li>
&lt;/ul>
&lt;h4 id="多级页表">多级页表&lt;/h4>
&lt;p>实际实现中, 多采用多级页表的方案, 各级页表自定向下组成树的形式, 协作实现虚拟到物理地址的转换.&lt;/p>
&lt;p>树中的分支成为页目录, 页目录中的表项不是直接存储目标物理地址, 而是下一级页表的地址; 最后一级页表的表项中保存着目标物理地址.&lt;/p>
&lt;blockquote>
&lt;p>多级页表是减小页表占用存储空间过大的有效方案.&lt;/p>
&lt;/blockquote>
&lt;p>顶级页表将地址空间划分为大块, 每个表项可以指向大小相等的内存块. 也可以指向将块进行再次细分的下一级页表. 支持大块的优点:&lt;/p>
&lt;ul>
&lt;li>大的内存块需要查表的次数更少&lt;/li>
&lt;li>提升TLB的效率, 因为一个TLB表项覆盖更大的内存区域.&lt;/li>
&lt;/ul>
&lt;p>凡事都是有利有弊, 使用大块也增加了内存浪费, 实际使用时需要根据需要来权衡.&lt;/p>
&lt;h2 id="内存类型">内存类型&lt;/h2>
&lt;h3 id="普通类型内存">普通类型内存&lt;/h3>
&lt;p>普通类型的内存是弱一致性的(weakly ordered)内存模型, 没有额外的约束, 可以提供最高的内存访问性能.&lt;/p>
&lt;p>通常代码段, 数据段以及其他数据都放在普通内存中.&lt;/p>
&lt;p>普通内存允许处理器做很多优化, 如分支预测, 数据预取, Cache line预取, 乱序执行等.&lt;/p>
&lt;h3 id="设备类型内存">设备类型内存&lt;/h3>
&lt;p>CPU访问设备内存会有很多限制, 如不能进行数据预取等. 设备类型的内存严格按照指令的顺序来执行的.&lt;/p>
&lt;p>设备类型内容通常留给设备来访问, 例如中断控制器(GIC), 串口, 定时器等.&lt;/p>
&lt;h2 id="两套页表">两套页表&lt;/h2>
&lt;ul>
&lt;li>当CPU访问的地址属于&lt;em>用户空间&lt;/em>时, MMU会自动选择&lt;strong>TTBR0&lt;/strong>指向的页表.&lt;/li>
&lt;li>当CPU访问的地址属于&lt;em>内核空间&lt;/em>时. MMU会自动选择&lt;strong>TTBR1&lt;/strong>指向的页表&lt;/li>
&lt;/ul>
&lt;p>EL2和EL3没有TTBR1, 只有TTBR0. 也就意味着:&lt;/p>
&lt;p>• If EL2 is using AArch64, it can only use Virtual Addresses in the range 0x0 to 0x0000FFFF_FFFFFFFF.
• If EL3 is using AArch64, it can only use Virtual Addresses in the range 0x0 to 0x0000FFFF_FFFFFFFF.&lt;/p>
&lt;h2 id="越权-越界">越权, 越界&lt;/h2>
&lt;p>在未使用虚拟地址空间之前, 所有的用户程序都可以访问全部的物理内存, 所以恶意程序可以修改其他程序的内存数据, 这使得整个系统处于危险的状态. 每个进程的地址空间都要受到保护, 以免被其他进程有意/无意的破坏.&lt;/p>
&lt;p>现代操作系统中, 每个进程都有独立的虚拟地址空间. 在进程的角度上, 它拥有整个虚拟地址空间. 不同的进程可以同时使用一个虚拟地址, MMU通过页表将其映射到合适的物理地址.&lt;/p>
&lt;h3 id="两个物理地址空间">两个物理地址空间&lt;/h3>
&lt;p>ARMv8 体系结构定义两个物理地址空间: secure address space 和 non-secure address space.&lt;/p>
&lt;p>理论上, 安全和非安全的地址空间是相互独立的, 然而现实中大多数系统都将安全和非安全视为访问控制的属性. 正常(非安全)世界只能访问非安全的物理内存; 而安全世界可以访问这两个地址空间.&lt;/p>
&lt;h3 id="armv8-mmu权限控制">ARMv8 MMU权限控制&lt;/h3>
&lt;p>程序请求某个地址时, MMU需要进行权限检查. 如果请求的地址是数据, 则检查读写权限; 如果请求的是地址, 则检查其可执行权限.&lt;/p>
&lt;p>ARMv8 页表项的AP字段控制该不同异常等级下, 页面的读写权限.&lt;/p>
&lt;p>[表格]&lt;/p>
&lt;p>ARMv8 页表项的PNX字段和XN/UXN字段来设置CPU是否对这个页面有执行权限.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>当系统有两套页表时, UXN是用来设置用户空间页面是否有可执行权限; PXN 用来设置特权空间的页面是否有可执行权限.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若系统只有一套页表, 则通过XN字段控制&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="页表的结构">页表的结构&lt;/h2>
&lt;h3 id="地址宽度">地址宽度&lt;/h3>
&lt;p>48bit&lt;/p>
&lt;h3 id="页面粒度">页面粒度&lt;/h3>
&lt;p>页面粒度表示一次最小分配内存块的大小. AArch64支持三种页的大小, 4KB, 16KB, 64KB. 支持哪一种是由实现定义的。创建页表的代码能够读取系统寄存器&lt;code>ID_AA64MMFR0_EL1&lt;/code>，以找出哪些是受支持的大小。Cortex-A53处理器支持所有三种尺寸，但有些处理器的早期版本并非如此，例如Cortex-A57，它不支持16K粒度。&lt;/p>
&lt;h3 id="aarch64-页表项结构">AArch64 页表项结构&lt;/h3>
&lt;h4 id="无效页表项">无效页表项&lt;/h4>
&lt;h4 id="table">table&lt;/h4>
&lt;h4 id="block">block&lt;/h4>
&lt;h3 id="页表结构4kb页面为例">页表结构(4KB页面为例)&lt;/h3>
&lt;p>以4KB页面粒度, 虚拟地址宽度为 48位. 使用4级页表.&lt;/p>
&lt;p>48位地址每层转换有9个地址位，即每层512个条目，最后12位选择4kB内的一个字节，直接来自原始地址&lt;/p>
&lt;h2 id="虚拟地址到物理地址的转换过程">虚拟地址到物理地址的转换过程&lt;/h2>
&lt;p>当处理器为获取指令或数据访问发出一个64位的虚拟地址时，MMU硬件将虚拟地址转换为相应的物理地址。对于虚拟地址，前16位[63:47]必须全部为0或1，否则地址将触发故障。&lt;/p>
&lt;h3 id="non-secure-and-secure-access">Non-secure and secure access&lt;/h3>
&lt;p>ARMv8-A架构定义了两种安全状态:安全的和非安全的。它还定义了两个物理地址空间:安全的和非安全的. 正常(非安全)世界只能访问非安全物理地址空间。安全世界可以访问两个物理地址空间。这也是通过转换表来控制的。&lt;/p>
&lt;p>在非安全状态下，转换表中的NS位和NSTable位将被忽略。只能访问非安全内存。在安全状态下，NS位和NSTable位控制虚拟地址转换为安全物理地址还是非安全物理地址。&lt;/p>
&lt;p>You can use SCR_EL3.SIF 来禁用安全世界访问非安全地址.&lt;/p>
&lt;h2 id="相关的寄存器">相关的寄存器&lt;/h2>
&lt;p>与地址转换相关的寄存器主要有以下几个:&lt;/p>
&lt;ol>
&lt;li>转换控制寄存器(TCR)&lt;/li>
&lt;li>系统控制寄存器(SCTLR)&lt;/li>
&lt;li>页表基地址寄存器(TTBR)&lt;/li>
&lt;/ol>
&lt;h3 id="tcr">TCR&lt;/h3>
&lt;p>IPS: 配置地址转换后输出物理地址的最大值&lt;/p>
&lt;p>TxSz: 配置输入地址的最大值, 即虚拟地址的宽度&lt;/p>
&lt;p>TG1: 配置TTBR1页表的页面粒度大小&lt;/p>
&lt;p>SHx: 配置TTBRx相关内存的Cache共享属性&lt;/p>
&lt;p>ORGNx:&lt;/p>
&lt;p>IRGNx:&lt;/p>
&lt;h3 id="sctlr">SCTLR&lt;/h3>
&lt;p>M: Disable/Enable MMU地址转换&lt;/p>
&lt;p>C: Disable/Enable Data Cache&lt;/p>
&lt;p>I: Disable/Enable Instruction Cache&lt;/p>
&lt;h3 id="ttbr">TTBR&lt;/h3>
&lt;p>存储页表的基地址&lt;/p>
&lt;h2 id="aarch32-虚拟内存系统">AArch32 虚拟内存系统&lt;/h2>
&lt;p>ARMv8 AArch32 的虚拟内存系统向后兼容ARMv7, 与ARMv7的基本一致.&lt;/p>
- https://wangloo.github.io/posts/armv8/mmu/ - @2019 Notepadium.</description></item><item><title>AArch64/32 异常返回过程</title><link>https://wangloo.github.io/posts/armv8/exception_return/</link><pubDate>Sat, 24 Sep 2022 21:19:01 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/exception_return/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/armv8/exception_return/ -&lt;h2 id="armv8-异常返回指令">ARMv8 异常返回指令&lt;/h2>
&lt;p>当异常处理程序结束后，需要执行&lt;em>异常返回指令&lt;/em>恢复进入异常之前的状态.&lt;/p>
&lt;p>具体要做的事情包括:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>恢复发生异常前的PC&lt;/p>
&lt;/li>
&lt;li>
&lt;p>从SPSR中恢复PSTATE寄存器(现场)&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>异常返回的指令根据当前&lt;strong>执行状态&lt;/strong>为AArch32还是AArch64有所不同.&lt;/p>
&lt;h3 id="aarch32">AArch32&lt;/h3>
&lt;p>AArch32的异常返回指令在不同的&lt;strong>模式&lt;/strong>下也有所不同:&lt;/p>
&lt;p>&lt;strong>若异常是在Hyp模式下处理:&lt;/strong> 仅可执行&lt;code>ERET&lt;/code>指令从异常返回.&lt;/p>
&lt;p>&lt;strong>若异常是在其他模式下处理&lt;/strong>, AArch32提供了以下的异常返回指令:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>ERET&lt;/code> 指令&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用带S后缀的数据处理指令直接操作PC(例如, &lt;code>MOVS, PC, LR&lt;/code>), 恢复PSTATE&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RFE 指令: &lt;code>RFE &amp;lt;Rn&amp;gt;&lt;/code>. 从基址寄存器&lt;!-- raw HTML omitted -->指向的地址依次加载PC和PSTATE&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LDM 指令: &lt;code>LDM &amp;lt;Rn&amp;gt; {pc..}&lt;/code>. 若目标寄存器中包含PC, 则会同时恢复PSTATE&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="aarch64">AArch64&lt;/h3>
&lt;p>AArch64下&lt;strong>统一使用&lt;/strong> &lt;code>ERET&lt;/code> 指令进行异常返回.&lt;/p>
&lt;h3 id="指令格式及用法参考">指令格式及用法参考&lt;/h3>
&lt;h4 id="eret">ERET&lt;/h4>
&lt;p>ERET指令完成了:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>从ELR_ELx中恢复PC指针&lt;/p>
&lt;/li>
&lt;li>
&lt;p>从SPSR_ELx中恢复PSTATE寄存器的状态.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="ldmload-multiple">LDM(Load Multiple)&lt;/h4>
&lt;p>格式: &lt;code>LDM &amp;lt;Rn&amp;gt; {registers}&lt;/code>&lt;/p>
&lt;p>含义: 从基址寄存器&lt;code>&amp;lt;Rn&amp;gt;&lt;/code>指向的地址开始依次加载多个寄存器值. 若目标寄存器中包含PC, 则同时恢复PSTATE.&lt;/p>
&lt;p>例如: &lt;code>LDM &amp;lt;r0&amp;gt; {pc, r1}&lt;/code> 等价于:&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-assembly" data-lang="assembly">pc = [r0]
r1 = [r0+4]
PSTATE = SPSR ;仅当目标寄存器包含PC时自动完成
&lt;/code>&lt;/pre>&lt;h4 id="rfereturn-from-exception">RFE(Return From Exception)&lt;/h4>
&lt;p>格式: &lt;code>LDM &amp;lt;Rn&amp;gt; &lt;/code>&lt;/p>
&lt;p>含义: 从基址寄存器&lt;code>&amp;lt;Rn&amp;gt;&lt;/code>指向的地址依次加载PC和PSTATE.&lt;/p>
&lt;p>例如: &lt;code>RFE &amp;lt;r0&amp;gt;&lt;/code> 等价于:&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-ass" data-lang="ass">pc = [r0]
PSTATE = [r0+4]
&lt;/code>&lt;/pre>- https://wangloo.github.io/posts/armv8/exception_return/ - @2019 Notepadium.</description></item></channel></rss>