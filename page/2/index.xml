<?xml-stylesheet href="/rss.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Homepage 🌈 on Wangloo's BLOG</title><link>https://wangloo.github.io/</link><description>Recent content in Homepage 🌈 on Wangloo's BLOG</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>@2019 Notepadium.</copyright><lastBuildDate>Thu, 15 Sep 2022 15:14:05 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>git 宝典</title><link>https://wangloo.github.io/posts/tools/git/git/</link><pubDate>Tue, 13 Dec 2022 17:39:42 +0800</pubDate><guid>https://wangloo.github.io/posts/tools/git/git/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/tools/git/git/ -&lt;h2 id="合并操作-git-merge">合并操作: git merge&lt;/h2>
&lt;p>merge 有两种方式:&lt;/p>
&lt;ul>
&lt;li>fast-forward&lt;/li>
&lt;li>three-way merger&lt;/li>
&lt;/ul>
&lt;h3 id="fast-forward-merge">Fast-forward Merge&lt;/h3>
&lt;p>假设合并的双方为&lt;code>main&lt;/code>为&lt;code>dev&lt;/code>, 如果其中一个是另一个的祖先, 此时直接移动 HEAD 到前方即可, 称为 fast-forward.&lt;/p>
&lt;p>例如, 当前在 main, 执行&lt;code>git merge dev&lt;/code>的过程如下:&lt;/p>
&lt;pre tabindex="0">&lt;code> main main
| |
M1 --- M2 ===&amp;gt; M1 --- M2 -- F1
\ |
\--- F1 dev
|
dev
&lt;/code>&lt;/pre>&lt;h3 id="three-way-merge">three-way Merge&lt;/h3>
&lt;p>合并的两者不构成直接的祖先-孩子关系, 产生了分叉. 此时进行合并就需要有个基准(参考), 对于两边相较于基准的每个 diff 来说:&lt;/p>
&lt;ul>
&lt;li>合并的两者都在基准上进行了改动, 且改动不一致, &lt;strong>标记为冲突&lt;/strong>&lt;/li>
&lt;li>如果该 diff&lt;strong>仅在其中一方&lt;/strong>有改动, 那么就保留此次改动&lt;/li>
&lt;/ul>
&lt;p>合并时使用的参考就是&lt;strong>两个合并 commit 的最近公共祖先&lt;/strong>, 这种借助三个 commit(main, dev, 公共祖先)才能完成的合并操作就叫做 three-way merge.&lt;/p>
&lt;p>例如, 当前在 main, 执行&lt;code>git merge dev&lt;/code>的过程如下:&lt;/p>
&lt;pre tabindex="0">&lt;code> main main
| |
M1 --- M2 --- M3 ===&amp;gt; M1 --- M2 --- M3 --- M4
\ \ /
\--- F1 \--- F1 ---
| |
dev dev
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>three-way 的合并方式如果发生了冲突, 会产生一次额外的 merge commit, 下面介绍它&lt;/p>
&lt;/blockquote>
&lt;h3 id="什么情况下-merge-commit-没有任何-diff">什么情况下 merge commit 没有任何 diff?&lt;/h3>
&lt;p>按照上面的例子, three-way merge 发生冲突后会产生一次额外的 merge commit, 即 M4. 如果这是去查看 M4 相较前一次 commit 的 diff, 有时是没有的, 有时又会产生 diff.&lt;/p>
&lt;p>如果在解决冲突的过程中, 我们仅仅是接收了 M2,M3 或者 F1 的修改, 那么此时 merge commit 就不会有 diff.&lt;/p>
&lt;p>然而, 在解决冲突时, 我们也可以不采用来自两条路径的修改, 做一次新的修改(可以说, 同时接收两条 diff 就是这种情况), 此时查看 merge commit 的 diff 就是有内容的.&lt;/p>
&lt;h2 id="变基-rebase">变基: rebase&lt;/h2>
&lt;p>rebase 命令需要指定一个&lt;strong>基准分支&lt;/strong>，&lt;code>git rebase &amp;lt;base-branch&amp;gt;&lt;/code>，
rebase 会将当前所处分支整体移动到&lt;code>base-branch&lt;/code>之后，即改变了当前分支的历史。&lt;/p>
&lt;pre tabindex="0">&lt;code>// before rebase
[A]---[B]---[C]---[D]&amp;lt;-dev
\
\--[E]&amp;lt;-master
// after rebase
[A]---[E]---[B]---[C]---[D]&amp;lt;-dev
|
master
&lt;/code>&lt;/pre>&lt;h3 id="交互式-rebase">交互式 rebase&lt;/h3>
&lt;p>交互式 rebase 是一种更高级的用法。基础的 rebase 上面说了是将当前分支的所有提交移动到 base-branch 之后。而交互式 rebase 提供一个方法，在移动之前&amp;quot;挑选&amp;quot;当前分支的 commit。&lt;/p>
&lt;p>实际工程中，通常来说，我们将开发分支移动到 master 之前，可以经过交互 rebase 来整理开发分支中混乱的 commit 记录。&lt;/p>
&lt;p>具体的使用方法是，为&lt;code>git rebase&lt;/code>指令提供&lt;code>-i&lt;/code>参数:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>git checkout dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git rebase -i master
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个命令会打开一个文本编辑器，列出当前 feature 分支的所有提交:&lt;/p>
&lt;pre tabindex="0">&lt;code>pick 33d5b7a Message for commit #1
pick 9480b3d Message for commit #2
pick 5c67e61 Message for commit #3
&lt;/code>&lt;/pre>&lt;p>列出的内容就能完整的表示 dev 分支的所有提交，按照顺序。而我们不仅可以任意的重排这些 commit，而且修改&lt;code>pick&lt;/code>关键字就能对这些 commit 做改动。举个例子，我们可能发现 commit2 只是对于 commit1 做了一个很小的改动，它们完全可以合并为一个 commit，那么直接 commit2 的&lt;code>pick&lt;/code>修改为&lt;code>fixup&lt;/code>，整个内容变为:&lt;/p>
&lt;pre tabindex="0">&lt;code>pick 33d5b7a Message for commit #1
fixup 9480b3d Message for commit #2
pick 5c67e61 Message for commit #3
&lt;/code>&lt;/pre>&lt;p>当你保存并退出这个文件时，改动就会生效，不仅将 dev 整体移动到了 master 后，并且合并了前两个 commit。&lt;/p>
&lt;pre tabindex="0">&lt;code>// after rebase interactive
[A]---[E]---[B]---[D]&amp;lt;-dev
|
master
&lt;/code>&lt;/pre>&lt;h3 id="rebase-整理多个-commit">rebase 整理多个 commit&lt;/h3>
&lt;p>如上面交互式 rebase 所述，当你开发完 dev 分支，需要&lt;code>merge&lt;/code>到 main 分支时，可以先利用交互式 rebase&amp;quot;整理&amp;quot;一下 dev 分支的 commit。&lt;/p>
&lt;p>这里其实要用到一个小 trick，上面说过 rebase 命令需要指定一个 base-branch，实际上是一个 base-commit，这种场景下我们不是要合并其他分支，所以&lt;strong>base-branch&lt;/strong>可以选择当前 dev 分支的前面某一次 commit。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>git checkout dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git rebase -i HEAD~3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上指令实现的功能就是给你整理最后 3 次提交的机会，但&lt;strong>不会合并其他分支的东西&lt;/strong>。&lt;/p>
&lt;p>那如果我想整理整个 dev 分支呢？是向上找到 dev 的第一次 commit 吗？ Git 提供了一个方便找到 dev 分叉出来的那次 commit，将其输出传递给&lt;code>git rebase -i&lt;/code>即可实现整理整个 dev 的所有 commit。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>git merger-base dev main
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="git-merege-vs-git-rebase">&lt;code>git merege&lt;/code> vs &lt;code>git rebase&lt;/code>&lt;/h2>
&lt;h3 id="准则">准则&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>如果分支已经被提交到远程仓库，就不能再改变他的历史了，即不能使用 rebase。
git 也会阻止你这么做，因为分支的历史已经被修改，除非 force-push。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>你能进行 rebase 的分支是本地的”私人分支”，私人表示为: 只有你自己在使用，别人不会基于你的分支做东西。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="dev-同步主分支的改动-rebase">dev 同步主分支的改动: rebase&lt;/h3>
&lt;p>假设我们正在本地的 dev 分支开发一个特性，此时你的同事在 main(也可以是其他的远程分支)上提交了一个重要的 commit，以至于你需要它来继续你的开发任务。&lt;/p>
&lt;p>这种情况我们使用 rebase 和 merge 都能完成目标，但是 rebase 是更好的选择。&lt;/p>
&lt;ul>
&lt;li>首先满足 rebase 的使用条件，我们仅仅是破坏了本地 dev 分支的历史，并没有动到其他的远程分支，所以就不存在干涉别人&lt;/li>
&lt;li>其次，在 dev 上 merge 其他分支会产生一次不必要的&lt;em>merge commit&lt;/em>，其不代表任何实际意义，没必要存在的&lt;/li>
&lt;/ul>
&lt;h3 id="合并-dev-到主分支-merge">合并 dev 到主分支: merge&lt;/h3>
&lt;p>很简单的逻辑，主分支或者其他合作开发的分支并不是你一个人在用，并且需要最后同步到远程仓库，不符合使用 rebase 的准则&lt;/p>
&lt;h1 id="git-log">git log&lt;/h1>
&lt;h2 id="参数">参数:&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Parameter&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>non-param&lt;/td>
&lt;td>列出所有历史提交的 SHA、作者、提交日期和 commit&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-p&lt;/td>
&lt;td>按补丁显示每次更新，比&amp;ndash;stat 更全&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;ndash;stat&lt;/td>
&lt;td>显示每次更新修改文件的名称及添加（删除）的行数。比&amp;ndash;name-only 更全&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;ndash;name-only&lt;/td>
&lt;td>显示文件清单&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;ndash;name-status&lt;/td>
&lt;td>显示文件清单及改动方式(新增、删除、修改)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;ndash;oneline&lt;/td>
&lt;td>只显示前 6 位 SHA 值和 commit&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-n&lt;/td>
&lt;td>显示前 n 条 log&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;lt;branch&amp;gt;&lt;/td>
&lt;td>查看某个分支的历史提交。&lt;strong>该参数只能 log 命令之后&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;lt;branch1&amp;gt;..&amp;lt;branch2&amp;gt;&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>参考网站：https://www.cnblogs.com/bellkosmos/p/5923439.html&lt;/p>
&lt;h2 id="example-1-彩色显示重要信息">Example 1: 彩色显示重要信息&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>git log --graph --pretty&lt;span style="color:#ff79c6">=&lt;/span>format:&lt;span style="color:#f1fa8c">&amp;#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&amp;lt;%an&amp;gt;%Creset&amp;#39;&lt;/span> --abbrev-commit
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="gitlog_1.png" alt="">&lt;/p>
&lt;h2 id="example-2-查看本地分支和对应远程分支的-commit-差异">Example 2: 查看本地分支和对应远程分支的 commit 差异&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>git log --oneline main..origin/main
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="子模块-submodule">子模块: submodule&lt;/h1>
&lt;h2 id="新增一个子模块">新增一个子模块&lt;/h2>
&lt;ol start="0">
&lt;li>
&lt;p>将子模块上传到远端仓库上&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行&lt;code>git submodule add [url] [path]&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>此时执行&lt;code>git status&lt;/code> 会有两个changes，分别是：&lt;/p>
&lt;ul>
&lt;li>&lt;code>.gitmodules&lt;/code>: 记录子模块的path和url&lt;/li>
&lt;li>&lt;code>[子模块同名的文件]&lt;/code>: 记录主项目追踪的是子模块的哪个commit.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>也就是说主项目中惠济路自己跟踪子模块的commit，并不一定总是最新的。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;code>git add&lt;/code>这两处改动，&lt;code>git commit -m &amp;quot;add submodule xxx&amp;quot;&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="clone一个使用子模块的项目">clone一个使用子模块的项目&lt;/h2>
&lt;ol>
&lt;li>用常规的&lt;code>git clone&lt;/code>命令将主项目拿下，此时子模块不会自动下载，只是一个空的目录&lt;/li>
&lt;li>&lt;code>git submodule init&lt;/code>，&lt;strong>这个命令其实是带参数的&lt;/strong>，指定你想更新哪些子模块，
缺省代表所有子模块。该命令实际的行为是将&lt;code>.gitmodule&lt;/code>中的内容写入&lt;code>.git/config&lt;/code>&lt;/li>
&lt;li>&lt;code>git submodule update&lt;/code>, 按照&lt;code>.git/config&lt;/code>指定的子模块去下载，&lt;strong>注意下载的
commit不一定是最新的，上面讲过&lt;/strong>&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>❓ &lt;code>git submodule init&lt;/code>命令是否有意义？&lt;/p>
&lt;p>有时我们并不想同步所有的子模块，而是其中的某几个，因为可能想自己重写一些，这时可以添加参数
指定想要同步的那些子模块。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>2️⃣3️⃣可以合并为一条命令： &lt;code>git submodule update --init&lt;/code>， 同步所有子模块。&lt;/p>
&lt;/blockquote>
&lt;h2 id="修改更新子模块">修改更新子模块&lt;/h2>
&lt;p>如果仅仅是使用子模块，并不做修改，那不用关注这个。但如果你同时参与submodule的开发，那就需要注意。&lt;/p>
&lt;ol>
&lt;li>修改子模块并提交；这一步很常规，&lt;code>cd&lt;/code>到子模块中，做完修改commit即可&lt;/li>
&lt;li>此时会发现在主项目中也多了一个额外的change，是刚才修改子模块的同名文件，
查看diff会发现改动为commit id改为了刚才提交的那次子模块修改&lt;/li>
&lt;/ol>
&lt;p>Q1: 这次改动代表什么含义？&lt;/p>
&lt;p>我们知道，子模块同名文件中记录主项目跟踪此子模块的commit，也是&lt;code>git commit update&lt;/code> 会达到的
commit。含义是&lt;strong>主项目配合子模块的这个commit是ok的&lt;/strong>。而这次改动也就代表跟踪的commit想要
发生变化，由于你刚才对子模块修改造成的，git自动猜测你想同时改动主项目的追踪。&lt;/p>
&lt;p>Q2: 对这个改动应该做什么操作？&lt;/p>
&lt;p>分两种场景: (1)如果子项目的这些更新有意义同步到主项目中，那么就add并commit这个同名文件的改动，
message为&amp;quot;更新submodule&amp;quot;。 (2)如若只是更新子项目而已，或许是为了其他依赖的项目所改的，并不
想涉及到本主项目，那么就restore此次更新，或者重新执行&lt;code>submodule update&lt;/code>即可(前提是对子模块
的修改已经push)。&lt;/p>
&lt;p>所以说，同意主项目中的这次change的人必须是更新这次子模块的人，由他决定是否同步到主项目。
其他人&lt;strong>甚至在使用期间都不需要&lt;code>cd&lt;/code>进入子模块做&lt;code>git pull&lt;/code>的&lt;/strong>，这样也就不会有决策产生，即便
子项目在远端更新了，你要做的就是关注那个同名文件就行，当同名文件更新了，在主项目中
&lt;code>submodule update&lt;/code>即可，&lt;/p>
&lt;h2 id="子模块的优缺点">子模块的优缺点&lt;/h2>
&lt;p>TODO&lt;/p>
- https://wangloo.github.io/posts/tools/git/git/ - @2019 Notepadium.</description></item><item><title>GNU 二进制工具集</title><link>https://wangloo.github.io/posts/os/gnu_tools/</link><pubDate>Sat, 03 Dec 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/os/gnu_tools/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/os/gnu_tools/ -&lt;p>..&lt;/p>
&lt;h2 id="nm---列出符号">nm - 列出符号&lt;/h2>
&lt;p>&lt;a href="https://sourceware.org/binutils/docs/binutils/nm.html">nm (GNU Binary Utilities) (sourceware.org)&lt;/a>&lt;/p>
- https://wangloo.github.io/posts/os/gnu_tools/ - @2019 Notepadium.</description></item><item><title>Makefile 一些技巧</title><link>https://wangloo.github.io/posts/c/makefile_tricks/</link><pubDate>Sat, 03 Dec 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/c/makefile_tricks/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/c/makefile_tricks/ -&lt;h2 id="伪目标的依赖关系">伪目标的依赖关系&lt;/h2>
&lt;p>Makefile 中的依赖关系指的是目标和依赖之间建立的关系，目标对应规则中的语句是否执行取决于依赖的状态。&lt;/p>
&lt;p>最简单的依赖关系可以拿两个文件来举例:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-makefile" data-lang="makefile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># gcc语句执行当前仅当 main.c 新于 main.elf
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#50fa7b">main.elf&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span> main.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gcc main.c -o main.elf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>make 在执行&lt;code>main.elf&lt;/code>的规则时，会先判断依赖关系。拿上面的例子来说，
gcc 语句是否执行取决于&lt;code>main.c&lt;/code> 和 &lt;code>main.elf&lt;/code>的修改时间，&lt;strong>只有当
依赖新与目标时，规则语句才会执行&lt;/strong>。&lt;/p>
&lt;p>然而许多情况下，目标或者依赖并不是一个文件，而是&lt;strong>虚拟目标&lt;/strong>。虚拟目标
并不是一个文件，即它没有修改时间这个属性，此时 make 就不能作比较，结果就是
&lt;strong>如果目标是伪目标，那么不管依赖如何都执行规则语句；如果依赖是伪目标，
那么目标的规则语句也永远被执行&lt;/strong>。下面是两个例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-make" data-lang="make">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 伪目标作为目标文件出现
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># build finish总是输出， 而gcc语句仅当main.c比main.elf新时才执行
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#50fa7b">.PHONY &lt;/span>&lt;span style="color:#ff79c6">:&lt;/span> all
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">all&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span> main.elf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @echo &lt;span style="color:#f1fa8c">&amp;#39;build finish&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">main.elf&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span> main.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gcc $&amp;lt; -o &lt;span style="color:#8be9fd;font-style:italic">$@&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-make" data-lang="make">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 伪目标作为依赖文件中出现
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 不管main.c是否比main.elf更新，因为pre-work是伪目标
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 所以gcc语句总是执行
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#50fa7b">.PHONY &lt;/span>&lt;span style="color:#ff79c6">:&lt;/span> pre-work
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">main.elf&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span> main.c pre-work
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gcc $&amp;lt; -o &lt;span style="color:#8be9fd;font-style:italic">$@&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的代码的效果是：两条规则中的语句都会执行，即使你并没有对 main.c 做任何修改！&lt;/p>
&lt;h2 id="恐怖的空格">恐怖的空格&lt;/h2>
&lt;p>Makefile 中的变量结合很常见，例如&lt;code>$(FIXDEP)=$(FIXDEP_PATH)/build/fixdep&lt;/code>.&lt;/p>
&lt;p>特别是当我们这些语句是从某些地方粘贴过来，要特别注意变量中是否有空格，Makefile 非常重视这个。假如&lt;code>$(FIXDEP_PATH)&lt;/code>中有一个空格，那么&lt;code>$(FIXDEP)&lt;/code>就变成&lt;strong>两个宏&lt;/strong>了（不知道叫宏合不合适）。而且 Make 的执行过程很难检查出来。&lt;/p>
&lt;h2 id="规则的执行顺序">规则的执行顺序&lt;/h2>
&lt;p>如果不从命令行传入目标, Makefile 中定义的规则其实是以&lt;strong>从上而下&lt;/strong>的顺序执行的, 但是我习惯把 &lt;code>all&lt;/code> 这种默认规则放在最下面, 所以一般我们可以看到很多 Makefile 会在开头写一句规则&lt;code>all:&lt;/code>, 作用就是告诉 make 默认(不显式指定)的目标是&lt;code>all&lt;/code>.&lt;/p>
&lt;blockquote>
&lt;p>Busybox 根目录 Makefile 中的做法示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-makefile" data-lang="makefile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># That&amp;#39;s our default target when &amp;gt;none is given on the command line
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#50fa7b">.PHONY&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span> _all
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">_all&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/blockquote>
&lt;h2 id="函数的魔法">函数的魔法&lt;/h2>
&lt;h3 id="patsubst">patsubst&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-make" data-lang="make">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">$(&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">patsubst&lt;/span> &amp;lt;&lt;span style="color:#8be9fd;font-style:italic">pattern&lt;/span>&amp;gt;,&amp;lt;&lt;span style="color:#8be9fd;font-style:italic">replacement&lt;/span>&amp;gt;,&amp;lt;&lt;span style="color:#8be9fd;font-style:italic">text&lt;/span>&amp;gt;&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>功能：查找&lt;code>&amp;lt;text&amp;gt;&lt;/code>中的单词（以空格，tab，回车，换行分割），看其是否符合&lt;code>&amp;lt;pattern&amp;gt;&lt;/code>,
如果符合，将其使用&lt;code>&amp;lt;replacement&amp;gt;&lt;/code>替换。可以使用通配符&lt;code>%&lt;/code>。&lt;/p>
&lt;p>以下两对是等效的, 明显还是直接使用变量的替换语法操作简单:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-make" data-lang="make">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">$(&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">patsubst&lt;/span> &amp;lt;&lt;span style="color:#8be9fd;font-style:italic">pattern&lt;/span>&amp;gt;,&amp;lt;&lt;span style="color:#8be9fd;font-style:italic">replacement&lt;/span>&amp;gt;,&lt;span style="color:#ff79c6">$(&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">var&lt;/span>&lt;span style="color:#ff79c6">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">$(var&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span>&amp;lt;pattern&amp;gt;=&amp;lt;replacement&amp;gt;;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">$(&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">patsubst&lt;/span> %&amp;lt;&lt;span style="color:#8be9fd;font-style:italic">suffix&lt;/span>&amp;gt;,%&amp;lt;&lt;span style="color:#8be9fd;font-style:italic">replacement&lt;/span>&amp;gt;,&lt;span style="color:#ff79c6">$(&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">var&lt;/span>&lt;span style="color:#ff79c6">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">$(var&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span>&amp;lt;suffix&amp;gt;=&amp;lt;replacement&amp;gt;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="使用-shell-变量">使用 shell 变量&lt;/h2>
&lt;p>Make 将 &lt;code>$$var&lt;/code> 转义为&lt;code>$var&lt;/code>, 供 shell 处理.&lt;/p>
&lt;p>demo(源自 6.828 根目录&lt;code>GNUmakefile&lt;/code>):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-makefile" data-lang="makefile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">handin-check&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @if &lt;span style="color:#8be9fd;font-style:italic">test&lt;/span> -n &lt;span style="color:#f1fa8c">&amp;#34;`git status -s`&amp;#34;&lt;/span>; &lt;span style="color:#ff79c6">then&lt;/span> &lt;span style="color:#f1fa8c">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&lt;/span> git status -s; &lt;span style="color:#f1fa8c">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">read&lt;/span> -p &lt;span style="color:#f1fa8c">&amp;#34;Untracked files will not be handed in. Continue? [y/N] &amp;#34;&lt;/span> r; &lt;span style="color:#f1fa8c">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">test&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$$&lt;/span>&lt;span style="color:#f1fa8c">r&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">=&lt;/span> y; &lt;span style="color:#f1fa8c">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&lt;/span> &lt;span style="color:#ff79c6">fi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>以上 demo 还使用了 test 命令来终止 make 的执行, 如果用户没有输入&lt;code>y&lt;/code>, make 将会终止执行&lt;/p>
&lt;/blockquote>
- https://wangloo.github.io/posts/c/makefile_tricks/ - @2019 Notepadium.</description></item><item><title>Uboot: 常用命令</title><link>https://wangloo.github.io/posts/os/uboot/commands/</link><pubDate>Sun, 27 Nov 2022 22:03:48 +0800</pubDate><guid>https://wangloo.github.io/posts/os/uboot/commands/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/os/uboot/commands/ -&lt;hr>
&lt;p>..&lt;/p>
&lt;h2 id="环境变量相关">环境变量相关&lt;/h2>
&lt;h2 id="内存操作">内存操作&lt;/h2>
&lt;h2 id="网络操作">网络操作&lt;/h2>
&lt;h2 id="emmc和sd卡">EMMC和SD卡&lt;/h2>
&lt;h2 id="boot操作指令">BOOT操作指令&lt;/h2>
&lt;h3 id="bootm">bootm&lt;/h3>
&lt;h3 id="go">go&lt;/h3>
&lt;h2 id="其他命令">其他命令&lt;/h2>
&lt;p>启动相关&lt;/p>
&lt;p>md&lt;/p>
&lt;p>mmcinfo&lt;/p>
&lt;p>cp&lt;/p>
- https://wangloo.github.io/posts/os/uboot/commands/ - @2019 Notepadium.</description></item><item><title>常用的 shell 命令</title><link>https://wangloo.github.io/posts/shell/shell-commands/</link><pubDate>Sun, 27 Nov 2022 14:45:58 +0800</pubDate><guid>https://wangloo.github.io/posts/shell/shell-commands/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/shell/shell-commands/ -&lt;blockquote>
&lt;p>我使用的 shell 是 Bash&lt;/p>
&lt;/blockquote>
&lt;h3 id="mount-相关">mount 相关&lt;/h3>
&lt;p>&lt;code>mount&lt;/code> 输出当前已经挂在的分区&lt;/p>
&lt;h3 id="where-and-which">where and which&lt;/h3>
&lt;p>which 查看可执行文件的位置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ which python3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/usr/bin/python3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>whereis 除了可执行文件还能搜索其他类型的文件, 不常用, 详见 &lt;code>man whereis&lt;/code>&lt;/p>
&lt;h3 id="--的妙用">&lt;code>-&lt;/code> 的妙用&lt;/h3>
&lt;p>一些命令支持使用 &lt;code>-&lt;/code> 代替文件名, 输入输出都可以:&lt;/p>
&lt;ul>
&lt;li>代替标准输出; 一些命令会将&lt;code>-o/-O&lt;/code> 后面的&lt;code>-&lt;/code>判定为输出到&lt;em>STDOUT&lt;/em>, 详见下面示例.&lt;/li>
&lt;li>代替标准输入;&lt;/li>
&lt;/ul>
&lt;p>下面给出两个同时代替输入输出的例子:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 将标准输入(STDIN)的内容作为gcc的输入, 编译后的结果输出到标准输出(STDOUT)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;void foo() {}&amp;#39;&lt;/span> | gcc -x c -o - -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 将下载的文件输出到标准输出, 同时作为tar命令的输入文件, 进行解压&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget -O - &lt;span style="color:#f1fa8c">&amp;#34;https://www.dropbox.com/download?plat=lnx.x86_64&amp;#34;&lt;/span> | tar xzf -
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>&lt;code>-&lt;/code> 如何被解析是&lt;strong>取决于命令的实现&lt;/strong>, 非标准. 比如 &lt;code>cd -&lt;/code> 就有特殊的含义&lt;/p>
&lt;/blockquote>
- https://wangloo.github.io/posts/shell/shell-commands/ - @2019 Notepadium.</description></item><item><title>C语言 'inline' 关键字</title><link>https://wangloo.github.io/posts/c/inline/</link><pubDate>Thu, 24 Nov 2022 01:35:24 +0800</pubDate><guid>https://wangloo.github.io/posts/c/inline/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/c/inline/ -&lt;p>TODO: inline 的发展历程: &lt;a href="https://gustedt.wordpress.com/2010/11/29/myth-and-reality-about-inline-in-c99/">Myth and reality about inline in C99 – Jens Gustedt&amp;rsquo;s Blog (wordpress.com)&lt;/a>&lt;/p>
&lt;h2 id="gnu89">GNU89:&lt;/h2>
&lt;p>函数的&lt;strong>实现&lt;/strong>之前添加不同的关键字:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>inline&lt;/code>: 表明这个函数可能被优化. 如果没有被优化, 编译器就会视为一个常规函数的定义.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>extern inline&lt;/code>: 表明这个函数可能被优化. 如果没有被优化, 编译器就将这个函数的定义&lt;strong>转换为该函数的声明&lt;/strong>, 即 &lt;code>extern inline func();&lt;/code> 因此当此函数被调用时, 可以调用一个外部的函数来替代. 如果没有函数调用它, 那么也可以没有外部的替代函数实现.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>static inline&lt;/code>: 表明这个函数可能被优化. 如果没有被优化, 编译器就会视为一个&lt;strong>常规静态函数&lt;/strong>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="c99">C99:&lt;/h2>
&lt;p>函数的实现之前添加不同的关键字:&lt;/p>
&lt;ul>
&lt;li>&lt;code>inline&lt;/code>: 等效于gnu89中的&lt;code>extern inline&lt;/code>&lt;/li>
&lt;li>&lt;code>extern inline&lt;/code>: 等效于gnu89中的&lt;code>inline&lt;/code>&lt;/li>
&lt;li>&lt;code>static inline&lt;/code>: 与gnu89相同含义.&lt;/li>
&lt;/ul>
&lt;h2 id="c">C++:&lt;/h2>
&lt;p>只有&lt;code>inline&lt;/code>一个关键字, 如果不能优化就定义为普通函数&lt;/p>
&lt;blockquote>
&lt;p>Ref:&lt;/p>
&lt;p>&lt;a href="https://stackoverflow.com/questions/216510/what-does-extern-inline-do/216546#216546">c++ - What does extern inline do? - Stack Overflow&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://gustedt.wordpress.com/2010/11/29/myth-and-reality-about-inline-in-c99/">Myth and reality about inline in C99 – Jens Gustedt&amp;rsquo;s Blog (wordpress.com)&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>&lt;a href="https://github.com/wangloo/inline-c99-gnu89-demo">C demo&lt;/a> 关于以上的各种情况&lt;/p>
&lt;/blockquote>
- https://wangloo.github.io/posts/c/inline/ - @2019 Notepadium.</description></item><item><title>C语言工具宏</title><link>https://wangloo.github.io/posts/c/c-macros/</link><pubDate>Thu, 24 Nov 2022 01:35:24 +0800</pubDate><guid>https://wangloo.github.io/posts/c/c-macros/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/c/c-macros/ -&lt;h3 id="计算数组元素的个数">计算数组元素的个数&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define nelem(array) sizeof(array)/sizeof(array[0])
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>- https://wangloo.github.io/posts/c/c-macros/ - @2019 Notepadium.</description></item><item><title>x86/ARMv8 函数调用约定</title><link>https://wangloo.github.io/posts/os/function-call-conventions/</link><pubDate>Mon, 21 Nov 2022 10:30:35 +0800</pubDate><guid>https://wangloo.github.io/posts/os/function-call-conventions/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/os/function-call-conventions/ -&lt;p>符合调用约定使得调用函数能够正常获取参数, callee结束之后能够回到原来位置继续执行.&lt;/p>
&lt;h2 id="x86-调用约定">X86 调用约定&lt;/h2>
&lt;h3 id="函数调用">函数调用&lt;/h3>
&lt;p>x86架构中, 函数调用以一条&lt;code>call&lt;/code>指令为分界.&lt;/p>
&lt;p>在&lt;code>call&lt;/code>指令执行之前, 所有的参数必须都躺在栈中, 参数入栈的规则是: &lt;strong>第一个参数最后入栈&lt;/strong>.&lt;/p>
&lt;p>另外, 执行&lt;code>call&lt;/code>指令之前, 必须确保栈指针&lt;code>esp&lt;/code>是16-byte对齐. 这项工作是&lt;strong>编译器&lt;/strong>完成的, 如果它判断参数入栈之后的&lt;code>esp&lt;/code> 不满足对齐条件, 则会手动调整&lt;code>esp&lt;/code>使之对齐. 实现方式见下面例子.&lt;/p>
&lt;p>&lt;code>call&lt;/code> 指令的语义是:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">push&lt;/span> pc+&lt;span style="color:#bd93f9">1&lt;/span> &lt;span style="color:#6272a4">;push next insttuction
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>mov pc, func &lt;span style="color:#6272a4">;set pc = new function
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>call&lt;/code> 指令之后的下一条指令就是callee的内容了, 至此就算是进入新函数的地盘.&lt;/p>
&lt;p>但是在执行新的任务之前, callee还需要完成&lt;strong>栈的转换&lt;/strong>, 因为此时使用的栈还是caller的.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">push&lt;/span> ebp &lt;span style="color:#6272a4">;preserve location of caller&amp;#39;s stack
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>mov ebp, esp &lt;span style="color:#6272a4">;new ebp is old esp
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>此时&lt;code>esp&lt;/code>也就是栈指针等于&lt;code>ebp&lt;/code>, 这是callee栈的初始条件&lt;/strong>. 万事俱备, 可以开始执行callee的实际任务了.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>ebp&lt;/code>在整个函数执行过程中是固定的, 好处是: 能够&lt;strong>快速的或者函数参数, 返回地址&lt;/strong>.&lt;/p>
&lt;/blockquote>
&lt;h3 id="函数返回">函数返回&lt;/h3>
&lt;p>callee执行完毕后, 需要返回到caller继续执行. 刚才说过, callee的返回地址在栈中, 所以我们要做的是找到返回地址所在的位置, 然后使&lt;code>pc = 返回地址&lt;/code>. 当然, 还有另一个重要的任务就是&lt;strong>恢复caller的栈&lt;/strong>.&lt;/p>
&lt;p>上述任务的实现使用两条汇编语句就可完成: &lt;code>leave&lt;/code> 和 &lt;code>ret&lt;/code>.&lt;/p>
&lt;p>&lt;code>leave&lt;/code> 负责搞定栈, 其语义为:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">mov&lt;/span> esp, ebp &lt;span style="color:#6272a4">;回滚栈空间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>pop ebp &lt;span style="color:#6272a4">;恢复caller的ebp
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>ret&lt;/code> 负责搞定&lt;code>pc&lt;/code>, 其语义为:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">pop&lt;/span> ebx &lt;span style="color:#6272a4">;取出返回地址
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>mov pc, ebx &lt;span style="color:#6272a4">;jmp to 返回地址
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>ret&lt;/code> 之后, 就算是返回caller的地盘了. 还有一件小事别忘了做: &lt;strong>用于保存参数的栈空间还没有回收&lt;/strong>, 回到caller之后需要先将&lt;code>esp&lt;/code>的位置进行调整.&lt;/p>
&lt;h3 id="example-函数的调用和返回">Example: 函数的调用和返回&lt;/h3>
&lt;p>一个关于函数调用和返回实现的完整例子.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">caller&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Func(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">Func&lt;/span>(&lt;span style="color:#8be9fd">int&lt;/span> a, &lt;span style="color:#8be9fd">int&lt;/span> b, &lt;span style="color:#8be9fd">int&lt;/span> c)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">/* Do something */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>(以下汇编是&lt;strong>AT&amp;amp;T&lt;/strong>格式的, 请见谅).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">; Caller
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#50fa7b">sub&lt;/span> $0x4,&lt;span style="color:#8be9fd;font-style:italic">%esp&lt;/span> &lt;span style="color:#6272a4">;make 16-bytes align before call. 0x4 是由编译器计算的
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>push $0x3 &lt;span style="color:#6272a4">;push 参数, 顺序是从右到左
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>push $0x2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">push&lt;/span> $0x1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">call&lt;/span> &lt;span style="color:#bd93f9">f01000ad&lt;/span> &amp;lt;Func&amp;gt; &lt;span style="color:#6272a4">;Func()&amp;#39;addr is f01000ad
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">;===========&amp;gt;&amp;gt; Turn to callee
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">;Func()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> push &lt;span style="color:#8be9fd;font-style:italic">%ebp&lt;/span> &lt;span style="color:#6272a4">;preserve old ebp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> mov &lt;span style="color:#8be9fd;font-style:italic">%esp&lt;/span>,&lt;span style="color:#8be9fd;font-style:italic">%ebp&lt;/span> &lt;span style="color:#6272a4">;set new ebp, ebp=esp now
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> /* Do something */
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">leave&lt;/span> &lt;span style="color:#6272a4">;restore stack
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> ret &lt;span style="color:#6272a4">;restore instruction point
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">;&amp;lt;&amp;lt;=========== Back to caller
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>add $0x10,&lt;span style="color:#8be9fd;font-style:italic">%esp&lt;/span> &lt;span style="color:#6272a4">;recycle stack(12 bytes parameters plus 4 bytes alignment)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="armv8-调用约定">Armv8 调用约定&lt;/h2>
&lt;p>大体的思想与x86相似, 只是细节有些许不同&lt;/p>
&lt;h3 id="函数调用-1">函数调用&lt;/h3>
&lt;p>ARMv8架构中, 函数调用以一条&lt;code>bl&lt;/code>指令为分界.&lt;/p>
&lt;p>执行&lt;code>bl&lt;/code>指令之前, 需要将参数准备好. 注意, &lt;strong>ARMv8中, 少于8个参数的函数在传参时, 参数是放在x0-x7中&lt;/strong>, 最左边的参数先使用x0, 以此类推. 参数超过8个的情况下才使用栈, 这与x86的方式不同.&lt;/p>
&lt;p>&lt;code>bl&lt;/code>指令保存返回地址, 并跳转到callee执行, 其语义是:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">mov&lt;/span> lr, pc+&lt;span style="color:#bd93f9">1&lt;/span> &lt;span style="color:#6272a4">;preserve return address
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#6272a4">;lr specially used for preservering return addr
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>mov pc, new_func &lt;span style="color:#6272a4">;set pc = new function
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>与x86相同, 跳转到callee之后必须先进行栈的设置, &lt;strong>Arm与x86不同的是它不需要管理栈底寄存器&lt;/strong>. 因为参数大部分是通过寄存器来传递, 返回地址也是存储在&lt;code>lr(x30)&lt;/code>寄存器中, 没必要为了极少的情况来做优化.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">sub&lt;/span> sp, sp, &lt;span style="color:#6272a4">#enough-space
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="函数返回-1">函数返回&lt;/h3>
&lt;p>要完成两件事: (1) 恢复栈 (2)返回原来位置执行&lt;/p>
&lt;p>先说(2), 由于&lt;code>lr&lt;/code>寄存器始终保存返回地址, 直接 &lt;code>mov sp, lr&lt;/code> 就能返回caller继续执行. &lt;strong>这也就是&lt;code>ret&lt;/code>指令的语义&lt;/strong>.&lt;/p>
&lt;p>(1)恢复栈的这件事同x86一样由callee完成,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">add&lt;/span> sp, sp, &lt;span style="color:#6272a4">#enough-space
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>x86 call 指令执行前需要esp对齐到 16-byte: &lt;a href="https://stackoverflow.com/questions/41971481/what-are-the-following-instructions-after-this-call-assembly">x86 - What are the following instructions after this call (assembly) - Stack Overflow&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/290689333">x86栈帧原理 - 知乎 (zhihu.com)&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>能够正确达到函数调用和返回的实现方式有很多, &lt;strong>不是仅有这一种方式&lt;/strong>, 约定仅仅是一个约定, 大家都这样去做降低了开发的难度.&lt;/p>
- https://wangloo.github.io/posts/os/function-call-conventions/ - @2019 Notepadium.</description></item><item><title>二级指针操作链表</title><link>https://wangloo.github.io/posts/c/pointers-pointers-list/</link><pubDate>Sun, 20 Nov 2022 23:40:30 +0800</pubDate><guid>https://wangloo.github.io/posts/c/pointers-pointers-list/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/c/pointers-pointers-list/ -&lt;p>问题源于我在知乎刷到的一个回答: &lt;a href="https://www.zhihu.com/question/477832027/answer/2044206446">能分享你C指针用得最灵活（飘）的一次吗?&lt;/a>&lt;/p>
&lt;p>文中提到了Linus关于&lt;strong>无头节点单项链表的删除操作&lt;/strong>给出的一种新的思路, 我觉得对理解指针非常有帮助, 所以在这里详细描述一下这件事.&lt;/p>
&lt;p>从我学习数据结构起, 对不含头节点的单向链表的删除操作, 做法常是: 借用&lt;strong>pre指针&lt;/strong>搜索. 这种情况下避免不了对于链表中第一个节点的特判(第一个节点没有pre).&lt;/p>
&lt;p>Linus提到了一种借助&lt;strong>二级指针避免该分支&lt;/strong>的方法.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">remove_if&lt;/span>(node &lt;span style="color:#ff79c6">**&lt;/span> head, remove_fn rm)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> (node&lt;span style="color:#ff79c6">**&lt;/span> curr &lt;span style="color:#ff79c6">=&lt;/span> head; &lt;span style="color:#ff79c6">*&lt;/span>curr; )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node &lt;span style="color:#ff79c6">*&lt;/span> entry &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">*&lt;/span>curr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (rm(entry))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">*&lt;/span>curr &lt;span style="color:#ff79c6">=&lt;/span> entry&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> free(entry);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">&amp;amp;&lt;/span>entry&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>指针的内容就是地址, &lt;code>int *p = a&lt;/code> 也就意味着变量&lt;code>p&lt;/code> 中保存着变量&lt;code>a&lt;/code>的地址. 所以参数&lt;code>head&lt;/code>在内存中的含义为:&lt;/p>
&lt;p>&lt;img src="./mem.png" alt="list的内存布局">&lt;/p>
&lt;p>假如要删除node2, 那么改变&lt;code>*curr&lt;/code>实际上就是&lt;strong>改了node1的&lt;code>next&lt;/code>成员&lt;/strong>.&lt;/p>
- https://wangloo.github.io/posts/c/pointers-pointers-list/ - @2019 Notepadium.</description></item><item><title>大小端问题</title><link>https://wangloo.github.io/posts/os/big-little-endian/</link><pubDate>Thu, 17 Nov 2022 10:30:35 +0800</pubDate><guid>https://wangloo.github.io/posts/os/big-little-endian/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/os/big-little-endian/ -&lt;hr>
&lt;h2 id="大小端问题的由来">大小端问题的由来&lt;/h2>
&lt;p>为什么计算机世界需要区分大小端? &lt;strong>内存里存取的单位是字节&lt;/strong>, 如果所有的数据类型长度都是一个字节, 那就完全不需要大小端了, 每个变量都仅占据单独一个字节.&lt;/p>
&lt;p>例如, 三个变量 &lt;code>a=10, b=20, c=30&lt;/code>, 在内存中的布局可能就是:&lt;/p>
&lt;pre tabindex="0">&lt;code> ┌────────────┐
│ │
│ 10 │ a
├────────────┤
│ │
│ 20 │ b
├────────────┤
│ │
│ 30 │ c
├────────────┤
│ │
│ │
│ │
│ │
│ │
└────────────┘
&lt;/code>&lt;/pre>&lt;p>但是我们最常使用的数据类型肯定有超过一个字节的, &lt;code>int&lt;/code>类型在64位的系统中就占&lt;strong>4个字节&lt;/strong>. 例如变量&lt;code>a=0xaabbccdd&lt;/code>&lt;/p>
&lt;p>一个变量的大小一旦超过4个字节, &lt;strong>内存的存取又是以字节位单位的&lt;/strong>, 那么要把它塞到内存里就必然会产生两种不同存放方式: &lt;strong>先放&lt;code>0xaa&lt;/code>还是先放&lt;code>0xdd&lt;/code>&lt;/strong>&lt;/p>
&lt;p>首先, &lt;code>0xdd&lt;/code>是变量a的低8位, &lt;code>0xaa&lt;/code>是最高8位, 这是确定的.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果先放&lt;code>0xaa&lt;/code>, 即低地址放高位, 就叫做&lt;em>大端&lt;/em>, 如左图;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果先放&lt;code>0xdd&lt;/code>, 即低地址放低位, 就叫&lt;em>小端&lt;/em>, 如右图.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>
start addr of `a` start addr of `a`
┌────────────┐ ┌────────────┐
│ │ │ │
│ aa │ │ dd │
├────────────┤ ├────────────┤
│ │ │ │
│ bb │ │ cc │
├────────────┤ ├────────────┤
│ │ │ │
│ cc │ │ bb │
├────────────┤ ├────────────┤
│ │ │ │
│ dd │ │ aa │
├────────────┤ ├────────────┤
│ │ │ │
│ │ │ │
└────────────┘ └────────────┘
&lt;/code>&lt;/pre>&lt;h2 id="什么情况">什么情况?&lt;/h2>
&lt;p>看下面的代码, 猜测输出的结果&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">unsigned&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> i &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">0x00646c72&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printf(&lt;span style="color:#f1fa8c">&amp;#34;Hello Wo%s&amp;#34;&lt;/span>, &lt;span style="color:#ff79c6">&amp;amp;&lt;/span>i);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>%s&lt;/code> 会按字节一直打印内存中的字符, 直到遇到&lt;code>\0&lt;/code>. 首先打印的字符便是变量&lt;code>i&lt;/code>的地址处的内容.&lt;/p>
&lt;p>如果是小端存储方式, 变量&lt;code>i&lt;/code>的地址处的一个字节值是0x72, 即字符&lt;code>r&lt;/code>. 以此类推, 所以如果CPU的字节序是小端形式, 那么&lt;code>printf&lt;/code>的结果是: Hello world&lt;/p>
&lt;h2 id="大小端形式的优缺点">大小端形式的优缺点&lt;/h2>
&lt;p>小端的优势:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>以不同的长度读取变量非常方便, 不用计算地址. 例如&lt;code>u64 a=0x1234&lt;/code>, 当&lt;code>(u16)a&lt;/code>时, CPU不需要重新计算读取的起始位置, 永远都是变量a的起始地址.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Easily to do mathematical computations “because of the 1:1 relationship between address offset and byte number (offset 0 is byte 0), multiple precision math routines are correspondingly easy to write.”&lt;/p>
&lt;/li>
&lt;/ol>
- https://wangloo.github.io/posts/os/big-little-endian/ - @2019 Notepadium.</description></item></channel></rss>