<?xml-stylesheet href="/rss.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Homepage 🌈 on Wangloo's BLOG</title><link>https://wangloo.github.io/</link><description>Recent content in Homepage 🌈 on Wangloo's BLOG</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>@2019 Notepadium.</copyright><lastBuildDate>Thu, 15 Sep 2022 15:14:05 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>GNU 二进制工具集</title><link>https://wangloo.github.io/posts/os/gnu_tools/</link><pubDate>Sat, 03 Dec 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/os/gnu_tools/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/os/gnu_tools/ -&lt;p>..&lt;/p>
&lt;h2 id="nm---列出符号">nm - 列出符号&lt;/h2>
&lt;p>&lt;a href="https://sourceware.org/binutils/docs/binutils/nm.html">nm (GNU Binary Utilities) (sourceware.org)&lt;/a>&lt;/p>
- https://wangloo.github.io/posts/os/gnu_tools/ - @2019 Notepadium.</description></item><item><title>Makefile 一些技巧</title><link>https://wangloo.github.io/posts/c/makefile_tricks/</link><pubDate>Sat, 03 Dec 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/c/makefile_tricks/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/c/makefile_tricks/ -&lt;h2 id="伪目标的依赖关系">伪目标的依赖关系&lt;/h2>
&lt;p>Makefile 中的依赖关系指的是目标和依赖之间建立的关系，目标对应规则中的语句是否执行取决于依赖的状态。&lt;/p>
&lt;p>最简单的依赖关系可以拿两个文件来举例:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-makefile" data-lang="makefile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># gcc语句执行当前仅当 main.c 新于 main.elf
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#50fa7b">main.elf&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span> main.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gcc main.c -o main.elf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>make 在执行&lt;code>main.elf&lt;/code>的规则时，会先判断依赖关系。拿上面的例子来说，
gcc 语句是否执行取决于&lt;code>main.c&lt;/code> 和 &lt;code>main.elf&lt;/code>的修改时间，&lt;strong>只有当
依赖新与目标时，规则语句才会执行&lt;/strong>。&lt;/p>
&lt;p>然而许多情况下，目标或者依赖并不是一个文件，而是&lt;strong>虚拟目标&lt;/strong>。虚拟目标
并不是一个文件，即它没有修改时间这个属性，此时 make 就不能作比较，结果就是
&lt;strong>如果目标是伪目标，那么不管依赖如何都执行规则语句；如果依赖是伪目标，
那么目标的规则语句也永远被执行&lt;/strong>。下面是两个例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-make" data-lang="make">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 伪目标作为目标文件出现
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># build finish总是输出， 而gcc语句仅当main.c比main.elf新时才执行
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#50fa7b">.PHONY &lt;/span>&lt;span style="color:#ff79c6">:&lt;/span> all
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">all&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span> main.elf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @echo &lt;span style="color:#f1fa8c">&amp;#39;build finish&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">main.elf&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span> main.c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gcc $&amp;lt; -o &lt;span style="color:#8be9fd;font-style:italic">$@&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-make" data-lang="make">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 伪目标作为依赖文件中出现
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 不管main.c是否比main.elf更新，因为pre-work是伪目标
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 所以gcc语句总是执行
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#50fa7b">.PHONY &lt;/span>&lt;span style="color:#ff79c6">:&lt;/span> pre-work
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">main.elf&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span> main.c pre-work
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gcc $&amp;lt; -o &lt;span style="color:#8be9fd;font-style:italic">$@&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的代码的效果是：两条规则中的语句都会执行，即使你并没有对 main.c 做任何修改！&lt;/p>
&lt;h2 id="恐怖的空格">恐怖的空格&lt;/h2>
&lt;p>Makefile 中的变量结合很常见，例如&lt;code>$(FIXDEP)=$(FIXDEP_PATH)/build/fixdep&lt;/code>.&lt;/p>
&lt;p>特别是当我们这些语句是从某些地方粘贴过来，要特别注意变量中是否有空格，Makefile 非常重视这个。假如&lt;code>$(FIXDEP_PATH)&lt;/code>中有一个空格，那么&lt;code>$(FIXDEP)&lt;/code>就变成&lt;strong>两个宏&lt;/strong>了（不知道叫宏合不合适）。而且 Make 的执行过程很难检查出来。&lt;/p>
&lt;h2 id="规则的执行顺序">规则的执行顺序&lt;/h2>
&lt;p>如果不从命令行传入目标, Makefile 中定义的规则其实是以&lt;strong>从上而下&lt;/strong>的顺序执行的, 但是我习惯把 &lt;code>all&lt;/code> 这种默认规则放在最下面, 所以一般我们可以看到很多 Makefile 会在开头写一句规则&lt;code>all:&lt;/code>, 作用就是告诉 make 默认(不显式指定)的目标是&lt;code>all&lt;/code>.&lt;/p>
&lt;blockquote>
&lt;p>Busybox 根目录 Makefile 中的做法示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-makefile" data-lang="makefile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># That&amp;#39;s our default target when &amp;gt;none is given on the command line
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#50fa7b">.PHONY&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span> _all
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">_all&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/blockquote>
&lt;h2 id="函数的魔法">函数的魔法&lt;/h2>
&lt;h3 id="patsubst">patsubst&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-make" data-lang="make">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">$(&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">patsubst&lt;/span> &amp;lt;&lt;span style="color:#8be9fd;font-style:italic">pattern&lt;/span>&amp;gt;,&amp;lt;&lt;span style="color:#8be9fd;font-style:italic">replacement&lt;/span>&amp;gt;,&amp;lt;&lt;span style="color:#8be9fd;font-style:italic">text&lt;/span>&amp;gt;&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>功能：查找&lt;code>&amp;lt;text&amp;gt;&lt;/code>中的单词（以空格，tab，回车，换行分割），看其是否符合&lt;code>&amp;lt;pattern&amp;gt;&lt;/code>,
如果符合，将其使用&lt;code>&amp;lt;replacement&amp;gt;&lt;/code>替换。可以使用通配符&lt;code>%&lt;/code>。&lt;/p>
&lt;p>以下两对是等效的, 明显还是直接使用变量的替换语法操作简单:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-make" data-lang="make">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">$(&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">patsubst&lt;/span> &amp;lt;&lt;span style="color:#8be9fd;font-style:italic">pattern&lt;/span>&amp;gt;,&amp;lt;&lt;span style="color:#8be9fd;font-style:italic">replacement&lt;/span>&amp;gt;,&lt;span style="color:#ff79c6">$(&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">var&lt;/span>&lt;span style="color:#ff79c6">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">$(var&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span>&amp;lt;pattern&amp;gt;=&amp;lt;replacement&amp;gt;;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">$(&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">patsubst&lt;/span> %&amp;lt;&lt;span style="color:#8be9fd;font-style:italic">suffix&lt;/span>&amp;gt;,%&amp;lt;&lt;span style="color:#8be9fd;font-style:italic">replacement&lt;/span>&amp;gt;,&lt;span style="color:#ff79c6">$(&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">var&lt;/span>&lt;span style="color:#ff79c6">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">$(var&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span>&amp;lt;suffix&amp;gt;=&amp;lt;replacement&amp;gt;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="使用-shell-变量">使用 shell 变量&lt;/h2>
&lt;p>Make 将 &lt;code>$$var&lt;/code> 转义为&lt;code>$var&lt;/code>, 供 shell 处理.&lt;/p>
&lt;p>demo(源自 6.828 根目录&lt;code>GNUmakefile&lt;/code>):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-makefile" data-lang="makefile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">handin-check&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @if &lt;span style="color:#8be9fd;font-style:italic">test&lt;/span> -n &lt;span style="color:#f1fa8c">&amp;#34;`git status -s`&amp;#34;&lt;/span>; &lt;span style="color:#ff79c6">then&lt;/span> &lt;span style="color:#f1fa8c">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&lt;/span> git status -s; &lt;span style="color:#f1fa8c">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">read&lt;/span> -p &lt;span style="color:#f1fa8c">&amp;#34;Untracked files will not be handed in. Continue? [y/N] &amp;#34;&lt;/span> r; &lt;span style="color:#f1fa8c">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">test&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$$&lt;/span>&lt;span style="color:#f1fa8c">r&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">=&lt;/span> y; &lt;span style="color:#f1fa8c">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&lt;/span> &lt;span style="color:#ff79c6">fi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>以上 demo 还使用了 test 命令来终止 make 的执行, 如果用户没有输入&lt;code>y&lt;/code>, make 将会终止执行&lt;/p>
&lt;/blockquote>
- https://wangloo.github.io/posts/c/makefile_tricks/ - @2019 Notepadium.</description></item><item><title>Uboot: 常用命令</title><link>https://wangloo.github.io/posts/os/uboot/commands/</link><pubDate>Sun, 27 Nov 2022 22:03:48 +0800</pubDate><guid>https://wangloo.github.io/posts/os/uboot/commands/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/os/uboot/commands/ -&lt;hr>
&lt;p>..&lt;/p>
&lt;h2 id="环境变量相关">环境变量相关&lt;/h2>
&lt;h2 id="内存操作">内存操作&lt;/h2>
&lt;h2 id="网络操作">网络操作&lt;/h2>
&lt;h2 id="emmc和sd卡">EMMC和SD卡&lt;/h2>
&lt;h2 id="boot操作指令">BOOT操作指令&lt;/h2>
&lt;h3 id="bootm">bootm&lt;/h3>
&lt;h3 id="go">go&lt;/h3>
&lt;h2 id="其他命令">其他命令&lt;/h2>
&lt;p>启动相关&lt;/p>
&lt;p>md&lt;/p>
&lt;p>mmcinfo&lt;/p>
&lt;p>cp&lt;/p>
- https://wangloo.github.io/posts/os/uboot/commands/ - @2019 Notepadium.</description></item><item><title>常用的 shell 命令</title><link>https://wangloo.github.io/posts/shell/shell-commands/</link><pubDate>Sun, 27 Nov 2022 14:45:58 +0800</pubDate><guid>https://wangloo.github.io/posts/shell/shell-commands/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/shell/shell-commands/ -&lt;blockquote>
&lt;p>我使用的 shell 是 Bash&lt;/p>
&lt;/blockquote>
&lt;h3 id="mount-相关">mount 相关&lt;/h3>
&lt;p>&lt;code>mount&lt;/code> 输出当前已经挂在的分区&lt;/p>
&lt;h3 id="where-and-which">where and which&lt;/h3>
&lt;p>which 查看可执行文件的位置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ which python3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/usr/bin/python3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>whereis 除了可执行文件还能搜索其他类型的文件, 不常用, 详见 &lt;code>man whereis&lt;/code>&lt;/p>
&lt;h3 id="--的妙用">&lt;code>-&lt;/code> 的妙用&lt;/h3>
&lt;p>一些命令支持使用 &lt;code>-&lt;/code> 代替文件名, 输入输出都可以:&lt;/p>
&lt;ul>
&lt;li>代替标准输出; 一些命令会将&lt;code>-o/-O&lt;/code> 后面的&lt;code>-&lt;/code>判定为输出到&lt;em>STDOUT&lt;/em>, 详见下面示例.&lt;/li>
&lt;li>代替标准输入;&lt;/li>
&lt;/ul>
&lt;p>下面给出两个同时代替输入输出的例子:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 将标准输入(STDIN)的内容作为gcc的输入, 编译后的结果输出到标准输出(STDOUT)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;void foo() {}&amp;#39;&lt;/span> | gcc -x c -o - -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 将下载的文件输出到标准输出, 同时作为tar命令的输入文件, 进行解压&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget -O - &lt;span style="color:#f1fa8c">&amp;#34;https://www.dropbox.com/download?plat=lnx.x86_64&amp;#34;&lt;/span> | tar xzf -
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>&lt;code>-&lt;/code> 如何被解析是&lt;strong>取决于命令的实现&lt;/strong>, 非标准. 比如 &lt;code>cd -&lt;/code> 就有特殊的含义&lt;/p>
&lt;/blockquote>
- https://wangloo.github.io/posts/shell/shell-commands/ - @2019 Notepadium.</description></item><item><title>C语言 'inline' 关键字</title><link>https://wangloo.github.io/posts/c/inline/</link><pubDate>Thu, 24 Nov 2022 01:35:24 +0800</pubDate><guid>https://wangloo.github.io/posts/c/inline/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/c/inline/ -&lt;p>TODO: inline 的发展历程: &lt;a href="https://gustedt.wordpress.com/2010/11/29/myth-and-reality-about-inline-in-c99/">Myth and reality about inline in C99 – Jens Gustedt&amp;rsquo;s Blog (wordpress.com)&lt;/a>&lt;/p>
&lt;h2 id="gnu89">GNU89:&lt;/h2>
&lt;p>函数的&lt;strong>实现&lt;/strong>之前添加不同的关键字:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>inline&lt;/code>: 表明这个函数可能被优化. 如果没有被优化, 编译器就会视为一个常规函数的定义.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>extern inline&lt;/code>: 表明这个函数可能被优化. 如果没有被优化, 编译器就将这个函数的定义&lt;strong>转换为该函数的声明&lt;/strong>, 即 &lt;code>extern inline func();&lt;/code> 因此当此函数被调用时, 可以调用一个外部的函数来替代. 如果没有函数调用它, 那么也可以没有外部的替代函数实现.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>static inline&lt;/code>: 表明这个函数可能被优化. 如果没有被优化, 编译器就会视为一个&lt;strong>常规静态函数&lt;/strong>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="c99">C99:&lt;/h2>
&lt;p>函数的实现之前添加不同的关键字:&lt;/p>
&lt;ul>
&lt;li>&lt;code>inline&lt;/code>: 等效于gnu89中的&lt;code>extern inline&lt;/code>&lt;/li>
&lt;li>&lt;code>extern inline&lt;/code>: 等效于gnu89中的&lt;code>inline&lt;/code>&lt;/li>
&lt;li>&lt;code>static inline&lt;/code>: 与gnu89相同含义.&lt;/li>
&lt;/ul>
&lt;h2 id="c">C++:&lt;/h2>
&lt;p>只有&lt;code>inline&lt;/code>一个关键字, 如果不能优化就定义为普通函数&lt;/p>
&lt;blockquote>
&lt;p>Ref:&lt;/p>
&lt;p>&lt;a href="https://stackoverflow.com/questions/216510/what-does-extern-inline-do/216546#216546">c++ - What does extern inline do? - Stack Overflow&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://gustedt.wordpress.com/2010/11/29/myth-and-reality-about-inline-in-c99/">Myth and reality about inline in C99 – Jens Gustedt&amp;rsquo;s Blog (wordpress.com)&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>&lt;a href="https://github.com/wangloo/inline-c99-gnu89-demo">C demo&lt;/a> 关于以上的各种情况&lt;/p>
&lt;/blockquote>
- https://wangloo.github.io/posts/c/inline/ - @2019 Notepadium.</description></item><item><title>C语言工具宏</title><link>https://wangloo.github.io/posts/c/c-macros/</link><pubDate>Thu, 24 Nov 2022 01:35:24 +0800</pubDate><guid>https://wangloo.github.io/posts/c/c-macros/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/c/c-macros/ -&lt;h3 id="计算数组元素的个数">计算数组元素的个数&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define nelem(array) sizeof(array)/sizeof(array[0])
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>- https://wangloo.github.io/posts/c/c-macros/ - @2019 Notepadium.</description></item><item><title>x86/ARMv8 函数调用约定</title><link>https://wangloo.github.io/posts/os/function-call-conventions/</link><pubDate>Mon, 21 Nov 2022 10:30:35 +0800</pubDate><guid>https://wangloo.github.io/posts/os/function-call-conventions/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/os/function-call-conventions/ -&lt;p>符合调用约定使得调用函数能够正常获取参数, callee结束之后能够回到原来位置继续执行.&lt;/p>
&lt;h2 id="x86-调用约定">X86 调用约定&lt;/h2>
&lt;h3 id="函数调用">函数调用&lt;/h3>
&lt;p>x86架构中, 函数调用以一条&lt;code>call&lt;/code>指令为分界.&lt;/p>
&lt;p>在&lt;code>call&lt;/code>指令执行之前, 所有的参数必须都躺在栈中, 参数入栈的规则是: &lt;strong>第一个参数最后入栈&lt;/strong>.&lt;/p>
&lt;p>另外, 执行&lt;code>call&lt;/code>指令之前, 必须确保栈指针&lt;code>esp&lt;/code>是16-byte对齐. 这项工作是&lt;strong>编译器&lt;/strong>完成的, 如果它判断参数入栈之后的&lt;code>esp&lt;/code> 不满足对齐条件, 则会手动调整&lt;code>esp&lt;/code>使之对齐. 实现方式见下面例子.&lt;/p>
&lt;p>&lt;code>call&lt;/code> 指令的语义是:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">push&lt;/span> pc+&lt;span style="color:#bd93f9">1&lt;/span> &lt;span style="color:#6272a4">;push next insttuction
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>mov pc, func &lt;span style="color:#6272a4">;set pc = new function
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>call&lt;/code> 指令之后的下一条指令就是callee的内容了, 至此就算是进入新函数的地盘.&lt;/p>
&lt;p>但是在执行新的任务之前, callee还需要完成&lt;strong>栈的转换&lt;/strong>, 因为此时使用的栈还是caller的.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">push&lt;/span> ebp &lt;span style="color:#6272a4">;preserve location of caller&amp;#39;s stack
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>mov ebp, esp &lt;span style="color:#6272a4">;new ebp is old esp
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>此时&lt;code>esp&lt;/code>也就是栈指针等于&lt;code>ebp&lt;/code>, 这是callee栈的初始条件&lt;/strong>. 万事俱备, 可以开始执行callee的实际任务了.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>ebp&lt;/code>在整个函数执行过程中是固定的, 好处是: 能够&lt;strong>快速的或者函数参数, 返回地址&lt;/strong>.&lt;/p>
&lt;/blockquote>
&lt;h3 id="函数返回">函数返回&lt;/h3>
&lt;p>callee执行完毕后, 需要返回到caller继续执行. 刚才说过, callee的返回地址在栈中, 所以我们要做的是找到返回地址所在的位置, 然后使&lt;code>pc = 返回地址&lt;/code>. 当然, 还有另一个重要的任务就是&lt;strong>恢复caller的栈&lt;/strong>.&lt;/p>
&lt;p>上述任务的实现使用两条汇编语句就可完成: &lt;code>leave&lt;/code> 和 &lt;code>ret&lt;/code>.&lt;/p>
&lt;p>&lt;code>leave&lt;/code> 负责搞定栈, 其语义为:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">mov&lt;/span> esp, ebp &lt;span style="color:#6272a4">;回滚栈空间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>pop ebp &lt;span style="color:#6272a4">;恢复caller的ebp
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>ret&lt;/code> 负责搞定&lt;code>pc&lt;/code>, 其语义为:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">pop&lt;/span> ebx &lt;span style="color:#6272a4">;取出返回地址
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>mov pc, ebx &lt;span style="color:#6272a4">;jmp to 返回地址
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>ret&lt;/code> 之后, 就算是返回caller的地盘了. 还有一件小事别忘了做: &lt;strong>用于保存参数的栈空间还没有回收&lt;/strong>, 回到caller之后需要先将&lt;code>esp&lt;/code>的位置进行调整.&lt;/p>
&lt;h3 id="example-函数的调用和返回">Example: 函数的调用和返回&lt;/h3>
&lt;p>一个关于函数调用和返回实现的完整例子.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">caller&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Func(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">Func&lt;/span>(&lt;span style="color:#8be9fd">int&lt;/span> a, &lt;span style="color:#8be9fd">int&lt;/span> b, &lt;span style="color:#8be9fd">int&lt;/span> c)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">/* Do something */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>(以下汇编是&lt;strong>AT&amp;amp;T&lt;/strong>格式的, 请见谅).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">; Caller
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#50fa7b">sub&lt;/span> $0x4,&lt;span style="color:#8be9fd;font-style:italic">%esp&lt;/span> &lt;span style="color:#6272a4">;make 16-bytes align before call. 0x4 是由编译器计算的
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>push $0x3 &lt;span style="color:#6272a4">;push 参数, 顺序是从右到左
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>push $0x2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">push&lt;/span> $0x1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">call&lt;/span> &lt;span style="color:#bd93f9">f01000ad&lt;/span> &amp;lt;Func&amp;gt; &lt;span style="color:#6272a4">;Func()&amp;#39;addr is f01000ad
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">;===========&amp;gt;&amp;gt; Turn to callee
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">;Func()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> push &lt;span style="color:#8be9fd;font-style:italic">%ebp&lt;/span> &lt;span style="color:#6272a4">;preserve old ebp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> mov &lt;span style="color:#8be9fd;font-style:italic">%esp&lt;/span>,&lt;span style="color:#8be9fd;font-style:italic">%ebp&lt;/span> &lt;span style="color:#6272a4">;set new ebp, ebp=esp now
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> /* Do something */
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">leave&lt;/span> &lt;span style="color:#6272a4">;restore stack
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> ret &lt;span style="color:#6272a4">;restore instruction point
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">;&amp;lt;&amp;lt;=========== Back to caller
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>add $0x10,&lt;span style="color:#8be9fd;font-style:italic">%esp&lt;/span> &lt;span style="color:#6272a4">;recycle stack(12 bytes parameters plus 4 bytes alignment)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="armv8-调用约定">Armv8 调用约定&lt;/h2>
&lt;p>大体的思想与x86相似, 只是细节有些许不同&lt;/p>
&lt;h3 id="函数调用-1">函数调用&lt;/h3>
&lt;p>ARMv8架构中, 函数调用以一条&lt;code>bl&lt;/code>指令为分界.&lt;/p>
&lt;p>执行&lt;code>bl&lt;/code>指令之前, 需要将参数准备好. 注意, &lt;strong>ARMv8中, 少于8个参数的函数在传参时, 参数是放在x0-x7中&lt;/strong>, 最左边的参数先使用x0, 以此类推. 参数超过8个的情况下才使用栈, 这与x86的方式不同.&lt;/p>
&lt;p>&lt;code>bl&lt;/code>指令保存返回地址, 并跳转到callee执行, 其语义是:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">mov&lt;/span> lr, pc+&lt;span style="color:#bd93f9">1&lt;/span> &lt;span style="color:#6272a4">;preserve return address
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#6272a4">;lr specially used for preservering return addr
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>mov pc, new_func &lt;span style="color:#6272a4">;set pc = new function
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>与x86相同, 跳转到callee之后必须先进行栈的设置, &lt;strong>Arm与x86不同的是它不需要管理栈底寄存器&lt;/strong>. 因为参数大部分是通过寄存器来传递, 返回地址也是存储在&lt;code>lr(x30)&lt;/code>寄存器中, 没必要为了极少的情况来做优化.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">sub&lt;/span> sp, sp, &lt;span style="color:#6272a4">#enough-space
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="函数返回-1">函数返回&lt;/h3>
&lt;p>要完成两件事: (1) 恢复栈 (2)返回原来位置执行&lt;/p>
&lt;p>先说(2), 由于&lt;code>lr&lt;/code>寄存器始终保存返回地址, 直接 &lt;code>mov sp, lr&lt;/code> 就能返回caller继续执行. &lt;strong>这也就是&lt;code>ret&lt;/code>指令的语义&lt;/strong>.&lt;/p>
&lt;p>(1)恢复栈的这件事同x86一样由callee完成,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-asm" data-lang="asm">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">add&lt;/span> sp, sp, &lt;span style="color:#6272a4">#enough-space
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>x86 call 指令执行前需要esp对齐到 16-byte: &lt;a href="https://stackoverflow.com/questions/41971481/what-are-the-following-instructions-after-this-call-assembly">x86 - What are the following instructions after this call (assembly) - Stack Overflow&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/290689333">x86栈帧原理 - 知乎 (zhihu.com)&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>能够正确达到函数调用和返回的实现方式有很多, &lt;strong>不是仅有这一种方式&lt;/strong>, 约定仅仅是一个约定, 大家都这样去做降低了开发的难度.&lt;/p>
- https://wangloo.github.io/posts/os/function-call-conventions/ - @2019 Notepadium.</description></item><item><title>二级指针操作链表</title><link>https://wangloo.github.io/posts/c/pointers-pointers-list/</link><pubDate>Sun, 20 Nov 2022 23:40:30 +0800</pubDate><guid>https://wangloo.github.io/posts/c/pointers-pointers-list/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/c/pointers-pointers-list/ -&lt;p>问题源于我在知乎刷到的一个回答: &lt;a href="https://www.zhihu.com/question/477832027/answer/2044206446">能分享你C指针用得最灵活（飘）的一次吗?&lt;/a>&lt;/p>
&lt;p>文中提到了Linus关于&lt;strong>无头节点单项链表的删除操作&lt;/strong>给出的一种新的思路, 我觉得对理解指针非常有帮助, 所以在这里详细描述一下这件事.&lt;/p>
&lt;p>从我学习数据结构起, 对不含头节点的单向链表的删除操作, 做法常是: 借用&lt;strong>pre指针&lt;/strong>搜索. 这种情况下避免不了对于链表中第一个节点的特判(第一个节点没有pre).&lt;/p>
&lt;p>Linus提到了一种借助&lt;strong>二级指针避免该分支&lt;/strong>的方法.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">remove_if&lt;/span>(node &lt;span style="color:#ff79c6">**&lt;/span> head, remove_fn rm)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> (node&lt;span style="color:#ff79c6">**&lt;/span> curr &lt;span style="color:#ff79c6">=&lt;/span> head; &lt;span style="color:#ff79c6">*&lt;/span>curr; )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node &lt;span style="color:#ff79c6">*&lt;/span> entry &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">*&lt;/span>curr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (rm(entry))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">*&lt;/span>curr &lt;span style="color:#ff79c6">=&lt;/span> entry&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> free(entry);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">&amp;amp;&lt;/span>entry&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>指针的内容就是地址, &lt;code>int *p = a&lt;/code> 也就意味着变量&lt;code>p&lt;/code> 中保存着变量&lt;code>a&lt;/code>的地址. 所以参数&lt;code>head&lt;/code>在内存中的含义为:&lt;/p>
&lt;p>&lt;img src="./mem.png" alt="list的内存布局">&lt;/p>
&lt;p>假如要删除node2, 那么改变&lt;code>*curr&lt;/code>实际上就是&lt;strong>改了node1的&lt;code>next&lt;/code>成员&lt;/strong>.&lt;/p>
- https://wangloo.github.io/posts/c/pointers-pointers-list/ - @2019 Notepadium.</description></item><item><title>大小端问题</title><link>https://wangloo.github.io/posts/os/big-little-endian/</link><pubDate>Thu, 17 Nov 2022 10:30:35 +0800</pubDate><guid>https://wangloo.github.io/posts/os/big-little-endian/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/os/big-little-endian/ -&lt;hr>
&lt;h2 id="大小端问题的由来">大小端问题的由来&lt;/h2>
&lt;p>为什么计算机世界需要区分大小端? &lt;strong>内存里存取的单位是字节&lt;/strong>, 如果所有的数据类型长度都是一个字节, 那就完全不需要大小端了, 每个变量都仅占据单独一个字节.&lt;/p>
&lt;p>例如, 三个变量 &lt;code>a=10, b=20, c=30&lt;/code>, 在内存中的布局可能就是:&lt;/p>
&lt;pre tabindex="0">&lt;code> ┌────────────┐
│ │
│ 10 │ a
├────────────┤
│ │
│ 20 │ b
├────────────┤
│ │
│ 30 │ c
├────────────┤
│ │
│ │
│ │
│ │
│ │
└────────────┘
&lt;/code>&lt;/pre>&lt;p>但是我们最常使用的数据类型肯定有超过一个字节的, &lt;code>int&lt;/code>类型在64位的系统中就占&lt;strong>4个字节&lt;/strong>. 例如变量&lt;code>a=0xaabbccdd&lt;/code>&lt;/p>
&lt;p>一个变量的大小一旦超过4个字节, &lt;strong>内存的存取又是以字节位单位的&lt;/strong>, 那么要把它塞到内存里就必然会产生两种不同存放方式: &lt;strong>先放&lt;code>0xaa&lt;/code>还是先放&lt;code>0xdd&lt;/code>&lt;/strong>&lt;/p>
&lt;p>首先, &lt;code>0xdd&lt;/code>是变量a的低8位, &lt;code>0xaa&lt;/code>是最高8位, 这是确定的.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果先放&lt;code>0xaa&lt;/code>, 即低地址放高位, 就叫做&lt;em>大端&lt;/em>, 如左图;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果先放&lt;code>0xdd&lt;/code>, 即低地址放低位, 就叫&lt;em>小端&lt;/em>, 如右图.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>
start addr of `a` start addr of `a`
┌────────────┐ ┌────────────┐
│ │ │ │
│ aa │ │ dd │
├────────────┤ ├────────────┤
│ │ │ │
│ bb │ │ cc │
├────────────┤ ├────────────┤
│ │ │ │
│ cc │ │ bb │
├────────────┤ ├────────────┤
│ │ │ │
│ dd │ │ aa │
├────────────┤ ├────────────┤
│ │ │ │
│ │ │ │
└────────────┘ └────────────┘
&lt;/code>&lt;/pre>&lt;h2 id="什么情况">什么情况?&lt;/h2>
&lt;p>看下面的代码, 猜测输出的结果&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">unsigned&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> i &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">0x00646c72&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printf(&lt;span style="color:#f1fa8c">&amp;#34;Hello Wo%s&amp;#34;&lt;/span>, &lt;span style="color:#ff79c6">&amp;amp;&lt;/span>i);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>%s&lt;/code> 会按字节一直打印内存中的字符, 直到遇到&lt;code>\0&lt;/code>. 首先打印的字符便是变量&lt;code>i&lt;/code>的地址处的内容.&lt;/p>
&lt;p>如果是小端存储方式, 变量&lt;code>i&lt;/code>的地址处的一个字节值是0x72, 即字符&lt;code>r&lt;/code>. 以此类推, 所以如果CPU的字节序是小端形式, 那么&lt;code>printf&lt;/code>的结果是: Hello world&lt;/p>
&lt;h2 id="大小端形式的优缺点">大小端形式的优缺点&lt;/h2>
&lt;p>小端的优势:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>以不同的长度读取变量非常方便, 不用计算地址. 例如&lt;code>u64 a=0x1234&lt;/code>, 当&lt;code>(u16)a&lt;/code>时, CPU不需要重新计算读取的起始位置, 永远都是变量a的起始地址.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Easily to do mathematical computations “because of the 1:1 relationship between address offset and byte number (offset 0 is byte 0), multiple precision math routines are correspondingly easy to write.”&lt;/p>
&lt;/li>
&lt;/ol>
- https://wangloo.github.io/posts/os/big-little-endian/ - @2019 Notepadium.</description></item><item><title>操作系统——上下文切换</title><link>https://wangloo.github.io/posts/os/context/</link><pubDate>Mon, 14 Nov 2022 22:13:06 +0800</pubDate><guid>https://wangloo.github.io/posts/os/context/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/os/context/ -&lt;p>本文基于&lt;strong>AArch64&lt;/strong>执行环境, 介绍现代操作系统中上下文切换的相关内容.&lt;/p>
&lt;h2 id="什么是上下文">什么是上下文？&lt;/h2>
&lt;p>上下文又称“现场”,&lt;/p>
&lt;h2 id="为什么需要上下文切换">为什么需要上下文切换?&lt;/h2>
&lt;p>(TODO: 为什么说线程是调度的单位?)&lt;/p>
&lt;p>现代操作系统中同时存在着成千上百个线程, 但是一个CPU同一时刻只能运行一个线程, 他们是轮流的占用CPU, 也叫并发执行. (TODO: 如何查看线程切换的间隔?) 线程高频率的切换, 操作系统是如何保证切换到下一个执行的线程时, 它能够继续上次的工作呢?&lt;/p>
&lt;h3 id="什么是上下文-1">什么是上下文?&lt;/h3>
&lt;p>我们正在看一本书的时候如果被其他的事情打断, 返回时为了能够从上次被打断的位置继续读, 就要在被打断的时候记下来当前是读到了哪个第几页的第几行.&lt;/p>
&lt;p>操作系统对待线程也是如此, 需要保存的用于恢复线程执行的信息就称为线程的上下文.&lt;/p>
&lt;p>那么对于线程来说需要记下的内容有什么呢? 寄存器和栈即可. 拿AArch64架构来距离, 线程的上下文就是:&lt;/p>
&lt;ol>
&lt;li>通用寄存器&lt;code>x0-x29&lt;/code>: 函数调用的参数, 某些计算过程的中间值, 都要用到这些寄存器. &lt;strong>线程的执行流可能在任何时候被打断&lt;/strong>, 当然这些内容也不能丢.&lt;/li>
&lt;li>通用寄存器&lt;code>lr(x30)&lt;/code>: &lt;code>lr&lt;/code> 保存着返回地址, 即当前函数结束之后该返回到哪执行.&lt;/li>
&lt;li>栈顶指针 &lt;code>sp&lt;/code>: 栈的重要性无需多言. 但是需要说明的是我们保存栈的方式&lt;strong>并非将栈中的所有内容保存, 而是保存栈的位置&lt;/strong>即可. 因为操作系统有别的机制(TODO), 能够保证即便线程不在执行, 属于该线程的栈也不会被破坏.&lt;/li>
&lt;li>程序计数器 &lt;code>pc&lt;/code>: 被打断的线程如果再次执行, 从哪里执行呢? 显然是被打断指令的下一条(或者重新执行当前). 这个指令的地址当然也需要被保存好.&lt;/li>
&lt;li>PSTATE: 想一下, 有了以上的内容就能够保证线程完整的恢复之前的环境吗? 其他的例如中断是开还是关, 有哪些标志位(NZCV)被设置了. 这些信息在AArch64中是保存在PSTATE的各个字段中.&lt;/li>
&lt;/ol>
&lt;p>如果我们能够有一个适当的逻辑, 在线程切换出去的时候将上下文保存起来, 然后恢复新线程的上下文, 是不是线程切换这件事就能做到了. 如何组织这个保存和恢复的过程在下面会介绍到.&lt;/p>
&lt;h2 id="linux-如何处理上下文切换">Linux 如何处理上下文切换&lt;/h2>
&lt;h2 id="另一种处理上下文切换的思路">另一种处理上下文切换的思路&lt;/h2>
&lt;h2 id="协程的上下文">协程的上下文&lt;/h2>
&lt;p>协程是用户级别的线程,&lt;/p>
&lt;ul>
&lt;li>协程之间的切换不进入内核&lt;/li>
&lt;li>切换协程只能是某个协程&lt;strong>主动放弃控制权&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>我们在这里讨论一下协程切换时需要保存的上下文是否与线程有所不同.&lt;/p>
&lt;p>首先, PC一定属于, 这个毋庸置疑. 其次是栈顶指针sp, &lt;strong>每个协程都有单独的栈&lt;/strong>, 如果不保存栈的位置, 那么协程内部定义局部变量就没法访问了(局部变量的访问指令都是以sp为base的偏移来做的).&lt;/p>
&lt;p>另外, 关于通用寄存器, 由于协程的切换需要主动调用某个函数(通常叫做&lt;code>yield()&lt;/code>), 在函数的最后将PC设置为新协程的上下文PC. 保存当前协程上下文的操作也在这个函数中, 而其参数我们并不关心, 即&lt;code>x0&lt;/code>-&lt;code>x7&lt;/code>没必要保存. 同样的, &lt;strong>caller-saved寄存器也是没必要保存的&lt;/strong>, 因为这些寄存器作为函数调用使用的临时变量, 当再次返回该协程时, PC=yield()返回地址, caller如果关心这些寄存器应当自己执行保存和恢复. 但是&lt;strong>callee-saved寄存器必须要保存到上下文中&lt;/strong>, 因为在yield()中, 我们如果修改了callee-saved寄存器, 就需要在返回时(也就是再次调度到该协程时) 恢复, 这是callee该做的, 也就是上下文中应该有的唯一通用寄存器组.&lt;/p>
- https://wangloo.github.io/posts/os/context/ - @2019 Notepadium.</description></item></channel></rss>