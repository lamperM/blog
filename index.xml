<?xml-stylesheet href="/rss.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Homepage 🌈 on Wangloo's BLOG</title><link>https://wangloo.github.io/</link><description>Recent content in Homepage 🌈 on Wangloo's BLOG</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>@2019 Notepadium.</copyright><lastBuildDate>Thu, 15 Sep 2022 15:14:05 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux 内核数据结构 hlist</title><link>https://wangloo.github.io/posts/os/linux/data_struct/hlist/</link><pubDate>Thu, 11 May 2023 20:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/os/linux/data_struct/hlist/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/os/linux/data_struct/hlist/ -&lt;p>linux 内核为创建【用单链表解决冲突的哈希表】设计了专门的数据结构 hlist。&lt;/p>
&lt;p>hlist 整体来说是带头结点的双向链表，头结点的类型为&lt;code>hlist_head&lt;/code>, 普通节点
的类型为&lt;code>hlist_node&lt;/code>. &lt;strong>为什么要区别两种类型？节约空间&lt;/strong>， 因为哈希表的
表项类型可以是&lt;code>hlist_head&lt;/code>, 它其实不需要&lt;code>prev&lt;/code>指针, 比起一般的结点，一个
哈希表能节约一半的空间。&lt;/p>
&lt;p>所以一个哈希表和头结点的结构可表示为:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">struct&lt;/span> hlist_head {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">struct&lt;/span> hlist_node &lt;span style="color:#ff79c6">*&lt;/span>first;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">struct&lt;/span> hlist_head table[TALBE_SZ];
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="二象性">二象性&lt;/h2>
&lt;p>任何事物都具有二象性，区分两种类型节约空间的空间，也带了一个问题：
&lt;strong>首个&lt;code>hlist_node&lt;/code>结点的&lt;code>prev&lt;/code>指向哪呢？&lt;/strong>&lt;/p>
&lt;p>正常情况下肯定毫不犹豫的指向头结点，即&lt;code>hlist_head&lt;/code>，但注意此时类型是
不同的，&lt;code>prev&lt;/code>不能同时是&lt;code>struct hlist_head*&lt;/code>和&lt;code>struct hlist_node *&lt;/code>。&lt;/p>
&lt;p>解决方案有两个，首先可以使首个结点的&lt;code>prev=NULL&lt;/code>, 这样虽然避免了类型引发的
问题，也能保证功能正确，但是却破坏了一致性，使得操作的复杂度上升，增加了许多
判断分支。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// delelt a node
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">del_node&lt;/span>(&lt;span style="color:#ff79c6">struct&lt;/span> hlist_head &lt;span style="color:#ff79c6">*&lt;/span>head, &lt;span style="color:#ff79c6">struct&lt;/span> hlist_node &lt;span style="color:#ff79c6">*&lt;/span>node)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 这个if 本来是不需要的，甚至参数的head 也不需要传，
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#6272a4">// 更好的处理方式见解决方案2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> (node &lt;span style="color:#ff79c6">==&lt;/span> head&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>first) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>first &lt;span style="color:#ff79c6">=&lt;/span> node&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>prev&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>next &lt;span style="color:#ff79c6">=&lt;/span> node&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (node&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>next) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>next&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>prev &lt;span style="color:#ff79c6">=&lt;/span> node&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>prev;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// insert a node
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">add_node_before&lt;/span>(&lt;span style="color:#ff79c6">struct&lt;/span> hlist_head &lt;span style="color:#ff79c6">*&lt;/span>head, &lt;span style="color:#ff79c6">struct&lt;/span> hlist_node &lt;span style="color:#ff79c6">*&lt;/span>new
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">struct&lt;/span> hlist_node &lt;span style="color:#ff79c6">*&lt;/span>next)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 这个if 本来是不需要的，参数head也是不需要传递的
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> (next &lt;span style="color:#ff79c6">==&lt;/span> head&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>first) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> new&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>prev &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">NULL&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>first &lt;span style="color:#ff79c6">=&lt;/span> new;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> new&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>prev &lt;span style="color:#ff79c6">=&lt;/span> next&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>prev;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> new&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>prev&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>next &lt;span style="color:#ff79c6">=&lt;/span> new;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> new&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>next &lt;span style="color:#ff79c6">=&lt;/span> next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> next&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>prev &lt;span style="color:#ff79c6">=&lt;/span> new;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="更好的解决方案-prev">更好的解决方案: &lt;code>**prev&lt;/code>&lt;/h2>
&lt;p>改变&lt;code>struct hlist_node&lt;/code>的构成，使用二级指针:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">struct&lt;/span> hlist_node {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">struct&lt;/span> hlist_node &lt;span style="color:#ff79c6">*&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">struct&lt;/span> hlist_node &lt;span style="color:#ff79c6">**&lt;/span>pprev;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使得每个结点的&lt;code>pprev = &amp;amp;(prev_node-&amp;gt;next)&lt;/code>, 首先类型是统一的，其次删除和添加
都无需额外的分支了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">del_node&lt;/span>(&lt;span style="color:#ff79c6">struct&lt;/span> hlist_node &lt;span style="color:#ff79c6">*&lt;/span>node)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">*&lt;/span>(node&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>pprev) &lt;span style="color:#ff79c6">=&lt;/span> node&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (node&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>next)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>next&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>pprev &lt;span style="color:#ff79c6">=&lt;/span> node&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>pprev;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">add_node&lt;/span>(&lt;span style="color:#ff79c6">struct&lt;/span> hlist_node &lt;span style="color:#ff79c6">*&lt;/span>new, &lt;span style="color:#ff79c6">struct&lt;/span> hlist_node &lt;span style="color:#ff79c6">*&lt;/span>next)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> new&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>pprev &lt;span style="color:#ff79c6">=&lt;/span> next&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>pprev;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">*&lt;/span>(new&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>pprev) &lt;span style="color:#ff79c6">=&lt;/span> new;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> new&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>next &lt;span style="color:#ff79c6">=&lt;/span> next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> next&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>pprev &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">&amp;amp;&lt;/span>(new&lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>next);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ref:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/360217911">&lt;code>**prev&lt;/code> 可以提高删除的效率&lt;/a>&lt;/li>
&lt;li>stackoverflow&lt;/li>
&lt;/ul>
- https://wangloo.github.io/posts/os/linux/data_struct/hlist/ - @2019 Notepadium.</description></item><item><title>C语言的内存对齐</title><link>https://wangloo.github.io/posts/c/alignment/</link><pubDate>Mon, 08 May 2023 17:19:44 +0800</pubDate><guid>https://wangloo.github.io/posts/c/alignment/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/c/alignment/ -&lt;h2 id="内存对齐为何被需要">内存对齐为何被需要&lt;/h2>
&lt;p>架构规定了数据类型大小的同时，也规定了对这些类型的变量合法访问的对齐要求。
也就是说，变量不能随便的放在内存的任意位置，起始地址必须满足特定的对齐要求，
对不满足要求的变量强行访问就叫做&lt;strong>非对齐访问&lt;/strong>， 非对齐访问通常会触发异常。&lt;/p>
&lt;h3 id="一般数据类型的对齐要求">一般数据类型的对齐要求&lt;/h3>
&lt;p>对于一般的数据类型，比如 int, long, char 这些，要求其变量地址对齐到自身大小，
比如 ARM64 中，int 变量的地址必须对齐到 4 字节，long 变量地址必须对齐到 8 字节等等。&lt;/p>
&lt;p>那么对于&lt;code>*(int *)0x1001 = 1234;&lt;/code>, 这类的内存访问就叫非对齐的内存访问。&lt;/p>
&lt;blockquote>
&lt;p>即 （变量 addr % 变量 size) ！= 0, 就称为非对齐内存访问。&lt;/p>
&lt;/blockquote>
&lt;h3 id="结构体的对齐要求">结构体的对齐要求&lt;/h3>
&lt;p>上面说的还都是一般的数据类型，对于结构体这种复杂的类型，对齐的要求也复杂些。&lt;/p>
&lt;ul>
&lt;li>首先是结构体成员，每个成员都必须满足其自身的对齐要求&lt;/li>
&lt;li>然后是结构体变量自身的起始地址的对齐要求是&lt;strong>其所有成员的最大对齐要求&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>然而两个要求均满足有时候根本不可能，比如一个结构体声明为:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">struct&lt;/span> foo {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">char&lt;/span> mem1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> mem2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">short&lt;/span> mem3;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不可能同时做到 foo 变量和其成员 mem2 同时满足对齐到 4 字节，所以&lt;strong>编译器会依据
上面的两条要求在成员之间添加 padding&lt;/strong>。&lt;/p>
&lt;p>除了变量中间添加 padding 外，在末尾也会添加，&lt;strong>使得结构体数组容易满足对齐需求&lt;/strong>。&lt;/p>
&lt;p>最后 foo 变量在内存中的样子可能是:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">struct&lt;/span> foo {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">char&lt;/span> mem1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">char&lt;/span> _pad1[&lt;span style="color:#bd93f9">3&lt;/span>]; &lt;span style="color:#6272a4">// 保证结构体和成员均对齐正确
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> mem2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">short&lt;/span> mem3;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">char&lt;/span> _pad2[&lt;span style="color:#bd93f9">2&lt;/span>]; &lt;span style="color:#6272a4">// 保证【结构体数组】对齐正确
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>若结构体的成员还是一个结构体，嵌套操作就可以了，编译器可以 handle。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>对于结构体的定义来说，若不想添加 padding，可以使用&lt;code>__attribute((packed))&lt;/code>
来声明。 常用于一些数据包的声明，除非你清楚自己为什么要这么做，要不别用。&lt;/p>
&lt;/blockquote>
&lt;h2 id="如何做到内存对齐">如何做到内存对齐&lt;/h2>
&lt;p>上面一节说明了各个类型的变量对于内存对齐的需求，只要是各个类型变量的地址满足要求了，
对所有变量的访问也就 OK 了。那么&lt;em>如何保证每个变量地址都满足需求呢？&lt;/em>&lt;/p>
&lt;p>对于静态分配的变量，即在编译链接时期就能确定地址，由编译器完成这项工作。编译器保证
分配给这些变量的地址是满足对齐要求的，这个完全不用担心。&lt;/p>
&lt;p>对于运行时动态分配的变量，例如&lt;code>malloc()&lt;/code>接口返回的，其实 malloc 本身不知道要申请
空间的对齐规则，因为它只接受一个 size 作为参数。 所以一般来说，为了保证满足所有的
对齐要求，&lt;code>malloc()&lt;/code> 返回的地址&lt;strong>总是满足最大的对齐请求，即指针的大小 8 字节。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>malloc()&lt;/code> 的实际效果与运行库的实现有关，并不是规定死的。不过我还没有见过不是
按照最大对齐要求分配的实现方法:)&lt;/p>
&lt;/blockquote>
&lt;h2 id="aarch64-对非对齐访问的支持">AArch64 对非对齐访问的支持&lt;/h2>
&lt;p>非对齐访问的结果是&lt;strong>架构定义的&lt;/strong>， 不同的架构可能造成的结果不同：&lt;/p>
&lt;ul>
&lt;li>架构可能支持非对齐访问，成功读取数据&lt;/li>
&lt;li>架构不支持非对齐访问，产生异常&lt;/li>
&lt;/ul>
&lt;p>AArch64 架构支持 16、32、64 和 128 位的非对齐访问，但是有几个前提条件:&lt;/p>
&lt;ul>
&lt;li>关闭系统的对齐检查: &lt;code>SCTLR_ELx.A&lt;/code> bit 来控制&lt;/li>
&lt;li>exclusive load/store 和 load-acuqire/store-release 两类指令必须是对齐访问的
。这就表示构建信号量和其他锁机制时必须是对齐访问的&lt;/li>
&lt;li>非对齐访问仅“普通内存”可用，&amp;quot;&lt;strong>Device memory&lt;/strong>&amp;ldquo;必须是对齐访问的&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>AArch64 非对齐访问的原理是&lt;strong>分解为多次的访存&lt;/strong>，所以&lt;strong>不能保证原子性&lt;/strong>，且性能是较差的。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>虽然 AArch64 支持非对齐访问， 但编译器默认还是会生成满足对齐要求的代码。&lt;/p>
&lt;/blockquote>
- https://wangloo.github.io/posts/c/alignment/ - @2019 Notepadium.</description></item><item><title>AArch64 内存属性与内存类型</title><link>https://wangloo.github.io/posts/armv8/memory_attr/</link><pubDate>Wed, 12 Apr 2023 08:01:33 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/memory_attr/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/armv8/memory_attr/ -&lt;p>有了虚拟内存系统之后，MMU 可以抽象出一些可配置的内存属性。&lt;/p>
&lt;p>例如，配置某个虚拟内存区域为不可执行、不被 cache 等，不可执行的属性
有助于防范攻击，不进入 cache 经常划分给 外设 Memory-mapped 区域。&lt;/p>
&lt;h2 id="设置内存属性">设置内存属性&lt;/h2>
&lt;blockquote>
&lt;p>相关内容可以在 ARMv8 arm 手册 D5.3.3 Attuibute fields in stage 1
VMSAv8-64 Block and Page descriptors 中找到参考&lt;/p>
&lt;/blockquote>
&lt;p>对于每一个表示内存块(block)的页表项，都有两个属性字段: &lt;strong>lower attr 和 upper attr&lt;/strong>.&lt;/p>
&lt;p>以下任何类型或者属性的设置都是通过这两个字段完成的。&lt;/p>
&lt;h2 id="大类-内存类型">大类: 内存类型&lt;/h2>
&lt;p>AArch64 提供两种内存类型: 普通内存和设备内存。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>普通内存会启用架构提供的所有优化技术，例如合并访存、乱序执行等。所以
普通内存有最高的性能，但同时不是那么的“安全”，需要底层人员手动使用
&lt;strong>内存屏障&lt;/strong>等手段保证某些情况下的顺序性要求。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>设备内存，顾名思义，常映射到外设的 Memory-mapped 区域。对于设备来说，
那些提高性能的技术会造成一些问题，例如某些寄存器的配置必须按照顺序，
这时就不能使用乱序执行。设备内存就牺牲了性能，优先保证正确性。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>配置内存类型也是通过页表项中的其中一个属性字段: &lt;code>AttrIndx[2:0]&lt;/code>,
它与系统寄存器&lt;code>MAIR_EL1&lt;/code>配合实现。&lt;/p>
&lt;p>具体表现为: &lt;code>mair_el1&lt;/code>寄存器被划分为 8 个字段，我们为每个字段写入
不同的值可代表不同的内存类型和一些配套属性，具体的真值表可以参见
&lt;code>mair_el1&lt;/code>寄存器的描述。&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>mair_el1&lt;/code>中内存类型配套属性只是属性的一部分，是和设备类型绑定的
那部分。&lt;/p>
&lt;/blockquote>
&lt;h2 id="更细分的描述1-cacheable">更细分的描述(1): cacheable&lt;/h2>
&lt;p>内存支持配置为是否被 cache，这在&lt;code>mair_el1&lt;/code>的字段中配置。&lt;/p>
&lt;p>要注意，&lt;strong>只有普通内存才支持配置是否进入 cache，所有的设备内存
都是 non-cacheable 的&lt;/strong>。&lt;/p>
&lt;h2 id="更细分的描述2-shareable">更细分的描述(2): shareable&lt;/h2>
&lt;p>shareable 说的是一块内存的外部可见性，也可分为 inner/outer
shareable.&lt;/p>
&lt;p>shareable 的设置需要参考此内存的 cacheable 属性:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果一块内存是 cacheable 的，则需要硬件提供 cache 的一致性维护机制。
如果不能保证 cache 的一致性，想要启用 shareable 就必须是 non-cacheable&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于 non-cacheable 的内存，一定是 shareable 的，
不需要配置。因为此时对数据的修改直接操作内存，读取操作亦是如此，一定
是外部可见的&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="更细分的描述x-">更细分的描述(x): &amp;hellip;&lt;/h2>
&lt;p>TODO&lt;/p>
- https://wangloo.github.io/posts/armv8/memory_attr/ - @2019 Notepadium.</description></item><item><title>C语言enum的使用</title><link>https://wangloo.github.io/posts/c/enum/</link><pubDate>Thu, 09 Mar 2023 17:18:57 +0800</pubDate><guid>https://wangloo.github.io/posts/c/enum/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/c/enum/ -&lt;h2 id="枚举类型的优势">枚举类型的优势&lt;/h2>
&lt;p>枚举类型完全可被宏定义替代，类如&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">enum&lt;/span> Furniture {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DOOR &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DESK,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOCK,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>与下面的代码等效&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define DOOR 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define DESK 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define LOCK 3
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么我们如何在两种设计方法中选择呢？在我看来某些情况下使用 enum 会有以下优势：&lt;/p>
&lt;ol>
&lt;li>提高代码键入效率；仅适用于所需变量的值是连续的整数，就像上面的情况，可以只给第一个 DOOR 赋值，其余的值累加。如果首个变量的值要求是 0，甚至每一个都无需显式赋值&lt;/li>
&lt;li>提高代码的可维护性；可以划定范围，编译器也会检查类型是否正确，偶尔会有用&lt;/li>
&lt;li>提高代码的可读性；例如 DOOR, DESK, LOCK&amp;hellip; 都属于家具，均定义在 Furniture 中&lt;/li>
&lt;/ol>
&lt;h2 id="枚举类型所占的大小">枚举类型所占的大小&lt;/h2>
&lt;p>枚举类型所占内存的大小，即枚举变量的大小。&lt;/p>
&lt;p>由于枚举变量的赋值，一次只能存放枚举结构中的某个常数。所以 枚举变量的大小，实质是常数所占内存空间的大小（常数为 int 类型，当前主流的编译器中一般是 32 位机器和 64 位机器中 int 型都是 4 个字节），枚举类型所占内存大小也是这样。&lt;/p>
&lt;p>所以默认情况下，无论枚举变量的值是多少，都是占用 4 个字节。即执行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>printf(&lt;span style="color:#f1fa8c">&amp;#34;sizeof(enum Furniture) = %d&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, &lt;span style="color:#ff79c6">sizeof&lt;/span>(&lt;span style="color:#ff79c6">enum&lt;/span> Furniture));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输入的结果是 4。&lt;/p>
&lt;h3 id="编译选项-fshort-enums">编译选项：-fshort-enums&lt;/h3>
&lt;p>GCC 下关于这个编译选项的介绍：&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>-fshort-enums&lt;/strong>
Allocate to an enum type only as many bytes as it needs for the declared range of possible values. Specifically, the enum type is equivalent to the smallest integer type that has enough room.
Warning: the -fshort-enums switch causes GCC to generate code that is not binary compatible with code generated without that switch. Use it to conform to a non-default application binary interface.&lt;/p>
&lt;/blockquote>
&lt;p>意思是说使用&lt;code>-fshort-enum&lt;/code>s 后，对改枚举类型所占空间的分配就会按照实际变量的占用空间，而非总是 4 字节。&lt;/p>
&lt;p>启用该选项之后，再打印它的 size 就会是 1，因为用 1 个字节就能表示所有枚举变量的值（DOOR=1，DESK=2，LOCK=3）.&lt;/p>
&lt;p>这个“1”不再是固定的，根据其中枚举变量值的不同，动态调整&lt;code>enum Furniture&lt;/code>的大小。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">enum&lt;/span> Furniture {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DOOR &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">256&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DESK,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOCK,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再打印它的 size，结果为 2。因为值 256 无法用 1 个字节存下。&lt;/p>
&lt;h2 id="enum-潜在的可移植性问题">enum 潜在的可移植性问题&lt;/h2>
&lt;p>看似好像启用该选项会节约一定的内存空间，是的。但它也有一定的缺点，其一就是可移植性问题。&lt;/p>
&lt;p>例如你编写的应用在编译时没有启用了该“优化”选项，默认采用 4 字节存储枚举变量。而链接的库文件在编译时却使用了“优化”选项，则库内部此枚举类型的大小可能为 1 字节。若此时恰好你有调用某个库 API，将 enum 变量作为参数进行传递，那么就会发生错误。&lt;/p>
&lt;p>为避免不同库和应用程序使用“优化”选项的差异造成潜在的危险，常用的解决方案是强制使 enum 变量占用 4 个字节，无论其是否开启“优化”。实现方式是在 enum 变量末尾添加一个成员 &lt;code>XXXX_END = 0xFFFFF&lt;/code>，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">enum&lt;/span> Furniture {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DOOR &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DESK,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOCK,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> END &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">0xFFFFF&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>- https://wangloo.github.io/posts/c/enum/ - @2019 Notepadium.</description></item><item><title>C语言的特点与难点</title><link>https://wangloo.github.io/posts/c/feature/</link><pubDate>Thu, 09 Mar 2023 17:18:57 +0800</pubDate><guid>https://wangloo.github.io/posts/c/feature/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/c/feature/ -&lt;h1 id="函数指针">函数指针&lt;/h1>
&lt;h2 id="指针的数组-or-指向数组的指针">指针的数组 or 指向数组的指针?&lt;/h2>
&lt;pre tabindex="0">&lt;code>&amp;gt;&amp;gt; int (*p)[10] p是指针, 指向长度为10的数组. 加括号是为了强调p是一个指针, 区别包含10个指针的array.
&amp;gt;&amp;gt; int *(p[10]) p是数组, 它的元素类型是int *, 加括号是为了强调p是数组.
&amp;gt;&amp;gt; int *p[10] 等效于int *(p[10])
&lt;/code>&lt;/pre>&lt;h2 id="基础架构">基础架构&lt;/h2>
&lt;pre tabindex="0">&lt;code>// 函数指针
&amp;gt;&amp;gt; int (*f)(int) 说明f是一个指向函数的指针, 加括号为了区别返回值为int*的函数
&amp;gt;&amp;gt; f = function; 函数指针的赋值
&amp;gt;&amp;gt; (*f)(x) 函数指针指向函数的调用, 可简化为f(x). 但是容易将f误认为是函数.
// 函数指针的数组
&amp;gt;&amp;gt; int (*(f[10])) (int) f是数组,元素为10个函数指针. 内层括号说明f是数组,外层括号说明元素类型是函数指针
&amp;gt;&amp;gt; int (*f[10]) (int) 与上面等效. 但外层括号不能省略
&amp;gt;&amp;gt; f[0] = function() 赋值
&amp;gt;&amp;gt; (*f[0])() 指向函数的调用, 可简化为f[0]()
// 返回函数指针的函数
&amp;gt;&amp;gt; void (*signal(int sig, ...))(int); signal是一个函数, 参数有sig.... 它的返回值是一个函数指针, 指向任意返回值为void, 参数为int的函数.
&lt;/code>&lt;/pre>&lt;h2 id="typedef帮助理解函数指针">&lt;code>typedef&lt;/code>帮助理解函数指针&lt;/h2>
&lt;p>&lt;code>signal()&lt;/code>是一个系统调用, 用于告诉系统, 当某种特定&amp;quot;软件中断&amp;quot;发生时调用&lt;em>特定的程序&lt;/em>. 它的真正名称应当是: &lt;em>Call that routine when the interrupt comes in&lt;/em>.&lt;/p>
&lt;p>看&lt;code>signal()&lt;/code>的原型, 非常复杂. 根据上面基础架构的铺垫, 可以看出&lt;code>signal()&lt;/code>的返回值是函数指针, 同时它的参数也是一个函数指针. 且这两个函数指针所指向函数的返回值和参数相同.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">void&lt;/span> (&lt;span style="color:#ff79c6">*&lt;/span>signal(&lt;span style="color:#8be9fd">int&lt;/span> sig, &lt;span style="color:#8be9fd">void&lt;/span>(&lt;span style="color:#ff79c6">*&lt;/span>func)(&lt;span style="color:#8be9fd">int&lt;/span>)))(&lt;span style="color:#8be9fd">int&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以借用&lt;code>typedef&lt;/code>表示通用部分.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">typedef&lt;/span> &lt;span style="color:#50fa7b">void&lt;/span> (&lt;span style="color:#ff79c6">*&lt;/span>sighandler_t)(&lt;span style="color:#8be9fd">int&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>而后&lt;code>signal&lt;/code>的声明就是人能看懂的了:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>sighandler_t &lt;span style="color:#50fa7b">signal&lt;/span>(&lt;span style="color:#8be9fd">int&lt;/span> signum, sighandler_t handler);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="c语言标准">C语言标准&lt;/h1>
&lt;p>我们在使用C语言编程时很少有人告诉我们C语言各个标准的情况，于是我们在看见一些函数标定支持的C标准（例如仅支持C99及以后），内心不会有什么波澜。&lt;/p>
&lt;p>我们常见这些C标准：K&amp;amp;R C、ANSI C、ISO C、C89、C99、C11、C18。让我们补充点可能很少使用的知识吧。&lt;/p>
&lt;h2 id="什么是kr-c">什么是K&amp;amp;R C？&lt;/h2>
&lt;p>1978年，丹尼斯•里奇（Dennis Ritchie）和布莱恩•柯林汉（Brian ernighan）合作出版了《C程序设计语言》的第一版。书中介绍的C语言标准也被称作“K&amp;amp;R C”。&lt;/p>
&lt;p>最初的C标准与我们现在用的有较大差别，例如它竟然还不支持void类型！&lt;/p>
&lt;h2 id="什么是ansi-ciso-cc89c90标准">什么是ANSI C、ISO C、C89、C90标准？&lt;/h2>
&lt;p>随着C语言使用得越来越广泛，出现了许多新问题，人们日益强烈地要求对C语言进行标准化。1983年，美国国家标准协会（ANSI）组成了一个委员会，X3J11，为了创立 C 的一套标准。经过漫长而艰苦的过程，该标准于1989年完成，这个版本的语言经常被称作ANSI C，或有时称为C89（为了区别C99）。在1990年，ANSI C标准（带有一些小改动）被美国国家标准协会（ANSI）采纳为ISO/IEC 9899:1990。这个版本有时候称为C90或者ISO C。综上，ANSI C、ISO C、C89、C90其实是同一种标准。&lt;/p>
&lt;p>这一版本的C就更接近我们平常使用的C了，大部分特性都引入了。&lt;/p>
&lt;h2 id="什么是c99标准">什么是C99标准？&lt;/h2>
&lt;p>2000年3月，ANSI 采纳了 ISO/IEC 9899:1999 标准。这个标准通常指C99。&lt;/p>
&lt;p>C99我们最常使用的新特性是：在源代码的中间位置声明变量。&lt;/p>
&lt;h2 id="什么是c11标准">什么是C11标准？&lt;/h2>
&lt;p>C11标准是C语言标准的第三版（2011年由ISO/IEC发布），前一个标准版本是C99标准。与C99相比，C11有哪些变化呢？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">1&lt;/span>、 对齐处理：alignof(T)返回T的对齐方式，aligned_alloc()以指定字节和对齐方式分配内存，头文件&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>stdalign.h&lt;span style="color:#ff79c6">&amp;gt;&lt;/span>定义了这些内容。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">2&lt;/span>、 _Noreturn：_Noreturn 是个函数修饰符，位置在函数返回类型的前面，声明函数无返回值，有点类似于gcc的__attribute__((noreturn))，后者在声明语句尾部。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">3&lt;/span>、 _Generic：_Generic支持轻量级范型编程，可以把一组具有不同类型而却有相同功能的函数抽象为一个接口。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">4&lt;/span>、 _Static_assert()：_Static_assert()，静态断言，在编译时刻进行，断言表达式必须是在编译时期可以计算的表达式，而普通的assert()在运行时刻断言。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">5&lt;/span>、安全版本的几个函数：gets_s()取代了gets()，原因是后者这个I&lt;span style="color:#ff79c6">/&lt;/span>O函数的实际缓冲区大小不确定，以至于发生常见的缓冲区溢出攻击，类似的函数还有其它的。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">6&lt;/span>、 fopen()新模式：fopen()增加了新的创建、打开模式“x”，在文件锁中比较常用。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">7&lt;/span>、 匿名结构体、联合体。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">8&lt;/span>、 多线程：头文件&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>threads.h&lt;span style="color:#ff79c6">&amp;gt;&lt;/span>定义了创建和管理线程的函数，新的存储类修饰符_Thread_local限定了变量不能在多线程之间共享。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">9&lt;/span>、 _Atomic类型修饰符和头文件&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>stdatomic.h&lt;span style="color:#ff79c6">&amp;gt;&lt;/span>。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">10&lt;/span>、改进的Unicode支持和头文件&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>uchar.h&lt;span style="color:#ff79c6">&amp;gt;&lt;/span>。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">11&lt;/span>、quick_exit()：又一种终止程序的方式，当exit()失败时用以终止程序。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">12&lt;/span>、复数宏，浮点数宏。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">13&lt;/span>、time.h新增timespec结构体，时间单位为纳秒，原来的timeval结构体时间单位为毫秒。
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="什么是c18标准">什么是C18标准？&lt;/h2>
&lt;p>C18也称C17是于2018年6月发布的 ISO/IEC 9899:2018 的非正式名称，也是目前（截止到2020年6月）为止最新的 C语言编程标准，被用来替代 C11 标准。&lt;/p>
&lt;p>C17 没有引入新的语言特性，只对 C11 进行了补充和修正。&lt;/p>
&lt;p>​&lt;/p>
&lt;h2 id="如何查看自己程序的c标准版本">如何查看自己程序的C标准版本？&lt;/h2>
&lt;p>使用宏__STDC_VERSION__可以输出当前使用的C标准版本，是一个长整型：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>printf(&lt;span style="color:#f1fa8c">&amp;#34;C std version:%ld&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, __STDC_VERSION__);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>值与标准的对应关系：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>标准&lt;/th>
&lt;th>宏&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>C94&lt;/td>
&lt;td>_&lt;em>STDC_VERSION&lt;/em>_= 199409L&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C99&lt;/td>
&lt;td>_&lt;em>STDC_VERSION&lt;/em>_= 199901L&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C11&lt;/td>
&lt;td>_&lt;em>STDC_VERSION&lt;/em>_= 201112L&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C18&lt;/td>
&lt;td>_&lt;em>STDC_VERSION&lt;/em>_= 201710L&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>​&lt;/p>
&lt;h2 id="如何指定按照某个标准执行编译">如何指定按照某个标准执行编译？&lt;/h2>
&lt;p>以下的介绍只针对GCC，我没有用过别的编译器。&lt;/p>
&lt;p>GCC中可以添加&lt;code>--std=xxx&lt;/code>来指定C标准版本，常用的情况如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">-&lt;/span>std&lt;span style="color:#ff79c6">=&lt;/span>c11 Conform to the ISO &lt;span style="color:#bd93f9">2011&lt;/span> C standard
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">-&lt;/span>std&lt;span style="color:#ff79c6">=&lt;/span>c89 Conform to the ISO &lt;span style="color:#bd93f9">1990&lt;/span> C standard
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">-&lt;/span>std&lt;span style="color:#ff79c6">=&lt;/span>c90 Conform to the ISO &lt;span style="color:#bd93f9">1990&lt;/span> C standard
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">-&lt;/span>std&lt;span style="color:#ff79c6">=&lt;/span>c99 Conform to the ISO &lt;span style="color:#bd93f9">1999&lt;/span> C stand
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">-&lt;/span>std&lt;span style="color:#ff79c6">=&lt;/span>gnu11 Conform to the ISO &lt;span style="color:#bd93f9">2011&lt;/span> C standard with GNU extensions
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">-&lt;/span>std&lt;span style="color:#ff79c6">=&lt;/span>gnu89 Conform to the ISO &lt;span style="color:#bd93f9">1990&lt;/span> C standard with GNU extensions
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">-&lt;/span>std&lt;span style="color:#ff79c6">=&lt;/span>gnu90 Conform to the ISO &lt;span style="color:#bd93f9">1990&lt;/span> C standard with GNU extensions
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">-&lt;/span>std&lt;span style="color:#ff79c6">=&lt;/span>gnu99 Conform to the ISO &lt;span style="color:#bd93f9">1999&lt;/span> C standard with GNU extensions
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>默认情况下，我电脑上的&lt;code>gcc 5.4.0&lt;/code>使用&lt;code>-std-gnu11&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;h2 id="参考目录">参考目录&lt;/h2>
&lt;p>&lt;a href="https://blog.csdn.net/zhengnianli/article/details/87387268">https://blog.csdn.net/zhengnianli/article/details/87387268&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://gcc.gnu.org/onlinedocs/gcc/C-Dialect-Options.html#C-Dialect-Options">C Dialect Options (Using the GNU Compiler Collection (GCC))&lt;/a>&lt;/p>
&lt;h1 id="含糊不清的符号扩展">含糊不清的符号扩展&lt;/h1>
&lt;h2 id="问题出在哪">问题出在哪？&lt;/h2>
&lt;p>下面一段代码会输出什么呢？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">char&lt;/span> c &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">0xff&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> (c &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0xff&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#f1fa8c">&amp;#34;successful&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">printf&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;failed&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>答案是取决于不同的编译器设定：&lt;/p>
&lt;ul>
&lt;li>当编译器将char识别为signed char时，该判断会失败。因为常数0xff被识别为int类型，所以编译器首先要对c进行符号扩展，判断语句&lt;code>c == 0xff&lt;/code>此时等价于&lt;code>(int)c == 0xff&lt;/code>。而对于signed char类型是扩展其最高位，即&lt;code>(int)c=0xffffffff&lt;/code>，if判断失败。&lt;/li>
&lt;li>当编译器将char识别为unsigned char时，判断成功。对于unsigned char类型总是扩展0。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>注：gcc可通过添加编译参数 -fsigned-char/ -funsigned-char来指定编译器如何识别char&lt;/p>
&lt;/blockquote>
&lt;p>同样的问题也存在与位域(bitfiled)中，详见-fsigned-bitfields/-funsigned-bitfields参数。&lt;/p>
&lt;h2 id="如何避免">如何避免？&lt;/h2>
&lt;p>在使用char类型时，根据情况写清楚unsigned/signed char就ok&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">unsigned&lt;/span> &lt;span style="color:#8be9fd">char&lt;/span> c &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">0xff&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> (c &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0xff&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#f1fa8c">&amp;#34;successful&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">printf&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;failed&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="右移和除法">右移和除法&lt;/h1>
&lt;p>你是否有听说过有符号数不能使用右移操作(&lt;code>&amp;gt;&amp;gt;&lt;/code>)来代替除法？ 这篇短文会向你证明它，并尝试向你解释为什么。&lt;/p>
&lt;h2 id="logical-shift-vs-arithmetic-shift">Logical Shift .vs. Arithmetic Shift&lt;/h2>
&lt;p>若你现在有二进制数&lt;code>x=1110B&lt;/code>，对其施加右移操作，请问高位填0还是填1？&lt;/p>
&lt;p>&lt;strong>逻辑移位&lt;/strong>不管造成的影响，总是用0来填充移位操作产生的空缺。但是这样简单的想法在一些情况总会出错。例如若上述x是有符号数，那么简单的填0就会造成错误，起码正负号出错了。&lt;/p>
&lt;p>&lt;strong>算数移位&lt;/strong>支持有符号数的移位操作，在移位后使用&lt;!-- raw HTML omitted -->符号位&lt;!-- raw HTML omitted -->进行填充，结合补码的表示方法，就能实现正确的负数移位操作。&lt;/p>
&lt;p>总结来说：在有符号的场景下，使用算数位移；如果你能保证移位操作是无符号的，那么用逻辑位移也无妨.&lt;/p>
&lt;p>x86汇编代码中，&lt;code>shr&lt;/code>代表逻辑右移指令，&lt;code>sar&lt;/code>代表算数右移指令，我们可以通过以下C代码及其反汇编的结果来更好的理解逻辑移位和算数移位：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#include&lt;/span> &lt;span style="color:#ff79c6">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span style="color:#ff79c6">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#include&lt;/span> &lt;span style="color:#ff79c6">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#ff79c6">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">signed&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> x &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">-&lt;/span>&lt;span style="color:#bd93f9">3&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">unsigned&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> y &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">3&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#ff79c6">&amp;gt;&amp;gt;=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> y &lt;span style="color:#ff79c6">&amp;gt;&amp;gt;=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code class="language-assembly" data-lang="assembly">x:
.long -3
y:
.long 3
main:
push rbp
mov rbp, rsp
mov eax, DWORD PTR x[rip]
sar eax
mov DWORD PTR x[rip], eax
mov eax, DWORD PTR y[rip]
shr eax
mov DWORD PTR y[rip], eax
mov eax, 0
pop rbp
ret
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://godbolt.org/z/K4M4Ko4c7">https://godbolt.org/z/K4M4Ko4c7&lt;/a>&lt;/p>
&lt;h2 id="实践出真知">实践出真知&lt;/h2>
&lt;p>在我作为一个初级程序员的认知中，&lt;code>/2&lt;/code>和&lt;code>&amp;gt;&amp;gt;1&lt;/code>是等价的，甚至一起还听说过后者能够优化代码的效率。但是今天我要告诉你， Definitely wrong!&lt;/p>
&lt;p>或许在遥远的古代，我们使用位移操作真的能够对代码进行加速，但是当下编译器已经足够聪明，如果你真的动手反汇编&amp;quot;&lt;code>/2&lt;/code>&amp;ldquo;的代码，那么你就会知道编译器已经替你优化为了位移操作。&lt;/p>
&lt;p>更糟糕的是，我们要避免使用移位操作来实现除法或者乘法，不仅仅是因为这两者等价，实际上，他们并不是等价的！并且会造成错误！&lt;/p>
&lt;p>考虑如下的C语言代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#include&lt;/span> &lt;span style="color:#ff79c6">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span style="color:#ff79c6">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#include&lt;/span> &lt;span style="color:#ff79c6">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#ff79c6">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">signed&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> x &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">-&lt;/span>&lt;span style="color:#bd93f9">3&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">signed&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> y &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">-&lt;/span>&lt;span style="color:#bd93f9">3&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#ff79c6">&amp;gt;&amp;gt;=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> y &lt;span style="color:#ff79c6">/=&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他们的汇编代码是相同的吗？这里还是拿X86汇编举例：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-assembly" data-lang="assembly">; Following is ‘x &amp;gt;&amp;gt;= 1’
mov eax, #-3 ;x
sar eax
mov x, eax
; Following is ‘y/= 2’
mov eax, #-3 ;y
mov edx, eax
shr edx, 31
add eax, edx
sar eax
mov y, eax
&lt;/code>&lt;/pre>&lt;p>注意：以上的汇编代码省去了一些我认为无关紧要的操作，并不是完全正确的，但是足够表达他们的差别了。&lt;/p>
&lt;p>可以看出，除法比移位多了一步&lt;code>shr edx, 31&lt;/code>过程，下面会探讨这个。&lt;/p>
&lt;p>还有一件使你震惊的事件，&lt;code>x&lt;/code>, &lt;code>y&lt;/code>的值最终是&lt;strong>不同&lt;/strong>的！是的，正是因为那条看似“多余”的&lt;code>shr&lt;/code>指令。&lt;/p>
&lt;h2 id="为什么结果不同">为什么结果不同&lt;/h2>
&lt;p>首先，我们可以确定的一件事是：编译器真的帮我们将除法操作优化为移位。所以，再也不要说你的代码中使用&lt;code>&amp;gt;&amp;gt;&lt;/code>来替代除法是为了增加执行效率了。&lt;/p>
&lt;p>让我们来解释下为什么两者的结果是不同的。&lt;/p>
&lt;p>首先，&lt;code>sar&lt;/code>指令在x86指令集中表示算数右移，这个是我们熟悉的，那么&lt;code>-3&lt;/code>进行算数右移后的结果就是&lt;code>-2&lt;/code>. 意味着&lt;code>&amp;gt;&amp;gt;&lt;/code>是向负无穷舍入的.&lt;/p>
&lt;p>那么除法操作又是在干什么呢? 它是将原值加上其符号位.Demo中使用的数据类型是32位&lt;code>int&lt;/code>.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-assembly" data-lang="assembly">shr edx, 31
add eax, edx
&lt;/code>&lt;/pre>&lt;p>这样做必然改变了原值啊，动手算一下就会知道，&lt;code>-3/2&lt;/code>的结果为&lt;code>-1&lt;/code>. 并且只有负奇数会受影响，对于正数，其符号为0；对于负偶数，其补码的最低位必为0，刚加上的1会被下一步的算数右移丢弃，不对高位产生影响。&lt;/p>
&lt;p>Aha, 差别就是向负无穷舍弃还是向0舍弃，一时间竟然不知道哪个是正确的了。&lt;/p>
&lt;h2 id="我们应该如何做">我们应该如何做&lt;/h2>
&lt;p>根据最新的[C语言标准草案](&lt;a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1336.pdf">ISO/IEC 9899:201x (open-std.org)&lt;/a>) 6.5.7章节，负数的右移操作是implementation-defined，即取决于具体的实现：&lt;/p>
&lt;blockquote>
&lt;p>The result of E1 &amp;raquo; E2 is E1 right-shifted E2 bit positions. If E1 has an unsigned type or if E1 has a signed type and a nonnegative value, the value of the result is the integral part of the quotient of E1 / 2E2. If E1 has a signed type and a negative value, the resulting value is implementation-defined.&lt;/p>
&lt;/blockquote>
&lt;p>因此，理论上它依赖于实现。所以我们在实际应用中为了程序的可移植性，应当避免对有符号数使用移位操作。除非你能确定它的值一定是非负数，在此情况下，请将它用无符号类型来声明。&lt;/p>
&lt;p>对于除法操作，标准中的6.5.5章节规定了，除法操作总是向0舍入. 非常好！&lt;/p>
&lt;blockquote>
&lt;p>When integers are divided, the result of the / operator is the algebraic quotient with any fractional part discarded.&lt;/p>
&lt;/blockquote>
&lt;p>检查你的代码，恢复所有的“优化”乘除法的行为吧！&lt;/p>
- https://wangloo.github.io/posts/c/feature/ - @2019 Notepadium.</description></item><item><title>C语言程序设计的一些经验</title><link>https://wangloo.github.io/posts/c/experience/</link><pubDate>Mon, 27 Feb 2023 19:20:20 +0800</pubDate><guid>https://wangloo.github.io/posts/c/experience/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/c/experience/ -&lt;h2 id="头文件的引用形式">头文件的引用形式&lt;/h2>
&lt;p>C 中引用一个头文件有两种形式 &lt;code>#include &amp;lt;&amp;gt;&lt;/code>和&lt;code>#include &amp;quot;&amp;quot;&lt;/code>，在应用开发中，需要引用一些系统库文件，我们通常使用&lt;code>&amp;lt;&amp;gt;&lt;/code>，对于自己定义的头文件，我们会使用&lt;code>&amp;quot;&amp;quot;&lt;/code>。&lt;/p>
&lt;p>然而对于底层软件的开发，比如说操作系统，用到的库都是自己工程中的文件，那么此时用&lt;code>&amp;quot;&amp;quot;&lt;/code>和&lt;code>&amp;lt;&amp;gt;&lt;/code>有时都能 work，那么它们的区别是什么呢？&lt;/p>
&lt;p>搜索相关关键词得到的结论是: 两种方式的区别是&lt;strong>搜索文件的优先级， &lt;code>&amp;quot;&amp;quot;&lt;/code>优先搜索的当前目录，而&lt;code>&amp;lt;&amp;gt;&lt;/code>优先搜索系统库文件目录&lt;/strong>。对于这个系统库，即那些使用&lt;code>gcc -I&amp;lt;dir&amp;gt;&lt;/code>参数指定的路径。
当然，如果第一优先级位置没有被找到，也会到另一个目录中搜索。这么两种方式均可，实际工程中也有部分人混合使用，毫不在意规则。但是有时会导致一些细节问题，比如说我们经常会用到&lt;code>-MMD&lt;/code>或者类似选项生成目标文件的依赖，方便实现增量编译。此时就可能会产生一些问题。&lt;/p>
&lt;p>假设你有一个头文件&lt;code>inc/father.h&lt;/code>, 它里面会引用&lt;code>inc/child.h&lt;/code>, 对于&lt;strong>根目录下&lt;/strong>的源文件&lt;code>main.c&lt;/code>，其引用语句该如何写呢？以下列出的几种形式都可以，任意的排列组合&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 编译参数: -I. -MMD
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// main.c
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">#include&lt;/span> &lt;span style="color:#ff79c6">&amp;#34;inc/father.h&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#include&lt;/span> &lt;span style="color:#ff79c6">&amp;lt;inc/father.h&amp;gt;&lt;/span>&lt;span style="color:#ff79c6">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// father.h
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">#include&lt;/span> &lt;span style="color:#ff79c6">&amp;#34;inc/child.h&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#include&lt;/span> &lt;span style="color:#ff79c6">&amp;lt;inc/child.h&amp;gt;&lt;/span>&lt;span style="color:#ff79c6">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#include&lt;/span> &lt;span style="color:#ff79c6">&amp;#34;child.h&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#include&lt;/span> &lt;span style="color:#ff79c6">&amp;lt;child.h&amp;gt;&lt;/span>&lt;span style="color:#ff79c6">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>如果 main.c 是使用系统库路径(&lt;code>-I.&lt;/code>)来找到的 father.h, 即上面 main.c 的第 2 种情况，那么其生成依赖文件的形式内容都是&lt;strong>绝对路径&lt;/strong>，包括 father.h 中的引用（因为即便 child.h 是相对路径找到的，相对的也是 father.h，其基准就是绝对路径）。例如:&lt;code>main.o: main.c /home/xx/father.h /home/xx/child.h&lt;/code>&lt;/li>
&lt;li>否则即以相对路径找到 father.h,即上说 main.c 的第 1 种，那么生成 father.h 依赖的方式&lt;strong>一定是相对路径，但 child.h 的形式却取决于其本身&lt;/strong>.
&lt;ul>
&lt;li>也就是说，如果 child.h 的寻找方式是绝对的（上面的第 1,2,4 种），那么依赖文件的形式就是&lt;code>main.o: main.c inc/father.h /home/xx/child.h&lt;/code>.&lt;/li>
&lt;li>如果 child.h 的寻找方式是相对的(上面的第 3 种)，那么依赖文件的形式是&lt;code>main.o: main.c inc/father.h inc/child.h&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>依赖文件的形式很重要，最简单的方式是均使用绝对路径，此时不需要考虑依赖文件在 makefile 中 include 的位置，也就是不需要考虑 make 的“当前路径”。如果非得使用相对路径，那么已经要确定能够 makefile 中 include 时的 make 当前路径就是生成依赖文件的路径，否则不能建立正确的依赖关系。&lt;/p>
&lt;p>实际上，在“基础架构”优秀的项目中，不可能出现或者尽量避免出来两种形式都能找到头文件的情况。比如说，我们会将源文件统一放在子目录&lt;code>src/&lt;/code>下与头文件隔离，这样就从根本上避免了相对依赖的生成，只能通过系统库的形式来找头文件。拿上面的例子来说，正确的方式是：main.c 放入 src/中，然后不管是源文件还是头文件，都统一使用&lt;code>#include &amp;quot;inc/xxx&amp;quot;&lt;/code>。这样做&lt;strong>即统一，也能保证所有的依赖都是绝对路径形式&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>另外说一点，其实依赖文件(.d)中源文件的依赖项形式也是需要考虑的，这不能通过系统架构来解决，只能用 Makefile 的技巧来实现。比如说，我们的 make 当前目录总是根目录，而在建立 OBJS 变量时为其加上绝对路径的前缀， 从而 make 不需要进入各级子目录，生成的依赖文件也都是相对于根目录的，include 依赖文件的行为也是在根目录进行的，保证统一。&lt;/p>
&lt;/blockquote>
&lt;h2 id="外部库的使用方式">外部库的使用方式&lt;/h2>
&lt;p>最近我在开发项目是, 需要使用到 libelf 库, 我在 Github 上找到了其源代码.&lt;/p>
&lt;p>我之前使用一个 lib 都是以链接的形式使用动态库/静态库, 但是既然它提供了源码, 那么我可以直接将源码拷贝到我的项目中吗? 答案肯定是可以, 那么这两种方案该如何抉择呢?&lt;/p>
&lt;p>在查阅了一些资料后, 我总结了以下几个判断依据:&lt;/p>
&lt;ol>
&lt;li>库的大小/对编译时间的敏感度; 如果使用源代码, 每次编译项目时需要额外对库文件进行编译(起码是第一次), 而库文件的定义是不常修改的, 如果库文件比较大, 则会延长整个项目的编译时间.&lt;/li>
&lt;li>是否需要版本控制; 要使用的库如果需要区分版本, 或者分配给其他的团队成员使用, 那么用库的形式似乎更为方便&lt;/li>
&lt;li>发挥 git submodule 的优势;&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>Ref: &lt;a href="https://softwareengineering.stackexchange.com/questions/313907/should-i-add-the-source-of-libraries-instead-of-linking-to-them">c++ - Should I add the source of libraries instead of linking to them? - Software Engineering Stack Exchange&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="const-修饰符的妙用">&lt;code>const&lt;/code> 修饰符的妙用&lt;/h2>
&lt;p>有些时候, 我们设计的结构体中会有&lt;em>name&lt;/em>字段, 类型是&lt;code>char *&lt;/code>. 在使用时为它分配空间, 不使用时需要回收.&lt;/p>
&lt;p>其实还有另一种情况, 就是&lt;em>name&lt;/em>要指向预先定义好的&amp;quot;static name list&amp;quot;, 适用于 name 的取值是确定的范围. 例如, libdwarf 库中的描述 section name 的&lt;code>dss_name&lt;/code> 成员.&lt;/p>
&lt;p>这时, 为了防止使用者调用&lt;code>free()&lt;/code>来释放它, 我们可以将其声明为&lt;code>const char *&lt;/code>, 此时如果调用&lt;code>free(.dss_name)&lt;/code>, 编译器会给出警告:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>const.c:16:10: warning: passing argument &lt;span style="color:#bd93f9">1&lt;/span> of ‘free’ discards ‘const’ qualifier from pointer target &lt;span style="color:#8be9fd;font-style:italic">type&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span>-Wdiscarded-qualifiers&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#bd93f9">16&lt;/span> | free&lt;span style="color:#ff79c6">(&lt;/span>dss_name&lt;span style="color:#ff79c6">)&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | ^~~~~~~~
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>- https://wangloo.github.io/posts/c/experience/ - @2019 Notepadium.</description></item><item><title>行结束符在windows和linux的区别</title><link>https://wangloo.github.io/posts/c/end-of-line/</link><pubDate>Sat, 24 Dec 2022 01:35:24 +0800</pubDate><guid>https://wangloo.github.io/posts/c/end-of-line/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/c/end-of-line/ -&lt;p>使用VIM 打开一个文件时, 有时会看到例如 &lt;code>^M&lt;/code> 这类字符出现. 下面我会挖一下其出现的原因.&lt;/p>
&lt;h2 id="eol-字符">EOL 字符&lt;/h2>
&lt;p>EOL 或者说 end-of-line 表示一个新行的开始.&lt;/p>
&lt;p>EOL 字符在不同的操作系统中是不同的. 本文中仅以 Linux 和 Windows 为例说明.&lt;/p>
&lt;ul>
&lt;li>Windows中是以读到回车&amp;lt;CR&amp;gt;和换行&amp;lt;LF&amp;gt; 表示 EOL.&lt;/li>
&lt;li>Linux 中仅以换行作为EOL&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;ul>
&lt;li>回车&amp;lt;CR&amp;gt; : Carriage return. 将光标回到行首, 对应C语言中的 &lt;code>\r&lt;/code>&lt;/li>
&lt;li>换行&amp;lt;LF&amp;gt; : Line feed. 将光标下移一行, 对应C语言中的 &lt;code>\n&lt;/code>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 Linux 中打开 Windows 下的文件将多余的回车通常显示成 &lt;code>^M&lt;/code> 或者 &lt;code>Control-M&lt;/code>&lt;/p>
&lt;h2 id="ref">Ref&lt;/h2>
&lt;p>&lt;a href="https://peterbenjamin.com/seminars/crossplatform/texteol.html">End Of Line Characters&lt;/a>&lt;/p>
- https://wangloo.github.io/posts/c/end-of-line/ - @2019 Notepadium.</description></item><item><title>浅谈 errno 的线程安全问题</title><link>https://wangloo.github.io/posts/os/errno_thread_safe/</link><pubDate>Wed, 21 Dec 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/os/errno_thread_safe/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/os/errno_thread_safe/ -&lt;p>我始终以为，C库中常用的 &lt;code>errno&lt;/code> 仅是一个全局变量，使用了全局变量就无法保证线程安全了，因为全局变量在所有线程中都是共享的。&lt;/p>
&lt;p>要实现线程安全的&lt;code>errno&lt;/code> 就必须将其设置为&lt;strong>线程私有的变量&lt;/strong>，下面就来看看GCC是如何巧妙的实现的。&lt;/p>
&lt;h2 id="正文">正文&lt;/h2>
&lt;p>现在的&lt;code>errno&lt;/code>定义并非一个全局变量, 而是一个&lt;strong>宏定义&lt;/strong>, 以下是在&lt;code>usr/include/errno&lt;/code>中的声明:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">extern&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#ff79c6">*&lt;/span>&lt;span style="color:#50fa7b">__errno_location&lt;/span> (&lt;span style="color:#8be9fd">void&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6"># define errno (*__errno_location ())
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种方式下其实现原理大概是: &lt;code>__errno_location&lt;/code> 函数返回一个&lt;code>int&lt;/code>指针, 而这个函数的实现中, 返回的就恰好是&lt;strong>实际的&lt;/strong>&lt;code>errno&lt;/code> 变量(与宏同名)的地址, 所以对其&lt;strong>解引用&lt;/strong>就相当于对其值进行操作. 所以, 这种定义规则下, 左值和右值表达式均成立.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>errno &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">10&lt;/span>; &lt;span style="color:#6272a4">// *__errno_location () = 10
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#8be9fd">int&lt;/span> x &lt;span style="color:#ff79c6">=&lt;/span> errno; &lt;span style="color:#6272a4">// x = *__errno_location ();
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>__errno_location&lt;/code> 的实现就至关重要, 因为如果其返回的变量地址不包含任何技巧的话, 就和原先直接定义全局变量的方式没差了, &lt;strong>说到底能否实现线程安全, 还得看实际保存errno的变量是否为线程独有的&lt;/strong>. 目前还没有发掘到其精髓, 只是套壳而已.&lt;/p>
&lt;p>以下给出&lt;code>/csu/errno-loc.c&lt;/code>中&lt;code>__errno_location&lt;/code> 的实现, 与我们预期一致, 返回变量的地址. 而同名变量&lt;code>errno&lt;/code>则定义在&lt;code>/csu/errno.c&lt;/code>中, &lt;strong>决定了能够实现errno的线程安全&lt;/strong>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#ff79c6">*&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">__errno_location&lt;/span> (&lt;span style="color:#8be9fd">void&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">&amp;amp;&lt;/span>errno;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>__thread &lt;span style="color:#8be9fd">int&lt;/span> errno;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;ldquo;&lt;code>__thread&lt;/code>&amp;rdquo; 是GCC提供的扩展前缀, 表示该变量将被库处理为线程私有的, 注意这一步是C库完成的, 对程序员透明. 相关的理论叫 &lt;em>Thread-local Storage&lt;/em>, AArch64 架构实现的原理是利用&lt;code>TPIDR_EL0&lt;/code> 寄存器, 其他架构可以参考&lt;a href="https://akkadia.org/drepper/tls.pdf">此PDF&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>❓ 以上源文件中有注释为 &lt;em>non-threaded&lt;/em>版本的实现, 是代表什么含义呢?&lt;/p>
&lt;/blockquote>
&lt;p>​&lt;/p>
&lt;p>虽然我暂时没有查阅到errno的其他线程安全的实现原理, 但起码GCC下该方式这是可行的. 依靠的是&amp;quot;&lt;code>__thread&lt;/code>&amp;ldquo;的支持, &lt;strong>与换成宏定义的方式无关&lt;/strong>, 不排除可能为了考虑兼容其他实现方式的可能性.&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;p>&lt;a href="https://stackoverflow.com/questions/18025995/how-is-thread-safe-errno-initialized-if-define-substitutes-errno-symbol">c - How is thread-safe errno initialized if #define substitutes errno symbol? - Stack Overflow&lt;/a>&lt;/p>
- https://wangloo.github.io/posts/os/errno_thread_safe/ - @2019 Notepadium.</description></item><item><title>git 宝典</title><link>https://wangloo.github.io/posts/git/</link><pubDate>Tue, 13 Dec 2022 17:39:42 +0800</pubDate><guid>https://wangloo.github.io/posts/git/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/git/ -&lt;h2 id="合并操作-git-merge">合并操作: git merge&lt;/h2>
&lt;p>merge 有两种方式:&lt;/p>
&lt;ul>
&lt;li>fast-forward&lt;/li>
&lt;li>three-way merger&lt;/li>
&lt;/ul>
&lt;h3 id="fast-forward-merge">Fast-forward Merge&lt;/h3>
&lt;p>假设合并的双方为&lt;code>main&lt;/code>为&lt;code>dev&lt;/code>, 如果其中一个是另一个的祖先, 此时直接移动 HEAD 到前方即可, 称为 fast-forward.&lt;/p>
&lt;p>例如, 当前在 main, 执行&lt;code>git merge dev&lt;/code>的过程如下:&lt;/p>
&lt;pre tabindex="0">&lt;code> main main
| |
M1 --- M2 ===&amp;gt; M1 --- M2 -- F1
\ |
\--- F1 dev
|
dev
&lt;/code>&lt;/pre>&lt;h3 id="three-way-merge">three-way Merge&lt;/h3>
&lt;p>合并的两者不构成直接的祖先-孩子关系, 产生了分叉. 此时进行合并就需要有个基准(参考), 对于两边相较于基准的每个 diff 来说:&lt;/p>
&lt;ul>
&lt;li>合并的两者都在基准上进行了改动, 且改动不一致, &lt;strong>标记为冲突&lt;/strong>&lt;/li>
&lt;li>如果该 diff&lt;strong>仅在其中一方&lt;/strong>有改动, 那么就保留此次改动&lt;/li>
&lt;/ul>
&lt;p>合并时使用的参考就是&lt;strong>两个合并 commit 的最近公共祖先&lt;/strong>, 这种借助三个 commit(main, dev, 公共祖先)才能完成的合并操作就叫做 three-way merge.&lt;/p>
&lt;p>例如, 当前在 main, 执行&lt;code>git merge dev&lt;/code>的过程如下:&lt;/p>
&lt;pre tabindex="0">&lt;code> main main
| |
M1 --- M2 --- M3 ===&amp;gt; M1 --- M2 --- M3 --- M4
\ \ /
\--- F1 \--- F1 ---
| |
dev dev
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>three-way 的合并方式如果发生了冲突, 会产生一次额外的 merge commit, 下面介绍它&lt;/p>
&lt;/blockquote>
&lt;h3 id="什么情况下-merge-commit-没有任何-diff">什么情况下 merge commit 没有任何 diff?&lt;/h3>
&lt;p>按照上面的例子, three-way merge 发生冲突后会产生一次额外的 merge commit, 即 M4. 如果这是去查看 M4 相较前一次 commit 的 diff, 有时是没有的, 有时又会产生 diff.&lt;/p>
&lt;p>如果在解决冲突的过程中, 我们仅仅是接收了 M2,M3 或者 F1 的修改, 那么此时 merge commit 就不会有 diff.&lt;/p>
&lt;p>然而, 在解决冲突时, 我们也可以不采用来自两条路径的修改, 做一次新的修改(可以说, 同时接收两条 diff 就是这种情况), 此时查看 merge commit 的 diff 就是有内容的.&lt;/p>
&lt;h2 id="变基-rebase">变基: rebase&lt;/h2>
&lt;p>rebase 命令需要指定一个&lt;strong>基准分支&lt;/strong>，&lt;code>git rebase &amp;lt;base-branch&amp;gt;&lt;/code>，
rebase 会将当前所处分支整体移动到&lt;code>base-branch&lt;/code>之后，即改变了当前分支的历史。&lt;/p>
&lt;pre tabindex="0">&lt;code>// before rebase
[A]---[B]---[C]---[D]&amp;lt;-dev
\
\--[E]&amp;lt;-master
// after rebase
[A]---[E]---[B]---[C]---[D]&amp;lt;-dev
|
master
&lt;/code>&lt;/pre>&lt;h3 id="交互式-rebase">交互式 rebase&lt;/h3>
&lt;p>交互式 rebase 是一种更高级的用法。基础的 rebase 上面说了是将当前分支的所有提交移动到 base-branch 之后。而交互式 rebase 提供一个方法，在移动之前&amp;quot;挑选&amp;quot;当前分支的 commit。&lt;/p>
&lt;p>实际工程中，通常来说，我们将开发分支移动到 master 之前，可以经过交互 rebase 来整理开发分支中混乱的 commit 记录。&lt;/p>
&lt;p>具体的使用方法是，为&lt;code>git rebase&lt;/code>指令提供&lt;code>-i&lt;/code>参数:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>git checkout dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git rebase -i master
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个命令会打开一个文本编辑器，列出当前 feature 分支的所有提交:&lt;/p>
&lt;pre tabindex="0">&lt;code>pick 33d5b7a Message for commit #1
pick 9480b3d Message for commit #2
pick 5c67e61 Message for commit #3
&lt;/code>&lt;/pre>&lt;p>列出的内容就能完整的表示 dev 分支的所有提交，按照顺序。而我们不仅可以任意的重排这些 commit，而且修改&lt;code>pick&lt;/code>关键字就能对这些 commit 做改动。举个例子，我们可能发现 commit2 只是对于 commit1 做了一个很小的改动，它们完全可以合并为一个 commit，那么直接 commit2 的&lt;code>pick&lt;/code>修改为&lt;code>fixup&lt;/code>，整个内容变为:&lt;/p>
&lt;pre tabindex="0">&lt;code>pick 33d5b7a Message for commit #1
fixup 9480b3d Message for commit #2
pick 5c67e61 Message for commit #3
&lt;/code>&lt;/pre>&lt;p>当你保存并退出这个文件时，改动就会生效，不仅将 dev 整体移动到了 master 后，并且合并了前两个 commit。&lt;/p>
&lt;pre tabindex="0">&lt;code>// after rebase interactive
[A]---[E]---[B]---[D]&amp;lt;-dev
|
master
&lt;/code>&lt;/pre>&lt;h3 id="rebase-整理多个-commit">rebase 整理多个 commit&lt;/h3>
&lt;p>如上面交互式 rebase 所述，当你开发完 dev 分支，需要&lt;code>merge&lt;/code>到 main 分支时，可以先利用交互式 rebase&amp;quot;整理&amp;quot;一下 dev 分支的 commit。&lt;/p>
&lt;p>这里其实要用到一个小 trick，上面说过 rebase 命令需要指定一个 base-branch，实际上是一个 base-commit，这种场景下我们不是要合并其他分支，所以&lt;strong>base-branch&lt;/strong>可以选择当前 dev 分支的前面某一次 commit。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>git checkout dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git rebase -i HEAD~3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上指令实现的功能就是给你整理最后 3 次提交的机会，但&lt;strong>不会合并其他分支的东西&lt;/strong>。&lt;/p>
&lt;p>那如果我想整理整个 dev 分支呢？是向上找到 dev 的第一次 commit 吗？ Git 提供了一个方便找到 dev 分叉出来的那次 commit，将其输出传递给&lt;code>git rebase -i&lt;/code>即可实现整理整个 dev 的所有 commit。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>git merger-base dev main
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="git-merege-vs-git-rebase">&lt;code>git merege&lt;/code> vs &lt;code>git rebase&lt;/code>&lt;/h2>
&lt;h3 id="准则">准则&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>如果分支已经被提交到远程仓库，就不能再改变他的历史了，即不能使用 rebase。
git 也会阻止你这么做，因为分支的历史已经被修改，除非 force-push。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>你能进行 rebase 的分支是本地的”私人分支”，私人表示为: 只有你自己在使用，别人不会基于你的分支做东西。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="dev-同步主分支的改动-rebase">dev 同步主分支的改动: rebase&lt;/h3>
&lt;p>假设我们正在本地的 dev 分支开发一个特性，此时你的同事在 main(也可以是其他的远程分支)上提交了一个重要的 commit，以至于你需要它来继续你的开发任务。&lt;/p>
&lt;p>这种情况我们使用 rebase 和 merge 都能完成目标，但是 rebase 是更好的选择。&lt;/p>
&lt;ul>
&lt;li>首先满足 rebase 的使用条件，我们仅仅是破坏了本地 dev 分支的历史，并没有动到其他的远程分支，所以就不存在干涉别人&lt;/li>
&lt;li>其次，在 dev 上 merge 其他分支会产生一次不必要的&lt;em>merge commit&lt;/em>，其不代表任何实际意义，没必要存在的&lt;/li>
&lt;/ul>
&lt;h3 id="合并-dev-到主分支-merge">合并 dev 到主分支: merge&lt;/h3>
&lt;p>很简单的逻辑，主分支或者其他合作开发的分支并不是你一个人在用，并且需要最后同步到远程仓库，不符合使用 rebase 的准则&lt;/p>
- https://wangloo.github.io/posts/git/ - @2019 Notepadium.</description></item><item><title>GNU 二进制工具集</title><link>https://wangloo.github.io/posts/os/gnu_tools/</link><pubDate>Sat, 03 Dec 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/os/gnu_tools/</guid><description>Wangloo's BLOG https://wangloo.github.io/posts/os/gnu_tools/ -&lt;p>..&lt;/p>
&lt;h2 id="nm---列出符号">nm - 列出符号&lt;/h2>
&lt;p>&lt;a href="https://sourceware.org/binutils/docs/binutils/nm.html">nm (GNU Binary Utilities) (sourceware.org)&lt;/a>&lt;/p>
- https://wangloo.github.io/posts/os/gnu_tools/ - @2019 Notepadium.</description></item></channel></rss>