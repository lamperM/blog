<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Homepage 🌈 on BLOG</title><link>https://wangloo.github.io/</link><description>Recent content in Homepage 🌈 on BLOG</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 15 Sep 2022 15:14:05 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>ARMv8: 内存模型与屏障</title><link>https://wangloo.github.io/posts/armv8/memory_model_and_barrier/</link><pubDate>Sun, 10 Sep 2023 18:02:04 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/memory_model_and_barrier/</guid><description>为什么要关心内存模型 内存模型是一个约定或者规则, 是体系结构决定的，定义了内存的某些属性和行为。 一般各个架构之间有所不同，比如 ARM 会做合并访存、乱序执行这类优化方法。
所以，某些情况下，指令的执行顺序可能不与你程序设计的一模一样，只是为你呈现的结果相同罢了。 当然这里边还有编译器来优化（捣乱 hh）。
一般程序无需关心内存模型带来的差异，除非你从事底层软件开发（嵌入式开发）这种需要和寄存器打交道， 涉及系统底层机制的实现时，你必须按照内存模型来合理的规划你的程序。
各种内存模型 不同的处理器架构有不同的内存模型.
例如, ARM 架构可能优化内存读写指令的顺序, 但是 X86/64 架构通常不会这样做. X86 架构的每次内存加载指令都带有 acquire 语义, 每次写内存都带有 release 语义. ARM 架构就不一定, 拿 ARMv8 来说, 仅有LDRA/STRL指令带有此含义. 我们称类似 ARM 架构行为的内存模型为 Relaxed Memory Model
将 X86/64 上稳定运行的 Lock-free 的代码搬到 ARM 上, 就不一定是可行的.
顺序一致性模型 Sequential Consistency Model 指令的执行顺序总是和可执行文件一致.不论是否存在内存访问指令重排等优化操作.
举个例子,
先写后读内存的模型中, 总是能实现读内存时值是新的(不会被优化成先读后写). 多条ldr指令的执行顺序也是严格按照程序所写 多处理器环境下, 每个核的执行顺序都是可执行文件中的指令顺序. 多核之间的同步需要程序员来保证.
宽松一致性模型 Relaxed Consistency Model 各种优化 buff 叠满，一般加载/存储指令的执行顺序不能保证，需要程序员自行维护。</description></item><item><title>QEMU 工作原理</title><link>https://wangloo.github.io/posts/qemu/1/</link><pubDate>Fri, 08 Sep 2023 16:21:27 +0800</pubDate><guid>https://wangloo.github.io/posts/qemu/1/</guid><description>指令翻译 在 host 上运行 guest 架构代码的能力由 QEMU TCG 模块提供。
TCG 做指令翻译的思路是 “边翻译边执行”， 并且将翻译工作分为前后端，中间会有一层中间指令， 这样能够方便添加对新指令的支持。这个有点类似于现代编译器，也是由类似间结果的流程，称为 IR。
TCG 执行一次翻译的单位是 Translation Block，以分支跳转、页边界为划分条件。</description></item><item><title>操作系统：相关名词汇总</title><link>https://wangloo.github.io/posts/os/abbreviation/</link><pubDate>Fri, 08 Sep 2023 16:21:27 +0800</pubDate><guid>https://wangloo.github.io/posts/os/abbreviation/</guid><description> 名词 含义解释 Unix 起源于BELL实验室的一个操作系统家族, 指代一类OS。
这些OS共同遵守Unix特性，但各个分支在实现上有所不同。
包括SystemV、BSD等分支 SystemV 是Unix的特殊版本，由AT&amp;amp;T公司开发 GNU 目标是开发一个完全自由、开源的OS，借鉴Unix Linux OS内核，借鉴了Linux。后与GNU工具集结合，称为GNU/Linux</description></item><item><title>操作系统：进程间通信方式介绍</title><link>https://wangloo.github.io/posts/os/linux/ipc/linux-ipc/</link><pubDate>Fri, 08 Sep 2023 16:21:27 +0800</pubDate><guid>https://wangloo.github.io/posts/os/linux/ipc/linux-ipc/</guid><description>SystemV IPC Linux 引入了 SystemV 中 IPC 的集中实现方式，包括：信号量、共享内存、消息队列。
共享内存 共享内存基于文件实现，用操作文件的方式来操作共享内存区。
原理是对一块物理内存做多个映射，用引用计数来维护，只有引用计数为0时，才能释放。
共享内存的特点是：
速度快，但自身没有同步功能，需要配合外部的同步机制。 信号量 为什么说信号量也是一种通信机制?
其实通信并不一定就是要发送数据，只要能够相互感知，通知到对方，就算是一种通信。 类比抛媚眼也算是通信的一种。
消息队列 并非基于文件，由自己的一套API，使用起来不方便。 消息队列是面向消息的（并非字节流），消息由类型。 消息队列有自己的同步机制，无需外部添加。 信号 常用于父子之间通信，只要你知道了对方的PID，就可以给对方发信号。
用kill(pid, signal)来发送信号。</description></item><item><title>Cortex-A53: PMU</title><link>https://wangloo.github.io/posts/armv8/pmu/</link><pubDate>Sat, 02 Sep 2023 22:02:04 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/pmu/</guid><description>关于PMU PMU是一个独立的单元，不和体系结构绑定。而是每个SOC都可以不同。比如说Cortex-A53实现了PMUv3架构，但别的基于ARMv8架构的Soc可能实现PMUv4或者其他版本。
PMU内部有六个计数器，所以可以记录六个事件的发生次数。计数器的数值不一定绝对的正确，因为管道的存在，所以一般来说还是通过长时间计数来减弱影响。
PMU和ETM的区别 1. 记录的事件不同 PMU：Cache Miss、分支预测失败、TLB Miss等 ETM：记录分支指令、内存屏障指令等所有指令的执行，包括地址、结果等。 另外还可以记录数据读写的地址、结果（可选）。 2. 记录的粒度不同 PMU：仅用计数器来记录事件发生的次数 ETM：指令的类型、地址、执行结果等。数据访问也类似。 所以说，ETM的信息量大，需要专门的缓存机制。而PMU只需在定时器结束时记录发生的次数就行， 不需要什么缓存，没有实际的数据流。</description></item><item><title>Hugo 主题创建(7): footer</title><link>https://wangloo.github.io/posts/hugo/new_theme_7/</link><pubDate>Sat, 02 Sep 2023 18:39:42 +0800</pubDate><guid>https://wangloo.github.io/posts/hugo/new_theme_7/</guid><description>footer属于 partial模板之一, 创建一个新文件footer.html, 然后在baseof模板中, 指定footer内容显示的位置.
1&amp;lt;body&amp;gt; 2 &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; 3 {{- partial &amp;#34;sidebar.html&amp;#34; . -}} 4 &amp;lt;main class=&amp;#34;container&amp;#34;&amp;gt; 5 {{- block &amp;#34;main&amp;#34; . }} 6 {{- end }} 7 {{- partial &amp;#34;footer.html&amp;#34; . -}} 8 &amp;lt;/main&amp;gt; 9 {{- partial &amp;#34;script.html&amp;#34; . -}} 10 &amp;lt;/div&amp;gt; 11 12&amp;lt;/body&amp;gt; 下面将按照功能划分, 添加各种内容到footer模板中.
文件创建和lastmode时间 commit: https://github.com/wangloo/hugo-theme-puer/commit/d263d9af65808ff03b2307abfb4db397ae1bcc2a
文件创建时间是获取的footer中的变量, lastmod其实也可以通过这种方式获取, 但是这样每次修改都要手动更新太复杂, 我们可以借助git追踪的文件的修改时间来作为lastmod, 默认不是这样的, 需要在config.toml中指定.
1[frontmatter] 2 lastmod = [&amp;#39;lastmod&amp;#39;, &amp;#39;:git&amp;#39;, &amp;#39;:fileModTime&amp;#39;, &amp;#39;date&amp;#39;, &amp;#39;publishDate&amp;#39;] 然后就是在footer.html中引用这两个变量即可:
1&amp;lt;HR width=&amp;#34;100%&amp;#34; id=&amp;#34;EOF&amp;#34;&amp;gt; 2 3{{- if not .</description></item><item><title>一道题搞定二分法的细节</title><link>https://wangloo.github.io/posts/algorithm/bsearch/</link><pubDate>Sun, 20 Aug 2023 20:30:35 +0800</pubDate><guid>https://wangloo.github.io/posts/algorithm/bsearch/</guid><description>实际上我做过的二分搜索的题目并不少，但是一直以来没有静下心去研究它的 【循环条件】【边界调整】【返回值】的细节，通过这个题目希望自己能完整、 清晰的了解二分搜索。
题目 https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array
给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。
示例 1：
输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4]
解答(python): 1def searchRange(self, nums: List[int], target: int) -&amp;gt; List[int]: 2 3 if nums == []: 4 return [-1, -1] 5 6 # 第一次二分，确定右边界 7 left, right = 0, len(nums)-1 8 while left &amp;lt;= right: 9 mid = (left + right) // 2 10 if nums[mid] &amp;lt;= target: 11 left = mid+1 12 else: 13 right = mid-1 14 end = right 15 16 # 第二次二分，确定左边界 17 left, right = 0, len(nums)-1 18 while left &amp;lt;= right: 19 mid = (left + right) // 2 20 if nums[mid] &amp;lt; target: 21 left = mid+1 22 else: 23 right = mid-1 24 sta = left 25 26 print(sta, end) 27 if end &amp;lt; 0 or sta &amp;gt; len(nums)-1 or nums[sta] !</description></item><item><title>近期对于摄影的感悟</title><link>https://wangloo.github.io/posts/photo/blog/</link><pubDate>Sun, 20 Aug 2023 20:30:35 +0800</pubDate><guid>https://wangloo.github.io/posts/photo/blog/</guid><description>胶片风格受大众喜爱 富士的价格为什么被炒的越来越高？如果单说是外观，那尼康的zfc、索尼、佳能的一些微单并不输给他很多， 我觉得其中有一个很重要的原因就是富士的胶片模拟风格。
作为一个程序员，我当然知道这些都是软件层面的东西， 其他厂家如果想做是完全可以做的，可能他们对这块也没什么兴趣。不得不承认富士可能在这方面做了一些 功夫，很可能并不单单只是颜色调整而已，它对于高光部分有更加细致的处理。
今天主要想说的是为什么这种古老的风格会再次风靡？，如今数码时代的进步使得一张照片的清晰度、还原真实诚程度飙升， 为何还要去追求这种模糊与做旧呢？这是审美的倒退吗？
我觉得，我们对美的认识或者说定义并不是随着科技的进步而进步的，有一些东西是不需要创新或者说无法进行创新的， 老的、旧的并不一定就差于现代的，衡量美的标准可能就是如此。
那么我就想，其他东西是否也会这样呢？是否在过了几十年几百年的发展之后，我们回过头来再看，还不如原来固有的。 我想中华文化就在这之列，我们盲目的学习西方追求自由、绝对的平等，我相信时间会证明这不是适合中国人的社会风气。</description></item><item><title>Hugo 主题创建(6): shortcode</title><link>https://wangloo.github.io/posts/hugo/new_theme_6/</link><pubDate>Sun, 20 Aug 2023 18:39:42 +0800</pubDate><guid>https://wangloo.github.io/posts/hugo/new_theme_6/</guid><description>shortcode 可以当成是一些对 html 代码块封装的函数，在写 markdown 的时候就会方便一些， 举个例子来说，我有时需要往 post 中插入图片，并调整它的大小，这时候每次都手动写一些 html 简直是太麻烦了，使用 shortcode 就像是调用函数一样，告诉它函数名和必要的参数， 它会在生成网页时自动转换为对应的 html 语法。
shortcode 分为两种：Hugo 默认和自定义的。Hugo 默认支持的 shortcode 有这些 https://gohugo.io/content-management/shortcodes/ ，这里面同时包含了告诉我们如果使用 shortcode 的基本语法。
当然hugo支持创建自定义 shortcode，详细的使用方法可以看这里， https://gohugo.io/templates/shortcode-templates/ ，我会大概说一下。
定义一个新的shortcode，即在layouts/shortcodes/下创建一个新的xxx.html文件，文件名就是你的函数名 这个shortcode会做什么事，就是在这个html中进行实现 插入链接图片 remoteFigure，参考的是diary主题的实现支持调整图片大小、填充样式、对齐、添加图片描述等。
puer 主题的 Github commit</description></item><item><title>C/python: cmp函数应该怎么写</title><link>https://wangloo.github.io/posts/codestyle/cmp-func/</link><pubDate>Sun, 20 Aug 2023 17:59:22 +0800</pubDate><guid>https://wangloo.github.io/posts/codestyle/cmp-func/</guid><description>C 中的qsort, python 中的sorted()很多时间需要自己构造比较的规则，也就是告诉排序函数怎么衡量两个值的大小关系？
TL;DR 升序的写法(C-qsort):
1int cmp(const void *a, const void *b) 2{ 3 return *(int *)a - *(int *)b; 4} 5 6int main(void) 7{ 8 int nums[] = {2, 1, 3, 5, 4}; 9 10 qsort(nums, 5, sizeof(int), cmp); 11 return 0; 12} 升序的写法(python-sorted()):
1from functools import cmp_to_key 2nums = [2, 3, 1, 4, 5] 3 4nums = sorted(nums, key=cmp_to_key(lambda x,y: x-y)) 5print(nums) python3 丢弃了sorted()中的cmp选项， 全部用 key 选项进行指定， 所以需要cmp_to_key进行转换</description></item><item><title>Hugo 主题创建(5): Tag 分类支持</title><link>https://wangloo.github.io/posts/hugo/new_theme_5/</link><pubDate>Tue, 15 Aug 2023 18:39:42 +0800</pubDate><guid>https://wangloo.github.io/posts/hugo/new_theme_5/</guid><description>通过 tag 可以实现对post进行分类，用到的支持是 HUGO Taxonomy Template（分类模板）
原理 实现tag的功能需要完成两类页面的设计： /tags/ 和 /tags/&amp;lt;one-tag&amp;gt;
前者属于 Taxonomy Terms（分类术语）页面，用分类术语模板实现， 后者属于 Taxonomy List （分类列表）页面，用分类列表模板实现，他们都属于 Taxonomy 模板。
不难推测出，分类术语模板规定了如何展现某个分类方式，比如说用云图来展示tag分类方法。 而分类list模板的作用是展示选中某一类之后的页面，比如说在云图中选中了某个tag。
更加详细的描述可以看官方文档: https://gohugobrasil.netlify.app/templates/taxonomy-templates/
设计 正与文档中所说，分类terms模板可以有多个查找的优先级：
/layouts/taxonomy/.terms.html /layouts/_default/terms.html /themes//layouts/taxonomy/.terms.html /themes//layouts/_default/terms.html 这样的好处是，比如说我有两种terms，tag和categories，我想在分类术语页面对这两种分类展示不用的页面， 就可以定义tags.terms.html和categories.terms.html, 而我目前就用terms.html，简单。
分类list模板也是，使用最通用的list.html, 和其他的list公用，并没有对分类list做单独的页面。
对应的 commit: https://github.com/wangloo/hugo-theme-puer/commit/63d8bb762b16a3d4657ba3523d6b6fb38cf5f9ca
上面的commit不小心提交了menu.html, 实际不属于taxonomy的目的，所以在这纠正: https://github.com/wangloo/hugo-theme-puer/commit/0af07f66807b540fd9d3be84e8d7faca7f962c4b</description></item><item><title>ARMv8: cache相关知识</title><link>https://wangloo.github.io/posts/armv8/cache/</link><pubDate>Mon, 14 Aug 2023 22:02:04 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/cache/</guid><description>之前在特斯拉面试的时候被问到了 cache 的 maintain 操作有哪些, 一时间竟想不起一个准确的词来, 这里就再学习一下, 把这个坑填上吧。
可能不会说的很细，目的只是把一些概念复习，做到心中大致有数。
cache 是个硬件 cache 的本质是一种 SRAM, 容量很小, 速度很快(ns 级)。
拿 Cortex-A53 来说，共有三级 Cache：
L1 cache 是 Core 单独的，分为数据 cache 和指令 cache，容量是 KB 级 L2 cache 一般是 cluster 内共享，容量是 MB 级 L3 cache 是所有 core 共享，容量是 MB 级 cache 控制器 单独的 cache 就是一个存储设备，得有一个控制器告诉它存什么以及什么时候存。
cache 控制器的任务举个例子说：比如 cache miss 的时候，需要从主存向 cache 回填数据，然而此时 CPU 那边记着要数据，我们都知道 cache 操作的单位 是 cache line 嘛，但这是 cache 控制器会有限填充一个 cache line 中 CPU 要的那一条（或几条），最后在后台默默填充完剩下的。</description></item><item><title>前端学习: display</title><link>https://wangloo.github.io/posts/html-css/display/</link><pubDate>Fri, 11 Aug 2023 22:02:04 +0800</pubDate><guid>https://wangloo.github.io/posts/html-css/display/</guid><description>display 是规定元素排列方式的属性，总的来说，元素的排列方式可分两种：block 和 inline。
block 的含义是，该元素默认情况下的 width 表现为充满整个父元素，height 表现为根据内容决定。 inline 的含义是，该元素的 width 和 height 都是必须根据内容决定，不能使用显示的width和height来改变。 即便 block 可以去设置 width, 比如为 50%, 但是它永远必须独占一行，下面的元素也不会排到它的空白处， 这就是 block 称之为 block 的原因。
细分来说，其实 display 这个属性共有五种取值： block, inline, inline-block, flex, grid。 我们将依次介绍。
block 默认 display 方式为 block 的标签有: p, h1-h6, div, li 等
inline 默认 display 方式为 inline 的标签有: span, a, strong
inline-block inline-block 是结合了 block 和 inline 的优势：既不必独占一行，又可以调整 width 和 height。
一些 button 经常使用的 display 就是 inline-block。</description></item><item><title>前端学习: position</title><link>https://wangloo.github.io/posts/html-css/position/</link><pubDate>Fri, 11 Aug 2023 21:02:04 +0800</pubDate><guid>https://wangloo.github.io/posts/html-css/position/</guid><description>position 属性决定了一个元素在页面中的排放方式, 通过与 top、bottom、left、right 结合可以决定任一元素在页面中应该在什么位置上。
position 的取值可以是: static/absolute/relative/fixed/sticky ，下面我将依次对他们的使用方法和场景进行介绍。
static static 是元素默认的 position，它使得元素按照顺序排列（什么样的顺序取决于display)。
它不能与 top、bottom 等属性结合，就是最简单的依次排布。
relative relative 与 static 相比，支持了 tom、bottom 这些属性，使得元素在依次排布的同时 能调整相对于上一个元素的位置变化。
据我所知，relative 并不常见。
absolute absolute 也就是我们常称的&amp;quot;绝对定位&amp;quot;， 产生的效果相对于父元素做了一些偏移，而不是上面所说的上一个元素，只有父元素的位置改变，它才按照偏移数值进行改变。 偏移数值的指定通过 top、bottom 来实现。
absolute 可以与 fixed 进行对比，两者相差很小。
absolute 无视 static。上面说 absolute 是基于父元素进行调整，仅当父元素是 static 时例外，absolute 会跳过这一层，找它的爷爷元素。
fixed fixed的含义是使元素的排列始终固定在页面的某个位置，换句话也可以说它总是基于body做relative的 排列。当然，偏移是通过top、bottom给出的。
一些页面的小广告用的排列就是fixed。
sticky sticky像默认的static，但它也有top、bottom等属性值，这些值有特殊含义： 当元素随着页面滚动变化，而使元素的页面绝对位置（相对于body）达到top、bottom值时， 便固定在那不会再移动，使元素永远不会被移动出页面。
看起来就好像是用页面的外框对sticky元素画了一个笼子，它永远跑不出页面之外。
sticky目前被广泛应用与导航栏，只要设置top=0
sticky是新增的属性，某些浏览器支持的可能不是很好</description></item><item><title>Hugo 主题创建(4): 样式打磨</title><link>https://wangloo.github.io/posts/hugo/new_theme_4/</link><pubDate>Fri, 11 Aug 2023 18:39:42 +0800</pubDate><guid>https://wangloo.github.io/posts/hugo/new_theme_4/</guid><description>字体替换 commit: https://github.com/wangloo/hugo-theme-puer/commit/861ca01617c06c83b701506c9a574cc2726d36d8
修改的参考：
一般文字用最近很火的【霞鹜文楷】 代码使用一些比较通用的代码字体，注意用!important提高优先级</description></item><item><title>Hugo 主题创建(3): 站内搜索</title><link>https://wangloo.github.io/posts/hugo/new_theme_3/</link><pubDate>Fri, 11 Aug 2023 16:39:42 +0800</pubDate><guid>https://wangloo.github.io/posts/hugo/new_theme_3/</guid><description> commit:
为什么选择fast search? hugo本身是不支持站内搜索功能的, 如果你写的文章较多就只能按照tag去检索分类. 这样至少也需要三次点击操作, 如果每个页面的边栏或者顶栏有一个搜索框, 能够 搜索文章的内容或者标题、Tag这些，对我来说效率就能得到显著提升。
fast search 是我检索到的目前比较简单、成熟的方案，它的亮点：
最小外部依赖（无需jQuery） 支持实现键盘唤出 无需NPM, grunt等外部工具 无需额外的编译步骤，你只需要像往常一样执行hugo 可以方便地切换到任意可使用json索引的客户端搜索工具 集成 集成的步骤我是参照的这篇文章 , fast search官方也有说明类似的步骤，过程不难，大概可分为：
Add index.json file to layouts/_default Add JSON as additional output format in config.toml Add search.js and fuse.js (downloaded from fusejs.io) to static/js Add searchbox html 到你想布局的位置 对searchbox添加样式文件 具体的步骤看博文或者官方文档就行，这里不赘述。
改动 做了一些让自己舒服的改动：
让搜索框常驻，只是搜索结果可以隐藏(ESC) /聚焦搜索框，和vim相同 简化样式，贴合我的主题 搜索结果只显示title就够 这样以后不论在哪，想要切换到一篇文章只需要两次鼠标（或者两次键盘）就能精准定位并打开，不必使用鼠标的方式可能更有作用哈哈。
TODO 只能搜索标题，不能搜索内容、tag？</description></item><item><title>Hugo 主题创建(2): 添加侧边栏</title><link>https://wangloo.github.io/posts/hugo/new_theme_2/</link><pubDate>Fri, 11 Aug 2023 15:39:42 +0800</pubDate><guid>https://wangloo.github.io/posts/hugo/new_theme_2/</guid><description>commit: https://github.com/wangloo/hugo-theme-puer/commit/32abfccc6bafd3763e07b751f0315a5403c6eaff
与顶栏相比，我更喜欢侧边栏，现在的屏幕纵向空间很宝贵。
本文创建了侧边栏模板的框架，预留了未来实现各种功能的布局，这个过程也是第一次接触partials/ 下的文件的作用——页面的某个组成部分。而_default/下的模板则是描述不同类型的页面。
布局 基于hugo模板的分类思想，侧边栏属于页表的一个部分，所以侧边栏的模板需要放在partials/下， 同理的还有footer、toc、comment等。我们给侧边栏模板起一个名字sidebar.html。
因为想在站点所有的页面（section、single、list）都显示侧边栏， 所以在baseof.html中需要引入sidebar模板：
1&amp;lt;!DOCTYPE html&amp;gt; 2&amp;lt;html&amp;gt; 3 4&amp;lt;head&amp;gt; 5 6 {{- partial &amp;#34;head.html&amp;#34; . -}} 7 &amp;lt;title&amp;gt; 8 {{ block &amp;#34;title&amp;#34; . }} 9 {{ .Site.Title }} 10 {{ end }} 11 &amp;lt;/title&amp;gt; 12&amp;lt;/head&amp;gt; 13 14&amp;lt;body&amp;gt; 15 &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; 16 {{- partial &amp;#34;sidebar.html&amp;#34; . -}} 17 &amp;lt;main class=&amp;#34;container&amp;#34;&amp;gt; 18 {{- block &amp;#34;main&amp;#34; . }} 19 {{- end }} 20 &amp;lt;/main&amp;gt; 21 &amp;lt;/div&amp;gt; 22&amp;lt;/body&amp;gt; 23 24&amp;lt;/html&amp;gt; sidebar.</description></item><item><title>Hugo 主题创建(1): 内置样式</title><link>https://wangloo.github.io/posts/hugo/new_theme_1/</link><pubDate>Fri, 11 Aug 2023 07:39:42 +0800</pubDate><guid>https://wangloo.github.io/posts/hugo/new_theme_1/</guid><description>本次对应的commit，应该属于站点的仓库，因为仅修改 config.toml
代码高亮 hugo 内置一套highlight引擎, 参见官网的描述 , 所以我们只需要对站点的配置文件(注意不是模板的配置文件)进行修改, 就能最简单的实现代码高亮.
如果你需要对其进行自定义, 且将其固化到你的主题中, 那么就可能需要使用highlight.js来完成, 遵循&amp;quot;提前优化是万恶之源&amp;quot;的理论, 暂时使用hugo提供的高亮支持就能符合我们的目标.
这是我的配置文件config.toml中关于代码高亮的启用:
1[markup] 2 [markup.highlight] 3 anchorLineNos = false # 行号格式化为&amp;lt;span&amp;gt; 4 codeFences = true # 代码围栏, 不启用高亮无效 5 guessSyntax = true # 自动推断高亮语言 6 hl_Lines = &amp;#39;&amp;#39; # 突出显示某些特定的行 7 hl_inline = false # 高亮 inline code, ver&amp;gt;=0.101.0 8 lineAnchors = &amp;#39;&amp;#39; #　与 anchorLineNos 配合 9 lineNoStart = 1 # 行号开始 10 lineNos = true # 是否显示行号 11 lineNumbersInTable = true # 生成html中分开行号和代码 12 noClasses = true 13 noHl = false 14 style = &amp;#39;vs&amp;#39; 15 tabWidth = 4 参考 hugo代码高亮引擎描述引导页: https://gohugo.</description></item><item><title>Hugo 主题创建(0): 脚手架</title><link>https://wangloo.github.io/posts/hugo/new_theme_0/</link><pubDate>Thu, 10 Aug 2023 17:39:42 +0800</pubDate><guid>https://wangloo.github.io/posts/hugo/new_theme_0/</guid><description>commit: https://github.com/wangloo/hugo-theme-puer/commit/c014d1fae09eea1fcc44e03c69b6dd4d185f91fd
背景交代 到现在为止我使用hugo也一年多了, 记了几十条的博客，对于使用频率如此高的工具来说， 有一个顺眼的外观、方便的功能布局简直是梦寐以求。
然而，试过了这么多的现有主题，始终没有一个让我觉得满意，可能我的要求过于苛刻：
搜索；我经常需要翻阅之前的博客/笔记，期望可以检索Tag，且不需要二次点击（ 上方直接是一个搜索框而不是一个按钮）。 TOC；要求可是展开显示三级的目录，且布局好看些。 外观；简洁，不花里胡哨，代码高亮看起来舒服。 xxx 所以，既然Hugo是一个开源的、社区环境较好的工具，那么为什么不尝试打造一款属于自己主题呢。
我是一名嵌入式开发工程师，对于前端的知识生疏，希望在良好的社区环境下能帮助我早日完成满足我个人需求的主题。
计划 搭建框架 制作模板，熟悉模板的概念，各个模板负责的区域 在上面的了解过程中逐渐加入对布局的调整，这一块可能需要学习css的知识 观摩学习前人的代码，结合百家之长，磨合出适合自己的布局和功能 开始动手：搭建脚手架 创建的过程可以参考这个博客 , 我主要想按照我的理解对整个框架进行详细的介绍。
目录结构 1. 2├── layouts 3│ ├── 404.html 4│ ├── _default &amp;lt;--- 此次重点研究 5│ │ ├── baseof.html 6│ │ ├── section.html 7│ │ ├── single.html 8│ │ └── list.html 9│ ├── index.html &amp;lt;--- 此次重点研究 10│ └── partials 11│ ├── footer.html 12│ ├── header.</description></item><item><title>openwrt 开发日记</title><link>https://wangloo.github.io/posts/embedded/openwrt/</link><pubDate>Sat, 05 Aug 2023 19:28:12 +0800</pubDate><guid>https://wangloo.github.io/posts/embedded/openwrt/</guid><description>构建 openWRT 我在此步骤失败了，后面项目没有依赖完整的编译过程， 所以可能对你不构成参考
过程可参考官方教程, 编译过程非常长，使用到的工具非常多，这里提供两个优化的思路:
提前安装本地依赖，忘了./scripts/feeds update -a还是./scripts/feeds install -a时需要检查系统的各种依赖, 可以提前统一安装一波.
1sudo apt install g++ 2sudo apt install libncurses5-dev 3sudo apt install zlib1g-dev 4sudo apt install bison 5sudo apt install flex 6sudo apt install unzip 7sudo apt install autoconf 8sudo apt install gawk 9sudo apt install make 10sudo apt install gettext 11sudo apt install gcc 12sudo apt install binutils 13sudo apt install patch 14sudo apt install bzip2 15sudo apt install libz-dev 16sudo apt install asciidoc 17sudo apt install subversion 18sudo apt install python 19sudo apt install git 提前下载dl, dl是默认在编译时下载的一些工具源码, 你可以将他们提前下载好 放到dl/下, 即可省去下载的时间, 特别当你不能翻墙时.</description></item><item><title>开发资料站集合</title><link>https://wangloo.github.io/posts/tools/useful_sites/</link><pubDate>Sat, 05 Aug 2023 19:28:12 +0800</pubDate><guid>https://wangloo.github.io/posts/tools/useful_sites/</guid><description>Architecture ARMv8 寄存器、指令速查：http://hehezhou.cn/arm/ u-boot 克隆仓库
1git clone https://github.com/u-boot/u-boot 交叉编译toolchain Linaro 经常用来编译armv7架构的一些项目。
https://releases.linaro.org/components/toolchain/binaries/
GNU https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads
C GNU 内联汇编 https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C
构建工具 跟我一起写makefile PDF：https://seisman.github.io/how-to-write-makefile/Makefile.pdf
嵌入式开发小工具 网络调试工具 http://free.cmsoft.cn/download/cmsoft/assistant/netassist5.0.3.zip
其他 Emoji cheat sheet https://www.webfx.com/tools/emoji-cheat-sheet/</description></item><item><title>我的开发环境构建指南</title><link>https://wangloo.github.io/posts/tools/dev_env/</link><pubDate>Mon, 17 Jul 2023 19:28:12 +0800</pubDate><guid>https://wangloo.github.io/posts/tools/dev_env/</guid><description>前言 写这篇博客的背景是我实在忍受不了每次换新的开发机器都得费好大的劲来完全恢复以前的环境， 而且，我平常喜欢搜集各种有用的工具、好看的主题，字体这些，如果零零散散的记录，大概率会忘记或者记不得某些细节。
所以，最后期望达到的是能够使我每次在新机器上搭建环境只需要看这一篇文章就可以了。因此这里会记录：
帮助提升开发效率的小工具 好看的字体、主题 配置某些环境的要点及注意事项 🥀 到目前为止，我还未发现一种方式能够完全达到“一键式布置”，这也不是本文的目的。 付出至少半天的时间的一定的，希望未来能发现一种好的方法。
字体 Fira Code 这款字体适合做编程字体，蛮好看的。我在 vscode 和 terminal 下都使用了这款字体。
详情及安装参考github
霞鹜文楷 开源的中文字体，做博客、PPT 不错。
详情及安装参考github
vscode 主题 配置备份 vim vimrc ycm 特别注意 YCM 插件对 python, vim 的版本均有要求。
下载 可以使用 vim-plug 等工具下载, 也可以下载源码然后拷贝到.vim目录下
编译 编译用到 python3, 这里是问题最多的一步
1# 编译并添加对C的提示支持 2python3 install.py --clangd-completer --verbose 3 4Searching Python 3.8 libraries... 5... 6Downloading Clangd from https://github.com/ycm-core/llvm/releases/download/13.0.0/clangd-13.0.0-x86_64-unknown-linux-gnu.tar.bz2... 使用--clangd-completer参数时, 脚本会去下载 clangd-14.0.0-x86_64-unknown-linux-gnu.tar.bz2 文件, 比较慢. 也可以提前根据提示的网站自己手动下载压缩包.</description></item><item><title>面试总结：特斯拉实习</title><link>https://wangloo.github.io/posts/work/tesla/</link><pubDate>Sat, 10 Jun 2023 08:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/work/tesla/</guid><description>上午结束了特斯拉嵌入式实习生-Linux platform的二面，特斯拉实习生 一共有三轮面试，一轮和二轮都是技术面，三面是主管面。 目前我完成了所有的技术面，且不论结果如何，整个面试过程对我而言还是收获颇丰的， 故以此文整理下自己的欠缺的技术知识，希望下次能够表现的更好。
二面 首先，此轮面试的面试官显然比上一轮更有礼貌一些，准时与会+介绍自己，不过有一点 是我开了摄像头他没开，也没有进行说明吧。 不过这些都是小事，我们这次主要谈论 技术的内容。
我在此回顾几个没有回答好的问题，供以后做参考。
ELF 文件的加载流程 原回答
拿到 ELF 存储的地址后，先将头部读出来，长度是固定的。头部有校验字段， maigic number, 然后是确认 ELF 编译的架构，位数是否正确。 确认格式正确后，读取程序头表，其中保存了各个需要加载的段的偏移，根据 base+段偏移能够得到该段的位置，然后根据段属性的不同，选择映射到不同 的区域和属性，例如 text 段映射为 RE, 代码段映射为 RW，清空 BSS 等 说明自己没接触过动态库文件，所以对动态加载不是很熟悉 点评如下: 对段表、程序头表，这些概念的区分还不是很熟，不清楚什么时候用 section table， 什么时候用 program header table. 以前都看过，只是 时间长了不用就忘记了，这一部分需要好好的做下笔记。
全局变量存在哪？谁负责初始化的 原回答
不知道。
全局保量存在的位置：
未初始化的全局变量 ==&amp;gt; bss段 const修饰的全局变量 ==&amp;gt; rodata段 其他已初始化的全局变量 ==&amp;gt; data段 对于已初始化的全局变量的访问，编译时，编译器将值存入data段，访问的指令是通过 相对寻址来做，例如相对于data段开头。对于静态链接来说，编译完成后访问指令的 基地址和偏移都是空，当链接时修改指令，即重定位的过程。
aligned_alloc()设计 这是面试最后的程序设计题，我也是没有做好，后面好歹在面试官的无数次提示中， 写出了一个解，题目很棒，只是自己实习不够，怪不得其他。</description></item><item><title>linux SLAB 内存分配器(3): SLUB/SLOB</title><link>https://wangloo.github.io/posts/os/linux/mem/slab3/</link><pubDate>Fri, 26 May 2023 18:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/os/linux/mem/slab3/</guid><description>slub 和 slob 是基于 slab 思想针对某些场景下的优化实现。
SLUB 当 slab 分配器面对过多的申请需求时，cache 中就会有多个 slab (struct slab), 在以前的 slab 分配器设计中， slab 描述符是放在物理页中的，即物理页的结构为： （slab 描述符+freelist+对象 s）,管理数据结构的开销就比较大。后期 SLUB 首先将 slab 描述符与struct page共用（通过 union 实现）。后面该思想被 SLAB 采纳。 SLAB 中每个 cache node 有三个 list: free, partial, full， 管理起来很麻烦， SLUB 中只有一个 partial 链表。 放弃着色，效果不明显 SLOB SLOB 的设计更加简洁，只有 600 行左右代码（SLAB，SLUB 都是 4000+），适合小内存的嵌入式设备。
SLOB 中没有对象的概念，每个 slab 中分配的小块内存大小可以是不同的， 通过长度+偏移来记录下一个小块内存的位置。
另外，SLOB 基本上放弃了 cache 的思想，系统中通过创建三个全局的链表: small, medium, large, 分别应对&amp;lt;256b, &amp;lt;1k, &amp;lt;PAGESIZE 的请求， slab 直接挂在这三个链表上，因为 slab 中的内存分配大小可以不同， 用三个链表可以加速查找。</description></item><item><title>linux SLAB 内存分配器(2): 算法</title><link>https://wangloo.github.io/posts/os/linux/mem/slab2/</link><pubDate>Sat, 20 May 2023 18:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/os/linux/mem/slab2/</guid><description>上一篇介绍了数据结构，这一篇主要介绍 slab 分配器的分配和释放算法。
最外层接口: kmalloc()/kfree() 最上层的接口是kmalloc(size, flag)。
slab 分配器维护了多个不同大小的 kmem_cache，放在数组kmem_caches[]中, 其对应的 object 大小和该 kmem_cache 的 name 在另一个数组kmalloc_info[] 中，它们的下标是对应的。使得我们能根据请求分配的大小来找到对应的struct kmem_cache结构。 【代码】
专用的&amp;quot;cache&amp;quot; 上面的结构，会遍历系统初始化创建的一些内存池，来寻找一个大小满足要求的 object， 但是通常不能找到大小相等的，如果系统中存在的固定 cache 中 object 的大小太稀疏， 就容易发生空间浪费的问题。
因此，我们可以为某个特定大小的内存请求再创建一个单独的 cache，仅仅用于满足这一类 结构体的申请，也是符合 slab 分配器关于面向对象的设计思想。
slab 分配器提供的相关接口是:
kmem_cache_create(): 创建一个专用 cache kmem_cache_alloc()： 从指定的 cache 里分配 object kmem_cache_free(): 释放对象到指定的 cache kmem_cache_destory(): 销毁某个 cache Reference https://blog.csdn.net/u010923083/article/details/116518646?spm=1001.2014.3001.5502</description></item><item><title>linux SLAB 内存分配器(1): 概述</title><link>https://wangloo.github.io/posts/os/linux/mem/slab1/</link><pubDate>Sat, 20 May 2023 17:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/os/linux/mem/slab1/</guid><description>参考的 linux kernel 代码版本 4.12
slab 是什么 slab 属于 linux 内核内存分配器的一种，满足细粒度的小块内存的请求。 内核中还有其他的内存分配器例如伙伴系统，它是满足页为单位的分配请求。 因为内核中大部分的分配请求都用不到一个页那么大，所以 slab 的出现能够减小 内存碎片的出现。
另外，非常重要的是，除了基本的小块内存分配， slab 的最初设计开始就基于 对象缓存的思想，加速分配和初始化的过程，下面将详细介绍缓存的设计思想。
slab 分配器的实现在 linux 中是基于伙伴系统的，slab 管理的内存来源 就是伙伴系统，只是进行“二次管理”， 。
slab 的设计思想 对象缓存特性 经常会在 slab 接口中看到kmem_cache这个前缀，我最初也有疑问说 slab 不就是一个内存分配算法，和 cache 扯上什么关系呢？
slab 一般用于分配一些结构的内存，拿struct task来举例，我们通常会为 struct task创建一个内存池，里面包含了若干大小为sizeof(struct task) 的内存块，用的时候从里面取，释放之后回归池子里即可。这是 slab 分配小块内存的 基本思想。
内核中的很多数据结构，我们在申请完空间之后立马做的一件事，就是初始化对象的成员 为某些特定的值，可以称这个过程为结构体(类)的构造函数，意为所有对象都会 做的那些相同的事。比如说，多核环境下很多结构中会有锁，或者链表，那么申请完空间 之后都会做锁或链表做初始化，这是固定的。实际上这些操作消耗的时间甚至大于申请 一块内存。
基于以上事实，slab 分配器做的缓存优化是：为每个类别的内存池都绑定一个构造函数 和析构函数，当用完的对象空间被释放时，调用析构函数将某些成员的值恢复为默认状态 ，这样下次申请的时候，直接拿就行了，省略了重复的初始化流程。而构造函数被调用的 情况仅仅是当该小块内存第一次被申请时。
由于这个思想，整个内存池也就被声明结构 struct kmem_cache, 它是整个 slab 算法的顶层数据结构，其中包含了许多相同大小的小内存块，slab 通过一些算法对其进行 管理。
整体数据结构的规划 上面说了整个系统的顶层结构是struct kmem_cache, 其中可以再划分为多个&amp;quot;slab&amp;quot;, 这个 slab 就能代表一个或多个连续的物理页嘛，从 buddy 申请来的。</description></item><item><title>Linux 中断管理: 软中断/tasklet/工作队列</title><link>https://wangloo.github.io/posts/os/linux/interrupt/softirq/</link><pubDate>Sat, 13 May 2023 20:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/os/linux/interrupt/softirq/</guid><description>软中断、tasklet、工作队列都是中断上下部分离的具体实现方案。
软中断 我们可以将某些中断配置为软中断，相当于建立一张 INTID 到软中断的映射表，这样在 中断到来时就能判断是否为软中断。
这张“表”的建立是静态的，即编译时确定的。key 为 INTID，value 为描述一个软中断 的数据结构，在下面会介绍。
软中断的服务函数必须是可重入的，即多个 CPU 可以同时执行同一个 softirq 的处理函数，涉及到的全局结构可以用 spinlock 钳制。
表示 softirq 的数据结构 struct softirq_action代表一个软中断，系统中所有支持的软中断组成一个数据 softirq_vec[], 所有的软中断按照优先级来分配下标。
1struct softirq_action { 2 // 指向softirq的处理函数 3 void (*action)(struct softirq_action *); 4}; softirq 的中断流程 在中断的上部，如果识别到当前中断是一个 softirq， 那么系统会标记一个软中断发生， 即raise_softirq()函数。其做的事情包括:
标记某个软中断发生，记录的结构是irq_cpustate_t.__softirq_pending (这个字段使loca_softirq_pending()访问) 唤醒ksoftirqd内核线程，之后介绍 光标记不行，那么什么时候执行它们的服务函数呢？
几个可能的检查点:(1) 中断退出前 (2)ksoftirq被唤醒时
如果在检查点发现有标记挂起的 softirq(local_softirq_pending() != 0), 内核调用do_softirq()处理它们：
如何in_interrupt()返回非 0， 直接返回。此时代表要么禁用了 softirq，要么当前是 在中断嵌套的环境下，也可能正在执行do_softirq()时中断嵌套的，而do_softirq() 函数是不能嵌套执行的。 调用__dosoft_irq(), 对于local_softirq_pending()的每一位都调用其 softirq_vec[nr]-&amp;gt;action() 这里有个重要的问题，此时处于中断下部，即开中断的情况，所以在处理 softirq 时会有新的 softirq 到来，这里就有两种策略：</description></item><item><title>Linux 内核数据结构 hlist</title><link>https://wangloo.github.io/posts/os/linux/data_struct/hlist/</link><pubDate>Thu, 11 May 2023 20:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/os/linux/data_struct/hlist/</guid><description>linux 内核为创建【用单链表解决冲突的哈希表】设计了专门的数据结构 hlist。
hlist 整体来说是带头结点的双向链表，头结点的类型为hlist_head, 普通节点 的类型为hlist_node. 为什么要区别两种类型？节约空间， 因为哈希表的 表项类型可以是hlist_head, 它其实不需要prev指针, 比起一般的结点，一个 哈希表能节约一半的空间。
所以一个哈希表和头结点的结构可表示为:
1struct hlist_head { 2 struct hlist_node *first; 3}; 4struct hlist_head table[TALBE_SZ]; 二象性 任何事物都具有二象性，区分两种类型节约空间的空间，也带了一个问题： 首个hlist_node结点的prev指向哪呢？
正常情况下肯定毫不犹豫的指向头结点，即hlist_head，但注意此时类型是 不同的，prev不能同时是struct hlist_head*和struct hlist_node *。
解决方案有两个，首先可以使首个结点的prev=NULL, 这样虽然避免了类型引发的 问题，也能保证功能正确，但是却破坏了一致性，使得操作的复杂度上升，增加了许多 判断分支。
1// delelt a node 2void del_node(struct hlist_head *head, struct hlist_node *node) 3{ 4 // 这个if 本来是不需要的，甚至参数的head 也不需要传， 5 // 更好的处理方式见解决方案2 6 if (node == head-&amp;gt;first) { 7 head-&amp;gt;first = node-&amp;gt;next; 8 } 9 else { 10 node-&amp;gt;prev-&amp;gt;next = node-&amp;gt;next; 11 } 12 13 if (node-&amp;gt;next) { 14 node-&amp;gt;next-&amp;gt;prev = node-&amp;gt;prev; 15 } 16} 17// insert a node 18void add_node_before(struct hlist_head *head, struct hlist_node *new 19 struct hlist_node *next) 20{ 21 // 这个if 本来是不需要的，参数head也是不需要传递的 22 if (next == head-&amp;gt;first) { 23 new-&amp;gt;prev = NULL; 24 head-&amp;gt;first = new; 25 } 26 else { 27 new-&amp;gt;prev = next-&amp;gt;prev; 28 new-&amp;gt;prev-&amp;gt;next = new; 29 } 30 new-&amp;gt;next = next; 31 next-&amp;gt;prev = new; 更好的解决方案: **prev 改变struct hlist_node的构成，使用二级指针:</description></item><item><title>Linux 进程间通信: 管道</title><link>https://wangloo.github.io/posts/os/linux/pipe/</link><pubDate>Thu, 11 May 2023 20:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/os/linux/pipe/</guid><description>管道属于实现进程间通信的一种方式，正如其名，一个进程在一头读，另一个进程在一头写。
管道被看做是打开的文件，但在已安装的文件系统中没有相应的实体，即并不是一个 真正的文件。
管道的创建和使用 可以使用pipe()系统调用来创建一个管道(后面会介绍另一个方式)，其返回一对文件 描述符，一个用来写一个用来读。必须返回两个描述符的原因是： POSIX 只定义了半双工 的管道，所以读写需要两个端口。
POSIX 另外要求使用一个描述符前需要关闭另一个描述符。 但 Linux 中则可以不关闭， 可以实现全双工，但为了可移植性， 一般还是将另一个先关闭。
用ls | more组合命令来解释如何使用pipe()实现通信:
shell 调用pipe(), 返回 fd3(对应读通道),fd4(对应写通道) 两次调用 fork() 创建两个子进程，由于属于不同的地址空间， 所以操作自己的文件描述符不会影响其他进程，但都指向同一个管道 父进程调用close()关闭这两个文件描述符 第一个子进程执行ls程序，其操作如下，
调用dup2(fd4, stdout), 执行文件描述符的拷贝，从此stdout 就代表管道的写通道 由于stdout代表写通道，所以可将 fd3 和 fd4 均关闭 exec()执行ls程序，默认情况下，其输出结果到 stdout， 当下即管道的写通道，即向管道中写了数据 第二个子进程执行more程序，其操作如下：
调用dup2(fd3, stdin), 从此stdin代表管道的读通道 同样可以将 fd3 和 fd4 关闭 exec()执行more程序，由于现在stdin就是管道的读通道, 上面的子进程向管道中写了数据，所以stdin现在有数据，more 可以正常输出 popen(): 更简单的 API 当管道的使用是单向的，即某个进程仅仅想知道另一个进程的执行输出，或者 某个进程想把数据灌入到另一个进程的输入。
此时 Linux C 库中的popen()和pclose()简化使用pipe()中 调用dup2(), close()这些繁琐的步骤。</description></item><item><title>Linux 进程与线程的关系</title><link>https://wangloo.github.io/posts/os/linux/process/thread/</link><pubDate>Wed, 10 May 2023 20:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/os/linux/process/thread/</guid><description>Linux 中其实并不区别进程和线程，都用task_struct来描述，可以说 它们之间的联系大于区别。
创建进程的接口是fork()， 创建线程的接口是pthread_create()， 但是它们最终都是调用的clone()系统调用， 只是参数不同而已。
当一个进程/线程发起创建线程的请求时，不像创建进程那样重新申请mm_struct 和打开的文件等结构， 而是直接将指针赋值为父进程的值，所以它和父进程共享同一个 地址空间这些。
上面说的父进程，因为没有父线程的概念，如果创建线程的task_struct也是一个 线程，那么它的地址空间也是最终指向某个进程的，所以父亲和新的线程就是同等 地位了。
再说说 PID，PID 能够唯一的标识一个进程，一个进程下所有的线程的 PID 都与父进程 相同，那么问题来了，如何标识线程的从属关系呢？
task_struct.tgid标识自己所归属的进程 ID，或者叫主线程 ID，反正就是地址空间 的真正来源。 而进程如何知道自己创建了哪些线程呢？， 通过task_struct.children 链表来查找，但这里面即有子进程又有线程，需要过滤。
有的地方会使用一个名词 管理线程， 其实就是线程共享的地址空间这些的原主。
内核线程 内核线程是一种特殊的进程，当然也是用task_struct来描述，内核线程的特殊点：
mm成员=NULL，没有用户空间的数据，不能访问用户空间 每个内核线程有私有数据，用set_child_tid成员指向， 是一个struct kthread结构，用to_kthread()来访问私有数据 内核线程也像普通线程一样参与调度，其创建的地方在内核，使用kthread_create() 创建，不能由用户态创建。
内核线程一般负责执行一些内核任务，比如软中断 就有一个内核线程，来专门执行到来中断的服务函数中不着急的部分。</description></item><item><title>ARMv8 基础概念</title><link>https://wangloo.github.io/posts/armv8/introduce/</link><pubDate>Tue, 09 May 2023 21:19:01 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/introduce/</guid><description>与 ARMv7 相比的改动 指令集： 新增 A64 指令集， 但也兼容原来的 A32 指令集 权限等级： AArch64 下新增 EL0-EL3 异常等级，对应 V7 的特权等级 通用寄存器：31 个通用寄存器，V7 15 个 虚拟地址长度：64 位的地址长度，理论支持 256TB 的寻址范围</description></item><item><title>C 和 C++ 的区别与联系</title><link>https://wangloo.github.io/posts/c/c_and_cpp/</link><pubDate>Tue, 09 May 2023 20:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/c/c_and_cpp/</guid><description>C++几乎是 C 的超集，只有很少的 C 的特性在 C++中不支持
C++增加了需要方便实现面向对象特性的语法和封装，当然这些用 C 应该也能实现， 只不过 C++使其实现起来更简单。
C++ 改进了一些 C 中的缺点，比如 new 自动计算大小避免出错 C++ 增加一些语法糖，比如迭代器等 C++ 原生支持一些方便的库文件，比如 STL 库</description></item><item><title>Dwarf-数据类型: basetype</title><link>https://wangloo.github.io/posts/c/dwarf/1_basetype/</link><pubDate>Tue, 09 May 2023 16:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/c/dwarf/1_basetype/</guid><description>想要描述一个变量，必须知道它类型信息，才能知道变量的大小、输出的格式等。
Dwarf 为 C 语言定义了一些描述数据类型的 DIE，包括 basetype, array,pointer, structure&amp;hellip;
basetype 今天我们先介绍最简单的 basetype。
basetype 是指那些 C 语言自身定义的基础类型，像int, double这些。
basetype 类型的 DIE 通常有属性:
DW_AT_name: basetype 的名称 DW_AT_byte_size: 该 basetype 占空间大小 下面给出描述int和double的 DIE 展示(还是通过objdump工具输出）：
1 &amp;lt;1&amp;gt;&amp;lt;43&amp;gt;: Abbrev Number: 3 (DW_TAG_base_type) 2 &amp;lt;44&amp;gt; DW_AT_byte_size : 4 3 &amp;lt;45&amp;gt; DW_AT_encoding : 5 (signed) 4 &amp;lt;46&amp;gt; DW_AT_name : int 5 6 &amp;lt;1&amp;gt;&amp;lt;60&amp;gt;: Abbrev Number: 4 (DW_TAG_base_type) 7 &amp;lt;61&amp;gt; DW_AT_byte_size : 8 8 &amp;lt;62&amp;gt; DW_AT_encoding : 4 (float) 9 &amp;lt;63&amp;gt; DW_AT_name : (indirect string, offset: 0x9): double Array 数组表示为 DW_TAG_array 的 DIE，通常含有属性:</description></item><item><title>Dwarf: 基础</title><link>https://wangloo.github.io/posts/c/dwarf/0_basic/</link><pubDate>Tue, 09 May 2023 15:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/c/dwarf/0_basic/</guid><description>Dwarf 把源文件中每个可描述的模块（例如函数，变量，结构体的声明等）描述为一个 DIE (Debugging Information Entry)，所以每个源文件可以描述为若干 DIE 的组合。
每个 DIE 由一个 tag 和若干 attribute-val 键值对构成:
tag: 描述此 DIE 的类型 attribute-val: 描述此 DIE 的一些细节属性，项目根据 DIE 的类型不同而有差别 各个 DIE 之间会相互联系，一个 DIE 可能含有 parent，若干的 child 和 sibling， 它们之间组成树的结构。
查看一个 ELF 的所有 DIE ELF 文件中的所有 DIE 存储在.debug_info section 中，通过 GNU utils 中的objdump工具 可以解析为可阅读的结构:
1objdump --dwarf=info &amp;lt;file&amp;gt; 若我们有一个 demo.c 如下:
1void func(void) { 2 int var_local; 3} 编译为可执行文件后， 执行上述的objdump命令， 可以得到如下的输出（节选）：
1 &amp;lt;1&amp;gt;&amp;lt;68&amp;gt;: Abbrev Number: 5 (DW_TAG_subprogram) 2 &amp;lt;69&amp;gt; DW_AT_external : 1 3 &amp;lt;69&amp;gt; DW_AT_name : (indirect string, offset: 0x32): func 4 &amp;lt;6d&amp;gt; DW_AT_decl_file : 1 5 &amp;lt;6e&amp;gt; DW_AT_decl_line : 3 6 &amp;lt;6f&amp;gt; DW_AT_decl_column : 6 7 &amp;lt;70&amp;gt; DW_AT_prototyped : 1 8 &amp;lt;70&amp;gt; DW_AT_low_pc : 0x1129 9 &amp;lt;78&amp;gt; DW_AT_high_pc : 0xb 10 &amp;lt;80&amp;gt; DW_AT_frame_base : 1 byte block: 9c (DW_OP_call_frame_cfa) 11 &amp;lt;82&amp;gt; DW_AT_GNU_all_call_sites: 1 12 &amp;lt;2&amp;gt;&amp;lt;82&amp;gt;: Abbrev Number: 6 (DW_TAG_variable) 13 &amp;lt;83&amp;gt; DW_AT_name : (indirect string, offset: 0x28): var_local 14 &amp;lt;87&amp;gt; DW_AT_decl_file : 1 15 &amp;lt;88&amp;gt; DW_AT_decl_line : 4 16 &amp;lt;89&amp;gt; DW_AT_decl_column : 9 17 &amp;lt;8a&amp;gt; DW_AT_type : &amp;lt;0x43&amp;gt; 上述例子中节选了两个 DIE，分别是函数func()和局部变量var_local, 可以看到它们的 tag 是不同的，且都具有一系列属性。</description></item><item><title>C语言的内存对齐</title><link>https://wangloo.github.io/posts/c/alignment/</link><pubDate>Mon, 08 May 2023 17:19:44 +0800</pubDate><guid>https://wangloo.github.io/posts/c/alignment/</guid><description>内存对齐为何被需要 架构规定了数据类型大小的同时，也规定了对这些类型的变量合法访问的对齐要求。 也就是说，变量不能随便的放在内存的任意位置，起始地址必须满足特定的对齐要求， 对不满足要求的变量强行访问就叫做非对齐访问， 非对齐访问通常会触发异常。
一般数据类型的对齐要求 对于一般的数据类型，比如 int, long, char 这些，要求其变量地址对齐到自身大小， 比如 ARM64 中，int 变量的地址必须对齐到 4 字节，long 变量地址必须对齐到 8 字节等等。
那么对于*(int *)0x1001 = 1234;, 这类的内存访问就叫非对齐的内存访问。
即 （变量 addr % 变量 size) ！= 0, 就称为非对齐内存访问。
结构体的对齐要求 上面说的还都是一般的数据类型，对于结构体这种复杂的类型，对齐的要求也复杂些。
首先是结构体成员，每个成员都必须满足其自身的对齐要求 然后是结构体变量自身的起始地址的对齐要求是其所有成员的最大对齐要求。 然而两个要求均满足有时候根本不可能，比如一个结构体声明为:
1struct foo { 2 char mem1; 3 int mem2; 4 short mem3; 5}; 不可能同时做到 foo 变量和其成员 mem2 同时满足对齐到 4 字节，所以编译器会依据 上面的两条要求在成员之间添加 padding。
除了变量中间添加 padding 外，在末尾也会添加，使得结构体数组容易满足对齐需求。
最后 foo 变量在内存中的样子可能是:</description></item><item><title>Linux 进程地址空间 堆的管理</title><link>https://wangloo.github.io/posts/os/linux/addrspace/heap/</link><pubDate>Mon, 08 May 2023 10:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/os/linux/addrspace/heap/</guid><description>当进程被创建时，就预留了一块特殊的线性区，其开始地址和结束地址单独保存在 mm_struct.start_brk和mm_strcut.brk成员中，并不由vm_area_struct 链接，这块特殊的线性区就叫堆。
进程使用的malloc()和free()等相关 API 都是操纵的堆空间。
修改堆空间的接口 对用户态进程来说，提供brk()系统调用来修改自身的堆空间。
brk(): 参数addr, 效果是修改mm_struct.brk到 addr，即修改一个堆的结束地址。
brk() 系统调用的实现，在内核态是调用do_mmap()扩充堆，或者do_unmap()缩小堆。 并且移动mm_struct.brk的值而已，这是 brk()的实现。
用户态进程还有一个接口: sbrk(), 参数是字节，代表扩充的字节数。 其下层还是调用的 brk()。
malloc()的实现 进程刚创建时，堆空间的大小为 0， 即bkr==start_brk。
调用malloc()，即对堆空间扩充，上面介绍了修改堆空间的接口， 所以我们可以使用brk()来实现malloc().
对于进程本身来说，只能通过brk()简单的增加/减少堆的总大小，这样做的效率是比较低的。 比如连续执行了三次malloc(), 如果要将中间的地址 free 掉，其实是无法实现的。
而且这种最简单的情况下，每次malloc()都要使用brk()系统调用，效率也是很低的。
所以，通常在 C 库则一层，即malloc()和brk()之间，会有一层对堆内存的管理， 包含碎片回收，内存池等算法来避免频繁的使用系统调用。</description></item><item><title>Linux 进程地址空间 写时复制</title><link>https://wangloo.github.io/posts/os/linux/addrspace/cow/</link><pubDate>Mon, 08 May 2023 09:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/os/linux/addrspace/cow/</guid><description>当前存在的问题 未启用写时复制时，fork()创建子进程地址空间的流程如下:
动态申请子进程的页表 动态申请子进程的物理页面，大小和父进程的相同 创建父进程虚拟地址-新物理页的映射到子进程页表 memcpy()将父进程所有页面拷贝到子进程地址空间下 这样做有什么问题呢？ 在fork()的常规调用环境下，fork()之后 接的一般是exec()类函数，即载入一个新的可执行文件，继续用父进程 的情况不多。
这样的话，上述过程中memcpy()父进程的页面就是多余的，而且如果 父进程比较大，会非常耗时。
写时复制的优化 执行 fork() 时，不给子进程分配新的物理页，而是将父进程的页表项 完全的拷贝到子进程中，结果就是父子进程的虚拟地址指向同一个物理地址。
换句话说，这样做就不需要memcpy()父进程所有的页面，仅仅是memcpy()一份 父进程的页表，给子进程用。
那么是否连新页表都不申请，直接用父进程的页表？
显然是不行的，因为本质上父子进程拥有不同的地址空间， 最后都要分隔开（无论是否执行exec()），所以没必要 推迟页表的申请，本身不怎么耗时。
但是创建线程时，确实使用同一张页表。
当然，仅设计到这步是不行的，因为按理来说父子进程是独立的，对子进程的 修改不应该影响父进程的地址空间。
所有，在 copy 完页表后，会将父子进程的所有地址空间（实际是页表项）设置 为只读属性，当父/子进程尝试修改地址空间时，触发异常，配合特定的 异常处理机制，为其创建一个新的屋里也，拷贝原来的+执行修改。
下图是对上述情况的描述，仅给出一个页面的示例，可以推广到整个地址空间：
1 VMA VMA 2 ┌───────┐ │ ┌───────┐ 3Parent │ │ │ Parent │ │ 4 │ │ │ │ │ 5 ├───────┤ │ ├───────┤ 6 │ ├────┐ │ │ ├────┐ 7 ├───────┤ │ PMA Write │ ├───────┤ │ PMA 8 │ │ │ ┌───────┐ ────┼───► │ │ │ ┌───────┐ 9 │ │ │ │ │ │ │ │ │ │ │ 10 │ │ │ │ │ │ │ │ │ │ │ 11 └───────┘ │ ├───────┤ │ └───────┘ │ ├───────┤ 12 ├────►│ │ Read │ └────►│ │ RW 13 ┌───────┐ │ ├───────┤ only │ ┌───────┐ ├───────┤ 14Child │ │ │ │ │ │ Child │ │ │ │ 15 │ │ │ │ │ │ │ │ ├───────┤ 16 ├───────┤ │ │ │ │ ├───────┤ ┌─►│ │ RW 17 │ ├────┘ └───────┘ │ │ ├───────┘ ├───────┤ 18 ├───────┤ │ ├───────┤ │ │ 19 │ │ │ │ │ └───────┘ 20 │ │ │ │ │ 21 │ │ │ │ │ 22 └───────┘ │ └───────┘ 23 │ 这样就完美了吗 实际上不是的，拷贝父进程的页表和vm_area_struct就不占内存了吗？</description></item><item><title>Linux 进程地址空间 概述</title><link>https://wangloo.github.io/posts/os/linux/addrspace/addrspace/</link><pubDate>Sun, 07 May 2023 14:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/os/linux/addrspace/addrspace/</guid><description>何为进程地址空间? 进程地址空间由允许进程使用的若干线性地址区域(也称&amp;quot;虚拟内存区域&amp;quot;)构成。
每个线性区域由起始地址、长度和属性来描述。
在进程刚创建时，其地址空间仅包含 3 个线性区，分别是：代码段、数据段和堆区，其中 堆区的初始大小为 0。
栈区虽然也属于进程使用的内存区域，但这个区域对用户是透明的，所以我们一般将其 归于内核管理，并非进程本身。
线性区增加的典型情况:
使用mmap()为一个文件映射内存空间 创建一个 IPC 共享线性区与其他进程协作 调用malloc()扩张自己的堆区 Linux 描述地址空间的数据结构 在进程的 tcb 中，描述地址空间相关的结构都保存在成员mm中，其类型为struct mm_struct, 其中重要的成员有：
mmap(struct vm_area_struct*): 指向所有线性区的链表头 mm_rb(struct rb_root): 指向所有线性区对象红黑树的根 pgd(pgd_t *): 指向进程的页表 mmlist(struct list_head): 指向下一个地址空间描述符(所有进程的地址空间描述符 被链接起来) Linux 描述线性区的数据结构 用struct vm_area_struct描述一个线性去，其中重要的成员有:
vm_mm(struct mm_struct *): 指向所属的地址空间描述符 vm_start(unsigned long): 此线性区的开始 vm_end(unsigned long): 下一个线性区的开始(此线性区结束地址+1） vm_next(struct vm_area_struct *): 指向进程线性区的 next vm_rb(struct rb_node): 此线性区对应红黑树中的节点 此线性区的大小就可以表示为: vm_end - vm_start.</description></item><item><title>OS信号 概述</title><link>https://wangloo.github.io/posts/os/linux/signal/</link><pubDate>Fri, 05 May 2023 20:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/os/linux/signal/</guid><description>信号是内核通知用户态进程的一种方式，也可用于用户进程间相互通知。
我更愿称其为通知而不是通信，因为目标进程只能知道信号的 ID，发送方不能 附带更多的信息。
为什么要引入信号? 使用户态进程能够知道系统中某些事件发生了。
例如，系统定时器时间到会产生SIGALRM 信号，用户态程序可以捕获此信号做一些事。
当然有些信号的产生可能不会“轮到”用户态感知，比如SIGKILL信号，由 内核直接将进程给杀死。 但无论怎么说，都是一种提醒该进程某件事发生了， 你该做点什么了的方式。
信号的两个阶段 信号的生命周期可分为两个阶段:
信号生成 信号被处理 下面会详细介绍两个阶段的实现原理，但总体上来说， 信号生成即更新目标进程的数据结构，代表某个信号产生了。
注意：信号可以发送给处理任何状态的进程，发送给非运行状态的信号由内核保存 知道进程恢复运行状态。
而且，目标进程只能同时有一个同种类型的信号处于挂起状态，也就是说，如果 上一个同种信号没有被处理，那么之后到来的同类信号会被忽略。
信号被处理可能有三种不同的方式: 忽略、执行默认行为或者调用自定义的 handler。
信号相关的数据结构 (1) 一个信号可能同时存在多个不同类信号处于挂起状态，所以需要队列来记录它们。 实际上需要两个: 进程组共享和进程私有的挂起队列。 因为某些信号是发送给整个进程组的，比如kill()，而一些是指定某个进程的， 比如tkill().
(2) 另外，tcb 中还需要记录所有信号的处理函数，缺省的和自定义。
所有的数据结构都记录在进程的 tcb 中。
信号的产生过程 信号可能来自内核或者其他进程，后者是通过系统调用的形式，故最终都会 转化为内核函数，操作目标进程的数据结构来实现信号发送。
详细来说就是项目标进程的挂起队列中插入一个项。
信号的处理过程 信号的整个处理过程包括：内核检查进程上是否有挂起的信号，若有则执行相应操作(忽略、缺省、自定义)。 以上描述对应内核函数do_signal().
注意： 这个检查过程仅发生在目标进程将返回用户态时。
有一个问题是，自定义的信号处理函数是在用户态的, 而do_signal()是发生在 内核态，所以内核要做一些特殊的操作：
创建一个临时的用户栈，不能破坏保存的原来用户态环境 ELR(返回地址) = 自定义处理程序，和其他的用户态环境构建 返回用户态，CPU 会执行处理函数 执行完毕后，通过之前对用户栈的特殊构建，使得程序接下来会运行一个 syscall (sys_sigreturn), 返回内核态 如上述操作检查完所有挂起的信号 当所有信号都被处理完成后，则恢复用户进程的原有环境，继续执行</description></item><item><title>OS内核同步互斥机制 概述</title><link>https://wangloo.github.io/posts/os/linux/sync/</link><pubDate>Thu, 04 May 2023 20:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/os/linux/sync/</guid><description>操作系统内核为何需要同步互斥机制 内核代码存在临界区，例如某个对内存区域的引用计数操作，或者对 调度队列的修改操作。
操作系统 必须保证当一个进程（内核进程）在临界区时不会有其他人（或者自己， 当被中断时）再去操作临界资源。
对于单 CPU 系统来说，保证上述行为的方式很简单: 关中断+关内核抢占
关中断能够保证，不会发生当一个内核进程正在操作调度队列时，发生中断 ，恰好中断服务函数也会访问调度队列。 关内核抢占能够保证，不会发生当一个内核进程正在操作调度队列时，发生 中断，中断返回时切换到了别的进程，这个进程的内核态也去操作了调度队列。 多 CPU 情况下，问题就变得负责，就需要配合各种同步互斥机制来实现上述行为要求。
常见的同步互斥机制 per-cpu 变量 优点：多 CPU 之间互不干扰 缺点： 要求逻辑独立， 极少数临界资源可以实现为 per-CPU 形式 开内核抢占时仍有危险，因为不同进程可能在一个 CPU 上， 使用同一个 per-cpu 变量 per-cpu 变量通常被安排在不同的 cache line，避免 cache 的频繁刷新
原子操作 解决多个 CPU 同时修改一个内存值时出现覆盖的问题，当然，单 CPU 没必要用原子操作。
使用原子操作能够保证: 同时执行读操作总会有一个 CPU 先占据总线，此时将总线上锁，其他 CPU 的读写只能等待占领的 CPU 写入彻底完成后。
AArch64 实现原子操作
屏障 仅使用屏障不能直接保证同步，但是需要同步互斥机制都要用到屏障。 比如实现原子操作需要ldrx和strx组合（虽然有新的 CAS 指令, 暂不考虑） ，但 ARM 架构中编译器会 reorder 指令，CPU 会乱序执行。如果 strx在ldrx 之前执行了， 那么原子操作就必然不能实现。</description></item><item><title>Linux追踪系统学习(1): tracepoint</title><link>https://wangloo.github.io/posts/os/linux/trace/tracepoint/</link><pubDate>Sun, 23 Apr 2023 23:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/os/linux/trace/tracepoint/</guid><description>tracepoint 是 Linux trace system 中 data source 之一， 其 trace 的对象是 kernel，属于一种静态的插桩方法。
添加和删除需要手动修改内核源码 可以向上提供接口，可以通过 frontend 来开启或者关闭，也可以自定义数据处理方式 在 disable 时， 仅有一次 if 判断的损耗，所以效率还算高。但缺点是不够灵活。 tracepoint 的组成 看其源码struct tracepoint就能知道它的组成结构：
1struct tracepoint { 2 const char *name; 3#define TP_STATE_DISABLE 0 4#define TP_STATE_ENABLE 1 5 int state; 6 7 // 并非用于注册hook的函数，而是注册hook时的hook 8 int (*reghook)(void); 9 void (*unreghook)(void); 10 11 // 在tracepoint触发时将调用的hook 12 struct tracepoint_hook *hooks; 13}; name: 是该 tracepoint 的名称 state: 用于控制其开关状态 hooks: 是一系列的函数指针，当 tracepoint hit 时，这些函数会被依次调用 reghook/unreghook: 在注册/注销 hook 时将被调用，可以用来输出一些提示信息 为了提供对 tracepoint 操作的接口，定义一个 tracepoint 时，会同时定义一系列功能函数, 包括：</description></item><item><title>ARMv8 中断管理(3): 中断服务程序</title><link>https://wangloo.github.io/posts/armv8/gicv3/3/</link><pubDate>Thu, 13 Apr 2023 23:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/gicv3/3/</guid><description>从进入 IRQ/FIQ 中断向量开始，中断处理的完整流程:
保存上下文 切换中断栈，为进入“真正的”中断服务程序做准备 执行真正的中断服务程序 恢复之前的上下文 “真正的”中断服务程序 “真正的”意为不算那些对于所有异常、中断来说都相同的“套话” ，只讨论对于中断特有的行为。
承认一个中断 真正的中断服务程序从接受 CPU Interface 传来的中断 开始算起，这一步的实现通过读取ICC_IAR1_EL1, 返回当前 中断的 INTID。
拿到 INTID 后，就根据不同的 ID 调用各自对应场景下的服务函数， 比如若 INTID 是对应与时钟中断，那么此步需要清楚状态寄存器、 重新开启时钟定时器。
标记中断处理完毕 做完相干的事情后，需要将该中断标记为已完成，方便后面的中断进来， 也就是上一节说的优先级下降和中断失效过程。
GICv3 支持将这两步合为一次操作，实际我们也是这样做的，通过写入 ICC_EOI1_EL1寄存器来完成标记处理完成。此中断的状态也就从 active-&amp;gt;inactive.
中断服务程序中，承认中断和标记完成两步操作应该是用 while 循环 包裹起来的。
反复的读取 IAR、标记中断已完成&amp;hellip; 如果此时该 CPU 上已经没有 中断待处理了，读取 IAR 会返回特殊 INTID: 1023
中断的上下部机制 中断服务函数的停留时间应该越短越好，否则影响其他任务占用 CPU，这是老生常谈的。
以上观点存在的原因是：中断服务函数中是关闭中断的，CPU 只有串行的处理完当前 中断后， 才能继续做下一件事情，即便是高优先级任务也得等待，因为时钟中断被关闭！
所以 Linux 在 2.6 引入了中断的上下部机制，将整个中断服务函数拆分为上部和下部:
上部：那些不能被打断的步骤，比如保存上下文，承认和标记中断完成等 下部：宽松的管理方式，执行过程就算被打断也没关系，指的就是上面说的对应各自中断 应用场景下的服务函数，比如一个按键触发代表的实际行为 ARMv8 如何支持中断上下部 ARMv8 中，进入异常向量是自动关中断的，可执行msr DAIFClr, #imm来手动开启。</description></item><item><title>Linux 内核抢占</title><link>https://wangloo.github.io/posts/os/linux/schedule/kernel_preempt/</link><pubDate>Thu, 13 Apr 2023 23:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/os/linux/schedule/kernel_preempt/</guid><description>抢占的含义 抢占指的是强制使一个任务让出 CPU 给其他任务。
抢占是调度器做的，每次执行schedule()就可能发生一次抢占，所以 抢占发生的地点是内核，也就是schedule()的执行环境。
用户抢占 与内核抢占相对应的是用户抢占，用户抢占不是指抢占发生的地点，因为 上面说了抢占发生的地点一定是内核。
所以用户抢占的含义是：抢占的时机是用户态，换句话说就是抢占发生之前， 系统正处于用户态。
用户抢占的经典场景是时钟中断，用户进程 1 执行的好好地，被时钟中断打断 然后中断返回时执行重调度，选择了新的用户进程 2。其他的可能用户抢占的场景 还有系统调用返回时， 总之是内核返回用户态时都会发生用户抢占。
内核抢占 启用内核抢占增加了系统中发生抢占的点，即抢占前系统正处于内核。
当一个进程正处于内核态执行任务时，比如执行mmap()系统调用的任务，在 未开启内核抢占的情况下，中断返回时只可能继续执行当前进程的任务，不会 发生调度。
当启用内核抢占时，上述情况下若发生中断，系统在退出中断后，即使此时不是 返回用户态，也可以执行schedule()，即可以发生抢占。此之谓内核抢占。
抢占发生的条件 启用内核抢占之后，其实抢占的过程也不区分用户态和内核态，只要满足条件都会 执行schedule()。
执行重调度的条件有两个:
是否需要重调度? 是否可以重调度? 是否需要重调度也就是何时执行schedule()的问题，大概包含以下的场景:
时钟中断 新进程创建 修改进程的 nice 值 中断返回内核态 内核恢复为可抢占(下面会介绍) 然而有一些情况不可以重新调度，比如内核中一些关键的步骤，那些不能被打断的 原子操作。
在关键步骤之前，需要调用preempt_disable()，此时 linux 会在 tcb 中会改变 preempt_count的值，这个操作不是关闭中断，而是在中断返回时即使有更高优先级的其他进程， 只要该值不符合要求，重调度也不会发生。
关键步骤执行完，调用preempt_enable()，此时为了去满足关键区域内可能 有新加入的高优先级进程，会调用一次重调度，这也正是上面所说需要重调度的场景之一。</description></item><item><title>ARMv8 中断管理(2): 中断的生命周期</title><link>https://wangloo.github.io/posts/armv8/gicv3/2/</link><pubDate>Wed, 12 Apr 2023 23:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/gicv3/2/</guid><description>一个中断完整的生命周期大概包括:
产生中断 中断分发: by Distributor or Redistributor 中断传递: deliver to CPU Interface 中断激活: pending-&amp;gt;active 优先级下降: priority drop 中断失效: active-&amp;gt;inactive 中断的产生 外设传来中断信号，或者处理器触发 SGI， GIC 此时将该中断标记为pending状态。
中断的分发 中断生命周期中的重要部分，根据中断的类型不同可能由 Distributor 和 Redistributor 负责分发工作。
分发器查配置得到此中断的优先级，目的 CPU 等信息。此时可能有多个中断想要发往同一 CPU， 优先级决定先分发哪个中断。将其顺利分发目的 CPU 的 CPU Interface
中断传递 CPU Interface 做最后一步检查，是否满足优先级屏蔽? 是否符合抢占条件?
如果条件都满足，给 CPU 一个信号，CPU 准备激活中断
TODO: 关于running priority 和 highest pending priority的解释
中断激活 CPU 此时将触发 IRQ/FIQ，执行对应的中断服务程序。
中断服务程序中需要显式的执行一些操作将中断状态由 pending 置为 active。
异常向量（中断处理函数）的详细步骤见下一节
优先级下降和中断失效 优先级下降和中断的失效可以配置为同时发生，实际中我们也是这么使用的。</description></item><item><title>ARMv8 中断管理(1): 架构与GICv3</title><link>https://wangloo.github.io/posts/armv8/gicv3/1/</link><pubDate>Wed, 12 Apr 2023 21:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/gicv3/1/</guid><description>ARMv8 中断系统的架构 GIC 的输入为许多的中断线，但输出到 CPU 的只有 IRQ 和 FIQ 两种， 所以就要由 GIC 做中断的分发和过滤工作。
总体来说，整个中断系统架构从底向上可分为三部分:
硬件接口；外设的引脚 中断控制器；桥梁，向下提供引脚连接外设，向上连接 CPU 在合适的时间 触发中断信号，充当中断系统的主管 中断处理函数；GIC 将中断信号传递到 CPU 后，CPU 执行中断处理函数 1+-----------+ +-----------+ 2| Process | | Process | 3+---------+-+ ++----------+ 4 | | 5 +-+--------+----+ 6 | | 7 | GIC | 8 | | 9 +-------+-------+ 10 | 11 +-------------+----------+ 12 | Peripheral Device | 13 +------------------------+ 中断控制器 GICv3 GIC 的有许多版本，本文皆以 GIC version3 为例介绍, 简称为 GICv3</description></item><item><title>AArch64 内存属性与内存类型</title><link>https://wangloo.github.io/posts/armv8/memory_attr/</link><pubDate>Wed, 12 Apr 2023 08:01:33 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/memory_attr/</guid><description>有了虚拟内存系统之后，MMU 可以抽象出一些可配置的内存属性。
例如，配置某个虚拟内存区域为不可执行、不被 cache 等，不可执行的属性 有助于防范攻击，不进入 cache 经常划分给外设 Memory-mapped 区域。
内存属性和内存类型 首先，我们没法直接设置内存类型，我们能设置的是一些细粒度的内存属性字段， 比如说权限(WRX)、cacheable、shareable 等。
我们说的内存类型也就是某些有意义的属性字段相互组合，ARM 给出了两种内存类型: 普通内存和设备内存。
普通内存会启用架构提供的所有优化技术，例如合并访存、乱序执行等。所以 普通内存有最高的性能，但同时不是那么的“安全”，需要底层人员手动使用 内存屏障等手段保证某些情况下的顺序性要求。
设备内存，顾名思义，常映射到外设的 Memory-mapped 区域。对于设备来说， 那些提高性能的技术会造成一些问题，例如某些寄存器的配置必须按照顺序， 这时就不能使用乱序执行。设备内存就牺牲了性能，优先保证正确性。
配置内存类型也是通过页表项中的其中一个属性字段: AttrIndx[2:0], 它与系统寄存器MAIR_EL1配合实现。
具体表现为: mair_el1寄存器被划分为 8 个字段，我们为每个字段写入 不同的值可代表不同的内存类型和一些配套属性，具体的真值表可以参见 mair_el1寄存器的描述。
mair_el1中内存类型配套属性只是属性的一部分，是和设备类型绑定的那部分。
cacheable&amp;amp;shareable 傻傻分不清 先说 cacheable，一段内存被设置为 non-cacheable 属性说明不会进入 cache， inner-cacheable 是实现定义的，可能指进 L1 cache/L2 cache， outer-cacheable 说明会进入 L3 cache。
要注意，只有普通内存才支持配置是否进入 cache，所有的设备内存需要 non-cacheable。
内存支持配置为是否被 cacheable，这在mair_el1的字段中配置。
shareable 说的是一块内存的外部可见性，外部不可见并不是真的看不到，只是说不保证值的正确性。
shareable 属性和 cacheable 其实是有关联的，他们俩比如配合使用，不能随便设置:</description></item><item><title>C语言enum的使用</title><link>https://wangloo.github.io/posts/c/enum/</link><pubDate>Thu, 09 Mar 2023 17:18:57 +0800</pubDate><guid>https://wangloo.github.io/posts/c/enum/</guid><description>枚举类型的优势 枚举类型完全可被宏定义替代，类如
1enum Furniture { 2 DOOR = 1, 3 DESK, 4 LOCK, 5} 与下面的代码等效
1#define DOOR 1 2#define DESK 2 3#define LOCK 3 那么我们如何在两种设计方法中选择呢？在我看来某些情况下使用 enum 会有以下优势：
提高代码键入效率；仅适用于所需变量的值是连续的整数，就像上面的情况，可以只给第一个 DOOR 赋值，其余的值累加。如果首个变量的值要求是 0，甚至每一个都无需显式赋值 提高代码的可维护性；可以划定范围，编译器也会检查类型是否正确，偶尔会有用 提高代码的可读性；例如 DOOR, DESK, LOCK&amp;hellip; 都属于家具，均定义在 Furniture 中 枚举类型所占的大小 枚举类型所占内存的大小，即枚举变量的大小。
由于枚举变量的赋值，一次只能存放枚举结构中的某个常数。所以 枚举变量的大小，实质是常数所占内存空间的大小（常数为 int 类型，当前主流的编译器中一般是 32 位机器和 64 位机器中 int 型都是 4 个字节），枚举类型所占内存大小也是这样。
所以默认情况下，无论枚举变量的值是多少，都是占用 4 个字节。即执行：
1printf(&amp;#34;sizeof(enum Furniture) = %d\n&amp;#34;, sizeof(enum Furniture)); 输入的结果是 4。
编译选项：-fshort-enums GCC 下关于这个编译选项的介绍：
-fshort-enums Allocate to an enum type only as many bytes as it needs for the declared range of possible values.</description></item><item><title>C语言的特点与难点</title><link>https://wangloo.github.io/posts/c/feature/</link><pubDate>Thu, 09 Mar 2023 17:18:57 +0800</pubDate><guid>https://wangloo.github.io/posts/c/feature/</guid><description>函数指针 指针的数组 or 指向数组的指针? 1&amp;gt;&amp;gt; int (*p)[10] p是指针, 指向长度为10的数组. 加括号是为了强调p是一个指针, 区别包含10个指针的array. 2&amp;gt;&amp;gt; int *(p[10]) p是数组, 它的元素类型是int *, 加括号是为了强调p是数组. 3&amp;gt;&amp;gt; int *p[10] 等效于int *(p[10]) 基础架构 1// 函数指针 2&amp;gt;&amp;gt; int (*f)(int) 说明f是一个指向函数的指针, 加括号为了区别返回值为int*的函数 3&amp;gt;&amp;gt; f = function; 函数指针的赋值 4&amp;gt;&amp;gt; (*f)(x) 函数指针指向函数的调用, 可简化为f(x). 但是容易将f误认为是函数. 5 6// 函数指针的数组 7&amp;gt;&amp;gt; int (*(f[10])) (int) f是数组,元素为10个函数指针. 内层括号说明f是数组,外层括号说明元素类型是函数指针 8&amp;gt;&amp;gt; int (*f[10]) (int) 与上面等效. 但外层括号不能省略 9&amp;gt;&amp;gt; f[0] = function() 赋值 10&amp;gt;&amp;gt; (*f[0])() 指向函数的调用, 可简化为f[0]() 11 12// 返回函数指针的函数 13&amp;gt;&amp;gt; void (*signal(int sig, .</description></item><item><title>C语言程序设计的一些经验</title><link>https://wangloo.github.io/posts/c/experience/</link><pubDate>Mon, 27 Feb 2023 19:20:20 +0800</pubDate><guid>https://wangloo.github.io/posts/c/experience/</guid><description>头文件的引用形式 C 中引用一个头文件有两种形式 #include &amp;lt;&amp;gt;和#include &amp;quot;&amp;quot;，在应用开发中，需要引用一些系统库文件，我们通常使用&amp;lt;&amp;gt;，对于自己定义的头文件，我们会使用&amp;quot;&amp;quot;。
然而对于底层软件的开发，比如说操作系统，用到的库都是自己工程中的文件，那么此时用&amp;quot;&amp;quot;和&amp;lt;&amp;gt;有时都能 work，那么它们的区别是什么呢？
搜索相关关键词得到的结论是: 两种方式的区别是搜索文件的优先级， &amp;quot;&amp;quot;优先搜索的当前目录，而&amp;lt;&amp;gt;优先搜索系统库文件目录。对于这个系统库，即那些使用gcc -I&amp;lt;dir&amp;gt;参数指定的路径。 当然，如果第一优先级位置没有被找到，也会到另一个目录中搜索。这么两种方式均可，实际工程中也有部分人混合使用，毫不在意规则。但是有时会导致一些细节问题，比如说我们经常会用到-MMD或者类似选项生成目标文件的依赖，方便实现增量编译。此时就可能会产生一些问题。
假设你有一个头文件inc/father.h, 它里面会引用inc/child.h, 对于根目录下的源文件main.c，其引用语句该如何写呢？以下列出的几种形式都可以，任意的排列组合
1// 编译参数: -I. -MMD 2// main.c 3#include &amp;#34;inc/father.h&amp;#34;4#include &amp;lt;inc/father.h&amp;gt;5 6// father.h 7#include &amp;#34;inc/child.h&amp;#34;8#include &amp;lt;inc/child.h&amp;gt;9#include &amp;#34;child.h&amp;#34;10#include &amp;lt;child.h&amp;gt; 如果 main.c 是使用系统库路径(-I.)来找到的 father.h, 即上面 main.c 的第 2 种情况，那么其生成依赖文件的形式内容都是绝对路径，包括 father.h 中的引用（因为即便 child.h 是相对路径找到的，相对的也是 father.h，其基准就是绝对路径）。例如:main.o: main.c /home/xx/father.h /home/xx/child.h 否则即以相对路径找到 father.h,即上说 main.c 的第 1 种，那么生成 father.h 依赖的方式一定是相对路径，但 child.h 的形式却取决于其本身. 也就是说，如果 child.h 的寻找方式是绝对的（上面的第 1,2,4 种），那么依赖文件的形式就是main.o: main.c inc/father.h /home/xx/child.h. 如果 child.h 的寻找方式是相对的(上面的第 3 种)，那么依赖文件的形式是main.</description></item><item><title>行结束符在windows和linux的区别</title><link>https://wangloo.github.io/posts/c/end-of-line/</link><pubDate>Sat, 24 Dec 2022 01:35:24 +0800</pubDate><guid>https://wangloo.github.io/posts/c/end-of-line/</guid><description>使用VIM 打开一个文件时, 有时会看到例如 ^M 这类字符出现. 下面我会挖一下其出现的原因.
EOL 字符 EOL 或者说 end-of-line 表示一个新行的开始.
EOL 字符在不同的操作系统中是不同的. 本文中仅以 Linux 和 Windows 为例说明.
Windows中是以读到回车&amp;lt;CR&amp;gt;和换行&amp;lt;LF&amp;gt; 表示 EOL. Linux 中仅以换行作为EOL 回车&amp;lt;CR&amp;gt; : Carriage return. 将光标回到行首, 对应C语言中的 \r 换行&amp;lt;LF&amp;gt; : Line feed. 将光标下移一行, 对应C语言中的 \n 在 Linux 中打开 Windows 下的文件将多余的回车通常显示成 ^M 或者 Control-M
Ref End Of Line Characters</description></item><item><title>浅谈 errno 的线程安全问题</title><link>https://wangloo.github.io/posts/os/errno_thread_safe/</link><pubDate>Wed, 21 Dec 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/os/errno_thread_safe/</guid><description>我始终以为，C库中常用的 errno 仅是一个全局变量，使用了全局变量就无法保证线程安全了，因为全局变量在所有线程中都是共享的。
要实现线程安全的errno 就必须将其设置为线程私有的变量，下面就来看看GCC是如何巧妙的实现的。
正文 现在的errno定义并非一个全局变量, 而是一个宏定义, 以下是在usr/include/errno中的声明:
1extern int *__errno_location (void); 2# define errno (*__errno_location ()) 这种方式下其实现原理大概是: __errno_location 函数返回一个int指针, 而这个函数的实现中, 返回的就恰好是实际的errno 变量(与宏同名)的地址, 所以对其解引用就相当于对其值进行操作. 所以, 这种定义规则下, 左值和右值表达式均成立.
1errno = 10; // *__errno_location () = 10 2int x = errno; // x = *__errno_location (); __errno_location 的实现就至关重要, 因为如果其返回的变量地址不包含任何技巧的话, 就和原先直接定义全局变量的方式没差了, 说到底能否实现线程安全, 还得看实际保存errno的变量是否为线程独有的. 目前还没有发掘到其精髓, 只是套壳而已.
以下给出/csu/errno-loc.c中__errno_location 的实现, 与我们预期一致, 返回变量的地址. 而同名变量errno则定义在/csu/errno.c中, 决定了能够实现errno的线程安全.
1int * 2__errno_location (void) 3{ 4 return &amp;amp;errno; 5} 1__thread int errno; &amp;ldquo;__thread&amp;rdquo; 是GCC提供的扩展前缀, 表示该变量将被库处理为线程私有的, 注意这一步是C库完成的, 对程序员透明.</description></item><item><title>git 宝典</title><link>https://wangloo.github.io/posts/tools/git/git/</link><pubDate>Tue, 13 Dec 2022 17:39:42 +0800</pubDate><guid>https://wangloo.github.io/posts/tools/git/git/</guid><description>合并操作: git merge merge 有两种方式:
fast-forward three-way merger Fast-forward Merge 假设合并的双方为main为dev, 如果其中一个是另一个的祖先, 此时直接移动 HEAD 到前方即可, 称为 fast-forward.
例如, 当前在 main, 执行git merge dev的过程如下:
1 main main 2 | | 3M1 --- M2 ===&amp;gt; M1 --- M2 -- F1 4 \ | 5 \--- F1 dev 6 | 7 dev three-way Merge 合并的两者不构成直接的祖先-孩子关系, 产生了分叉. 此时进行合并就需要有个基准(参考), 对于两边相较于基准的每个 diff 来说:
合并的两者都在基准上进行了改动, 且改动不一致, 标记为冲突 如果该 diff仅在其中一方有改动, 那么就保留此次改动 合并时使用的参考就是两个合并 commit 的最近公共祖先, 这种借助三个 commit(main, dev, 公共祖先)才能完成的合并操作就叫做 three-way merge.</description></item><item><title>GNU 二进制工具集</title><link>https://wangloo.github.io/posts/os/gnu_tools/</link><pubDate>Sat, 03 Dec 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/os/gnu_tools/</guid><description>..
nm - 列出符号 nm (GNU Binary Utilities) (sourceware.org)</description></item><item><title>Makefile 一些技巧</title><link>https://wangloo.github.io/posts/c/makefile_tricks/</link><pubDate>Sat, 03 Dec 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/c/makefile_tricks/</guid><description>伪目标的依赖关系 Makefile 中的依赖关系指的是目标和依赖之间建立的关系，目标对应规则中的语句是否执行取决于依赖的状态。
最简单的依赖关系可以拿两个文件来举例:
1# gcc语句执行当前仅当 main.c 新于 main.elf 2main.elf: main.c 3 gcc main.c -o main.elf make 在执行main.elf的规则时，会先判断依赖关系。拿上面的例子来说， gcc 语句是否执行取决于main.c 和 main.elf的修改时间，只有当 依赖新与目标时，规则语句才会执行。
然而许多情况下，目标或者依赖并不是一个文件，而是虚拟目标。虚拟目标 并不是一个文件，即它没有修改时间这个属性，此时 make 就不能作比较，结果就是 如果目标是伪目标，那么不管依赖如何都执行规则语句；如果依赖是伪目标， 那么目标的规则语句也永远被执行。下面是两个例子：
1# 伪目标作为目标文件出现 2# build finish总是输出， 而gcc语句仅当main.c比main.elf新时才执行 3.PHONY : all 4all: main.elf 5 @echo &amp;#39;build finish&amp;#39; 6main.elf: main.c 7 gcc $&amp;lt; -o $@ 1# 伪目标作为依赖文件中出现 2# 不管main.c是否比main.elf更新，因为pre-work是伪目标 3# 所以gcc语句总是执行 4.PHONY : pre-work 5main.elf: main.c pre-work 6 gcc $&amp;lt; -o $@ 上面的代码的效果是：两条规则中的语句都会执行，即使你并没有对 main.c 做任何修改！</description></item><item><title>Uboot: 常用命令</title><link>https://wangloo.github.io/posts/os/uboot/commands/</link><pubDate>Sun, 27 Nov 2022 22:03:48 +0800</pubDate><guid>https://wangloo.github.io/posts/os/uboot/commands/</guid><description>..
环境变量相关 内存操作 网络操作 EMMC和SD卡 BOOT操作指令 bootm go 其他命令 启动相关
md
mmcinfo
cp</description></item><item><title>常用的 shell 命令</title><link>https://wangloo.github.io/posts/shell/shell-commands/</link><pubDate>Sun, 27 Nov 2022 14:45:58 +0800</pubDate><guid>https://wangloo.github.io/posts/shell/shell-commands/</guid><description>开发 mkfs.ext4 格式化文件为ext4分区
1mkfs.ext4 &amp;lt;file&amp;gt; # 将file格式化为ext4 dd https://www.runoob.com/linux/linux-comm-dd.html
mount 1sudo mount [file] [dir] # 挂载file到dir 2sudo umount [dir] 3sudo mount # 输出当前已经挂载的分区 通用 where and which which 查看可执行文件的位置
1$ which python3 2/usr/bin/python3 whereis 除了可执行文件还能搜索其他类型的文件, 不常用, 详见 man whereis
- 的妙用 一些命令支持使用 - 代替文件名, 输入输出都可以:
代替标准输出; 一些命令会将-o/-O 后面的-判定为输出到STDOUT, 详见下面示例. 代替标准输入; 下面给出两个同时代替输入输出的例子:
1# 将标准输入(STDIN)的内容作为gcc的输入, 编译后的结果输出到标准输出(STDOUT) 2echo &amp;#39;void foo() {}&amp;#39; | gcc -x c -o - - 3# 将下载的文件输出到标准输出, 同时作为tar命令的输入文件, 进行解压 4wget -O - &amp;#34;https://www.</description></item><item><title>C语言 'inline' 关键字</title><link>https://wangloo.github.io/posts/c/inline/</link><pubDate>Thu, 24 Nov 2022 01:35:24 +0800</pubDate><guid>https://wangloo.github.io/posts/c/inline/</guid><description>TODO: inline 的发展历程: Myth and reality about inline in C99 – Jens Gustedt&amp;rsquo;s Blog (wordpress.com)
GNU89: 函数的实现之前添加不同的关键字:
inline: 表明这个函数可能被优化. 如果没有被优化, 编译器就会视为一个常规函数的定义.
extern inline: 表明这个函数可能被优化. 如果没有被优化, 编译器就将这个函数的定义转换为该函数的声明, 即 extern inline func(); 因此当此函数被调用时, 可以调用一个外部的函数来替代. 如果没有函数调用它, 那么也可以没有外部的替代函数实现.
static inline: 表明这个函数可能被优化. 如果没有被优化, 编译器就会视为一个常规静态函数.
C99: 函数的实现之前添加不同的关键字:
inline: 等效于gnu89中的extern inline extern inline: 等效于gnu89中的inline static inline: 与gnu89相同含义. C++: 只有inline一个关键字, 如果不能优化就定义为普通函数
Ref:
c++ - What does extern inline do?</description></item><item><title>C语言工具宏</title><link>https://wangloo.github.io/posts/c/c-macros/</link><pubDate>Thu, 24 Nov 2022 01:35:24 +0800</pubDate><guid>https://wangloo.github.io/posts/c/c-macros/</guid><description>计算数组元素的个数 1#define nelem(array) sizeof(array)/sizeof(array[0])</description></item><item><title>x86/ARMv8 函数调用约定</title><link>https://wangloo.github.io/posts/os/function-call-conventions/</link><pubDate>Mon, 21 Nov 2022 10:30:35 +0800</pubDate><guid>https://wangloo.github.io/posts/os/function-call-conventions/</guid><description>符合调用约定使得调用函数能够正常获取参数, callee结束之后能够回到原来位置继续执行.
X86 调用约定 函数调用 x86架构中, 函数调用以一条call指令为分界.
在call指令执行之前, 所有的参数必须都躺在栈中, 参数入栈的规则是: 第一个参数最后入栈.
另外, 执行call指令之前, 必须确保栈指针esp是16-byte对齐. 这项工作是编译器完成的, 如果它判断参数入栈之后的esp 不满足对齐条件, 则会手动调整esp使之对齐. 实现方式见下面例子.
call 指令的语义是:
1push pc+1 ;push next insttuction 2mov pc, func ;set pc = new function call 指令之后的下一条指令就是callee的内容了, 至此就算是进入新函数的地盘.
但是在执行新的任务之前, callee还需要完成栈的转换, 因为此时使用的栈还是caller的.
1push ebp ;preserve location of caller&amp;#39;s stack 2mov ebp, esp ;new ebp is old esp 此时esp也就是栈指针等于ebp, 这是callee栈的初始条件. 万事俱备, 可以开始执行callee的实际任务了.
ebp在整个函数执行过程中是固定的, 好处是: 能够快速的或者函数参数, 返回地址.
函数返回 callee执行完毕后, 需要返回到caller继续执行. 刚才说过, callee的返回地址在栈中, 所以我们要做的是找到返回地址所在的位置, 然后使pc = 返回地址.</description></item><item><title>二级指针操作链表</title><link>https://wangloo.github.io/posts/c/pointers-pointers-list/</link><pubDate>Sun, 20 Nov 2022 23:40:30 +0800</pubDate><guid>https://wangloo.github.io/posts/c/pointers-pointers-list/</guid><description>问题源于我在知乎刷到的一个回答: 能分享你C指针用得最灵活（飘）的一次吗?
文中提到了Linus关于无头节点单项链表的删除操作给出的一种新的思路, 我觉得对理解指针非常有帮助, 所以在这里详细描述一下这件事.
从我学习数据结构起, 对不含头节点的单向链表的删除操作, 做法常是: 借用pre指针搜索. 这种情况下避免不了对于链表中第一个节点的特判(第一个节点没有pre).
Linus提到了一种借助二级指针避免该分支的方法.
1void remove_if(node ** head, remove_fn rm) 2{ 3 for (node** curr = head; *curr; ) 4 { 5 node * entry = *curr; 6 if (rm(entry)) 7 { 8 *curr = entry-&amp;gt;next; 9 free(entry); 10 } 11 else 12 curr = &amp;amp;entry-&amp;gt;next; 13 } 14} 指针的内容就是地址, int *p = a 也就意味着变量p 中保存着变量a的地址. 所以参数head在内存中的含义为:
假如要删除node2, 那么改变*curr实际上就是改了node1的next成员.</description></item><item><title>大小端问题</title><link>https://wangloo.github.io/posts/os/big-little-endian/</link><pubDate>Thu, 17 Nov 2022 10:30:35 +0800</pubDate><guid>https://wangloo.github.io/posts/os/big-little-endian/</guid><description>大小端问题的由来 为什么计算机世界需要区分大小端? 内存里存取的单位是字节, 如果所有的数据类型长度都是一个字节, 那就完全不需要大小端了, 每个变量都仅占据单独一个字节.
例如, 三个变量 a=10, b=20, c=30, 在内存中的布局可能就是:
1 ┌────────────┐ 2 │ │ 3 │ 10 │ a 4 ├────────────┤ 5 │ │ 6 │ 20 │ b 7 ├────────────┤ 8 │ │ 9 │ 30 │ c 10 ├────────────┤ 11 │ │ 12 │ │ 13 │ │ 14 │ │ 15 │ │ 16 └────────────┘ 但是我们最常使用的数据类型肯定有超过一个字节的, int类型在64位的系统中就占4个字节. 例如变量a=0xaabbccdd
一个变量的大小一旦超过4个字节, 内存的存取又是以字节位单位的, 那么要把它塞到内存里就必然会产生两种不同存放方式: 先放0xaa还是先放0xdd
首先, 0xdd是变量a的低8位, 0xaa是最高8位, 这是确定的.</description></item><item><title>操作系统——上下文切换</title><link>https://wangloo.github.io/posts/os/context/</link><pubDate>Mon, 14 Nov 2022 22:13:06 +0800</pubDate><guid>https://wangloo.github.io/posts/os/context/</guid><description>本文基于AArch64执行环境, 介绍现代操作系统中上下文切换的相关内容.
什么是上下文？ 上下文又称“现场”,
为什么需要上下文切换? (TODO: 为什么说线程是调度的单位?)
现代操作系统中同时存在着成千上百个线程, 但是一个CPU同一时刻只能运行一个线程, 他们是轮流的占用CPU, 也叫并发执行. (TODO: 如何查看线程切换的间隔?) 线程高频率的切换, 操作系统是如何保证切换到下一个执行的线程时, 它能够继续上次的工作呢?
什么是上下文? 我们正在看一本书的时候如果被其他的事情打断, 返回时为了能够从上次被打断的位置继续读, 就要在被打断的时候记下来当前是读到了哪个第几页的第几行.
操作系统对待线程也是如此, 需要保存的用于恢复线程执行的信息就称为线程的上下文.
那么对于线程来说需要记下的内容有什么呢? 寄存器和栈即可. 拿AArch64架构来距离, 线程的上下文就是:
通用寄存器x0-x29: 函数调用的参数, 某些计算过程的中间值, 都要用到这些寄存器. 线程的执行流可能在任何时候被打断, 当然这些内容也不能丢. 通用寄存器lr(x30): lr 保存着返回地址, 即当前函数结束之后该返回到哪执行. 栈顶指针 sp: 栈的重要性无需多言. 但是需要说明的是我们保存栈的方式并非将栈中的所有内容保存, 而是保存栈的位置即可. 因为操作系统有别的机制(TODO), 能够保证即便线程不在执行, 属于该线程的栈也不会被破坏. 程序计数器 pc: 被打断的线程如果再次执行, 从哪里执行呢? 显然是被打断指令的下一条(或者重新执行当前). 这个指令的地址当然也需要被保存好. PSTATE: 想一下, 有了以上的内容就能够保证线程完整的恢复之前的环境吗? 其他的例如中断是开还是关, 有哪些标志位(NZCV)被设置了. 这些信息在AArch64中是保存在PSTATE的各个字段中. 如果我们能够有一个适当的逻辑, 在线程切换出去的时候将上下文保存起来, 然后恢复新线程的上下文, 是不是线程切换这件事就能做到了. 如何组织这个保存和恢复的过程在下面会介绍到.
Linux 如何处理上下文切换 另一种处理上下文切换的思路 协程的上下文 协程是用户级别的线程,
协程之间的切换不进入内核 切换协程只能是某个协程主动放弃控制权 我们在这里讨论一下协程切换时需要保存的上下文是否与线程有所不同.</description></item><item><title>基于ARM64实现setjmp/longjmp</title><link>https://wangloo.github.io/posts/c/setjmp_and_longjmp/</link><pubDate>Tue, 01 Nov 2022 23:38:54 +0800</pubDate><guid>https://wangloo.github.io/posts/c/setjmp_and_longjmp/</guid><description>介绍 setjmp() and longjmp() 是一对组合使用的函数, 可以实现全局的goto.
setjmp() 构造一个运行环境, 调用longjmp() 则将执行流切换到该环境.
1/* setjmp() 保存当前的运行环境(上下文)到 env 参数中 */ 2int setjmp(jmp_buf env); 3 4/* longjmp() 将控制流切换到 env 指定的运行环境 */ 5void longjmp(jmp_buf env, int val); 使用方法 1#include &amp;lt;setjmp.h&amp;gt;2#include &amp;lt;stdio.h&amp;gt;3 4jmp_buf e; 5 6void foo() { 7 longjmp(e, 1); 8} 9 10int main(void) { 11 int ret; 12 13 /* After calling longjmp(), the execution flow back to setjmp(), 14and setjmp() will return not 0. */ 15 ret = setjmp(e); 16 if (ret == 0) { 17 printf(&amp;#34;Return from setjmp\n&amp;#34;); 18 foo(); 19 } else { 20 printf(&amp;#34;Return from longjmp\n&amp;#34;); 21 } 22 23 return 0; 24} 基于 AArch64 的实现 需要保存的上下文包括</description></item><item><title>Armv8 Kernel Monitor</title><link>https://wangloo.github.io/posts/os/monitor/</link><pubDate>Fri, 28 Oct 2022 22:56:19 +0800</pubDate><guid>https://wangloo.github.io/posts/os/monitor/</guid><description>Kernel Monitor 是什么 Kernel Monitor 是一个适配我们微内核操作系统的 Kernel 调试和监控系统. 它能实现内核的动态调试和监控. 同时, 它还接管内核的同步异常和系统错误, 使开发者能够了解发生异常时系统的状态.
Kernel Monitor 具有一定的可扩展性, 例如通过统计内核中存储的 TCB 来实时监控系统中所有线程的状态. 可根据开发者的需求添加统计的对象, 如 Endpoint, Capability等.
 Kernel Monitor 总体设计 Kernel Monitor 系统包含 Clinet 和 Server 两个部分. 简单来说, Client 负责处理用户输入, 并将输入进行解析, 封装为 一系列基础命令. 发送给 Server. Server 负责执行这些 基础的命令, 如设置断点, 查看某个地址的值等.
整个系统有两种架构: 本地 Monitor 和远程 Monitor.
本地monitor 和远程 monitor 的区别是: Monitor Client 的位置在哪, 是否与 Server 在同一个机器上.
先说 Monitor Server, 它必须嵌入要调试的 Kernel 中, 位于一个地址空间, 方便操作 Kernel 的内存.</description></item><item><title>ARMv8-A MMU介绍</title><link>https://wangloo.github.io/posts/armv8/mmu/</link><pubDate>Thu, 29 Sep 2022 08:01:33 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/mmu/</guid><description>Introduction MMU: 专用于将虚拟地址转换为物理地址. 通常配合分页机制来工作.
页表: 页表中的表项包含提供虚拟地址和物理地址之间的映射.
MMU就是直接访问页表, 并且通过将频繁使用的映射缓存到TLB中.
MMU 的结构 MMU是一种硬件, 可以通过在适当的安全状态下对其进行配置. 每个Core都有自己的MMU, 每个MMU包括:
一个TLB, 缓存最近访问的映射. 一个Table Walk Unit, 从内存中查询页表, 得到最终的虚拟地址-物理地址的映射. MMU 控制着整个系统的缓存策略, 内存属性和访问权限. MMU开启后, 软件发出的所有内存访问都使用虚拟地址, 要求MMU为每次访问进行地址转换.
MMU 的配置 在启用MMU前, 必须告知其页表存放的位置.
MMU 地址转换的过程 对于每个转换请求, MMU首先检查TLB是否已经对该地址缓存, 如果该地址未缓存, 则需要遍历页表.
页表遍历单元在页表中搜索相关的映射表项.
一旦找到映射, MMU就会检查权限和属性. 决定允许本次访问, 或者发出故障信号. 若未找到映射, 则触发缺页异常. 页表的工作原理 页表的工作方式是将虚拟地址空间和物理地址空间划分为大小相等的块, 称为页面.
页表中的每个表项对应着一块虚拟地址空间中的块, 表项的值就是这块虚拟地址空间对应的物理地址块, 以及访问物理地址时要使用的属性.
在查表过程中, 将虚拟地址分为两部分:
高阶位用作页表的索引. 用来找到对应的物理块 低地址是块内的偏移量, 不会因为映射而改变. 页表项中的物理地址与该偏移组合形成用于访问内存的物理地址. 多级页表 实际实现中, 多采用多级页表的方案, 各级页表自定向下组成树的形式, 协作实现虚拟到物理地址的转换.
树中的分支成为页目录, 页目录中的表项不是直接存储目标物理地址, 而是下一级页表的地址; 最后一级页表的表项中保存着目标物理地址.</description></item><item><title>AArch64/32 异常返回过程</title><link>https://wangloo.github.io/posts/armv8/exception_return/</link><pubDate>Sat, 24 Sep 2022 21:19:01 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/exception_return/</guid><description>ARMv8 异常返回指令 当异常处理程序结束后，需要执行异常返回指令恢复进入异常之前的状态.
具体要做的事情包括:
恢复发生异常前的PC
从SPSR中恢复PSTATE寄存器(现场)
异常返回的指令根据当前执行状态为AArch32还是AArch64有所不同.
AArch32 AArch32的异常返回指令在不同的模式下也有所不同:
若异常是在Hyp模式下处理: 仅可执行ERET指令从异常返回.
若异常是在其他模式下处理, AArch32提供了以下的异常返回指令:
ERET 指令
使用带S后缀的数据处理指令直接操作PC(例如, MOVS, PC, LR), 恢复PSTATE
RFE 指令: RFE &amp;lt;Rn&amp;gt;. 从基址寄存器指向的地址依次加载PC和PSTATE
LDM 指令: LDM &amp;lt;Rn&amp;gt; {pc..}. 若目标寄存器中包含PC, 则会同时恢复PSTATE
AArch64 AArch64下统一使用 ERET 指令进行异常返回.
指令格式及用法参考 ERET ERET指令完成了:
从ELR_ELx中恢复PC指针
从SPSR_ELx中恢复PSTATE寄存器的状态.
LDM(Load Multiple) 格式: LDM &amp;lt;Rn&amp;gt; {registers}
含义: 从基址寄存器&amp;lt;Rn&amp;gt;指向的地址开始依次加载多个寄存器值.</description></item><item><title>GNU C内联汇编学习笔记</title><link>https://wangloo.github.io/posts/c/inline-asm/</link><pubDate>Sat, 24 Sep 2022 16:48:58 +0800</pubDate><guid>https://wangloo.github.io/posts/c/inline-asm/</guid><description>语句结构 1asm asm-qualifiers ( AssemblerTemplate 2 : OutputOperands 3 : InputOperands 4 : Clobbers 5 : GotoLabels) The asm keyword is a GNU extension. 当使用编译选项 -ansi 或 -std 时, 使用 __asm__代替 asm.
Qualifiers volatile: 避免编译器的过分优化 goto inline Parameters AssemblerTemplate: 字符串, 汇编代码的模板
OutputOperands: 输出操作数; 指令将会修改的变量集合
InputOperands: 输入操作数; 指令将读取的变量集合
Clobbers: ???TODO
GotoLabels: 仅当 qualifiers 使用goto时, 声明label集合.
The total number of input + output + goto operands is limited to 30.</description></item><item><title>武器库: shell scripts</title><link>https://wangloo.github.io/posts/shell/shell-script/</link><pubDate>Wed, 20 Jul 2022 11:54:13 +0800</pubDate><guid>https://wangloo.github.io/posts/shell/shell-script/</guid><description>ℹ️ 以下命令/脚本的执行环境均为 bash.
统计代码量 使用到的命令包含: find, wc, xargs, sort 等
列出所有的文件及其代码行数, 只统计.c 和.h, 过滤./scripts目录.
1find -name &amp;#39;*.[c|h]&amp;#39; ! -path &amp;#39;./scripts/*&amp;#39; | xargs wc -l +将内容按照代码行数降序排列
1find -name &amp;#39;*.[c|h]&amp;#39; ! -path &amp;#39;./scripts/*&amp;#39; | xargs wc -l | sort -rn 若仅列出总的代码行数, 去除空行
1(find ./ -name &amp;#39;*.[c|h]&amp;#39; -print0 | xargs -0 cat) | sed &amp;#39;/^\s*$/d&amp;#39; | wc -l 删除目录下所有的可执行文件 1find . -maxdepth 1 -executable -type f | xargs rm 判断执行脚本时带的参数 1if [ $# -ne 1 ]; then 2 echo &amp;#34;ONE parameter is needed&amp;#34; 3 exit -1 4fi 5 6if [ $1 == &amp;#39;build&amp;#39; ]; then 7 # do something 8elif [ $1 == &amp;#39;run&amp;#39; ]; then 9 # do something 10elif [ $1 == &amp;#39;gdb&amp;#39; ]; then 11 # do something 12else 13 echo &amp;#34;Not supported command&amp;#34; 14fi 自动拷贝文件到 SD Card TODO</description></item><item><title>C 语言位操作技巧</title><link>https://wangloo.github.io/posts/c/bitops/</link><pubDate>Sun, 03 Jul 2022 09:44:13 +0800</pubDate><guid>https://wangloo.github.io/posts/c/bitops/</guid><description>连续内存取n bit 1#include &amp;lt;stdio.h&amp;gt;2#include &amp;lt;stdint.h&amp;gt;3#include &amp;lt;assert.h&amp;gt;4 5#define bitmask(n) ((1ul &amp;lt;&amp;lt; (n)) - 1) 6 7/* 8* 从ptr指向的内存开始，抽取第start个bit开始的连续n个bit 9* 限制: n &amp;lt; 32 10*/ 11uint32_t extract_bits(uint8_t *ptr, uint32_t start, uint32_t n) 12{ 13 uint32_t start_byte = start / 8; 14 uint32_t start_offset = start % 8; 15 uint32_t *pstart = (uint32_t *)(ptr + start_byte); 16 17 uint32_t end = start + n - 1; 18 uint32_t end_byte = end / 8; 19 uint32_t end_offset = end % 8; 20 uint32_t *pend = (uint32_t *)(ptr + end_byte); 21 22 uint32_t data = *pstart &amp;gt;&amp;gt; start_offset; 23 24 if (n &amp;gt; 32 - start_offset) { 25 /* 由于n &amp;lt; 32, 所以补齐*pend一定就够了， 26* end_offset对齐到最后一位(n-1).</description></item><item><title>Stack and Heap</title><link>https://wangloo.github.io/posts/os/stack-and-heap/</link><pubDate>Tue, 28 Jun 2022 16:41:54 +0800</pubDate><guid>https://wangloo.github.io/posts/os/stack-and-heap/</guid><description> 堆的含义 我们都知道malloc动态申请的变量是存放在堆中. 所以相比栈来说, 堆是动态的.
堆占据进程虚拟地址空间的大部分, 我们可能通过堆来申请1GB的数组, 但是栈通常不行 , 大多也就几兆的空间.
 堆空间的管理 进程中堆空间的管理是运行库负责的, 在Linux中是GLIBC.
运行库在初始化时会像操作系统申请一大块的堆空间, 再为每个进行分别分配需求. 当然, 如果某些程序的需求过大, 运行库也可以使用mmap系统调用直接向操作系统申请, 然后 返回给用户进程.
GLIBC的malloc函数的处理方式是: 对于小于128KB的申请, 会从运行库&amp;quot;批发的&amp;quot;堆空间 里分出一块来; 但若申请的空间过大, 则使用mmap系统调用来创建匿名空间分配给用户.
Linux中虚拟地址块(VMA)的管理使用了红黑树, 可以用于运行库管理自己向操作系统 &amp;ldquo;批发&amp;quot;的堆空间. 使得用户程序动态申请和释放内存性能提高.</description></item><item><title>动态链接</title><link>https://wangloo.github.io/posts/os/dynamic-link/</link><pubDate>Sun, 26 Jun 2022 19:50:45 +0800</pubDate><guid>https://wangloo.github.io/posts/os/dynamic-link/</guid><description>静态链接带来的问题 像是libc这种几乎每个程序都要用到的库, 如果是静态的, 那么不仅意外着每个程序的 可执行文件很大, 浪费磁盘空间. 并且当程序加载到内存时, 可能许多程序都会用到printf , 使得内存中会存在好多份的printf源码.
维护和更新难. 一旦静态链接的其中一个目标文件更新, 所有的可执行程序都要重新链接.
不满足局部性原理. 上面提到, 内存中同时存在多份的printf源码会破坏局部性原理的. 显然如果所有的程序共享一份printf源码的想法更好. 即动态加载.
可移植性差. 静态链接, 只要有一个依赖目标文件的实现不同, 软件厂商就得专门发布一个 版本. 而动态链接则信赖客户电脑上的动态库, 相当于一个中间层.
动态链接的过程 对比静态链接使用ld链接器在编译后即执行链接, 动态链接则是将链接过程推迟到运行时, 即装载到内存时.
这样, 链接器在链接产生可执行文件时就有两种做法:
对于静态符号, 按照静态链接的规则进行地址引用重定位 对于动态符号, 链接器则仅标记其为动态链接中的符号, 不进行处理. 而是等到装载时由 专门的动态链接器来完成动态符号的链接工作. ⁉️ 链接器如何确定一个符号是静态的 or 动态的?
在动态共享对象(.so)中保存了完整的动态符号表*, 表中存在的符号即为动态的, 否则为静态.
Linux 的 C 语言运行库glib的动态链接版本叫libc.so. 它在外存上只保存一份, 所有的程序 都可以在运行时使用它. 所以千万不要删掉它.
动态链接有一定的性能损失, 因为每次运行程序时都要重新链接, 并不像静态链接是一劳永逸的.</description></item><item><title>ELF 文件的链接与加载</title><link>https://wangloo.github.io/posts/os/elf-format/</link><pubDate>Mon, 20 Jun 2022 16:21:27 +0800</pubDate><guid>https://wangloo.github.io/posts/os/elf-format/</guid><description>ELF不只是可执行文件 Files in ELF format includes:
Type description 实例 Relocatable File 这些文件包含了代码和data, 可以被用来链接成可执行文件或共享目标文件. .o, .a Executable File 直接可执行的文件 /bin/ls Shared Object File Including code and data. 链接器可将其与其他Relocatable File或Shared Object File结合, 生成新的目标文件. 动态链接器可将其与Executable File结合, 作为进程映像的一部分来运行. .so Core Dump File Restore critical infomation when process is terminated unexpectedly core dump 📌 file command in Linux can output the format of a file.</description></item><item><title>写高质量的C语言工程的技巧</title><link>https://wangloo.github.io/posts/codestyle/improve_quality/</link><pubDate>Tue, 14 Jun 2022 17:59:22 +0800</pubDate><guid>https://wangloo.github.io/posts/codestyle/improve_quality/</guid><description>添加更多的编译选项(comiler options)来防止bug 对于我常用的GCC, 推荐开启一下的compiler options:
-Wall: enable a lot of common warnings
-Wno-format-truncation: warns about the snprintf output buffer not being large enough for a corresponding “%s” in the format string.
-Werror: turn warnings into errors.
 动态申请的空间到底要不要释放 When using a barebones embedded OS, you absolutely need to tightly manage your memory.
但是, 如果你是写应用业务的代码, 特别是在内存足够的场景下. 最好不要手动释放内存, 因为当线程/进程退出时, 操作系统会自动帮我们释放. 某些情况下, 释放内存的操作会很大程度上增加逻辑的复杂度.
如果你是一个内核程序员, 则必须手动的释放.</description></item><item><title>MicroKernel Learning: SeL4</title><link>https://wangloo.github.io/posts/microkernel/sel4/</link><pubDate>Sat, 04 Jun 2022 11:52:51 +0800</pubDate><guid>https://wangloo.github.io/posts/microkernel/sel4/</guid><description>seL4 Capabilities In seL4, capabilities are stored in C-space. C-space is a hierarchical data structure very similar to page table.
page table is a mapping from virtual address to physical address. C-space is a mapping from object ID to capability. Kernel object is made up of several C-nodes, just like a page table made up of individual page tables. Each C-nodes is an array of cap slots, which contain capability.</description></item><item><title>Hugo 官方文档学习</title><link>https://wangloo.github.io/posts/hugo/basic/</link><pubDate>Sat, 21 May 2022 17:39:42 +0800</pubDate><guid>https://wangloo.github.io/posts/hugo/basic/</guid><description>本章将解答Hugo是什么, 以及Hugo是如何工作的. 只有了解Hugo的工作机制之后, 才能发挥想象力进行DIY.
本章内容大多来自官方手册或者搜索引擎提供的结果.
Hugo 项目结构 一个hugo 项目通常包含以下内容:
1. 2├── archetypes 3├── config.toml 4├── content 5├── data 6├── layouts 7├── public 8├── static 9└── themes 这里面有些是必须的, 有些是可选的.
archetypes
定义新创建post时, header的格式.
asserts
Note: assets directory is not created by default.
config
Hugo uses the config.toml, config.yaml, or config.json (if found in the site root) as the default site config file.
The user can choose to override that default with one or more site config files using the command-line --config switch.</description></item><item><title>2019 Stanford Commencement Timcook</title><link>https://wangloo.github.io/posts/motivation/2019-stanford-commencement-timcook/</link><pubDate>Wed, 18 May 2022 19:32:38 +0800</pubDate><guid>https://wangloo.github.io/posts/motivation/2019-stanford-commencement-timcook/</guid><description>Content Fourteen years ago, Steve stood on this stage and told your predecessors &amp;ldquo;Your time is limited. So don&amp;rsquo;t waste is living someone else&amp;rsquo;s life.&amp;rdquo;
So what is true then is true now. Don&amp;rsquo;t waste your time living someone else&amp;rsquo;s life. Don&amp;rsquo;t try to emulate the people who came before you to the exclusion of everything else, contorting into a shape that doesn&amp;rsquo;t fit.
Graduates, the fact is, when your time comes, and it will, you will never be ready.</description></item><item><title>Html Css Learning note (0)</title><link>https://wangloo.github.io/posts/html-css/0/</link><pubDate>Tue, 17 May 2022 11:02:04 +0800</pubDate><guid>https://wangloo.github.io/posts/html-css/0/</guid><description>Get start What is HTML&amp;amp;CSS? HTML is resonsible for the content of the page. That&amp;rsquo;s the text, images, buttons, etc.
CSS is resonsible for the presentation of the content. That&amp;rsquo;s the color, layout, etc.
Web designers create the overall look and fell of a website.
Web developers implement the design using HTML, CSS and JavaScript code.
Configure VIM as HTML code-editor Finally in the arms of vscode 🙉</description></item><item><title>我的 vim 调教随笔</title><link>https://wangloo.github.io/posts/vim/basic/</link><pubDate>Mon, 09 May 2022 19:28:12 +0800</pubDate><guid>https://wangloo.github.io/posts/vim/basic/</guid><description>Search a word quickly: put cursor on the word, press / and press &amp;lt;C-R&amp;gt; &amp;lt;C-W&amp;gt;.
 缩写的含义(Meaning of abbreviations) Operation
d - delete y - yank(copy, 因为c被占了) c - change r - replace v - visual select Scope or location
i - inside a - around f - forward t - to Object
w - word s - sentence p - paragraph  书签: Bookmark ma: create bookmark a inside file.</description></item><item><title>reveal.js Tutorial</title><link>https://wangloo.github.io/posts/revealjs/</link><pubDate>Sun, 08 May 2022 19:34:44 +0800</pubDate><guid>https://wangloo.github.io/posts/revealjs/</guid><description>Change code theme Default use monokai.css. see 官方文档
修改需要下载新的css放到plugin/highlight/目录下.
其他可用的css在highlight.js仓库中下载.
Align Slide Align 取消center对齐方式:
1Reveal.initialize({ 2 ... 3 center: false, 4 ... }) 所有slide左对齐: https://github.com/hakimel/reveal.js/issues/1897
用markdown写的方式下使某一幻灯片左对齐: https://github.com/hakimel/reveal.js/issues/890#issuecomment-129735291</description></item><item><title>ARM64: A64指令集</title><link>https://wangloo.github.io/posts/armv8/a64/</link><pubDate>Sat, 07 May 2022 21:19:01 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/a64/</guid><description>Load/Store 指令 寻址模式 Base register - w0=[x1]
1ldr w0, [x1] Offset addressing mode - w0=[x1+12]
1ldr w0, [x1, 12] Pre-index addressing mode - x1+=12; w0=[x1]
1ldr w0, [x1, 12]! Post-index addressing mode - w0=[x1]; x1+=12
1ldr w0, [x1], 12 更多示例 1// load a byte from x1 2ldrb w0, [x1] 3 4// load a signed byte from x1 5ldrsb w0, [x1] 6 7// store a 32-bit word to address in x1 8str w0, [x1] 9 10// load two 32-bit words from stack, then add 8-byte to sp 11ldp w0, w1, [sp], 8 12 13// store two 64-bit words at [sp-96] and subtract 96-byte from sp.</description></item><item><title>ARMv8-A 寄存器</title><link>https://wangloo.github.io/posts/armv8/register/</link><pubDate>Sat, 07 May 2022 20:19:44 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/register/</guid><description>寄存器分类 通用寄存器 x0-x7 参数寄存器: Restore function parameters and return vaule. x9-x15 caller-saved 临时寄存器: callee 默认可以直接使用来保存临时变量, 不需要保存和恢复. 如果 caller 在里面存储了非临时信息, 那么在函数调用之前应当由 caller 负责保存. x19-x28 callee-saved 寄存器: callee 应该避免使用. 如果必须要使用，那么在返回前必须恢复. special registers: x8 restore indirect result. Commonly used when returning a struct. x18 platform reserved register. x29 frame pointer register(FP). x30 link register(LR). All general-purpose register xN is 64-bit width. They all have corresponding wN register using the lower 32-bit of xN.</description></item><item><title>Numberical Analysis Exam</title><link>https://wangloo.github.io/posts/numberical-analysis/</link><pubDate>Sat, 07 May 2022 18:04:58 +0800</pubDate><guid>https://wangloo.github.io/posts/numberical-analysis/</guid><description>考试大纲 🎯 To Reader:
This blog is JUST FOR EXAMINATION! If you are interested in numberical analysis, please quit this web. I try to sort out the knowledge points of the course, just to pass the exam.
Based on the course of Professor Zhong Erjie of UESTC.
💢 I hate mathematics!
 第二章 非线性方程/方程组的求解 1. 二分法及迭代 二分法误差估计定理 2. 不动点迭代 不动点及不动点迭代的概念 迭代格式的选择? 是否收敛? 迭代的初值是否合适? 3. 牛顿法解非线性方程 背景: 如果函数f(x)是线性的, 那么它的求根问题就会简化.</description></item><item><title>LaTeX Vim Tutorial</title><link>https://wangloo.github.io/posts/latex-vim-tutorial/</link><pubDate>Wed, 04 May 2022 17:07:51 +0800</pubDate><guid>https://wangloo.github.io/posts/latex-vim-tutorial/</guid><description>Use plugin vimtex Vim build-in support of LaTeX files is just OK. When we need more excellent exprience, good plugins is very recommended.
vimtex is a nice and modern vim plugin for LaTeX files.
Useful Futures of vimtex IMO
&amp;lt;leader&amp;gt;ll Complier. By default, it will auto-complier when you type :w. &amp;lt;leader&amp;gt;lt Open content tree as a sidebar. &amp;lt;leader&amp;gt;lv View PDF with configured PDF viewer. &amp;lt;leader&amp;gt;li File information. cse Change surrounding \begin \end environment.</description></item><item><title>Portability Issues</title><link>https://wangloo.github.io/posts/reading-notes/expert_c_programming/portability_issues/</link><pubDate>Sun, 01 May 2022 16:41:35 +0800</pubDate><guid>https://wangloo.github.io/posts/reading-notes/expert_c_programming/portability_issues/</guid><description>When reading C standard documents, we usually see phrases like &amp;ldquo;Implementation-defined&amp;rdquo;, &amp;ldquo;Unspecified&amp;rdquo;,.etc.
So, what do they really mean?
术语 我们将这些难以直接理解的词汇称为术语，在ANSI C中，术语可以分为描述不可移植代码(unportable), 坏代码(bad), 可移植的代码(portable)三类.
unportable code Implementation-defined
需要由编译器设计者决定采取何种行为，他们可能不同，但都不能说是错误的.
例如：当整型数右移时，是否需要扩展符号位. 右移代替除法可能导致的灾难.
unspecified
在某些正确情况下的做法，标准并未明确规定应该怎样做.
例如：参数求值的顺序.
bad code undefined
在某些不正确情况下的做法，但标准并未规定应该怎样做。意味着你可以采取任何行动，可以什么都不做，也可以发出一条警告信息, 或者终止CPU重启等等. 你甚至可以发射核导弹(只要你安装了能发射核导弹的硬件系统).
例如：当一个有符号整数溢出时该采取什么行动.
constraint
这是一个必须遵守的限制或要求. 如果你不遵守, 那么你的程序的行为就会变成如上所说的undefined. 这出现了一种很有意思的情况: 分辨某种东西是否是一个constaint是很容易的, 因为每个标准的主题都附有一个constraint小节, 列出了所有的约束条件。
例如: %操作符的操作数必须为整型. 所以,在非整型数据上使用%操作符肯定会导致undefined.
portable code strictly conforming
严格遵守标准的. 符合该条件的程序应当是:
只使用已确定的特性 不突破任何由编译器实现(Implementation-defined)的限制. 不使用unspecified和undefined特性 这样规定的目的是最大程序保证代码的可移植性. 但符合该术语的代码并不常见, 例如INT_MAX的值在不同架构的机器上结果可能不同.
comforming
遵循标准的; 一个遵循标准的程序可以依赖一些对于某种编译器特有的不可移植的特性. 这样一个程序对于某个编译器可能是遵循标准的, 但对于另外一个编译器又是不遵循标准的.</description></item><item><title>Third Blog</title><link>https://wangloo.github.io/posts/third-blog/</link><pubDate>Sun, 01 May 2022 16:41:35 +0800</pubDate><guid>https://wangloo.github.io/posts/third-blog/</guid><description/></item><item><title>GCC '-M' and Related Parameters</title><link>https://wangloo.github.io/posts/c/gcc_-m_related/</link><pubDate>Tue, 26 Apr 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/c/gcc_-m_related/</guid><description>As we all know, there are huge number of parameters for GCC. With them, we can make many things possible. Now we talk about -M and related ones. After reading this article, you will know the meaning of there magic parameters. And I will put some little demos follows. Finally, we will see what can they do in really project. Let&amp;rsquo;s go ahead.
实例规则 以下的分析都是基于这样一个生成目标文件的规则, 应该来说具有一定的通用性。
1build/obj/main.o: src/main.c 2 $(CC) $(CFLAGS) $(INCLUDES) -c $&amp;lt; -o $@ main.</description></item><item><title>Second Blog</title><link>https://wangloo.github.io/posts/second-blog/second-blog/</link><pubDate>Tue, 26 Apr 2022 15:32:11 +0800</pubDate><guid>https://wangloo.github.io/posts/second-blog/second-blog/</guid><description>This is my second blog.
Wish you have a good life.
happy smile sunset</description></item><item><title>First Blog</title><link>https://wangloo.github.io/posts/first-blog/first-blog/</link><pubDate>Tue, 26 Apr 2022 15:13:07 +0800</pubDate><guid>https://wangloo.github.io/posts/first-blog/first-blog/</guid><description>This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog.</description></item><item><title/><link>https://wangloo.github.io/posts/os/arm64-linux-qemu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wangloo.github.io/posts/os/arm64-linux-qemu/</guid><description>编译Linux 源码 上海交通大学镜像站
1# get linux source code 2wget http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/ 3# extract 4tar xvf linux-4.12.1.tar.gz 5# enter dir 6cd linux-4.12.1/ 7 8# generate .config 9make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- defconfig 10make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- menuconfig 11# compile 12make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- Image -j16 构建根文件系统 使用 Busybox 构建, 下载源码时可能比较慢, 暂时没有发现国内镜像站
1# Download busybox source code 2wget https://busybox.net/downloads/busybox-1.35.0.tar.bz2 3 4# menuconfig - generate .config 5make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- menuconfig 6# compile 7make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- -j16 8 9make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- install 10 11# create rootfs 12cd .</description></item><item><title/><link>https://wangloo.github.io/posts/os/trace/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wangloo.github.io/posts/os/trace/</guid><description>名词解释 probe 一个probe是一个位置或者活动, 动态追踪工具可以在probe上绑定一些action. 例如记录栈帧位置, 查看参数等.
probe就像是一个可编程的传感器, 你可以为他设定触发的事件或者指令. 当probe 触发时, 可以执行你提前绑定的函数, 了解此时系统的状态</description></item></channel></rss>