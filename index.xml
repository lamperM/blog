<?xml-stylesheet href="/rss.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Homepage 🌈 on Soben's Secret Base</title><link>https://wangloo.github.io/</link><description>Recent content in Homepage 🌈 on Soben's Secret Base</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>@2019 Notepadium.</copyright><lastBuildDate>Thu, 15 Sep 2022 15:14:05 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>C 内敛汇编</title><link>https://wangloo.github.io/posts/c/inline-asm/</link><pubDate>Tue, 03 Jan 2023 20:54:31 +0800</pubDate><guid>https://wangloo.github.io/posts/c/inline-asm/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/c/inline-asm/ -&lt;p>&lt;strong>如果要将多条语句放在一个&lt;code>asm&lt;/code>关键字中&lt;/strong>, 每条语句之间必须使用分隔符, 常见的为&lt;code>\n\t&lt;/code>. 例如:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">asm&lt;/span> &lt;span style="color:#50fa7b">volatile&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;isb &lt;/span>&lt;span style="color:#f1fa8c">\n\t&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;dsb &lt;/span>&lt;span style="color:#f1fa8c">\n\t&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;eret &lt;/span>&lt;span style="color:#f1fa8c">\n\t&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>貌似对于 arm 汇编, 只用 &lt;code>\n&lt;/code> 也OK?
TODO: 找到依据&lt;/p>
&lt;/blockquote>
&lt;h2 id="volatile">volatile&lt;/h2>
&lt;h4 id="cc">cc&lt;/h4>
&lt;p>This stands for &amp;ldquo;condition codes&amp;rdquo;. Since the add instruction will affect the carry flag amongst other things, we need to tell gcc about it. Otherwise it might want to split a test-and-branch around our code. If it did so, the branch might go the wrong way due to the condition codes being corrupted. Basically, any inline asm that does arithmetic should explicitly clobber the flags like this.&lt;/p>
&lt;h4 id="memory">memory&lt;/h4>
&lt;p>The &amp;ldquo;memory&amp;rdquo; clobber tells the compiler that the assembly code performs memory reads or writes to items other than those listed in the input and output operands (for example, accessing the memory pointed to by one of the input parameters). To ensure memory contains correct values, GCC may need to flush specific register values to memory before executing the asm. Further, the compiler does not assume that any values read from memory before an asm remain unchanged after that asm; it reloads them as needed. Using the &amp;ldquo;memory&amp;rdquo; clobber effectively forms a read/write memory barrier for the compiler.&lt;/p>
&lt;p>Note that this clobber does not prevent the processor from doing speculative reads past the asm statement. To prevent that, you need processor-specific fence instructions.&lt;/p>
- https://wangloo.github.io/posts/c/inline-asm/ - @2019 Notepadium.</description></item><item><title>行结束符在windows和linux的区别</title><link>https://wangloo.github.io/posts/c/end-of-line/</link><pubDate>Sat, 24 Dec 2022 01:35:24 +0800</pubDate><guid>https://wangloo.github.io/posts/c/end-of-line/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/c/end-of-line/ -&lt;p>使用VIM 打开一个文件时, 有时会看到例如 &lt;code>^M&lt;/code> 这类字符出现. 下面我会挖一下其出现的原因.&lt;/p>
&lt;h2 id="eol-字符">EOL 字符&lt;/h2>
&lt;p>EOL 或者说 end-of-line 表示一个新行的开始.&lt;/p>
&lt;p>EOL 字符在不同的操作系统中是不同的. 本文中仅以 Linux 和 Windows 为例说明.&lt;/p>
&lt;ul>
&lt;li>Windows中是以读到回车&amp;lt;CR&amp;gt;和换行&amp;lt;LF&amp;gt; 表示 EOL.&lt;/li>
&lt;li>Linux 中仅以换行作为EOL&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;ul>
&lt;li>回车&amp;lt;CR&amp;gt; : Carriage return. 将光标回到行首, 对应C语言中的 &lt;code>\r&lt;/code>&lt;/li>
&lt;li>换行&amp;lt;LF&amp;gt; : Line feed. 将光标下移一行, 对应C语言中的 &lt;code>\n&lt;/code>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>在 Linux 中打开 Windows 下的文件将多余的回车通常显示成 &lt;code>^M&lt;/code> 或者 &lt;code>Control-M&lt;/code>&lt;/p>
&lt;h2 id="ref">Ref&lt;/h2>
&lt;p>&lt;a href="https://peterbenjamin.com/seminars/crossplatform/texteol.html">End Of Line Characters&lt;/a>&lt;/p>
- https://wangloo.github.io/posts/c/end-of-line/ - @2019 Notepadium.</description></item><item><title>浅谈 errno 的线程安全问题</title><link>https://wangloo.github.io/posts/os/errno_thread_safe/</link><pubDate>Wed, 21 Dec 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/os/errno_thread_safe/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/os/errno_thread_safe/ -&lt;p>我始终以为，C库中常用的 &lt;code>errno&lt;/code> 仅是一个全局变量，使用了全局变量就无法保证线程安全了，因为全局变量在所有线程中都是共享的。&lt;/p>
&lt;p>要实现线程安全的&lt;code>errno&lt;/code> 就必须将其设置为&lt;strong>线程私有的变量&lt;/strong>，下面就来看看GCC是如何巧妙的实现的。&lt;/p>
&lt;h2 id="正文">正文&lt;/h2>
&lt;p>现在的&lt;code>errno&lt;/code>定义并非一个全局变量, 而是一个&lt;strong>宏定义&lt;/strong>, 以下是在&lt;code>usr/include/errno&lt;/code>中的声明:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">extern&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#ff79c6">*&lt;/span>&lt;span style="color:#50fa7b">__errno_location&lt;/span> (&lt;span style="color:#8be9fd">void&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6"># define errno (*__errno_location ())
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种方式下其实现原理大概是: &lt;code>__errno_location&lt;/code> 函数返回一个&lt;code>int&lt;/code>指针, 而这个函数的实现中, 返回的就恰好是&lt;strong>实际的&lt;/strong>&lt;code>errno&lt;/code> 变量(与宏同名)的地址, 所以对其&lt;strong>解引用&lt;/strong>就相当于对其值进行操作. 所以, 这种定义规则下, 左值和右值表达式均成立.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>errno &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">10&lt;/span>; &lt;span style="color:#6272a4">// *__errno_location () = 10
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#8be9fd">int&lt;/span> x &lt;span style="color:#ff79c6">=&lt;/span> errno; &lt;span style="color:#6272a4">// x = *__errno_location ();
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>__errno_location&lt;/code> 的实现就至关重要, 因为如果其返回的变量地址不包含任何技巧的话, 就和原先直接定义全局变量的方式没差了, &lt;strong>说到底能否实现线程安全, 还得看实际保存errno的变量是否为线程独有的&lt;/strong>. 目前还没有发掘到其精髓, 只是套壳而已.&lt;/p>
&lt;p>以下给出&lt;code>/csu/errno-loc.c&lt;/code>中&lt;code>__errno_location&lt;/code> 的实现, 与我们预期一致, 返回变量的地址. 而同名变量&lt;code>errno&lt;/code>则定义在&lt;code>/csu/errno.c&lt;/code>中, &lt;strong>决定了能够实现errno的线程安全&lt;/strong>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#ff79c6">*&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">__errno_location&lt;/span> (&lt;span style="color:#8be9fd">void&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">&amp;amp;&lt;/span>errno;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>__thread &lt;span style="color:#8be9fd">int&lt;/span> errno;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;ldquo;&lt;code>__thread&lt;/code>&amp;rdquo; 是GCC提供的扩展前缀, 表示该变量将被库处理为线程私有的, 注意这一步是C库完成的, 对程序员透明. 相关的理论叫 &lt;em>Thread-local Storage&lt;/em>, AArch64 架构实现的原理是利用&lt;code>TPIDR_EL0&lt;/code> 寄存器, 其他架构可以参考&lt;a href="https://akkadia.org/drepper/tls.pdf">此PDF&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>❓ 以上源文件中有注释为 &lt;em>non-threaded&lt;/em>版本的实现, 是代表什么含义呢?&lt;/p>
&lt;/blockquote>
&lt;p>​&lt;/p>
&lt;p>虽然我暂时没有查阅到errno的其他线程安全的实现原理, 但起码GCC下该方式这是可行的. 依靠的是&amp;quot;&lt;code>__thread&lt;/code>&amp;ldquo;的支持, &lt;strong>与换成宏定义的方式无关&lt;/strong>, 不排除可能为了考虑兼容其他实现方式的可能性.&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;p>&lt;a href="https://stackoverflow.com/questions/18025995/how-is-thread-safe-errno-initialized-if-define-substitutes-errno-symbol">c - How is thread-safe errno initialized if #define substitutes errno symbol? - Stack Overflow&lt;/a>&lt;/p>
- https://wangloo.github.io/posts/os/errno_thread_safe/ - @2019 Notepadium.</description></item><item><title>git 宝典</title><link>https://wangloo.github.io/posts/git/</link><pubDate>Tue, 13 Dec 2022 17:39:42 +0800</pubDate><guid>https://wangloo.github.io/posts/git/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/git/ -&lt;h2 id="合并操作-git-merge">合并操作: git merge&lt;/h2>
&lt;p>merge 有两种方式:&lt;/p>
&lt;ul>
&lt;li>fast-forward&lt;/li>
&lt;li>three-way merger&lt;/li>
&lt;/ul>
&lt;h3 id="fast-forward-merge">Fast-forward Merge&lt;/h3>
&lt;p>假设合并的双方为&lt;code>main&lt;/code>为&lt;code>dev&lt;/code>, 如果其中一个是另一个的祖先, 此时直接移动HEAD到前方即可, 称为fast-forward.&lt;/p>
&lt;p>例如, 当前在main, 执行&lt;code>git merge dev&lt;/code>的过程如下:&lt;/p>
&lt;pre tabindex="0">&lt;code> main main
| |
M1 --- M2 ===&amp;gt; M1 --- M2 -- F1
\ |
\--- F1 dev
|
dev
&lt;/code>&lt;/pre>&lt;h3 id="three-way-merge">three-way Merge&lt;/h3>
&lt;p>合并的两者不构成直接的祖先-孩子关系, 产生了分叉. 此时进行合并就需要有个基准(参考), 对于两边相较于基准的每个diff来说:&lt;/p>
&lt;ul>
&lt;li>合并的两者都在基准上进行了改动, 且改动不一致, &lt;strong>标记为冲突&lt;/strong>&lt;/li>
&lt;li>如果该diff&lt;strong>仅在其中一方&lt;/strong>有改动, 那么就保留此次改动&lt;/li>
&lt;/ul>
&lt;p>合并时使用的参考就是&lt;strong>两个合并commit的最近公共祖先&lt;/strong>, 这种借助三个commit(main, dev, 公共祖先)才能完成的合并操作就叫做 three-way merge.&lt;/p>
&lt;p>例如, 当前在main, 执行&lt;code>git merge dev&lt;/code>的过程如下:&lt;/p>
&lt;pre tabindex="0">&lt;code> main main
| |
M1 --- M2 --- M3 ===&amp;gt; M1 --- M2 --- M3 --- M4
\ \ /
\--- F1 \--- F1 ---
| |
dev dev
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>three-way 的合并方式如果发生了冲突, 会产生一次额外的 merge commit, 下面介绍它&lt;/p>
&lt;/blockquote>
&lt;h3 id="什么情况下-merge-commit-没有任何diff">什么情况下 merge commit 没有任何diff?&lt;/h3>
&lt;p>按照上面的例子, three-way merge 发生冲突后会产生一次额外的merge commit, 即M4. 如果这是去查看M4 相较前一次commit的diff, 有时是没有的, 有时又会产生diff.&lt;/p>
&lt;p>如果在解决冲突的过程中, 我们仅仅是接收了 M2,M3 或者F1的修改, 那么此时merge commit就不会有diff.&lt;/p>
&lt;p>然而, 在解决冲突时, 我们也可以不采用来自两条路径的修改, 做一次新的修改(可以说, 同时接收两条diff就是这种情况), 此时查看merge commit的diff就是有内容的.&lt;/p>
- https://wangloo.github.io/posts/git/ - @2019 Notepadium.</description></item><item><title>GNU 二进制工具集</title><link>https://wangloo.github.io/posts/os/gnu_tools/</link><pubDate>Sat, 03 Dec 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/os/gnu_tools/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/os/gnu_tools/ -&lt;p>..&lt;/p>
&lt;h2 id="nm---列出符号">nm - 列出符号&lt;/h2>
&lt;p>&lt;a href="https://sourceware.org/binutils/docs/binutils/nm.html">nm (GNU Binary Utilities) (sourceware.org)&lt;/a>&lt;/p>
- https://wangloo.github.io/posts/os/gnu_tools/ - @2019 Notepadium.</description></item><item><title>Makefile 一些技巧</title><link>https://wangloo.github.io/posts/c/makefile_tricks/</link><pubDate>Sat, 03 Dec 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/c/makefile_tricks/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/c/makefile_tricks/ -&lt;p>..&lt;/p>
&lt;h3 id="使用shell-变量">使用shell 变量&lt;/h3>
&lt;p>Make 将 &lt;code>$$var&lt;/code> 转义为&lt;code>$var&lt;/code>, 供shell处理.&lt;/p>
&lt;p>demo(源自6.828 根目录&lt;code>GNUmakefile&lt;/code>):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-makefile" data-lang="makefile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">handin-check&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @if &lt;span style="color:#8be9fd;font-style:italic">test&lt;/span> -n &lt;span style="color:#f1fa8c">&amp;#34;`git status -s`&amp;#34;&lt;/span>; &lt;span style="color:#ff79c6">then&lt;/span> &lt;span style="color:#f1fa8c">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&lt;/span> git status -s; &lt;span style="color:#f1fa8c">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">read&lt;/span> -p &lt;span style="color:#f1fa8c">&amp;#34;Untracked files will not be handed in. Continue? [y/N] &amp;#34;&lt;/span> r; &lt;span style="color:#f1fa8c">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">test&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$$&lt;/span>&lt;span style="color:#f1fa8c">r&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">=&lt;/span> y; &lt;span style="color:#f1fa8c">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&lt;/span> &lt;span style="color:#ff79c6">fi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>以上demo还使用了 test 命令来终止make的执行, 如果用户没有输入&lt;code>y&lt;/code>, make将会终止执行&lt;/p>
&lt;/blockquote>
- https://wangloo.github.io/posts/c/makefile_tricks/ - @2019 Notepadium.</description></item><item><title>Uboot: 常用命令</title><link>https://wangloo.github.io/posts/os/uboot/commands/</link><pubDate>Sun, 27 Nov 2022 22:03:48 +0800</pubDate><guid>https://wangloo.github.io/posts/os/uboot/commands/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/os/uboot/commands/ -&lt;hr>
&lt;p>..&lt;/p>
&lt;h2 id="环境变量相关">环境变量相关&lt;/h2>
&lt;h2 id="内存操作">内存操作&lt;/h2>
&lt;h2 id="网络操作">网络操作&lt;/h2>
&lt;h2 id="emmc和sd卡">EMMC和SD卡&lt;/h2>
&lt;h2 id="boot操作指令">BOOT操作指令&lt;/h2>
&lt;h3 id="bootm">bootm&lt;/h3>
&lt;h3 id="go">go&lt;/h3>
&lt;h2 id="其他命令">其他命令&lt;/h2>
&lt;p>启动相关&lt;/p>
&lt;p>md&lt;/p>
&lt;p>mmcinfo&lt;/p>
&lt;p>cp&lt;/p>
- https://wangloo.github.io/posts/os/uboot/commands/ - @2019 Notepadium.</description></item><item><title>vim插件YCM: 安装和配置</title><link>https://wangloo.github.io/posts/vim/ycm-install/</link><pubDate>Sun, 27 Nov 2022 21:50:39 +0800</pubDate><guid>https://wangloo.github.io/posts/vim/ycm-install/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/vim/ycm-install/ -&lt;p>YCM 插件对 python, vim的版本均有要求&lt;/p>
&lt;h2 id="下载">下载&lt;/h2>
&lt;p>可以使用vim-plug等工具下载, 也可以下载源码然后拷贝到&lt;code>.vim&lt;/code>目录下&lt;/p>
&lt;h2 id="编译">编译&lt;/h2>
&lt;p>编译用到python3, 这里是问题最多的一步&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 编译并添加对C的提示支持&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>python3 install.py --clangd-completer --verbose
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Searching Python 3.8 libraries...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Downloading Clangd from https://github.com/ycm-core/llvm/releases/download/13.0.0/clangd-13.0.0-x86_64-unknown-linux-gnu.tar.bz2...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用&lt;code>--clangd-completer&lt;/code>参数时, 脚本会去下载clangd-14.0.0-x86_64-unknown-linux-gnu.tar.bz2文件, 比较慢. 也可以&lt;strong>提前根据提示的网站自己手动下载&lt;/strong>压缩包.&lt;/p>
&lt;p>下载完成后, 放到本地目录下:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>:~/.vim/plugged/YouCompleteMe/third_party/ycmd/third_party/clangd/cache$ ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>clangd-14.0.0-x86_64-unknown-linux-gnu.tar.bz2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>还需对脚本&lt;code>YouCompleteMe/third_party/ycmd/build.py&lt;/code>进行修改, 防止重新下载.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">def&lt;/span> &lt;span style="color:#50fa7b">DownloadClangd&lt;/span>( printer ):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MakeCleanDirectory( CLANGD_OUTPUT_DIR )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">not&lt;/span> p&lt;span style="color:#ff79c6">.&lt;/span>exists( CLANGD_CACHE_DIR ):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os&lt;span style="color:#ff79c6">.&lt;/span>makedirs( CLANGD_CACHE_DIR )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4"># 注释下面的语句&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4"># elif p.exists( file_name ) and not CheckFileIntegrity( file_name, check_sum ):&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4"># printer( &amp;#39;Cached Clangd archive does not match checksum. Removing...&amp;#39; )&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4"># os.remove( file_name )&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> p&lt;span style="color:#ff79c6">.&lt;/span>exists( file_name ):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printer( &lt;span style="color:#f1fa8c">f&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;Using cached Clangd: &lt;/span>&lt;span style="color:#f1fa8c">{&lt;/span> file_name &lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;&lt;/span> )
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="配置">配置&lt;/h2>
&lt;p>YCM 配合一个配置文件&lt;code>.ycm_c_c++_conf.py&lt;/code>, YCM搜索的位置在vimrc中指定:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-vimrc" data-lang="vimrc">&lt;span style="display:flex;">&lt;span>Plug &lt;span style="color:#f1fa8c">&amp;#39;rdnetto/YCM-Generator&amp;#39;&lt;/span>, { &lt;span style="color:#f1fa8c">&amp;#39;branch&amp;#39;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#39;stable&amp;#39;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">let&lt;/span> g:ycm_global_ycm_extra_conf = &lt;span style="color:#f1fa8c">&amp;#34;~/.ycm_c_c++_conf.py&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其内容的example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-py" data-lang="py">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> os
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> ycm_core
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flags &lt;span style="color:#ff79c6">=&lt;/span> [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#39;-Wall&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#39;-Wextra&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># &amp;#39;-Werror&amp;#39;, &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#39;-Wno-long-long&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># &amp;#39;-Wno-variadic-macros&amp;#39;,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#39;-fexceptions&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#39;-ferror-limit=10000&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#39;-DNDEBUG&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#39;-std=c99&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#39;-xc&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#39;-isystem/usr/include/&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SOURCE_EXTENSIONS &lt;span style="color:#ff79c6">=&lt;/span> [ &lt;span style="color:#f1fa8c">&amp;#39;.cpp&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;.cxx&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;.cc&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;.c&amp;#39;&lt;/span>, ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">def&lt;/span> &lt;span style="color:#50fa7b">FlagsForFile&lt;/span>( filename, &lt;span style="color:#ff79c6">**&lt;/span>kwargs ):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#39;flags&amp;#39;&lt;/span>: flags,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#39;do_cache&amp;#39;&lt;/span>: &lt;span style="color:#ff79c6">True&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>🔻 对于C/C++来说, YCM的使用最好配合&lt;em>compilation database&lt;/em> 来使用, 例如&lt;a href="https://github.com/nickdiego/compiledb">compiledb&lt;/a>. 否则, 可能头文件的path识别出问题(&lt;a href="https://stackoverflow.com/questions/64277317/youcompleteme-not-work-properly-for-c-headers.">stackoverflow&lt;/a>).&lt;/p>
&lt;p>2022年2月13日我使用的compilation database生成工具从&lt;code>compiledb&lt;/code>换成了&lt;code>bear&lt;/code>, 因为&lt;code>bear&lt;/code>更好的支持递归, 即有&lt;code>make -C&lt;/code>的情况.&lt;/p>
&lt;p>需要的compilation database生成工具介绍: &lt;a href="https://sarcasm.github.io/notes/dev/compilation-database.html">Compilation database — Sarcasm notebook&lt;/a>&lt;/p>
- https://wangloo.github.io/posts/vim/ycm-install/ - @2019 Notepadium.</description></item><item><title>常用的 shell 命令</title><link>https://wangloo.github.io/posts/shell/shell-commands/</link><pubDate>Sun, 27 Nov 2022 14:45:58 +0800</pubDate><guid>https://wangloo.github.io/posts/shell/shell-commands/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/shell/shell-commands/ -&lt;blockquote>
&lt;p>我使用的 shell 是 Bash&lt;/p>
&lt;/blockquote>
&lt;h3 id="mount-相关">mount 相关&lt;/h3>
&lt;p>&lt;code>mount&lt;/code> 输出当前已经挂在的分区&lt;/p>
&lt;h3 id="where-and-which">where and which&lt;/h3>
&lt;p>which 查看可执行文件的位置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ which python3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/usr/bin/python3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>whereis 除了可执行文件还能搜索其他类型的文件, 不常用, 详见 &lt;code>man whereis&lt;/code>&lt;/p>
&lt;h3 id="--的妙用">&lt;code>-&lt;/code> 的妙用&lt;/h3>
&lt;p>一些命令支持使用 &lt;code>-&lt;/code> 代替文件名, 输入输出都可以:&lt;/p>
&lt;ul>
&lt;li>代替标准输出; 一些命令会将&lt;code>-o/-O&lt;/code> 后面的&lt;code>-&lt;/code>判定为输出到&lt;em>STDOUT&lt;/em>, 详见下面示例.&lt;/li>
&lt;li>代替标准输入;&lt;/li>
&lt;/ul>
&lt;p>下面给出两个同时代替输入输出的例子:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 将标准输入(STDIN)的内容作为gcc的输入, 编译后的结果输出到标准输出(STDOUT)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;void foo() {}&amp;#39;&lt;/span> | gcc -x c -o - -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># 将下载的文件输出到标准输出, 同时作为tar命令的输入文件, 进行解压&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget -O - &lt;span style="color:#f1fa8c">&amp;#34;https://www.dropbox.com/download?plat=lnx.x86_64&amp;#34;&lt;/span> | tar xzf -
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>&lt;code>-&lt;/code> 如何被解析是&lt;strong>取决于命令的实现&lt;/strong>, 非标准. 比如 &lt;code>cd -&lt;/code> 就有特殊的含义&lt;/p>
&lt;/blockquote>
- https://wangloo.github.io/posts/shell/shell-commands/ - @2019 Notepadium.</description></item><item><title>C语言工具宏</title><link>https://wangloo.github.io/posts/c/c-macros/</link><pubDate>Thu, 24 Nov 2022 01:35:24 +0800</pubDate><guid>https://wangloo.github.io/posts/c/c-macros/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/c/c-macros/ -&lt;h3 id="计算数组元素的个数">计算数组元素的个数&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define nelem(array) sizeof(array)/sizeof(array[0])
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>- https://wangloo.github.io/posts/c/c-macros/ - @2019 Notepadium.</description></item></channel></rss>