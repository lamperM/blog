<?xml-stylesheet href="/rss.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Homepage 🌈 on Soben's Secret Base</title><link>https://wangloo.github.io/</link><description>Recent content in Homepage 🌈 on Soben's Secret Base</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>@2019 Notepadium.</copyright><lastBuildDate>Thu, 15 Sep 2022 15:14:05 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>git 宝典</title><link>https://wangloo.github.io/posts/git/</link><pubDate>Tue, 13 Dec 2022 17:39:42 +0800</pubDate><guid>https://wangloo.github.io/posts/git/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/git/ -&lt;h2 id="合并操作-git-merge">合并操作: git merge&lt;/h2>
&lt;p>merge 有两种方式:&lt;/p>
&lt;ul>
&lt;li>fast-forward&lt;/li>
&lt;li>three-way merger&lt;/li>
&lt;/ul>
&lt;h3 id="fast-forward-merge">Fast-forward Merge&lt;/h3>
&lt;p>假设合并的双方为&lt;code>main&lt;/code>为&lt;code>dev&lt;/code>, 如果其中一个是另一个的祖先, 此时直接移动HEAD到前方即可, 称为fast-forward.&lt;/p>
&lt;p>例如, 当前在main, 执行&lt;code>git merge dev&lt;/code>的过程如下:&lt;/p>
&lt;pre tabindex="0">&lt;code> main main
| |
M1 --- M2 ===&amp;gt; M1 --- M2 -- F1
\ |
\--- F1 dev
|
dev
&lt;/code>&lt;/pre>&lt;h3 id="three-way-merge">three-way Merge&lt;/h3>
&lt;p>合并的两者不构成直接的祖先-孩子关系, 产生了分叉. 此时进行合并就需要有个基准(参考), 对于两边相较于基准的每个diff来说:&lt;/p>
&lt;ul>
&lt;li>合并的两者都在基准上进行了改动, 且改动不一致, &lt;strong>标记为冲突&lt;/strong>&lt;/li>
&lt;li>如果该diff&lt;strong>仅在其中一方&lt;/strong>有改动, 那么就保留此次改动&lt;/li>
&lt;/ul>
&lt;p>合并时使用的参考就是&lt;strong>两个合并commit的最近公共祖先&lt;/strong>, 这种借助三个commit(main, dev, 公共祖先)才能完成的合并操作就叫做 three-way merge.&lt;/p>
&lt;p>例如, 当前在main, 执行&lt;code>git merge dev&lt;/code>的过程如下:&lt;/p>
&lt;pre tabindex="0">&lt;code> main main
| |
M1 --- M2 --- M3 ===&amp;gt; M1 --- M2 --- M3 --- M4
\ \ /
\--- F1 \--- F1 ---
| |
dev dev
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>three-way 的合并方式如果发生了冲突, 会产生一次额外的 merge commit, 下面介绍它&lt;/p>
&lt;/blockquote>
&lt;h3 id="什么情况下-merge-commit-没有任何diff">什么情况下 merge commit 没有任何diff?&lt;/h3>
&lt;p>按照上面的例子, three-way merge 发生冲突后会产生一次额外的merge commit, 即M4. 如果这是去查看M4 相较前一次commit的diff, 有时是没有的, 有时又会产生diff.&lt;/p>
&lt;p>如果在解决冲突的过程中, 我们仅仅是接收了 M2,M3 或者F1的修改, 那么此时merge commit就不会有diff.&lt;/p>
&lt;p>然而, 在解决冲突时, 我们也可以不采用来自两条路径的修改, 做一次新的修改(可以说, 同时接收两条diff就是这种情况), 此时查看merge commit的diff就是有内容的.&lt;/p>
- https://wangloo.github.io/posts/git/ - @2019 Notepadium.</description></item><item><title>GNU 二进制工具集</title><link>https://wangloo.github.io/posts/compiler-tools/gnu_tools/</link><pubDate>Sat, 03 Dec 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/compiler-tools/gnu_tools/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/compiler-tools/gnu_tools/ -&lt;p>..&lt;/p>
&lt;h2 id="nm---列出符号">nm - 列出符号&lt;/h2>
&lt;p>&lt;a href="https://sourceware.org/binutils/docs/binutils/nm.html">nm (GNU Binary Utilities) (sourceware.org)&lt;/a>&lt;/p>
- https://wangloo.github.io/posts/compiler-tools/gnu_tools/ - @2019 Notepadium.</description></item><item><title>Makefile 一些技巧</title><link>https://wangloo.github.io/posts/compiler-tools/makefile_tricks/</link><pubDate>Sat, 03 Dec 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/compiler-tools/makefile_tricks/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/compiler-tools/makefile_tricks/ -&lt;p>..&lt;/p>
&lt;h3 id="使用shell-变量">使用shell 变量&lt;/h3>
&lt;p>Make 将 &lt;code>$$var&lt;/code> 转义为&lt;code>$var&lt;/code>, 供shell处理.&lt;/p>
&lt;p>demo(源自6.828 根目录&lt;code>GNUmakefile&lt;/code>):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-makefile" data-lang="makefile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">handin-check&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @if &lt;span style="color:#8be9fd;font-style:italic">test&lt;/span> -n &lt;span style="color:#f1fa8c">&amp;#34;`git status -s`&amp;#34;&lt;/span>; &lt;span style="color:#ff79c6">then&lt;/span> &lt;span style="color:#f1fa8c">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&lt;/span> git status -s; &lt;span style="color:#f1fa8c">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">read&lt;/span> -p &lt;span style="color:#f1fa8c">&amp;#34;Untracked files will not be handed in. Continue? [y/N] &amp;#34;&lt;/span> r; &lt;span style="color:#f1fa8c">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">test&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$$&lt;/span>&lt;span style="color:#f1fa8c">r&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">=&lt;/span> y; &lt;span style="color:#f1fa8c">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&lt;/span> &lt;span style="color:#ff79c6">fi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>以上demo还使用了 test 命令来终止make的执行, 如果用户没有输入&lt;code>y&lt;/code>, make将会终止执行&lt;/p>
&lt;/blockquote>
- https://wangloo.github.io/posts/compiler-tools/makefile_tricks/ - @2019 Notepadium.</description></item><item><title>Armv8 Kernel Monitor</title><link>https://wangloo.github.io/posts/os-learning/monitor/</link><pubDate>Fri, 28 Oct 2022 22:56:19 +0800</pubDate><guid>https://wangloo.github.io/posts/os-learning/monitor/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/os-learning/monitor/ -&lt;p> &lt;/p>
&lt;h2 id="kernel-monitor-是什么">Kernel Monitor 是什么&lt;/h2>
&lt;p>Kernel Monitor 是一个适配我们微内核操作系统的 Kernel 调试和监控系统. 它能实现内核的动态调试和监控. 同时, 它还接管内核的同步异常和系统错误, 使开发者能够了解发生异常时系统的状态.&lt;/p>
&lt;p>Kernel Monitor 具有一定的可扩展性, 例如通过统计内核中存储的 TCB 来实时监控系统中所有线程的状态. 可根据开发者的需求添加统计的对象, 如 Endpoint, Capability等.&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="kernel-monitor-总体设计">Kernel Monitor 总体设计&lt;/h2>
&lt;p>Kernel Monitor 系统包含 Clinet 和 Server 两个部分. 简单来说, Client 负责处理用户输入, 并将输入进行解析, 封装为 一系列基础命令. 发送给 Server. Server 负责执行这些 基础的命令, 如设置断点, 查看某个地址的值等.&lt;/p>
&lt;p>整个系统有&lt;em>两种架构&lt;/em>: 本地 Monitor 和远程 Monitor.&lt;/p>
&lt;p>本地monitor 和远程 monitor 的区别是: &lt;strong>Monitor Client 的位置在哪, 是否与 Server 在同一个机器上&lt;/strong>.&lt;/p>
&lt;blockquote>
&lt;p>先说 Monitor Server, 它必须嵌入要调试的 Kernel 中, &lt;strong>位于一个地址空间&lt;/strong>, 方便操作 Kernel 的内存.&lt;/p>
&lt;/blockquote>
&lt;h3 id="本地-monitor">本地 Monitor&lt;/h3>
&lt;p>在本地 Monitor 中, client 和 sever 都位于目标机(Target)上, 目标机通常是开发板.&lt;/p>
&lt;p>对于 AArch64 体系结构来说, 最多有四个异常等级(EL0-EL3). &lt;!-- raw HTML omitted -->Client 可以运行在EL2.&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>&lt;img src="./%E6%9C%AC%E5%9C%B0monitor.png" alt="image-20221029141414942">&lt;/p>
&lt;h3 id="远程-monitor">远程 Monitor&lt;/h3>
&lt;p>远程 Monitor 架构则不同, &lt;!-- raw HTML omitted -->Clinet 运行在宿主机(Host)上&lt;!-- raw HTML omitted -->, 通常是Linux. 它与 Server 的通信是通过网络/UART实现的.&lt;/p>
&lt;p>&lt;img src="./%E8%BF%9C%E7%A8%8Bmonitor.png" alt="image-20221029142002468">&lt;/p>
&lt;blockquote>
&lt;p>Monitor Client 运行在本地和远程对于实现的难度和用户体验有影响.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果 Client 实现在本地, 则 Client 无需实现网口和串口的驱动, 但Monitor 输入输出的串口与操作系统本身的串口相同, 信息冗杂在一起不易查看; 同时, 如果 Client 实现在本地, 那么对于ELF的解析需要在无操作系统提供的库支持下完成, 可能比较复杂.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果 Client 实现在远程, 即为 Linux 上的一个APP. 那么它和 Server 的通信就需要通过外部的网口或者串口(对于我们使用的64位开发板只引出了一个串口, 所以只能使用网口). 需要在 Server 上实现网口的驱动, 这部分比较复杂. 但是好处是 Client 的实现简单很多, 因为有 Linux APP 运行环境的支持. 同时, 远程 Monitor 架构下, Monitor 和 操作系统自身的输入输出分开, 用户可读性更好.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Server 是嵌入到Kernel的代码中, 与Client进行交互. 它是整个 Monitor 系统的后端, 负责实现基础的调试操作. 例如, 设置断点, 内存的读写, 寄存器的读写等.&lt;/p>
&lt;ul>
&lt;li>由于Server与 Kernel 位于同一个地址空间, 所以查看/修改内存的值是非常方便的. 对于寄存器也是同理.&lt;/li>
&lt;li>断点(Breakpoint), 监视点(Watchpoint), 单步执行(Soft step)的实现依赖与 ARMv8 提供的的 &lt;a href="https://developer.arm.com/-/media/Arm%20Developer%20Community/PDF/Learn%20the%20Architecture/V8A%20Self-hosted%20debug.pdf?revision=5eff4cc6-b4ca-4017-a07d-2957307058cb">self-hosted debug&lt;/a> 支持.&lt;/li>
&lt;/ul>
&lt;p>同时, Server 还负责监视系统中所有的 同步异常和系统错误. 一旦发生, 可在 Monitor 中查看某些内存, 寄存器的值定位问题发生的原因.&lt;/p>
&lt;h3 id="monitor-client-设计">Monitor Client 设计&lt;/h3>
&lt;p>Client 的构成可分为三个模块 :&lt;/p>
&lt;ul>
&lt;li>用户交互模块&lt;/li>
&lt;li>符号处理模块&lt;/li>
&lt;li>消息收发模块&lt;/li>
&lt;/ul>
&lt;p>用户交互模块负责处理用户的输入输出, 调用其他两个模块完成调试命令.&lt;/p>
&lt;p>符号处理模块负责解析可执行文件(ELF), 并建立静态符号表, 存储符号和地址的对应关系. 将用户输入的符号解析为虚拟地址, 或者反向解析.&lt;/p>
&lt;p>消息收发模块负责处理用户的输入, 将其转化为基础, 标准的命令, 发送给Server执行. Client 和 Server之间通信的数据包协议可以使用 &lt;a href="https://sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html">GDB Remote Serial Protocol&lt;/a> (以下简称RSP协议), 或者自己规定一个协议也是可行的.&lt;/p>
&lt;blockquote>
&lt;p>RSP协议支持三种基础命令:&lt;/p>
&lt;ol>
&lt;li>寄存器相关&lt;/li>
&lt;li>内存相关&lt;/li>
&lt;li>程序控制命令&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;h3 id="启用-monitor-时-kernel-启动流程">启用 Monitor 时 Kernel 启动流程&lt;/h3>
&lt;ol>
&lt;li>Kernel 首先做必要的初始化, GIC, 异常向量表, MMU等.&lt;/li>
&lt;li>将控制权交给 Monitor, 等待用户输入.&lt;/li>
&lt;/ol>
&lt;p> &lt;/p>
&lt;h2 id="kernel-debug-过程示例">Kernel debug 过程示例&lt;/h2>
&lt;h3 id="示例一-查看变量-var-的值">示例一: 查看变量 &lt;code>var&lt;/code> 的值&lt;/h3>
&lt;ol>
&lt;li>用户输入 &lt;code>print var&lt;/code> 指令.&lt;/li>
&lt;li>由符号处理模块, 将&lt;code>var&lt;/code>符号转为var 虚拟地址.&lt;/li>
&lt;li>由消息收发指令将请求封装为RSP协议包格式, 并发送到 Monitor Server.&lt;/li>
&lt;li>执行流程交给 Monitor Server, 它访问该地址, 将内容封装发回 Monitor Client.&lt;/li>
&lt;li>Client 输出&lt;code>var&lt;/code>的值, 继续等待用户输入&lt;/li>
&lt;/ol>
&lt;h3 id="示例二-添加断点到-main-函数">示例二: 添加断点到 &lt;code>main&lt;/code> 函数&lt;/h3>
&lt;ol>
&lt;li>用户输入 &lt;code>break main&lt;/code> 指令&lt;/li>
&lt;li>由符号处理模块, 解析得到 &lt;code>main&lt;/code> 函数的地址.&lt;/li>
&lt;li>消息收发模块将请求封装为RSP包格式, 发送到Monitor Server.&lt;/li>
&lt;li>执行流程交给 Server. 它执行 &lt;em>breakpoint exception 指令&lt;/em>, 并设置相关软件断点相关寄存器&lt;/li>
&lt;li>执行流交给 Kernel, 直到达到断点处(可使用地址+ContextID双重验证), 触发Debug异常&lt;/li>
&lt;li>Debug异常属于同步异常, 由 Monitor 系统接管, 回到 Client 继续等待用户输入&lt;/li>
&lt;/ol>
&lt;h3 id="示例三-单步执行">示例三: 单步执行&lt;/h3>
&lt;ol>
&lt;li>用户输入 &lt;code>step&lt;/code> 指令&lt;/li>
&lt;li>消息收发模块将请求封装为RSP包格式, 发送到 Monitor Server.&lt;/li>
&lt;li>执行流程交给 Server, 启用 software step. 然执行一次异常返回, 回到Kernel 继续执行.&lt;/li>
&lt;li>因为启用了 Software step, 回到 Kernel 执行完一条指令后, 就会触发 Debug异常&lt;/li>
&lt;li>Debug 异常属于同步异常, 由 Monitor 系统接管, 回到 Client 继续等待用户输入&lt;/li>
&lt;/ol>
&lt;p> &lt;/p>
&lt;h2 id="其他拓展功能">其他拓展功能&lt;/h2>
&lt;p>back trace&lt;/p>
&lt;p>性能分析&lt;/p>
- https://wangloo.github.io/posts/os-learning/monitor/ - @2019 Notepadium.</description></item><item><title>ARMv8-A MMU 介绍</title><link>https://wangloo.github.io/posts/armv8/mmu/</link><pubDate>Thu, 29 Sep 2022 08:01:33 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/mmu/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/armv8/mmu/ -&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>MMU: 专用于将虚拟地址转换为物理地址. 通常配合分页机制来工作.&lt;/p>
&lt;p>页表: 页表中的表项包含提供虚拟地址和物理地址之间的映射.&lt;/p>
&lt;p>MMU就是直接访问页表, 并且通过将频繁使用的映射缓存到TLB中.&lt;/p>
&lt;h3 id="mmu-的结构">MMU 的结构&lt;/h3>
&lt;p>MMU是一种硬件, 可以通过在适当的安全状态下对其进行配置. 每个Core都有自己的MMU, 每个MMU包括:&lt;/p>
&lt;ol>
&lt;li>一个TLB, 缓存最近访问的映射.&lt;/li>
&lt;li>一个Table Walk Unit, 从内存中查询页表, 得到最终的虚拟地址-物理地址的映射.&lt;/li>
&lt;/ol>
&lt;p>MMU 控制着整个系统的缓存策略, 内存属性和访问权限. MMU开启后, 软件发出的所有内存访问都使用虚拟地址, 要求MMU为每次访问进行地址转换.&lt;/p>
&lt;h3 id="mmu-的配置">MMU 的配置&lt;/h3>
&lt;p>在启用MMU前, 必须告知其页表存放的位置.&lt;/p>
&lt;h3 id="mmu-地址转换的过程">MMU 地址转换的过程&lt;/h3>
&lt;p>对于每个转换请求, MMU首先检查TLB是否已经对该地址缓存, 如果该地址未缓存, 则需要遍历页表.&lt;/p>
&lt;p>页表遍历单元在页表中搜索相关的映射表项.&lt;/p>
&lt;ul>
&lt;li>一旦找到映射, MMU就会检查权限和属性. 决定允许本次访问, 或者发出故障信号.&lt;/li>
&lt;li>若未找到映射, 则触发缺页异常.&lt;/li>
&lt;/ul>
&lt;h3 id="页表的工作原理">页表的工作原理&lt;/h3>
&lt;p>页表的工作方式是将虚拟地址空间和物理地址空间划分为大小相等的块, 称为页面.&lt;/p>
&lt;p>页表中的每个表项对应着一块虚拟地址空间中的块, 表项的值就是这块虚拟地址空间对应的物理地址块, 以及访问物理地址时要使用的属性.&lt;/p>
&lt;p>在查表过程中, 将虚拟地址分为两部分:&lt;/p>
&lt;ul>
&lt;li>高阶位用作页表的索引. 用来找到对应的物理块&lt;/li>
&lt;li>低地址是块内的偏移量, 不会因为映射而改变. 页表项中的物理地址与该偏移组合形成用于访问内存的物理地址.&lt;/li>
&lt;/ul>
&lt;h4 id="多级页表">多级页表&lt;/h4>
&lt;p>实际实现中, 多采用多级页表的方案, 各级页表自定向下组成树的形式, 协作实现虚拟到物理地址的转换.&lt;/p>
&lt;p>树中的分支成为页目录, 页目录中的表项不是直接存储目标物理地址, 而是下一级页表的地址; 最后一级页表的表项中保存着目标物理地址.&lt;/p>
&lt;blockquote>
&lt;p>多级页表是减小页表占用存储空间过大的有效方案.&lt;/p>
&lt;/blockquote>
&lt;p>顶级页表将地址空间划分为大块, 每个表项可以指向大小相等的内存块. 也可以指向将块进行再次细分的下一级页表. 支持大块的优点:&lt;/p>
&lt;ul>
&lt;li>大的内存块需要查表的次数更少&lt;/li>
&lt;li>提升TLB的效率, 因为一个TLB表项覆盖更大的内存区域.&lt;/li>
&lt;/ul>
&lt;p>凡事都是有利有弊, 使用大块也增加了内存浪费, 实际使用时需要根据需要来权衡.&lt;/p>
&lt;h2 id="内存类型">内存类型&lt;/h2>
&lt;h3 id="普通类型内存">普通类型内存&lt;/h3>
&lt;p>普通类型的内存是弱一致性的(weakly ordered)内存模型, 没有额外的约束, 可以提供最高的内存访问性能.&lt;/p>
&lt;p>通常代码段, 数据段以及其他数据都放在普通内存中.&lt;/p>
&lt;p>普通内存允许处理器做很多优化, 如分支预测, 数据预取, Cache line预取, 乱序执行等.&lt;/p>
&lt;h3 id="设备类型内存">设备类型内存&lt;/h3>
&lt;p>CPU访问设备内存会有很多限制, 如不能进行数据预取等. 设备类型的内存严格按照指令的顺序来执行的.&lt;/p>
&lt;p>设备类型内容通常留给设备来访问, 例如中断控制器(GIC), 串口, 定时器等.&lt;/p>
&lt;h2 id="两套页表">两套页表&lt;/h2>
&lt;ul>
&lt;li>当CPU访问的地址属于&lt;em>用户空间&lt;/em>时, MMU会自动选择&lt;strong>TTBR0&lt;/strong>指向的页表.&lt;/li>
&lt;li>当CPU访问的地址属于&lt;em>内核空间&lt;/em>时. MMU会自动选择&lt;strong>TTBR1&lt;/strong>指向的页表&lt;/li>
&lt;/ul>
&lt;p>EL2和EL3没有TTBR1, 只有TTBR0. 也就意味着:&lt;/p>
&lt;p>• If EL2 is using AArch64, it can only use Virtual Addresses in the range 0x0 to 0x0000FFFF_FFFFFFFF.
• If EL3 is using AArch64, it can only use Virtual Addresses in the range 0x0 to 0x0000FFFF_FFFFFFFF.&lt;/p>
&lt;h2 id="越权-越界">越权, 越界&lt;/h2>
&lt;p>在未使用虚拟地址空间之前, 所有的用户程序都可以访问全部的物理内存, 所以恶意程序可以修改其他程序的内存数据, 这使得整个系统处于危险的状态. 每个进程的地址空间都要受到保护, 以免被其他进程有意/无意的破坏.&lt;/p>
&lt;p>现代操作系统中, 每个进程都有独立的虚拟地址空间. 在进程的角度上, 它拥有整个虚拟地址空间. 不同的进程可以同时使用一个虚拟地址, MMU通过页表将其映射到合适的物理地址.&lt;/p>
&lt;h3 id="两个物理地址空间">两个物理地址空间&lt;/h3>
&lt;p>ARMv8 体系结构定义两个物理地址空间: secure address space 和 non-secure address space.&lt;/p>
&lt;p>理论上, 安全和非安全的地址空间是相互独立的, 然而现实中大多数系统都将安全和非安全视为访问控制的属性. 正常(非安全)世界只能访问非安全的物理内存; 而安全世界可以访问这两个地址空间.&lt;/p>
&lt;h3 id="armv8-mmu权限控制">ARMv8 MMU权限控制&lt;/h3>
&lt;p>程序请求某个地址时, MMU需要进行权限检查. 如果请求的地址是数据, 则检查读写权限; 如果请求的是地址, 则检查其可执行权限.&lt;/p>
&lt;p>ARMv8 页表项的AP字段控制该不同异常等级下, 页面的读写权限.&lt;/p>
&lt;p>[表格]&lt;/p>
&lt;p>ARMv8 页表项的PNX字段和XN/UXN字段来设置CPU是否对这个页面有执行权限.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>当系统有两套页表时, UXN是用来设置用户空间页面是否有可执行权限; PXN 用来设置特权空间的页面是否有可执行权限.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若系统只有一套页表, 则通过XN字段控制&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="页表的结构">页表的结构&lt;/h2>
&lt;h3 id="地址宽度">地址宽度&lt;/h3>
&lt;p>48bit&lt;/p>
&lt;h3 id="页面粒度">页面粒度&lt;/h3>
&lt;p>页面粒度表示一次最小分配内存块的大小. AArch64支持三种页的大小, 4KB, 16KB, 64KB. 支持哪一种是由实现定义的。创建页表的代码能够读取系统寄存器&lt;code>ID_AA64MMFR0_EL1&lt;/code>，以找出哪些是受支持的大小。Cortex-A53处理器支持所有三种尺寸，但有些处理器的早期版本并非如此，例如Cortex-A57，它不支持16K粒度。&lt;/p>
&lt;h3 id="aarch64-页表项结构">AArch64 页表项结构&lt;/h3>
&lt;h4 id="无效页表项">无效页表项&lt;/h4>
&lt;h4 id="table">table&lt;/h4>
&lt;h4 id="block">block&lt;/h4>
&lt;h3 id="页表结构4kb页面为例">页表结构(4KB页面为例)&lt;/h3>
&lt;p>以4KB页面粒度, 虚拟地址宽度为 48位. 使用4级页表.&lt;/p>
&lt;p>48位地址每层转换有9个地址位，即每层512个条目，最后12位选择4kB内的一个字节，直接来自原始地址&lt;/p>
&lt;h2 id="虚拟地址到物理地址的转换过程">虚拟地址到物理地址的转换过程&lt;/h2>
&lt;p>当处理器为获取指令或数据访问发出一个64位的虚拟地址时，MMU硬件将虚拟地址转换为相应的物理地址。对于虚拟地址，前16位[63:47]必须全部为0或1，否则地址将触发故障。&lt;/p>
&lt;h3 id="non-secure-and-secure-access">Non-secure and secure access&lt;/h3>
&lt;p>ARMv8-A架构定义了两种安全状态:安全的和非安全的。它还定义了两个物理地址空间:安全的和非安全的. 正常(非安全)世界只能访问非安全物理地址空间。安全世界可以访问两个物理地址空间。这也是通过转换表来控制的。&lt;/p>
&lt;p>在非安全状态下，转换表中的NS位和NSTable位将被忽略。只能访问非安全内存。在安全状态下，NS位和NSTable位控制虚拟地址转换为安全物理地址还是非安全物理地址。&lt;/p>
&lt;p>You can use SCR_EL3.SIF 来禁用安全世界访问非安全地址.&lt;/p>
&lt;h2 id="相关的寄存器">相关的寄存器&lt;/h2>
&lt;p>与地址转换相关的寄存器主要有以下几个:&lt;/p>
&lt;ol>
&lt;li>转换控制寄存器(TCR)&lt;/li>
&lt;li>系统控制寄存器(SCTLR)&lt;/li>
&lt;li>页表基地址寄存器(TTBR)&lt;/li>
&lt;/ol>
&lt;h3 id="tcr">TCR&lt;/h3>
&lt;p>IPS: 配置地址转换后输出物理地址的最大值&lt;/p>
&lt;p>TxSz: 配置输入地址的最大值, 即虚拟地址的宽度&lt;/p>
&lt;p>TG1: 配置TTBR1页表的页面粒度大小&lt;/p>
&lt;p>SHx: 配置TTBRx相关内存的Cache共享属性&lt;/p>
&lt;p>ORGNx:&lt;/p>
&lt;p>IRGNx:&lt;/p>
&lt;h3 id="sctlr">SCTLR&lt;/h3>
&lt;p>M: Disable/Enable MMU地址转换&lt;/p>
&lt;p>C: Disable/Enable Data Cache&lt;/p>
&lt;p>I: Disable/Enable Instruction Cache&lt;/p>
&lt;h3 id="ttbr">TTBR&lt;/h3>
&lt;p>存储页表的基地址&lt;/p>
&lt;h2 id="aarch32-虚拟内存系统">AArch32 虚拟内存系统&lt;/h2>
&lt;p>ARMv8 AArch32 的虚拟内存系统向后兼容ARMv7, 与ARMv7的基本一致.&lt;/p>
- https://wangloo.github.io/posts/armv8/mmu/ - @2019 Notepadium.</description></item><item><title>GICv3 - for ARMV8</title><link>https://wangloo.github.io/posts/armv8/gicv3/</link><pubDate>Sat, 10 Sep 2022 21:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/gicv3/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/armv8/gicv3/ -&lt;h1 id="gicv3generic-interrupt-controller---version-3">GICV3(Generic Interrupt Controller - version 3)&lt;/h1>
&lt;h2 id="关于gic">关于GIC&lt;/h2>
&lt;p>GIC即中断控制器, 负责管理中断的接收, 屏蔽, 路由等相关任务, 并向系统程序员提供配置的接口.&lt;/p>
&lt;p>GIC与异常模型协作完成中断的整个生命周期, GIC主要负责&lt;code>中断源-产生IRQ/FIQ信号&lt;/code>这段路, 关于处理IRQ/FIQ则是由CPU内部的&lt;em>异常模型&lt;/em>来完成.&lt;/p>
&lt;h2 id="对比-gicv2">对比 GICv2&lt;/h2>
&lt;ul>
&lt;li>支持更多的处理器, 用&lt;code>affinity routing&lt;/code> 方案来做中断路由.&lt;/li>
&lt;li>支持中断分组, 为了配合ARMv8的异常等级模型&lt;/li>
&lt;li>新增中断类型: SGI, 软件生成中断&lt;/li>
&lt;li>新增中断类型: SPI, Shared Peripheral Interrupts&lt;/li>
&lt;li>对于CPU interface的寄存器, 可直接使用系统寄存器接口(system register interface)来访问, 比memory-mapped的方式快.&lt;/li>
&lt;li>ITS, Interrupt Translation Service 暂不介绍&lt;/li>
&lt;li>LPI, Locality-specific Peripheral Interrupts . 暂不介绍&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>GICv3支持ARMv8-A或ARMv8-R系列处理器, 但没有必然的绑定关系. ARMv8-A也可以使用GICv2.&lt;/p>
&lt;/blockquote>
&lt;h2 id="中断类型">中断类型&lt;/h2>
&lt;h3 id="locality-specific-peripheral-interrupt-lpi">Locality-specific Peripheral Interrupt (LPI)&lt;/h3>
&lt;p>LPIs are always &lt;a href="https://en.wikipedia.org/wiki/Message_Signaled_Interrupts">message-based interrupts&lt;/a> interrupts. 这里不做介绍.&lt;a href="https://en.wikipedia.org/wiki/Message_Signaled_Interrupts">wiki&lt;/a>&lt;/p>
&lt;h3 id="private-peripheral-interrupt-ppi">Private Peripheral Interrupt (PPI)&lt;/h3>
&lt;p>PPI是路由到&lt;strong>单个CPU&lt;/strong>的外设中断, 不同的CPU可以使用相同的中断号. 例如, 所有CPU都可以使用中断号16表示私有的定时器中断.&lt;/p>
&lt;h3 id="shared-peripheral-interrupt-spi">Shared Peripheral Interrupt (SPI)&lt;/h3>
&lt;p>SPI是可路由到&lt;strong>一组CPU&lt;/strong>的外设中断, Distributor 负责SPI路由.&lt;/p>
&lt;h3 id="software-generated-interrupt-sgi">Software Generated Interrupt (SGI)&lt;/h3>
&lt;p>SGI是由某个CPU产生, 路由到系统中的一个或多个CPU, 通常用于处理器间通信.&lt;/p>
&lt;h2 id="gicv3-的组件">GICv3 的组件&lt;/h2>
&lt;p>GICv3架构由以下逻辑组件构成:&lt;/p>
&lt;ul>
&lt;li>A Distributor&lt;/li>
&lt;li>A Redistributor for each CPU&lt;/li>
&lt;li>A CPU interface for each CPU&lt;/li>
&lt;li>Interrupt Translation Service components (ITS). 可选, 暂不介绍&lt;/li>
&lt;/ul>
&lt;p>The Distributor, Redistributor 一起组成了 &lt;em>IRI(Interrupt Routing Infrastructure)&lt;/em>.&lt;/p>
&lt;p>&lt;img src="./IRI.png" alt="iri">{width=&amp;ldquo;10px&amp;rdquo;}&lt;/p>
&lt;h3 id="distributor">Distributor&lt;/h3>
&lt;p>控制SPI和SGI的路由. 对于 SPI, 提供了一下接口:&lt;/p>
&lt;ul>
&lt;li>启动/禁用 SPI&lt;/li>
&lt;li>设置 SPI 的优先级&lt;/li>
&lt;li>配置对于 SPI 的路由&lt;/li>
&lt;li>设置 SPI 的触发方式&lt;/li>
&lt;li>生成 message-based SPI&lt;/li>
&lt;li>为每个 SPI 分组&lt;/li>
&lt;li>控制 SPI 的 &lt;code>pending and active&lt;/code> 状态&lt;/li>
&lt;/ul>
&lt;p>对于&lt;code>Distributor&lt;/code>的大部分配置通过&lt;code>GICD_CTLR&lt;/code>实现. 包括:&lt;/p>
&lt;ul>
&lt;li>启用 Affinity routing&lt;/li>
&lt;li>禁用安全性&lt;/li>
&lt;li>中断分组的配置.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>关于Distributor 寄存器都含有 &lt;code>GICD_&lt;/code> 前缀, 通过 &lt;code>memory-mapped&lt;/code> 方式访问.&lt;/p>
&lt;/blockquote>
&lt;h3 id="redistributor">Redistributor&lt;/h3>
&lt;ul>
&lt;li>启动/禁用 SGI 和 PPI&lt;/li>
&lt;li>设置 SGI 和 PPI 的优先级&lt;/li>
&lt;li>设置 SGI 和 PPI 的触发方式&lt;/li>
&lt;li>为 SGI 和 PPI 分配组&lt;/li>
&lt;li>控制 SGI 和 PPI 的 &lt;code>pending&lt;/code> 状态和 &lt;code>active&lt;/code> 状态&lt;/li>
&lt;li>与之链接的 CPU 的电源管理.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>关于Redistributor 寄存器都含有 &lt;code>GICR_&lt;/code> 前缀, 通过 &lt;code>memory-mapped&lt;/code> 方式访问.&lt;/p>
&lt;/blockquote>
&lt;h3 id="cpu-interface">CPU interface&lt;/h3>
&lt;ul>
&lt;li>Acknowledge 一个中断&lt;/li>
&lt;li>执行 End Of Interrupt&lt;/li>
&lt;li>Deactivate 一个中断&lt;/li>
&lt;li>设置 CPU 的优先级Mask&lt;/li>
&lt;li>配置中断抢占&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>关于 CPU interface 寄存器是以 &lt;code>ICC_&lt;/code> 为前缀, 还有 &lt;code>ICV&lt;/code> for vitual interrupt, &lt;code>ICH&lt;/code> for hypervisor configuration.&lt;/p>
&lt;/blockquote>
&lt;h2 id="中断的状态转换">中断的状态转换&lt;/h2>
&lt;p>&lt;img src="./int-lifestyle.png" alt="">&lt;/p>
&lt;ol>
&lt;li>生成中断. 中断可能来自外部信号, 或者软件生成(SGI)&lt;/li>
&lt;li>Distribute. IRI 负责中断的分组, 优先级屏蔽等. 将合适的中断发送到CPU Interface.&lt;/li>
&lt;li>Deliver. CPU interface 将中断发送到连接的CPU.&lt;/li>
&lt;li>Activate. CPU读取IAR寄存器, 即发送ACK. 该中断的状态转为active.&lt;/li>
&lt;li>Priority drop. 处理程序结束之后, 写&lt;code>ICC_EOIR&lt;/code>寄存器, end of interrupt&lt;/li>
&lt;li>Deactivation. 写&lt;code>ICC_DIR&lt;/code>寄存器清除中断的active标志位. 一般来说, end of interrupt 和 deactivation 可配置成同时发生.&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>&lt;code>ICC_CTLR_ELx.EOImode&lt;/code> 位控制是否 end of interrupt 同时导致 deactivation.&lt;/p>
&lt;p>❓ EOI 和 deactivated 分开进行暂时还不知道应用场景.&lt;/p>
&lt;/blockquote>
&lt;h2 id="中断id-intid">中断ID: INTID&lt;/h2>
&lt;p>INTID 是中断的标识符, 它的最大值是&lt;em>实现定义&lt;/em>的, 可以在&lt;code>GICD_TYPER.IDbits&lt;/code>中读取。&lt;/p>
&lt;p>INTID按照中断类型分类的, 对照表如下:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>INTID&lt;/th>
&lt;th>中断类型&lt;/th>
&lt;th>Note&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0-15&lt;/td>
&lt;td>SGI&lt;/td>
&lt;td>本地的, 不同CPU可使用同一中断号代表不同中断&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>16-31&lt;/td>
&lt;td>PPI&lt;/td>
&lt;td>本地的&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>32-1019&lt;/td>
&lt;td>SPI&lt;/td>
&lt;td>全局的&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1020-1023&lt;/td>
&lt;td>特殊中断&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1056-1119&lt;/td>
&lt;td>扩展的PPI&lt;/td>
&lt;td>本地的&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4096 – 5119&lt;/td>
&lt;td>扩展的SPI&lt;/td>
&lt;td>全局的&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="特殊中断号">特殊中断号&lt;/h3>
&lt;blockquote>
&lt;p>These INTIDs do not require an end of interrupt or deactivation.&lt;/p>
&lt;/blockquote>
&lt;p>1020:&lt;/p>
&lt;p>1021:&lt;/p>
&lt;p>1022:&lt;/p>
&lt;p>1023: 读&lt;code>ICC_IAR1_EL1&lt;/code> 返回该值表明当前的CPU上没有待处理的中断.&lt;/p>
&lt;h2 id="中断分组">中断分组&lt;/h2>
&lt;p>为了配合 ARMv8 的异常模型和安全模型, GICv3 支持为每个中断配置不同的组. 不同组的中断只能路由到特定的异常等级和安全状态进行处理.&lt;/p>
&lt;p>共包含三个分组: Gourp 0, Secure Group 1, Non-secure Group 1.&lt;/p>
&lt;ul>
&lt;li>Group 0的中断需要在EL3 处理.&lt;/li>
&lt;li>Secure Group1 的中断需要在 Secure EL1 或者 Secure EL2(如果启用了虚拟化)处理.&lt;/li>
&lt;li>Non-secure Group 1 的中断需要在 Non-secure EL2 or Non-secure EL1 if not using virtualization&lt;/li>
&lt;/ul>
&lt;p>同时, 中断位于哪个组也决定了其触发的是FIQ还是IRQ. 对于 AArch64 来说, 对应关系可见下表:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>当前异常等级&lt;/th>
&lt;th>Group 0 的中断&lt;/th>
&lt;th>Secure Group 1 的中断&lt;/th>
&lt;th>Non-secure Group 1&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Secure EL1/0/2&lt;/td>
&lt;td>FIQ&lt;/td>
&lt;td>IRQ&lt;/td>
&lt;td>FIQ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Non-secure EL1/0/2&lt;/td>
&lt;td>FIQ&lt;/td>
&lt;td>FIQ&lt;/td>
&lt;td>IRQ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>EL3&lt;/td>
&lt;td>FIQ&lt;/td>
&lt;td>FIQ&lt;/td>
&lt;td>FIQ&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>Group 0 的中断, 需要在EL3处理, 其优先级较高, 所以均属于 FIQ&lt;/li>
&lt;/ul>
&lt;h2 id="中断路由">中断路由&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>PPIs are routed directly from the source to the local Redistributor .&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SPIs are routed from the source through the Distributor to the target Redistributor and the associated CPU interface.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SGIs are generated by software through the CPU interface and Redistributor. They are then routed through the Distributor to one or more target Redistributors and the associated CPU interfaces&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="what-is-affinity-routing">What is Affinity Routing?&lt;/h3>
&lt;p>Affinity routing 是一种基于地址的标识多个CPU的方法, 用于中断的路由. Affinity value 由4个8bit字段组成, 结构是&lt;code>aff3.aff2.aff1.aff0&lt;/code>.&lt;/p>
&lt;p>由于 PPI 的中断源是直连 Redistributor 的, 所以仅 SPI 和 SGI 可以使用 Affinity routing.&lt;/p>
&lt;ul>
&lt;li>对于 SPI, 目标CPU的 affinity value 通过&lt;code>GICD_IROUTER&amp;lt;n&amp;gt;&lt;/code> 设置.&lt;/li>
&lt;li>对于 SGI, 在生成时即可同时配置, 详见 &lt;code>ICC_SGI0R_EL1&lt;/code> 和 &lt;code>ICC_SGI1R_EL1&lt;/code>.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Aff3.Aff2.Aff1.Aff0 与 Aff3.Aff2.Aff2.TargetList&lt;/p>
&lt;p>对于SPI, 目标的CPU只能是一个, 故&lt;code>Aff0&lt;/code>表示该CPU的ID. 而SGI可以配置同时发给多个CPU, 所以&lt;code>TargetList&lt;/code>是基于位操作的, 每个位表示一个CPU.&lt;/p>
&lt;/blockquote>
&lt;h2 id="编程指导">编程指导&lt;/h2>
&lt;h3 id="初始化">初始化&lt;/h3>
&lt;p>由于 &lt;em>Distributor&lt;/em> 整个系统共享的, 所以必须在其他核启动之前, 由主核完成初始化. 然后当所有核都启动后, 各自完成各自 &lt;em>Redistributor&lt;/em> 和 &lt;em>CPU interface&lt;/em> 的初始化工作.&lt;/p>
- https://wangloo.github.io/posts/armv8/gicv3/ - @2019 Notepadium.</description></item><item><title>Useful Shell Script Examples</title><link>https://wangloo.github.io/posts/shell/shell-script/</link><pubDate>Wed, 20 Jul 2022 11:54:13 +0800</pubDate><guid>https://wangloo.github.io/posts/shell/shell-script/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/shell/shell-script/ -&lt;h2 id="判断执行脚本时带的参数">判断执行脚本时带的参数&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">$#&lt;/span> -ne &lt;span style="color:#bd93f9">1&lt;/span> &lt;span style="color:#ff79c6">]&lt;/span>; &lt;span style="color:#ff79c6">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;ONE parameter is needed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">exit&lt;/span> -1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">$1&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;build&amp;#39;&lt;/span> &lt;span style="color:#ff79c6">]&lt;/span>; &lt;span style="color:#ff79c6">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4"># do something&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">elif&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">$1&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;run&amp;#39;&lt;/span> &lt;span style="color:#ff79c6">]&lt;/span>; &lt;span style="color:#ff79c6">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4"># do something&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">elif&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">$1&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;gdb&amp;#39;&lt;/span> &lt;span style="color:#ff79c6">]&lt;/span>; &lt;span style="color:#ff79c6">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4"># do something&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Not supported command&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="自动拷贝文件到sd-card">自动拷贝文件到SD Card&lt;/h2>
&lt;blockquote>
&lt;p>TODO&lt;/p>
&lt;ol>
&lt;li>添加进度条&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">sd_path&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#ff79c6">$(&lt;/span>find /media/&lt;span style="color:#8be9fd;font-style:italic">$USER&lt;/span> -maxdepth &lt;span style="color:#bd93f9">1&lt;/span> -type d -name &lt;span style="color:#f1fa8c">&amp;#34;*-*&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">while&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span> ! -d &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">sd_path&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sleep &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;waiting for inserting SD-Card&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;SD-Card is inserted&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cp ./output/kernel/kernel.bin &lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">sd_path&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Copy completely&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="获取所有文件信息可递归进入子目录">获取所有文件信息(可递归进入子目录)&lt;/h2>
&lt;p>获取&lt;code>dir&lt;/code>路径下的所有文件的信息, 这里获取的是文件的&lt;strong>完整路径&lt;/strong>.&lt;/p>
&lt;blockquote>
&lt;p>TODO&lt;/p>
&lt;ol>
&lt;li>操作数组下标的方式可能有待改进? &lt;code>filenum&lt;/code>感觉没必要, 暂时还不会改&lt;/li>
&lt;li>通过拼接获得文件信息(路径)的方式也有点怪异&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">dir&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>./
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">files&lt;/span>&lt;span style="color:#ff79c6">=()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">filenum&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">function&lt;/span> getfiles&lt;span style="color:#ff79c6">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> file in &lt;span style="color:#f1fa8c">`&lt;/span>ls &lt;span style="color:#8be9fd;font-style:italic">$dir&lt;/span>&lt;span style="color:#f1fa8c">`&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span> -d &lt;span style="color:#8be9fd;font-style:italic">$file&lt;/span> &lt;span style="color:#ff79c6">]&lt;/span>; &lt;span style="color:#ff79c6">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">cd&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">$file&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> getfiles
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">cd&lt;/span> ..
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> files&lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$filenum&lt;/span>&lt;span style="color:#ff79c6">]=&lt;/span>&lt;span style="color:#ff79c6">$(&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">pwd&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">$file&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span>/&lt;span style="color:#ff79c6">$(&lt;/span>basename &lt;span style="color:#8be9fd;font-style:italic">$file&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4"># echo file=$(pwd $file)/$(basename $file)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> filenum++
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="带颜色的输出">带颜色的输出&lt;/h2>
&lt;p>使用&lt;a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape code&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>Black 0;30 Dark Gray 1;30
Red 0;31 Light Red 1;31
Green 0;32 Light Green 1;32
Brown/Orange 0;33 Yellow 1;33
Blue 0;34 Light Blue 1;34
Purple 0;35 Light Purple 1;35
Cyan 0;36 Light Cyan 1;36
Light Gray 0;37 White 1;37
&lt;/code>&lt;/pre>&lt;p>Code example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">RED&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;\033[0;31m&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">GREEN&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;\033[0;32m&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">YELLOW&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;\033[1;33m&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">BLUE&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;\033[0;34m&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">CYAN&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;\033[0;36m&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">NC&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;\033[0m&amp;#39;&lt;/span> &lt;span style="color:#6272a4"># No Color&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> -e &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">YELLOW&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">HELLO, YELLOW&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">NC&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> -e &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">GREEN&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">HELLO, GREEN&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">NC&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> -e &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">RED&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">HELLO, RED&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">NC&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> -e &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">BLUE&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">HELLO, BLUE&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">NC&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> -e &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">CYAN&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">HELLO, CYAN&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">NC&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">#########################################################&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># generic functions #####################################&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">function&lt;/span> ERROR&lt;span style="color:#ff79c6">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> -e &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">RED&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">[error] &lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$*&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">NC&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">exit&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">function&lt;/span> INFO &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> -e &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">BLUE&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">[info] &lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$*&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">NC&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">function&lt;/span> WARN &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> -e &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">YELLOW&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">[warn] &lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$*&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">NC&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">function&lt;/span> LOG &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">echo&lt;/span> -e &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">GREEN&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">[log] &lt;/span>&lt;span style="color:#8be9fd;font-style:italic">$*&lt;/span>&lt;span style="color:#f1fa8c">${&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">NC&lt;/span>&lt;span style="color:#f1fa8c">}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> &amp;gt;&amp;gt; &lt;span style="color:#8be9fd;font-style:italic">$LOG&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INFO &lt;span style="color:#f1fa8c">&amp;#34;This is an infomation&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WARN &lt;span style="color:#f1fa8c">&amp;#34;This is a log&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>- https://wangloo.github.io/posts/shell/shell-script/ - @2019 Notepadium.</description></item><item><title>C 语言位操作技巧</title><link>https://wangloo.github.io/posts/codestyle/bit-operation-hacks/</link><pubDate>Sun, 03 Jul 2022 09:44:13 +0800</pubDate><guid>https://wangloo.github.io/posts/codestyle/bit-operation-hacks/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/codestyle/bit-operation-hacks/ -&lt;h2 id="判断一个数是否为2的幂">判断一个数是否为2的幂&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">unsigned&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> v;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> ((v &lt;span style="color:#ff79c6">&amp;amp;&lt;/span> (v &lt;span style="color:#ff79c6">-&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>)) &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#f1fa8c">&amp;#34;v is a power of 2&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">printf&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;v is not a power of 2&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="统计一个数的二进制中1的数量">统计一个数的二进制中1的数量&lt;/h2>
&lt;p>依然是利用&lt;code>v &amp;amp; (v -1)&lt;/code>的运算结果会将v的最低位的&lt;code>1&lt;/code>(如果有的话)置&lt;code>0&lt;/code>.&lt;/p>
&lt;p>循环执行此操作就可统计v中&lt;code>1&lt;/code>的数量.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#50fa7b">numberof1&lt;/span>(&lt;span style="color:#8be9fd">int&lt;/span> v) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> count &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">while&lt;/span>(v) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count&lt;span style="color:#ff79c6">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v &lt;span style="color:#ff79c6">=&lt;/span> v &lt;span style="color:#ff79c6">&amp;amp;&lt;/span> (v &lt;span style="color:#ff79c6">-&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> count;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="将一个数向上取整为2的幂">将一个数向上取整为2的幂&lt;/h2>
&lt;p>用一个&lt;code>1&lt;/code>一直左移, 直到比这个数大为止.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">uint32_t&lt;/span> &lt;span style="color:#50fa7b">roundup_pow_op_two&lt;/span>(&lt;span style="color:#ff79c6">const&lt;/span> &lt;span style="color:#8be9fd">uint32_t&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">uint32_t&lt;/span> ret &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">while&lt;/span> (ret &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ret &lt;span style="color:#ff79c6">=&lt;/span> ret &lt;span style="color:#ff79c6">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> ret;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="向上向下对齐-检查是否对齐">向上/向下对齐, 检查是否对齐&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">/* uintptr_t 代表指针的位数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * 加uintptr_t转换的原因是: (void *)不能进行运算
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define IS_ALIGNED(X, align) (((uintptr_t)(const void *)(X)) % (align) == 0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define ALIGN_UP(X, align) (((X) + ((align) - 1)) &amp;amp; ~((align) - 1))
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define ALIGN_DOWN(x, align) ((X) &amp;amp; ~((align) - 1))
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define X (0x12345675)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define align (1 &amp;lt;&amp;lt; 2)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> v &lt;span style="color:#ff79c6">=&lt;/span> IS_ALIGNED(X, align);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#bd93f9">0&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> v) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#f1fa8c">&amp;#34;Given X(0x%x) is not align to 0x%08x&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, X, align);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#f1fa8c">&amp;#34;After align up, new X = 0x%x&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, ALIGN_UP(X, align));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#f1fa8c">&amp;#34;After align down, new X = 0x%x&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, ALIGN_DOWN(X, align));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#f1fa8c">&amp;#34;Give X(0x%x) is aligned to 0x%08x&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, X, align);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#f1fa8c">&amp;#34;After align up, new X = 0x%x&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, ALIGN_UP(X, align));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#f1fa8c">&amp;#34;After align down, new X = 0x%x&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, ALIGN_DOWN(X, align));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="检查两个有符号数是否异号">检查两个有符号数是否异号&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> x,y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> ((x &lt;span style="color:#ff79c6">^&lt;/span> y) &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#f1fa8c">&amp;#34;They have opposite signs&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">printf&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;They have same signs&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="大小端转换">大小端转换&lt;/h2>
&lt;p> &lt;/p>
&lt;h2 id="对某个位的getsetclear操作">对某个位的get/set/clear操作&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define GET_BIT(x, bit) ( ((x) &amp;amp; (1ULL &amp;lt;&amp;lt; (bit))) &amp;gt;&amp;gt; (bit) )
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define SET_BIT(x, bit) ( (x) |= (1ULL &amp;lt;&amp;lt; (bit)) )
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define CLEAR_BIT(x, bit) ( (x) &amp;amp;= ~(1ULL &amp;lt;&amp;lt; (bit)) )
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>Release note:&lt;/p>
&lt;ol>
&lt;li>添加对&lt;code>unsigned long long&lt;/code>长度的支持&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p> &lt;/p>
&lt;h2 id="sign-extending-from-a-varaiable-bit-width">Sign extending from a varaiable bit-width&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> bits &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">*&lt;/span> &lt;span style="color:#bd93f9">8&lt;/span>; &lt;span style="color:#6272a4">// number of bits representing the number in x
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> x &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">0xFFC1&lt;/span>; &lt;span style="color:#6272a4">// ready to get sign-extended
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> rst; &lt;span style="color:#6272a4">// resulting sign-extended number
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#ff79c6">const&lt;/span> mask &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">1U&lt;/span> &lt;span style="color:#ff79c6">&amp;lt;&amp;lt;&lt;/span> (bits &lt;span style="color:#ff79c6">-&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>); &lt;span style="color:#6272a4">// mask can be pre-computed if bits if fixed.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#ff79c6">=&lt;/span> x &lt;span style="color:#ff79c6">&amp;amp;&lt;/span> ((&lt;span style="color:#bd93f9">1U&lt;/span> &lt;span style="color:#ff79c6">&amp;lt;&amp;lt;&lt;/span> bits) &lt;span style="color:#ff79c6">-&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>); &lt;span style="color:#6272a4">// cut x if it holds more bits
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> rst &lt;span style="color:#ff79c6">=&lt;/span> (x &lt;span style="color:#ff79c6">^&lt;/span> mask) &lt;span style="color:#ff79c6">-&lt;/span> mask; &lt;span style="color:#6272a4">// excellent trick!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#f1fa8c">&amp;#34;INPUT: 0x%x, RESULT: 0x%x&lt;/span>&lt;span style="color:#f1fa8c">\n&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, x, rst);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p> &lt;/p>
&lt;h2 id="字符字符数组的大小写转换">字符/字符数组的大小写转换&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define TO_LOWER(c) (unsigned char)((c &amp;gt;= &amp;#39;A&amp;#39; &amp;amp;&amp;amp; c &amp;lt;= &amp;#39;Z&amp;#39;) ? (c | 0x20) : c)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define TO_UPPER(c) (unsigned char)((c &amp;gt;= &amp;#39;a&amp;#39; &amp;amp;&amp;amp; c &amp;lt;= &amp;#39;z&amp;#39;) ? (c &amp;amp; ~0x20) : c)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define TO_LOWER_STR(s, len) { \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6"> for (int i = 0; i &amp;lt; len &amp;amp;&amp;amp; s[i] != &amp;#39;\0&amp;#39;; i++) { \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6"> s[i] = TO_LOWER(s[i]); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6"> } \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#define TO_UPPER_STR(s, len) {\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6"> for (int i = 0; i &amp;lt; len &amp;amp;&amp;amp; s[i] != &amp;#39;\0&amp;#39;; i++) { \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6"> s[i] = TO_UPPER(s[i]); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6"> } \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>- https://wangloo.github.io/posts/codestyle/bit-operation-hacks/ - @2019 Notepadium.</description></item><item><title>Stack and Heap</title><link>https://wangloo.github.io/posts/os-learning/stack-and-heap/</link><pubDate>Tue, 28 Jun 2022 16:41:54 +0800</pubDate><guid>https://wangloo.github.io/posts/os-learning/stack-and-heap/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/os-learning/stack-and-heap/ -&lt;p> &lt;/p>
&lt;h2 id="堆的含义">堆的含义&lt;/h2>
&lt;p>我们都知道&lt;code>malloc&lt;/code>动态申请的变量是存放在堆中. 所以相比栈来说, 堆是动态的.&lt;/p>
&lt;p>堆占据进程虚拟地址空间的大部分, 我们可能通过堆来申请&lt;code>1GB&lt;/code>的数组, 但是栈通常不行
, 大多也就几兆的空间.&lt;/p>
&lt;p> &lt;/p>
&lt;h2 id="堆空间的管理">堆空间的管理&lt;/h2>
&lt;p>进程中堆空间的管理是&lt;code>运行库&lt;/code>负责的, 在Linux中是&lt;code>GLIBC&lt;/code>.&lt;/p>
&lt;p>运行库在初始化时会像操作系统申请一大块的堆空间, 再为每个进行分别分配需求. 当然,
如果某些程序的需求过大, 运行库也可以使用&lt;code>mmap&lt;/code>系统调用直接向操作系统申请, 然后
返回给用户进程.&lt;/p>
&lt;blockquote>
&lt;p>GLIBC的&lt;code>malloc&lt;/code>函数的处理方式是: 对于小于&lt;code>128KB&lt;/code>的申请, 会从运行库&amp;quot;批发的&amp;quot;堆空间
里分出一块来; 但若申请的空间过大, 则使用&lt;code>mmap&lt;/code>系统调用来创建匿名空间分配给用户.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Linux中虚拟地址块(VMA)的管理使用了红黑树, 可以用于运行库管理自己向操作系统
&amp;ldquo;批发&amp;quot;的堆空间. 使得用户程序动态申请和释放内存性能提高.&lt;/p>
&lt;/blockquote>
- https://wangloo.github.io/posts/os-learning/stack-and-heap/ - @2019 Notepadium.</description></item><item><title>动态链接</title><link>https://wangloo.github.io/posts/os-learning/dynamic-link/</link><pubDate>Sun, 26 Jun 2022 19:50:45 +0800</pubDate><guid>https://wangloo.github.io/posts/os-learning/dynamic-link/</guid><description>Soben's Secret Base https://wangloo.github.io/posts/os-learning/dynamic-link/ -&lt;h2 id="静态链接带来的问题">静态链接带来的问题&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>像是&lt;code>libc&lt;/code>这种几乎每个程序都要用到的库, 如果是静态的, 那么不仅意外着每个程序的
可执行文件很大, 浪费磁盘空间. 并且当程序加载到内存时, 可能许多程序都会用到&lt;code>printf&lt;/code>
, 使得内存中会存在好多份的&lt;code>printf&lt;/code>源码.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>维护和更新难. 一旦静态链接的其中一个目标文件更新, 所有的可执行程序都要重新链接.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不满足局部性原理. 上面提到, 内存中同时存在多份的&lt;code>printf&lt;/code>源码会破坏&lt;em>局部性原理&lt;/em>的.
显然如果所有的程序共享一份&lt;code>printf&lt;/code>源码的想法更好. 即动态加载.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可移植性差. 静态链接, 只要有一个依赖目标文件的实现不同, 软件厂商就得专门发布一个
版本. 而动态链接则信赖客户电脑上的&lt;em>动态库&lt;/em>, 相当于一个中间层.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p> &lt;/p>
&lt;h2 id="动态链接的过程">动态链接的过程&lt;/h2>
&lt;p>对比静态链接使用&lt;code>ld&lt;/code>链接器在编译后即执行链接, 动态链接则是将链接过程推迟到&lt;strong>运行时&lt;/strong>,
即装载到内存时.&lt;/p>
&lt;p>这样, 链接器在链接产生可执行文件时就有两种做法:&lt;/p>
&lt;ul>
&lt;li>对于静态符号, 按照静态链接的规则进行&lt;em>地址引用重定位&lt;/em>&lt;/li>
&lt;li>对于动态符号, 链接器则仅标记其为动态链接中的符号, 不进行处理. 而是等到装载时由
专门的&lt;em>动态链接器&lt;/em>来完成动态符号的链接工作.&lt;/li>
&lt;/ul>
&lt;p>⁉️ 链接器如何确定一个符号是静态的or动态的?&lt;/p>
&lt;p>在动态共享对象(&lt;em>.so)中保存了完整的&lt;/em>动态符号表*, 表中存在的符号即为动态的, 否则为静态.&lt;/p>
&lt;blockquote>
&lt;p>Linux的C语言运行库&lt;code>glib&lt;/code>的动态链接版本叫&lt;code>libc.so&lt;/code>. 它在外存上只保存一份, 所有的程序
都可以在运行时使用它. 所以千万不要删掉它.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>动态链接有一定的性能损失, 因为每次运行程序时都要重新链接, 并不像静态链接是一劳永逸的.
也有例如&lt;code>延迟绑定&lt;/code>对性能进行优化的方法, 大概仅有5%的损耗, 与带来的便利相比可以忽略不计.&lt;/p>
&lt;/blockquote>
&lt;p> &lt;/p>
&lt;h2 id="地址无关代码-pic">地址无关代码 PIC&lt;/h2>
&lt;p>GCC生成动态库时需要添加参数&lt;code>-fPIC&lt;/code>, 含义就是生成地址无关码&lt;/p>
&lt;p>地址无关码的含义是代码中&lt;strong>不包含任何的绝对地址引用&lt;/strong>, 全都是&lt;strong>相对地址&lt;/strong>.&lt;/p>
&lt;ul>
&lt;li>对于&lt;strong>模块内&lt;/strong>的跳转/数据引用, 使用相对的跳转/加载指令. 例如ARM指令集中的&lt;code>B&lt;/code>, &lt;code>ADR&lt;/code>, 经过汇编器之后, 目标的地址都会转为相对于该指令(PC)的偏移.&lt;/li>
&lt;li>对于&lt;strong>模块间&lt;/strong>的跳转/数据引用, 借用&lt;em>GOT表&lt;/em>来间接实现地址无关.&lt;/li>
&lt;/ul>
&lt;p>而如果该动态库中全部使用相对地址, 那么加载时也就不需要进行重定位, 即所有的程序都可以
共享这些地址无关代码.&lt;/p>
&lt;blockquote>
&lt;p>上面说PIC的动态库不需要重定位其实是错误的, 只不过它的重定位过程不需要修改代码段,
而是设置了一个放置在数据段的&lt;em>GOT&lt;/em>表来实现代码段部分的地址无关特性.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>现在貌似GCC ARM版本在编译动态库时强制使用-fPIC选项, 否则会报错. 对此我不是
非常确定!&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>一般来说, 不将主程序编译为地址无关码. 因为主程序不需要共享, 而且地址无关码的调用
需要两个指令: &lt;code>计算地址&lt;/code> + &lt;code>跳转&lt;/code>. 多了一步根据偏移得到绝对地址.&lt;/p>
&lt;/blockquote>
- https://wangloo.github.io/posts/os-learning/dynamic-link/ - @2019 Notepadium.</description></item></channel></rss>