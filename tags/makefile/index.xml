<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>makefile on Wangloo's BLOG</title><link>https://wangloo.github.io/tags/makefile/</link><description>Recent content in makefile on Wangloo's BLOG</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>@2019 Notepadium.</copyright><lastBuildDate>Sat, 03 Dec 2022 19:08:22 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/tags/makefile/index.xml" rel="self" type="application/rss+xml"/><item><title>Makefile 一些技巧</title><link>https://wangloo.github.io/posts/c/makefile_tricks/</link><pubDate>Sat, 03 Dec 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/c/makefile_tricks/</guid><description>伪目标的依赖关系 Makefile 中的依赖关系指的是目标和依赖之间建立的关系，目标对应规则中的语句是否执行取决于依赖的状态。
最简单的依赖关系可以拿两个文件来举例:
# gcc语句执行当前仅当 main.c 新于 main.elf main.elf: main.c gcc main.c -o main.elf make 在执行main.elf的规则时，会先判断依赖关系。拿上面的例子来说， gcc 语句是否执行取决于main.c 和 main.elf的修改时间，只有当 依赖新与目标时，规则语句才会执行。
然而许多情况下，目标或者依赖并不是一个文件，而是虚拟目标。虚拟目标 并不是一个文件，即它没有修改时间这个属性，此时 make 就不能作比较，结果就是 如果目标是伪目标，那么不管依赖如何都执行规则语句；如果依赖是伪目标， 那么目标的规则语句也永远被执行。下面是两个例子：
# 伪目标作为目标文件出现 # build finish总是输出， 而gcc语句仅当main.c比main.elf新时才执行 .PHONY : all all: main.elf @echo &amp;#39;build finish&amp;#39; main.elf: main.c gcc $&amp;lt; -o $@ # 伪目标作为依赖文件中出现 # 不管main.c是否比main.elf更新，因为pre-work是伪目标 # 所以gcc语句总是执行 .PHONY : pre-work main.elf: main.c pre-work gcc $&amp;lt; -o $@ 上面的代码的效果是：两条规则中的语句都会执行，即使你并没有对 main.c 做任何修改！</description></item><item><title>GCC '-M' and Related Parameters</title><link>https://wangloo.github.io/posts/c/gcc_-m_related/</link><pubDate>Tue, 26 Apr 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/c/gcc_-m_related/</guid><description>As we all know, there are huge number of parameters for GCC. With them, we can make many things possible. Now we talk about -M and related ones. After reading this article, you will know the meaning of there magic parameters. And I will put some little demos follows. Finally, we will see what can they do in really project. Let&amp;rsquo;s go ahead.
实例规则 以下的分析都是基于这样一个生成目标文件的规则, 应该来说具有一定的通用性。
build/obj/main.o: src/main.c $(CC) $(CFLAGS) $(INCLUDES) -c $&amp;lt; -o $@ main.</description></item></channel></rss>