<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Binary on BLOG</title><link>https://wangloo.github.io/tags/binary/</link><description>Recent content in Binary on BLOG</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 24 Nov 2023 16:21:27 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/tags/binary/index.xml" rel="self" type="application/rss+xml"/><item><title>Design a Elf Loader</title><link>https://wangloo.github.io/posts/binary/elf_load/</link><pubDate>Fri, 24 Nov 2023 16:21:27 +0800</pubDate><guid>https://wangloo.github.io/posts/binary/elf_load/</guid><description>分析Elf文件 映射 Segments 对栈进行预处理 1int main(int argc, char **argv, char **envp) {...} 见到一个main函数的定义，你是否考虑过:
main函数使用这些参数的作用分别是什么? Elf运行前，他们是如何被正确放置的? 我们又如何正确的访问? 内核中的Elf加载器还需要将辅助向量和其他信息(argc,argv,envp)一起放在栈上。 初始化后，进程的堆栈如下所示(64位架构下):
1position content size (bytes) + comment 2 ------------------------------------------------------------------------ 3 [ free used for process ] 4 stack pointer -&amp;gt; [ argc = number of args ] 8 5 [ argv[0] (pointer) ] 8 (program name) 6 [ argv[1] (pointer) ] 8 7 [ argv[..] (pointer) ] 8 * x 8 [ argv[n - 1] (pointer) ] 8 9 [ argv[n] (pointer) ] 8 (= NULL) 10 11 [ envp[0] (pointer) ] 8 12 [ envp[1] (pointer) ] 8 13 [ envp[.</description></item><item><title>DWARF(2): basetype类型</title><link>https://wangloo.github.io/posts/binary/dwarf/1_basetype/</link><pubDate>Tue, 09 May 2023 16:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/binary/dwarf/1_basetype/</guid><description>想要描述一个变量，必须知道它类型信息，才能知道变量的大小、输出的格式等。
Dwarf 为 C 语言定义了一些描述数据类型的 DIE，包括 basetype, array,pointer, structure&amp;hellip;
basetype 今天我们先介绍最简单的 basetype。
basetype 是指那些 C 语言自身定义的基础类型，像int, double这些。
basetype 类型的 DIE 通常有属性:
DW_AT_name: basetype 的名称 DW_AT_byte_size: 该 basetype 占空间大小 下面给出描述int和double的 DIE 展示(还是通过objdump工具输出）：
1 &amp;lt;1&amp;gt;&amp;lt;43&amp;gt;: Abbrev Number: 3 (DW_TAG_base_type) 2 &amp;lt;44&amp;gt; DW_AT_byte_size : 4 3 &amp;lt;45&amp;gt; DW_AT_encoding : 5 (signed) 4 &amp;lt;46&amp;gt; DW_AT_name : int 5 6 &amp;lt;1&amp;gt;&amp;lt;60&amp;gt;: Abbrev Number: 4 (DW_TAG_base_type) 7 &amp;lt;61&amp;gt; DW_AT_byte_size : 8 8 &amp;lt;62&amp;gt; DW_AT_encoding : 4 (float) 9 &amp;lt;63&amp;gt; DW_AT_name : (indirect string, offset: 0x9): double Array 数组表示为 DW_TAG_array 的 DIE，通常含有属性:</description></item><item><title>DWARF(1): 基础</title><link>https://wangloo.github.io/posts/binary/dwarf/0_basic/</link><pubDate>Tue, 09 May 2023 15:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/binary/dwarf/0_basic/</guid><description>Dwarf 把源文件中每个可描述的模块（例如函数，变量，结构体的声明等）描述为一个 DIE (Debugging Information Entry)，所以每个源文件可以描述为若干 DIE 的组合。
每个 DIE 由一个 tag 和若干 attribute-val 键值对构成:
tag: 描述此 DIE 的类型 attribute-val: 描述此 DIE 的一些细节属性，项目根据 DIE 的类型不同而有差别 各个 DIE 之间会相互联系，一个 DIE 可能含有 parent，若干的 child 和 sibling， 它们之间组成树的结构。
查看一个 ELF 的所有 DIE ELF 文件中的所有 DIE 存储在.debug_info section 中，通过 GNU utils 中的objdump工具 可以解析为可阅读的结构:
1objdump --dwarf=info &amp;lt;file&amp;gt; 若我们有一个 demo.c 如下:
1void func(void) { 2 int var_local; 3} 编译为可执行文件后， 执行上述的objdump命令， 可以得到如下的输出（节选）：
1 &amp;lt;1&amp;gt;&amp;lt;68&amp;gt;: Abbrev Number: 5 (DW_TAG_subprogram) 2 &amp;lt;69&amp;gt; DW_AT_external : 1 3 &amp;lt;69&amp;gt; DW_AT_name : (indirect string, offset: 0x32): func 4 &amp;lt;6d&amp;gt; DW_AT_decl_file : 1 5 &amp;lt;6e&amp;gt; DW_AT_decl_line : 3 6 &amp;lt;6f&amp;gt; DW_AT_decl_column : 6 7 &amp;lt;70&amp;gt; DW_AT_prototyped : 1 8 &amp;lt;70&amp;gt; DW_AT_low_pc : 0x1129 9 &amp;lt;78&amp;gt; DW_AT_high_pc : 0xb 10 &amp;lt;80&amp;gt; DW_AT_frame_base : 1 byte block: 9c (DW_OP_call_frame_cfa) 11 &amp;lt;82&amp;gt; DW_AT_GNU_all_call_sites: 1 12 &amp;lt;2&amp;gt;&amp;lt;82&amp;gt;: Abbrev Number: 6 (DW_TAG_variable) 13 &amp;lt;83&amp;gt; DW_AT_name : (indirect string, offset: 0x28): var_local 14 &amp;lt;87&amp;gt; DW_AT_decl_file : 1 15 &amp;lt;88&amp;gt; DW_AT_decl_line : 4 16 &amp;lt;89&amp;gt; DW_AT_decl_column : 9 17 &amp;lt;8a&amp;gt; DW_AT_type : &amp;lt;0x43&amp;gt; 上述例子中节选了两个 DIE，分别是函数func()和局部变量var_local, 可以看到它们的 tag 是不同的，且都具有一系列属性。</description></item></channel></rss>