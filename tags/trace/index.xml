<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>trace on BLOG</title><link>https://wangloo.github.io/tags/trace/</link><description>Recent content in trace on BLOG</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sun, 23 Apr 2023 23:51:49 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/tags/trace/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux Trace(1): Tracepoint</title><link>https://wangloo.github.io/posts/os/linux/trace/tracepoint/</link><pubDate>Sun, 23 Apr 2023 23:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/os/linux/trace/tracepoint/</guid><description>tracepoint 是 Linux trace system 中 data source 之一， 其 trace 的对象是 kernel，属于一种静态的插桩方法。
添加和删除需要手动修改内核源码 可以向上提供接口，可以通过 frontend 来开启或者关闭，也可以自定义数据处理方式 在 disable 时， 仅有一次 if 判断的损耗，所以效率还算高。但缺点是不够灵活。 tracepoint 的组成 看其源码struct tracepoint就能知道它的组成结构：
1 2 3 4 5 6 7 8 9 10 11 12 13 struct tracepoint { const char *name; #define TP_STATE_DISABLE 0 #define TP_STATE_ENABLE 1 int state; // 并非用于注册hook的函数，而是注册hook时的hook int (*reghook)(void); void (*unreghook)(void); // 在tracepoint触发时将调用的hook struct tracepoint_hook *hooks; }; name: 是该 tracepoint 的名称 state: 用于控制其开关状态 hooks: 是一系列的函数指针，当 tracepoint hit 时，这些函数会被依次调用 reghook/unreghook: 在注册/注销 hook 时将被调用，可以用来输出一些提示信息 为了提供对 tracepoint 操作的接口，定义一个 tracepoint 时，会同时定义一系列功能函数, 包括：</description></item></channel></rss>