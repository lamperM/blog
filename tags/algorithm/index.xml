<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithm on BLOG</title><link>https://wangloo.github.io/tags/algorithm/</link><description>Recent content in Algorithm on BLOG</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sun, 20 Aug 2023 20:30:35 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/tags/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>一道题搞定二分法的细节</title><link>https://wangloo.github.io/posts/algorithm/bsearch/</link><pubDate>Sun, 20 Aug 2023 20:30:35 +0800</pubDate><guid>https://wangloo.github.io/posts/algorithm/bsearch/</guid><description>实际上我做过的二分搜索的题目并不少，但是一直以来没有静下心去研究它的 【循环条件】【边界调整】【返回值】的细节，通过这个题目希望自己能完整、 清晰的了解二分搜索。
题目 https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array
给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。
示例 1：
输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4]
解答(python): def searchRange(self, nums: List[int], target: int) -&amp;gt; List[int]: if nums == []: return [-1, -1] # 第一次二分，确定右边界 left, right = 0, len(nums)-1 while left &amp;lt;= right: mid = (left + right) // 2 if nums[mid] &amp;lt;= target: left = mid+1 else: right = mid-1 end = right # 第二次二分，确定左边界 left, right = 0, len(nums)-1 while left &amp;lt;= right: mid = (left + right) // 2 if nums[mid] &amp;lt; target: left = mid+1 else: right = mid-1 sta = left print(sta, end) if end &amp;lt; 0 or sta &amp;gt; len(nums)-1 or nums[sta] !</description></item></channel></rss>