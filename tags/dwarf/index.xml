<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dwarf on BLOG</title><link>https://wangloo.github.io/tags/dwarf/</link><description>Recent content in Dwarf on BLOG</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 16 Dec 2023 15:51:49 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/tags/dwarf/index.xml" rel="self" type="application/rss+xml"/><item><title>Dwarf: Stack Unwinding</title><link>https://wangloo.github.io/posts/binary/dwarf/frame/</link><pubDate>Sat, 16 Dec 2023 15:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/binary/dwarf/frame/</guid><description>前言 栈回溯是调试代码常用的功能之一，Gdb 中对应的命令是bt,info frame等。 这篇文件将介绍利用 Dwarf 生成的调试信息实现栈回溯的方法。
原理 Dwarf v2 开始提供一种叫做 Call Frame Information（简称 CFI）的信息， 它存储在.debug_frame中，调试器可以通过解析这个 Section 完成栈回溯。 .debug_frame里的内容可以看做是一张二维表格，一列是 pc， 另一列是对于此 Pc 如何查找上一个 Frame。
Demo 例如，对于以下的 C 代码和对应的汇编（通过object -S生成)， 汇编代码有一点长，但没关系我们不需要关注每一条汇编指令。 这段代码共有两个函数，main()和fibonacci()， 由 main 函数调用 fibonacci 来计算第 10 个 bibonacci 数。 目前暂时不需要看汇编。
选择 fibonacci()作为例子的原因是模拟一个非叶子函数， 因为 Arm64 下对叶子函数可能不会生成正确的 CFI 信息， 因为这种情况不常见，所以我们先讨论普通的情况。 另外，我知道这个计算 fibonacci 数的算法不是最优的， 但是我们毕竟不是算法优化的主题，所以能够说明问题即可。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int fiboncci(int n) { if (n &amp;lt;= 2) return 1; else return fiboncci(n-1) + fiboncci(n-2); } int main(void) { int result; result = fiboncci(10); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 int fiboncci(int n) { 400594: a9bd7bfd stp x29, x30, [sp, #-48]!</description></item><item><title>Dwarf(2): basetype类型</title><link>https://wangloo.github.io/posts/binary/dwarf/1_basetype/</link><pubDate>Tue, 09 May 2023 16:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/binary/dwarf/1_basetype/</guid><description>想要描述一个变量，必须知道它类型信息，才能知道变量的大小、输出的格式等。
Dwarf 为 C 语言定义了一些描述数据类型的 DIE，包括 basetype, array,pointer, structure&amp;hellip;
basetype 今天我们先介绍最简单的 basetype。
basetype 是指那些 C 语言自身定义的基础类型，像int, double这些。
basetype 类型的 DIE 通常有属性:
DW_AT_name: basetype 的名称 DW_AT_byte_size: 该 basetype 占空间大小 下面给出描述int和double的 DIE 展示(还是通过objdump工具输出）：
1 2 3 4 5 6 7 8 9 &amp;lt;1&amp;gt;&amp;lt;43&amp;gt;: Abbrev Number: 3 (DW_TAG_base_type) &amp;lt;44&amp;gt; DW_AT_byte_size : 4 &amp;lt;45&amp;gt; DW_AT_encoding : 5 (signed) &amp;lt;46&amp;gt; DW_AT_name : int &amp;lt;1&amp;gt;&amp;lt;60&amp;gt;: Abbrev Number: 4 (DW_TAG_base_type) &amp;lt;61&amp;gt; DW_AT_byte_size : 8 &amp;lt;62&amp;gt; DW_AT_encoding : 4 (float) &amp;lt;63&amp;gt; DW_AT_name : (indirect string, offset: 0x9): double Array 数组表示为 DW_TAG_array 的 DIE，通常含有属性:</description></item><item><title>Dwarf(1): 基础</title><link>https://wangloo.github.io/posts/binary/dwarf/0_basic/</link><pubDate>Tue, 09 May 2023 15:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/binary/dwarf/0_basic/</guid><description>Dwarf 把源文件中每个可描述的模块（例如函数，变量，结构体的声明等）描述为一个 DIE (Debugging Information Entry)，所以每个源文件可以描述为若干 DIE 的组合。
每个 DIE 由一个 tag 和若干 attribute-val 键值对构成:
tag: 描述此 DIE 的类型 attribute-val: 描述此 DIE 的一些细节属性，项目根据 DIE 的类型不同而有差别 各个 DIE 之间会相互联系，一个 DIE 可能含有 parent，若干的 child 和 sibling， 它们之间组成树的结构。
查看一个 ELF 的所有 DIE ELF 文件中的所有 DIE 存储在.debug_info section 中，通过 GNU utils 中的objdump工具 可以解析为可阅读的结构:
1 objdump --dwarf=info &amp;lt;file&amp;gt; 若我们有一个 demo.c 如下:
1 2 3 void func(void) { int var_local; } 编译为可执行文件后， 执行上述的objdump命令， 可以得到如下的输出（节选）：</description></item><item><title>Libdwarf 函数介绍及其实现方法</title><link>https://wangloo.github.io/posts/binary/dwarf/libdwarf_func/</link><pubDate>Sun, 07 May 2023 14:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/binary/dwarf/libdwarf_func/</guid><description>Function dwarf_alloc.c _dwarf_get_alloc() 1 2 3 char * _dwarf_get_alloc(Dwarf_Debug dbg, Dwarf_Small alloc_type, Dwarf_Unsigned count) 函数功能: 根据类型申请一块空间
注意, 申请时大小会多DW_RESERVE, 此函数返回的地址是 mem_alloc()返回的地址+DW_RESERVE
_dwarf_error() 1 2 void _dwarf_error(Dwarf_Debug dbg, Dwarf_Error * error, Dwarf_Sword errval) 函数功能 错误处理的函数
函数流程 判断传入参数error是否为空, 如果为空则跳转到 step 4. 分配一个新的Dwarf_Error空间 将传入的错误信息存入Dwarf_Error, 并将其作为指针返回 error为空时, 一般要在出错时执行一些方法,即 dbg-&amp;gt;de_errhand() 所以, 此时dbg 和 dbg-&amp;gt;de_errhand 必须非空. dwarf_elf_access.c dwarf_elf_object_access_init() 1 2 3 4 5 int dwarf_elf_object_access_init(u64 elf_base_addr, int libdwarf_owns_elf, Dwarf_Obj_Access_Interface** ret_obj, int *err) 函数功能 初始化 Dwarf_Obj_Access_Interface 结构</description></item></channel></rss>