<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dwarf on BLOG</title><link>https://wangloo.github.io/tags/dwarf/</link><description>Recent content in Dwarf on BLOG</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 16 Dec 2023 15:51:49 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/tags/dwarf/index.xml" rel="self" type="application/rss+xml"/><item><title>Dwarf: Stack Unwinding</title><link>https://wangloo.github.io/posts/binary/dwarf/frame/</link><pubDate>Sat, 16 Dec 2023 15:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/binary/dwarf/frame/</guid><description>前言 栈回溯是调试代码常用的功能之一，Gdb 中对应的命令是bt,info frame等。 这篇文件将介绍利用 Dwarf 生成的调试信息实现栈回溯的方法。
原理 Dwarf v2 开始提供一种叫做 Call Frame Information（简称 CFI）的信息， 它存储在.debug_frame中，调试器可以通过解析这个 Section 完成栈回溯。 .debug_frame里的内容可以看做是一张二维表格，一列是 pc， 另一列是对于此 Pc 如何查找上一个 Frame。
Demo 例如，对于以下的 C 代码和对应的汇编（通过object -S生成)， 汇编代码有一点长，但没关系我们不需要关注每一条汇编指令。 这段代码共有两个函数，main()和fibonacci()， 由 main 函数调用 fibonacci 来计算第 10 个 bibonacci 数。 目前暂时不需要看汇编。
选择 fibonacci()作为例子的原因是模拟一个非叶子函数， 因为 Arm64 下对叶子函数可能不会生成正确的 CFI 信息， 因为这种情况不常见，所以我们先讨论普通的情况。 另外，我知道这个计算 fibonacci 数的算法不是最优的， 但是我们毕竟不是算法优化的主题，所以能够说明问题即可。
1int fiboncci(int n) 2{ 3 if (n &amp;lt;= 2) 4 return 1; 5 else 6 return fiboncci(n-1) + fiboncci(n-2); 7} 8 9int main(void) 10{ 11 int result; 12 13 result = fiboncci(10); 14 return 0; 15} 1int fiboncci(int n) 2{ 3 400594: a9bd7bfd stp x29, x30, [sp, #-48]!</description></item></channel></rss>