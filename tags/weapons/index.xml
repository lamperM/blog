<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>weapons on Soben's Secret Base</title><link>https://wangloo.github.io/blog/tags/weapons/</link><description>Recent content in weapons on Soben's Secret Base</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>@2019 Notepadium.</copyright><lastBuildDate>Sun, 03 Jul 2022 09:44:13 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/blog/tags/weapons/index.xml" rel="self" type="application/rss+xml"/><item><title>Bit Operation Hacks</title><link>https://wangloo.github.io/blog/posts/codestyle/bit-operation-hacks/</link><pubDate>Sun, 03 Jul 2022 09:44:13 +0800</pubDate><guid>https://wangloo.github.io/blog/posts/codestyle/bit-operation-hacks/</guid><description>判断一个数是否为2的幂 unsigned int v; if ((v &amp;amp; (v - 1)) == 0) printf(&amp;#34;v is a power of 2\n&amp;#34;); else printf(&amp;#34;v is not a power of 2\n&amp;#34;);  统计一个数的二进制中1的数量 依然是利用v &amp;amp; (v -1)的运算结果会将v的最低位的1(如果有的话)置0.
循环执行此操作就可统计v中1的数量.
int numberof1(int v) { int count = 0; while(v) { count++; v = v &amp;amp; (v -1); } return count; }  将一个数向上取整为2的幂 用一个1一直左移, 直到比这个数大为止.
uint32_t roundup_pow_op_two(const uint32_t x) { uint32_t ret = 1; while (ret &amp;lt; x) { ret = ret &amp;lt;&amp;lt; 1; } return ret; }  向上/向下对齐, 检查是否对齐 /* uintptr_t 代表指针的位数 * 加uintptr_t转换的原因是: (void *)不能进行运算 */ #define IS_ALIGNED(X, align) (((uintptr_t)(const void *)(X)) % (align) == 0) #define ALIGN_UP(X, align) (((X) + ((align) - 1)) &amp;amp; ~((align) - 1)) #define ALIGN_DOWN(x, align) ((X) &amp;amp; ~((align) - 1)) #define X (0x12345675) #define align (1 &amp;lt;&amp;lt; 2) int main() { int v = IS_ALIGNED(X, align); if (0 == v) { printf(&amp;#34;Given X(0x%x) is not align to 0x%08x\n&amp;#34;, X, align); printf(&amp;#34;After align up, new X = 0x%x\n&amp;#34;, ALIGN_UP(X, align)); printf(&amp;#34;After align down, new X = 0x%x\n&amp;#34;, ALIGN_DOWN(X, align)); } else { printf(&amp;#34;Give X(0x%x) is aligned to 0x%08x\n&amp;#34;, X, align); printf(&amp;#34;After align up, new X = 0x%x\n&amp;#34;, ALIGN_UP(X, align)); printf(&amp;#34;After align down, new X = 0x%x\n&amp;#34;, ALIGN_DOWN(X, align)); } return 0; }  检查两个有符号数是否异号 int x,y; if ((x ^ y) &amp;lt; 0) printf(&amp;#34;They have opposite signs\n&amp;#34;); else printf(&amp;#34;They have same signs\n&amp;#34;);  大小端转换  对某个位的get/set/clear操作 #define GET_BIT(x, bit) ( ((x) &amp;amp; (1ULL &amp;lt;&amp;lt; (bit))) &amp;gt;&amp;gt; (bit) ) #define SET_BIT(x, bit) ( (x) |= (1ULL &amp;lt;&amp;lt; (bit)) ) #define CLEAR_BIT(x, bit) ( (x) &amp;amp;= ~(1ULL &amp;lt;&amp;lt; (bit)) ) Release note:</description></item></channel></rss>