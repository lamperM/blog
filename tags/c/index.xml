<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c on Soben's Secret Base</title><link>https://wangloo.github.io/tags/c/</link><description>Recent content in c on Soben's Secret Base</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>@2019 Notepadium.</copyright><lastBuildDate>Tue, 03 Jan 2023 20:54:31 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/tags/c/index.xml" rel="self" type="application/rss+xml"/><item><title>C 内敛汇编</title><link>https://wangloo.github.io/posts/c/inline-asm/</link><pubDate>Tue, 03 Jan 2023 20:54:31 +0800</pubDate><guid>https://wangloo.github.io/posts/c/inline-asm/</guid><description>如果要将多条语句放在一个asm关键字中, 每条语句之间必须使用分隔符, 常见的为\n\t. 例如:
asm volatile( &amp;#34;isb \n\t&amp;#34; &amp;#34;dsb \n\t&amp;#34; &amp;#34;eret \n\t&amp;#34; ); 貌似对于 arm 汇编, 只用 \n 也OK? TODO: 找到依据
volatile cc This stands for &amp;ldquo;condition codes&amp;rdquo;. Since the add instruction will affect the carry flag amongst other things, we need to tell gcc about it. Otherwise it might want to split a test-and-branch around our code. If it did so, the branch might go the wrong way due to the condition codes being corrupted.</description></item><item><title>C语言工具宏</title><link>https://wangloo.github.io/posts/c/c-macros/</link><pubDate>Thu, 24 Nov 2022 01:35:24 +0800</pubDate><guid>https://wangloo.github.io/posts/c/c-macros/</guid><description>计算数组元素的个数 #define nelem(array) sizeof(array)/sizeof(array[0])</description></item><item><title>Inline in C</title><link>https://wangloo.github.io/posts/c/inline/</link><pubDate>Thu, 24 Nov 2022 01:35:24 +0800</pubDate><guid>https://wangloo.github.io/posts/c/inline/</guid><description>TODO: inline 的发展历程: Myth and reality about inline in C99 – Jens Gustedt&amp;rsquo;s Blog (wordpress.com)
GNU89: 函数的实现之前添加不同的关键字:
inline: 表明这个函数可能被优化. 如果没有被优化, 编译器就会视为一个常规函数的定义.
extern inline: 表明这个函数可能被优化. 如果没有被优化, 编译器就将这个函数的定义转换为该函数的声明, 即 extern inline func(); 因此当此函数被调用时, 可以调用一个外部的函数来替代. 如果没有函数调用它, 那么也可以没有外部的替代函数实现.
static inline: 表明这个函数可能被优化. 如果没有被优化, 编译器就会视为一个常规静态函数.
C99: 函数的实现之前添加不同的关键字:
inline: 等效于gnu89中的extern inline extern inline: 等效于gnu89中的inline static inline: 与gnu89相同含义. C++: 只有inline一个关键字, 如果不能优化就定义为普通函数
Ref:
c++ - What does extern inline do?</description></item><item><title>二级指针操作链表</title><link>https://wangloo.github.io/posts/c/pointers-pointers-list/</link><pubDate>Sun, 20 Nov 2022 23:40:30 +0800</pubDate><guid>https://wangloo.github.io/posts/c/pointers-pointers-list/</guid><description>问题源于我在知乎刷到的一个回答: 能分享你C指针用得最灵活（飘）的一次吗?
文中提到了Linus关于无头节点单项链表的删除操作给出的一种新的思路, 我觉得对理解指针非常有帮助, 所以在这里详细描述一下这件事.
从我学习数据结构起, 对不含头节点的单向链表的删除操作, 做法常是: 借用pre指针搜索. 这种情况下避免不了对于链表中第一个节点的特判(第一个节点没有pre).
Linus提到了一种借助二级指针避免该分支的方法.
void remove_if(node ** head, remove_fn rm) { for (node** curr = head; *curr; ) { node * entry = *curr; if (rm(entry)) { *curr = entry-&amp;gt;next; free(entry); } else curr = &amp;amp;entry-&amp;gt;next; } } 指针的内容就是地址, int *p = a 也就意味着变量p 中保存着变量a的地址. 所以参数head在内存中的含义为:
假如要删除node2, 那么改变*curr实际上就是改了node1的next成员.</description></item><item><title>C 语言位操作技巧</title><link>https://wangloo.github.io/posts/codestyle/bit-operation-hacks/</link><pubDate>Sun, 03 Jul 2022 09:44:13 +0800</pubDate><guid>https://wangloo.github.io/posts/codestyle/bit-operation-hacks/</guid><description>判断一个数是否为2的幂 unsigned int v; if ((v &amp;amp; (v - 1)) == 0) printf(&amp;#34;v is a power of 2\n&amp;#34;); else printf(&amp;#34;v is not a power of 2\n&amp;#34;);  统计一个数的二进制中1的数量 依然是利用v &amp;amp; (v -1)的运算结果会将v的最低位的1(如果有的话)置0.
循环执行此操作就可统计v中1的数量.
int numberof1(int v) { int count = 0; while(v) { count++; v = v &amp;amp; (v -1); } return count; }  将一个数向上取整为2的幂 用一个1一直左移, 直到比这个数大为止.
uint32_t roundup_pow_op_two(const uint32_t x) { uint32_t ret = 1; while (ret &amp;lt; x) { ret = ret &amp;lt;&amp;lt; 1; } return ret; }  向上/向下对齐, 检查是否对齐 /* uintptr_t 代表指针的位数 * 加uintptr_t转换的原因是: (void *)不能进行运算 */ #define IS_ALIGNED(X, align) (((uintptr_t)(const void *)(X)) % (align) == 0) #define ALIGN_UP(X, align) (((X) + ((align) - 1)) &amp;amp; ~((align) - 1)) #define ALIGN_DOWN(x, align) ((X) &amp;amp; ~((align) - 1)) #define X (0x12345675) #define align (1 &amp;lt;&amp;lt; 2) int main() { int v = IS_ALIGNED(X, align); if (0 == v) { printf(&amp;#34;Given X(0x%x) is not align to 0x%08x\n&amp;#34;, X, align); printf(&amp;#34;After align up, new X = 0x%x\n&amp;#34;, ALIGN_UP(X, align)); printf(&amp;#34;After align down, new X = 0x%x\n&amp;#34;, ALIGN_DOWN(X, align)); } else { printf(&amp;#34;Give X(0x%x) is aligned to 0x%08x\n&amp;#34;, X, align); printf(&amp;#34;After align up, new X = 0x%x\n&amp;#34;, ALIGN_UP(X, align)); printf(&amp;#34;After align down, new X = 0x%x\n&amp;#34;, ALIGN_DOWN(X, align)); } return 0; }  检查两个有符号数是否异号 int x,y; if ((x ^ y) &amp;lt; 0) printf(&amp;#34;They have opposite signs\n&amp;#34;); else printf(&amp;#34;They have same signs\n&amp;#34;);  大小端转换  对某个位的get/set/clear操作 #define GET_BIT(x, bit) ( ((x) &amp;amp; (1ULL &amp;lt;&amp;lt; (bit))) &amp;gt;&amp;gt; (bit) ) #define SET_BIT(x, bit) ( (x) |= (1ULL &amp;lt;&amp;lt; (bit)) ) #define CLEAR_BIT(x, bit) ( (x) &amp;amp;= ~(1ULL &amp;lt;&amp;lt; (bit)) ) Release note:</description></item><item><title>Improving the quality of C code</title><link>https://wangloo.github.io/posts/codestyle/improve_quality/</link><pubDate>Tue, 14 Jun 2022 17:59:22 +0800</pubDate><guid>https://wangloo.github.io/posts/codestyle/improve_quality/</guid><description>添加更多的编译选项(comiler options)来防止bug 对于我常用的GCC, 推荐开启一下的compiler options:
-Wall: enable a lot of common warnings
-Wno-format-truncation: warns about the snprintf output buffer not being large enough for a corresponding “%s” in the format string.
-Werror: turn warnings into errors.
 动态申请的空间到底要不要释放 When using a barebones embedded OS, you absolutely need to tightly manage your memory.
但是, 如果你是写应用业务的代码, 特别是在内存足够的场景下. 最好不要手动释放内存, 因为当线程/进程退出时, 操作系统会自动帮我们释放. 某些情况下, 释放内存的操作会很大程度上增加逻辑的复杂度.
如果你是一个内核程序员, 则必须手动的释放.</description></item><item><title>GCC '-M' and Related Parameters</title><link>https://wangloo.github.io/posts/c/gcc_-m_related/</link><pubDate>Tue, 26 Apr 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/c/gcc_-m_related/</guid><description>As we all know, there are huge number of parameters for GCC. With them, we can make many things possible. Now we talk about -M and related ones. After reading this article, you will know the meaning of there magic parameters. And I will put some little demos follows. Finally, we will see what can they do in really project. Let&amp;rsquo;s go ahead.
-M Output the dependencies of the input source file.</description></item></channel></rss>