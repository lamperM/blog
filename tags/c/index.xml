<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c on Soben's Secret Base</title><link>https://wangloo.github.io/tags/c/</link><description>Recent content in c on Soben's Secret Base</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>@2019 Notepadium.</copyright><lastBuildDate>Mon, 27 Feb 2023 19:20:20 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/tags/c/index.xml" rel="self" type="application/rss+xml"/><item><title>C语言程序设计的一些经验</title><link>https://wangloo.github.io/posts/c/experience/</link><pubDate>Mon, 27 Feb 2023 19:20:20 +0800</pubDate><guid>https://wangloo.github.io/posts/c/experience/</guid><description>外部库的使用方式 最近我在开发项目是, 需要使用到libelf库, 我在Github上找到了其源代码.
我之前使用一个lib都是以链接的形式使用动态库/静态库, 但是既然它提供了源码, 那么我可以直接将源码拷贝到我的项目中吗? 答案肯定是可以, 那么这两种方案该如何抉择呢?
在查阅了一些资料后, 我总结了以下几个判断依据:
库的大小/对编译时间的敏感度; 如果使用源代码, 每次编译项目时需要额外对库文件进行编译(起码是第一次), 而库文件的定义是不常修改的, 如果库文件比较大, 则会延长整个项目的编译时间. 是否需要版本控制; 要使用的库如果需要区分版本, 或者分配给其他的团队成员使用, 那么用库的形式似乎更为方便 发挥git submodule的优势; Ref: c++ - Should I add the source of libraries instead of linking to them? - Software Engineering Stack Exchange
const 修饰符的妙用 有些时候, 我们设计的结构体中会有name字段, 类型是char *. 在使用时为它分配空间, 不使用时需要回收.
其实还有另一种情况, 就是name要指向预先定义好的&amp;quot;static name list&amp;quot;, 适用于name的取值是确定的范围. 例如, libdwarf库中的描述section name的dss_name 成员.
这时, 为了防止使用者调用free()来释放它, 我们可以将其声明为const char *, 此时如果调用free(.dss_name), 编译器会给出警告:</description></item><item><title>C 内敛汇编</title><link>https://wangloo.github.io/posts/c/inline-asm/</link><pubDate>Tue, 03 Jan 2023 20:54:31 +0800</pubDate><guid>https://wangloo.github.io/posts/c/inline-asm/</guid><description>如果要将多条语句放在一个asm关键字中, 每条语句之间必须使用分隔符, 常见的为\n\t. 例如:
asm volatile( &amp;#34;isb \n\t&amp;#34; &amp;#34;dsb \n\t&amp;#34; &amp;#34;eret \n\t&amp;#34; ); 貌似对于 arm 汇编, 只用 \n 也OK? TODO: 找到依据
volatile cc This stands for &amp;ldquo;condition codes&amp;rdquo;. Since the add instruction will affect the carry flag amongst other things, we need to tell gcc about it. Otherwise it might want to split a test-and-branch around our code. If it did so, the branch might go the wrong way due to the condition codes being corrupted.</description></item><item><title>C语言工具宏</title><link>https://wangloo.github.io/posts/c/c-macros/</link><pubDate>Thu, 24 Nov 2022 01:35:24 +0800</pubDate><guid>https://wangloo.github.io/posts/c/c-macros/</guid><description>计算数组元素的个数 #define nelem(array) sizeof(array)/sizeof(array[0])</description></item><item><title>Inline in C</title><link>https://wangloo.github.io/posts/c/inline/</link><pubDate>Thu, 24 Nov 2022 01:35:24 +0800</pubDate><guid>https://wangloo.github.io/posts/c/inline/</guid><description>TODO: inline 的发展历程: Myth and reality about inline in C99 – Jens Gustedt&amp;rsquo;s Blog (wordpress.com)
GNU89: 函数的实现之前添加不同的关键字:
inline: 表明这个函数可能被优化. 如果没有被优化, 编译器就会视为一个常规函数的定义.
extern inline: 表明这个函数可能被优化. 如果没有被优化, 编译器就将这个函数的定义转换为该函数的声明, 即 extern inline func(); 因此当此函数被调用时, 可以调用一个外部的函数来替代. 如果没有函数调用它, 那么也可以没有外部的替代函数实现.
static inline: 表明这个函数可能被优化. 如果没有被优化, 编译器就会视为一个常规静态函数.
C99: 函数的实现之前添加不同的关键字:
inline: 等效于gnu89中的extern inline extern inline: 等效于gnu89中的inline static inline: 与gnu89相同含义. C++: 只有inline一个关键字, 如果不能优化就定义为普通函数
Ref:
c++ - What does extern inline do?</description></item><item><title>二级指针操作链表</title><link>https://wangloo.github.io/posts/c/pointers-pointers-list/</link><pubDate>Sun, 20 Nov 2022 23:40:30 +0800</pubDate><guid>https://wangloo.github.io/posts/c/pointers-pointers-list/</guid><description>问题源于我在知乎刷到的一个回答: 能分享你C指针用得最灵活（飘）的一次吗?
文中提到了Linus关于无头节点单项链表的删除操作给出的一种新的思路, 我觉得对理解指针非常有帮助, 所以在这里详细描述一下这件事.
从我学习数据结构起, 对不含头节点的单向链表的删除操作, 做法常是: 借用pre指针搜索. 这种情况下避免不了对于链表中第一个节点的特判(第一个节点没有pre).
Linus提到了一种借助二级指针避免该分支的方法.
void remove_if(node ** head, remove_fn rm) { for (node** curr = head; *curr; ) { node * entry = *curr; if (rm(entry)) { *curr = entry-&amp;gt;next; free(entry); } else curr = &amp;amp;entry-&amp;gt;next; } } 指针的内容就是地址, int *p = a 也就意味着变量p 中保存着变量a的地址. 所以参数head在内存中的含义为:
假如要删除node2, 那么改变*curr实际上就是改了node1的next成员.</description></item><item><title>C 语言位操作技巧</title><link>https://wangloo.github.io/posts/codestyle/bit-operation-hacks/</link><pubDate>Sun, 03 Jul 2022 09:44:13 +0800</pubDate><guid>https://wangloo.github.io/posts/codestyle/bit-operation-hacks/</guid><description>判断一个数是否为2的幂 unsigned int v; if ((v &amp;amp; (v - 1)) == 0) printf(&amp;#34;v is a power of 2\n&amp;#34;); else printf(&amp;#34;v is not a power of 2\n&amp;#34;);  统计一个数的二进制中1的数量 依然是利用v &amp;amp; (v -1)的运算结果会将v的最低位的1(如果有的话)置0.
循环执行此操作就可统计v中1的数量.
int numberof1(int v) { int count = 0; while(v) { count++; v = v &amp;amp; (v -1); } return count; }  将一个数向上取整为2的幂 用一个1一直左移, 直到比这个数大为止.
uint32_t roundup_pow_of_two(const uint32_t x) { uint32_t ret = 1; while (ret &amp;lt; x) { ret = ret &amp;lt;&amp;lt; 1; } return ret; } Linux内核中使用了一种更快的方案, amazing!</description></item><item><title>写高质量的C语言工程的技巧</title><link>https://wangloo.github.io/posts/codestyle/improve_quality/</link><pubDate>Tue, 14 Jun 2022 17:59:22 +0800</pubDate><guid>https://wangloo.github.io/posts/codestyle/improve_quality/</guid><description>添加更多的编译选项(comiler options)来防止bug 对于我常用的GCC, 推荐开启一下的compiler options:
-Wall: enable a lot of common warnings
-Wno-format-truncation: warns about the snprintf output buffer not being large enough for a corresponding “%s” in the format string.
-Werror: turn warnings into errors.
 动态申请的空间到底要不要释放 When using a barebones embedded OS, you absolutely need to tightly manage your memory.
但是, 如果你是写应用业务的代码, 特别是在内存足够的场景下. 最好不要手动释放内存, 因为当线程/进程退出时, 操作系统会自动帮我们释放. 某些情况下, 释放内存的操作会很大程度上增加逻辑的复杂度.
如果你是一个内核程序员, 则必须手动的释放.</description></item><item><title>GCC '-M' and Related Parameters</title><link>https://wangloo.github.io/posts/c/gcc_-m_related/</link><pubDate>Tue, 26 Apr 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/c/gcc_-m_related/</guid><description>As we all know, there are huge number of parameters for GCC. With them, we can make many things possible. Now we talk about -M and related ones. After reading this article, you will know the meaning of there magic parameters. And I will put some little demos follows. Finally, we will see what can they do in really project. Let&amp;rsquo;s go ahead.
-M Output the dependencies of the input source file.</description></item></channel></rss>