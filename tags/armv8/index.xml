<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>armv8 on BLOG</title><link>https://wangloo.github.io/tags/armv8/</link><description>Recent content in armv8 on BLOG</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 12 Apr 2023 08:01:33 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/tags/armv8/index.xml" rel="self" type="application/rss+xml"/><item><title>AArch64 内存属性与内存类型</title><link>https://wangloo.github.io/posts/armv8/memory_attr/</link><pubDate>Wed, 12 Apr 2023 08:01:33 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/memory_attr/</guid><description>有了虚拟内存系统之后，MMU 可以抽象出一些可配置的内存属性。
例如，配置某个虚拟内存区域为不可执行、不被 cache 等，不可执行的属性 有助于防范攻击，不进入 cache 经常划分给 外设 Memory-mapped 区域。
设置内存属性 相关内容可以在 ARMv8 arm 手册 D5.3.3 Attuibute fields in stage 1 VMSAv8-64 Block and Page descriptors 中找到参考
对于每一个表示内存块(block)的页表项，都有两个属性字段: lower attr 和 upper attr.
以下任何类型或者属性的设置都是通过这两个字段完成的。
大类: 内存类型 AArch64 提供两种内存类型: 普通内存和设备内存。
普通内存会启用架构提供的所有优化技术，例如合并访存、乱序执行等。所以 普通内存有最高的性能，但同时不是那么的“安全”，需要底层人员手动使用 内存屏障等手段保证某些情况下的顺序性要求。
设备内存，顾名思义，常映射到外设的 Memory-mapped 区域。对于设备来说， 那些提高性能的技术会造成一些问题，例如某些寄存器的配置必须按照顺序， 这时就不能使用乱序执行。设备内存就牺牲了性能，优先保证正确性。
配置内存类型也是通过页表项中的其中一个属性字段: AttrIndx[2:0], 它与系统寄存器MAIR_EL1配合实现。
具体表现为: mair_el1寄存器被划分为 8 个字段，我们为每个字段写入 不同的值可代表不同的内存类型和一些配套属性，具体的真值表可以参见 mair_el1寄存器的描述。
mair_el1中内存类型配套属性只是属性的一部分，是和设备类型绑定的 那部分。
更细分的描述(1): cacheable 内存支持配置为是否被 cache，这在mair_el1的字段中配置。</description></item><item><title>x86/ARMv8 函数调用约定</title><link>https://wangloo.github.io/posts/os/function-call-conventions/</link><pubDate>Mon, 21 Nov 2022 10:30:35 +0800</pubDate><guid>https://wangloo.github.io/posts/os/function-call-conventions/</guid><description>符合调用约定使得调用函数能够正常获取参数, callee结束之后能够回到原来位置继续执行.
X86 调用约定 函数调用 x86架构中, 函数调用以一条call指令为分界.
在call指令执行之前, 所有的参数必须都躺在栈中, 参数入栈的规则是: 第一个参数最后入栈.
另外, 执行call指令之前, 必须确保栈指针esp是16-byte对齐. 这项工作是编译器完成的, 如果它判断参数入栈之后的esp 不满足对齐条件, 则会手动调整esp使之对齐. 实现方式见下面例子.
call 指令的语义是:
1push pc+1 ;push next insttuction 2mov pc, func ;set pc = new function call 指令之后的下一条指令就是callee的内容了, 至此就算是进入新函数的地盘.
但是在执行新的任务之前, callee还需要完成栈的转换, 因为此时使用的栈还是caller的.
1push ebp ;preserve location of caller&amp;#39;s stack 2mov ebp, esp ;new ebp is old esp 此时esp也就是栈指针等于ebp, 这是callee栈的初始条件. 万事俱备, 可以开始执行callee的实际任务了.
ebp在整个函数执行过程中是固定的, 好处是: 能够快速的或者函数参数, 返回地址.
函数返回 callee执行完毕后, 需要返回到caller继续执行. 刚才说过, callee的返回地址在栈中, 所以我们要做的是找到返回地址所在的位置, 然后使pc = 返回地址.</description></item><item><title>基于ARM64实现setjmp/longjmp</title><link>https://wangloo.github.io/posts/c/setjmp_and_longjmp/</link><pubDate>Tue, 01 Nov 2022 23:38:54 +0800</pubDate><guid>https://wangloo.github.io/posts/c/setjmp_and_longjmp/</guid><description>介绍 setjmp() and longjmp() 是一对组合使用的函数, 可以实现全局的goto.
setjmp() 构造一个运行环境, 调用longjmp() 则将执行流切换到该环境.
1/* setjmp() 保存当前的运行环境(上下文)到 env 参数中 */ 2int setjmp(jmp_buf env); 3 4/* longjmp() 将控制流切换到 env 指定的运行环境 */ 5void longjmp(jmp_buf env, int val); 使用方法 1#include &amp;lt;setjmp.h&amp;gt;2#include &amp;lt;stdio.h&amp;gt;3 4jmp_buf e; 5 6void foo() { 7 longjmp(e, 1); 8} 9 10int main(void) { 11 int ret; 12 13 /* After calling longjmp(), the execution flow back to setjmp(), 14and setjmp() will return not 0. */ 15 ret = setjmp(e); 16 if (ret == 0) { 17 printf(&amp;#34;Return from setjmp\n&amp;#34;); 18 foo(); 19 } else { 20 printf(&amp;#34;Return from longjmp\n&amp;#34;); 21 } 22 23 return 0; 24} 基于 AArch64 的实现 需要保存的上下文包括</description></item><item><title>ARMv8-A MMU介绍</title><link>https://wangloo.github.io/posts/armv8/mmu/</link><pubDate>Thu, 29 Sep 2022 08:01:33 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/mmu/</guid><description>Introduction MMU: 专用于将虚拟地址转换为物理地址. 通常配合分页机制来工作.
页表: 页表中的表项包含提供虚拟地址和物理地址之间的映射.
MMU就是直接访问页表, 并且通过将频繁使用的映射缓存到TLB中.
MMU 的结构 MMU是一种硬件, 可以通过在适当的安全状态下对其进行配置. 每个Core都有自己的MMU, 每个MMU包括:
一个TLB, 缓存最近访问的映射. 一个Table Walk Unit, 从内存中查询页表, 得到最终的虚拟地址-物理地址的映射. MMU 控制着整个系统的缓存策略, 内存属性和访问权限. MMU开启后, 软件发出的所有内存访问都使用虚拟地址, 要求MMU为每次访问进行地址转换.
MMU 的配置 在启用MMU前, 必须告知其页表存放的位置.
MMU 地址转换的过程 对于每个转换请求, MMU首先检查TLB是否已经对该地址缓存, 如果该地址未缓存, 则需要遍历页表.
页表遍历单元在页表中搜索相关的映射表项.
一旦找到映射, MMU就会检查权限和属性. 决定允许本次访问, 或者发出故障信号. 若未找到映射, 则触发缺页异常. 页表的工作原理 页表的工作方式是将虚拟地址空间和物理地址空间划分为大小相等的块, 称为页面.
页表中的每个表项对应着一块虚拟地址空间中的块, 表项的值就是这块虚拟地址空间对应的物理地址块, 以及访问物理地址时要使用的属性.
在查表过程中, 将虚拟地址分为两部分:
高阶位用作页表的索引. 用来找到对应的物理块 低地址是块内的偏移量, 不会因为映射而改变. 页表项中的物理地址与该偏移组合形成用于访问内存的物理地址. 多级页表 实际实现中, 多采用多级页表的方案, 各级页表自定向下组成树的形式, 协作实现虚拟到物理地址的转换.
树中的分支成为页目录, 页目录中的表项不是直接存储目标物理地址, 而是下一级页表的地址; 最后一级页表的表项中保存着目标物理地址.</description></item><item><title>AArch64/32 异常返回过程</title><link>https://wangloo.github.io/posts/armv8/exception_return/</link><pubDate>Sat, 24 Sep 2022 21:19:01 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/exception_return/</guid><description>ARMv8 异常返回指令 当异常处理程序结束后，需要执行异常返回指令恢复进入异常之前的状态.
具体要做的事情包括:
恢复发生异常前的PC
从SPSR中恢复PSTATE寄存器(现场)
异常返回的指令根据当前执行状态为AArch32还是AArch64有所不同.
AArch32 AArch32的异常返回指令在不同的模式下也有所不同:
若异常是在Hyp模式下处理: 仅可执行ERET指令从异常返回.
若异常是在其他模式下处理, AArch32提供了以下的异常返回指令:
ERET 指令
使用带S后缀的数据处理指令直接操作PC(例如, MOVS, PC, LR), 恢复PSTATE
RFE 指令: RFE &amp;lt;Rn&amp;gt;. 从基址寄存器指向的地址依次加载PC和PSTATE
LDM 指令: LDM &amp;lt;Rn&amp;gt; {pc..}. 若目标寄存器中包含PC, 则会同时恢复PSTATE
AArch64 AArch64下统一使用 ERET 指令进行异常返回.
指令格式及用法参考 ERET ERET指令完成了:
从ELR_ELx中恢复PC指针
从SPSR_ELx中恢复PSTATE寄存器的状态.
LDM(Load Multiple) 格式: LDM &amp;lt;Rn&amp;gt; {registers}
含义: 从基址寄存器&amp;lt;Rn&amp;gt;指向的地址开始依次加载多个寄存器值.</description></item><item><title>GICv3 介绍</title><link>https://wangloo.github.io/posts/armv8/gicv3/</link><pubDate>Sat, 10 Sep 2022 21:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/gicv3/</guid><description>GICV3(Generic Interrupt Controller - version 3) 关于GIC GIC即中断控制器, 负责管理中断的接收, 屏蔽, 路由等相关任务, 并向系统程序员提供配置的接口.
GIC与异常模型协作完成中断的整个生命周期, GIC主要负责中断源-产生IRQ/FIQ信号这段路, 关于处理IRQ/FIQ则是由CPU内部的异常模型来完成.
对比 GICv2 支持更多的处理器, 用affinity routing 方案来做中断路由. 支持中断分组, 为了配合ARMv8的异常等级模型 新增中断类型: SGI, 软件生成中断 新增中断类型: SPI, Shared Peripheral Interrupts 对于CPU interface的寄存器, 可直接使用系统寄存器接口(system register interface)来访问, 比memory-mapped的方式快. ITS, Interrupt Translation Service 暂不介绍 LPI, Locality-specific Peripheral Interrupts . 暂不介绍 GICv3支持ARMv8-A或ARMv8-R系列处理器, 但没有必然的绑定关系. ARMv8-A也可以使用GICv2.
中断类型 Locality-specific Peripheral Interrupt (LPI) LPIs are always message-based interrupts interrupts. 这里不做介绍.wiki
Private Peripheral Interrupt (PPI) PPI是路由到单个CPU的外设中断, 不同的CPU可以使用相同的中断号.</description></item><item><title>ARMv8-A 寄存器</title><link>https://wangloo.github.io/posts/armv8/register/</link><pubDate>Sat, 07 May 2022 20:19:44 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/register/</guid><description>寄存器分类 通用寄存器 x0-x7 参数寄存器: Restore function parameters and return vaule. x9-x15 caller-saved 临时寄存器: callee 默认可以直接使用来保存临时变量, 不需要保存和恢复. 如果 caller 在里面存储了非临时信息, 那么在函数调用之前应当由 caller 负责保存. x19-x28 callee-saved 寄存器: callee 应该避免使用. 如果必须要使用，那么在返回前必须恢复. special registers: x8 restore indirect result. Commonly used when returning a struct. x18 platform reserved register. x29 frame pointer register(FP). x30 link register(LR). All general-purpose register xN is 64-bit width. They all have corresponding wN register using the lower 32-bit of xN.</description></item></channel></rss>