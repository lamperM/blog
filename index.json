[{"categories":null,"contents":"指令翻译 在 host 上运行 guest 架构代码的能力由 QEMU TCG 模块提供。\nTCG 做指令翻译的思路是 “边翻译边执行”， 并且将翻译工作分为前后端，中间会有一层中间指令， 这样能够方便添加对新指令的支持。这个有点类似于现代编译器，也是由类似间结果的流程，称为 IR。\nTCG 执行一次翻译的单位是 Translation Block，以分支跳转、页边界为划分条件。\n","date":"2023-09-08T16:21:27+08:00","permalink":"https://wangloo.github.io/posts/qemu/1/","section":"posts","tags":["qemu"],"title":"QEMU 工作原理"},{"categories":null,"contents":"   名词 含义解释     Unix 起源于BELL实验室的一个操作系统家族, 指代一类OS。\n这些OS共同遵守Unix特性，但各个分支在实现上有所不同。\n包括SystemV、BSD等分支   SystemV 是Unix的特殊版本，由AT\u0026amp;T公司开发   GNU 目标是开发一个完全自由、开源的OS，借鉴Unix   Linux OS内核，借鉴了Linux。后与GNU工具集结合，称为GNU/Linux                        ","date":"2023-09-08T16:21:27+08:00","permalink":"https://wangloo.github.io/posts/os/abbreviation/","section":"posts","tags":["Operating System"],"title":"操作系统：相关名词汇总"},{"categories":null,"contents":"SystemV IPC Linux 引入了 SystemV 中 IPC 的集中实现方式，包括：信号量、共享内存、消息队列。\n共享内存 共享内存基于文件实现，用操作文件的方式来操作共享内存区。\n原理是对一块物理内存做多个映射，用引用计数来维护，只有引用计数为0时，才能释放。\n共享内存的特点是：\n 速度快，但自身没有同步功能，需要配合外部的同步机制。  信号量  为什么说信号量也是一种通信机制?\n其实通信并不一定就是要发送数据，只要能够相互感知，通知到对方，就算是一种通信。 类比抛媚眼也算是通信的一种。\n 消息队列  并非基于文件，由自己的一套API，使用起来不方便。 消息队列是面向消息的（并非字节流），消息由类型。 消息队列有自己的同步机制，无需外部添加。  信号 常用于父子之间通信，只要你知道了对方的PID，就可以给对方发信号。\n用kill(pid, signal)来发送信号。\n","date":"2023-09-08T16:21:27+08:00","permalink":"https://wangloo.github.io/posts/os/linux/ipc/linux-ipc/","section":"posts","tags":["Operating System","linux"],"title":"操作系统：进程间通信方式介绍"},{"categories":null,"contents":"关于PMU PMU是一个独立的单元，不和体系结构绑定。而是每个SOC都可以不同。比如说Cortex-A53实现了PMUv3架构，但别的基于ARMv8架构的Soc可能实现PMUv4或者其他版本。\nPMU内部有六个计数器，所以可以记录六个事件的发生次数。计数器的数值不一定绝对的正确，因为管道的存在，所以一般来说还是通过长时间计数来减弱影响。\nPMU和ETM的区别 1. 记录的事件不同  PMU：Cache Miss、分支预测失败、TLB Miss等 ETM：记录分支指令、内存屏障指令等所有指令的执行，包括地址、结果等。 另外还可以记录数据读写的地址、结果（可选）。  2. 记录的粒度不同  PMU：仅用计数器来记录事件发生的次数 ETM：指令的类型、地址、执行结果等。数据访问也类似。  所以说，ETM的信息量大，需要专门的缓存机制。而PMU只需在定时器结束时记录发生的次数就行， 不需要什么缓存，没有实际的数据流。\n","date":"2023-09-02T22:02:04+08:00","permalink":"https://wangloo.github.io/posts/armv8/pmu/","section":"posts","tags":["armv8"],"title":"Cortex-A53: PMU"},{"categories":null,"contents":"footer属于 partial模板之一, 创建一个新文件footer.html, 然后在baseof模板中, 指定footer内容显示的位置.\n1\u0026lt;body\u0026gt; 2 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 3 {{- partial \u0026#34;sidebar.html\u0026#34; . -}} 4 \u0026lt;main class=\u0026#34;container\u0026#34;\u0026gt; 5 {{- block \u0026#34;main\u0026#34; . }} 6 {{- end }} 7 {{- partial \u0026#34;footer.html\u0026#34; . -}} 8 \u0026lt;/main\u0026gt; 9 {{- partial \u0026#34;script.html\u0026#34; . -}} 10 \u0026lt;/div\u0026gt; 11 12\u0026lt;/body\u0026gt; 下面将按照功能划分, 添加各种内容到footer模板中.\n文件创建和lastmode时间  commit: https://github.com/wangloo/hugo-theme-puer/commit/d263d9af65808ff03b2307abfb4db397ae1bcc2a\n 文件创建时间是获取的footer中的变量, lastmod其实也可以通过这种方式获取, 但是这样每次修改都要手动更新太复杂, 我们可以借助git追踪的文件的修改时间来作为lastmod, 默认不是这样的, 需要在config.toml中指定.\n1[frontmatter] 2 lastmod = [\u0026#39;lastmod\u0026#39;, \u0026#39;:git\u0026#39;, \u0026#39;:fileModTime\u0026#39;, \u0026#39;date\u0026#39;, \u0026#39;publishDate\u0026#39;] 然后就是在footer.html中引用这两个变量即可:\n1\u0026lt;HR width=\u0026#34;100%\u0026#34; id=\u0026#34;EOF\u0026#34;\u0026gt; 2 3{{- if not .Lastmod.IsZero -}} 4 \u0026lt;p style=\u0026#34;color:#777;\u0026#34;\u0026gt;创建于: {{ .Date.Format \u0026#34;2006-01-02T15:04:05\u0026#34;}}, Lastmod: {{ .Lastmod.Format \u0026#34;2006-01-02T15:04:05\u0026#34;}}\u0026lt;/p\u0026gt; 5{{- end -}} ","date":"2023-09-02T18:39:42+08:00","permalink":"https://wangloo.github.io/posts/hugo/new_theme_7/","section":"posts","tags":["hugo"],"title":"Hugo 主题创建(7): footer"},{"categories":null,"contents":"实际上我做过的二分搜索的题目并不少，但是一直以来没有静下心去研究它的 【循环条件】【边界调整】【返回值】的细节，通过这个题目希望自己能完整、 清晰的了解二分搜索。\n题目 https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array\n 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。\n如果数组中不存在目标值 target，返回 [-1, -1]。\n你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。\n 示例 1：\n输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4]\n  解答(python): 1def searchRange(self, nums: List[int], target: int) -\u0026gt; List[int]: 2 3 if nums == []: 4 return [-1, -1] 5 6 # 第一次二分，确定右边界 7 left, right = 0, len(nums)-1 8 while left \u0026lt;= right: 9 mid = (left + right) // 2 10 if nums[mid] \u0026lt;= target: 11 left = mid+1 12 else: 13 right = mid-1 14 end = right 15 16 # 第二次二分，确定左边界 17 left, right = 0, len(nums)-1 18 while left \u0026lt;= right: 19 mid = (left + right) // 2 20 if nums[mid] \u0026lt; target: 21 left = mid+1 22 else: 23 right = mid-1 24 sta = left 25 26 print(sta, end) 27 if end \u0026lt; 0 or sta \u0026gt; len(nums)-1 or nums[sta] != target or nums[end] != target: 28 return [-1, -1] 29 else: 30 return [sta, end] 细节 写好一个二分搜索就是需要确定三件事:\n 循环边界条件 调整边界 返回值  这三件事是环环相扣的，先说确定的，调整边界的操作一定是left=mid+1 or right=mid-1, 整数的二分不存在left=mid这种操作，仅限于浮点数中。\n再说边界条件，我个人喜欢使用带等号的判断，即while left \u0026lt;= right, 这纯粹是个人习惯.\n问题转化 以求右侧下标为例, 可以等价为: 搜索\u0026lt;=target的最大值. 这其实是问题的关键, 只是另外加一个判断说如果求得数 不是target, 返回特殊值就行了. 如果你还是不理解这两个问题为什么是等价的, 那么看完下面的解释应该也能清楚.\n先说搜索\u0026lt;=target的最大值的计算方法, 一般的二分搜索, 搜索完成之后, 如果没有找到target, right=left-1, 且 right 指向比 target 首个小的元素,left 指向首个比 target 大的元素.\n那么代码是不是可以这么写:\n1left, right = 0, n-1 2while left \u0026lt;= right: 3 mid = (left + right) // 2 4 if nums[mid] == target: 5 return mid 6 elif nums[mid] \u0026lt; target: 7 left += 1 8 else: 9 right += 1 10 11return right 更进一步的说, 如果\u0026quot;把target也看作是小于target\u0026quot;, 也就是让循环不停下, 最后平衡的条件也一定是满足 right 指向比 target 首个小的元素,left 指向首个比 target 大的元素., 只不过此时=target 也被算作是小于target, 走小于target的处理流程. 最终的结果就是right指向的就是target(如果存在), 要不就是比target小的那个数.\n于是代码就可以被优化为:\n1left, right = 0, n-1 2while left \u0026lt;= right: 3 mid = (left + right) // 2 4 if nums[mid] \u0026lt;= target: 5 left += 1 6 else: 7 right += 1 8 9return right 再审原题 上述这种进一步思考的思想是不是与原题中的要求类似? 我可以有一连串的target, 我要求的是最右边的target在哪, 如果把=target也看作是小于target, 让循环继续跑, 最后right指向的就是最右边的那个target.\n","date":"2023-08-20T20:30:35+08:00","permalink":"https://wangloo.github.io/posts/algorithm/bsearch/","section":"posts","tags":["algorithm"],"title":"一道题搞定二分法的细节"},{"categories":null,"contents":"胶片风格受大众喜爱 富士的价格为什么被炒的越来越高？如果单说是外观，那尼康的zfc、索尼、佳能的一些微单并不输给他很多， 我觉得其中有一个很重要的原因就是富士的胶片模拟风格。\n作为一个程序员，我当然知道这些都是软件层面的东西， 其他厂家如果想做是完全可以做的，可能他们对这块也没什么兴趣。不得不承认富士可能在这方面做了一些 功夫，很可能并不单单只是颜色调整而已，它对于高光部分有更加细致的处理。\n今天主要想说的是为什么这种古老的风格会再次风靡？，如今数码时代的进步使得一张照片的清晰度、还原真实诚程度飙升， 为何还要去追求这种模糊与做旧呢？这是审美的倒退吗？\n我觉得，我们对美的认识或者说定义并不是随着科技的进步而进步的，有一些东西是不需要创新或者说无法进行创新的， 老的、旧的并不一定就差于现代的，衡量美的标准可能就是如此。\n那么我就想，其他东西是否也会这样呢？是否在过了几十年几百年的发展之后，我们回过头来再看，还不如原来固有的。 我想中华文化就在这之列，我们盲目的学习西方追求自由、绝对的平等，我相信时间会证明这不是适合中国人的社会风气。\n","date":"2023-08-20T20:30:35+08:00","permalink":"https://wangloo.github.io/posts/photo/blog/","section":"posts","tags":["photo"],"title":"近期对于摄影的感悟"},{"categories":null,"contents":"shortcode 可以当成是一些对 html 代码块封装的函数，在写 markdown 的时候就会方便一些， 举个例子来说，我有时需要往 post 中插入图片，并调整它的大小，这时候每次都手动写一些 html 简直是太麻烦了，使用 shortcode 就像是调用函数一样，告诉它函数名和必要的参数， 它会在生成网页时自动转换为对应的 html 语法。\nshortcode 分为两种：Hugo 默认和自定义的。Hugo 默认支持的 shortcode 有这些 https://gohugo.io/content-management/shortcodes/ ，这里面同时包含了告诉我们如果使用 shortcode 的基本语法。\n当然hugo支持创建自定义 shortcode，详细的使用方法可以看这里， https://gohugo.io/templates/shortcode-templates/ ，我会大概说一下。\n 定义一个新的shortcode，即在layouts/shortcodes/下创建一个新的xxx.html文件，文件名就是你的函数名 这个shortcode会做什么事，就是在这个html中进行实现  插入链接图片 remoteFigure，参考的是diary主题的实现支持调整图片大小、填充样式、对齐、添加图片描述等。\n puer 主题的 Github commit\n ","date":"2023-08-20T18:39:42+08:00","permalink":"https://wangloo.github.io/posts/hugo/new_theme_6/","section":"posts","tags":["hugo"],"title":"Hugo 主题创建(6): shortcode"},{"categories":null,"contents":"C 中的qsort, python 中的sorted()很多时间需要自己构造比较的规则，也就是告诉排序函数怎么衡量两个值的大小关系？\nTL;DR 升序的写法(C-qsort):\n1int cmp(const void *a, const void *b) 2{ 3 return *(int *)a - *(int *)b; 4} 5 6int main(void) 7{ 8 int nums[] = {2, 1, 3, 5, 4}; 9 10 qsort(nums, 5, sizeof(int), cmp); 11 return 0; 12} 升序的写法(python-sorted()):\n1from functools import cmp_to_key 2nums = [2, 3, 1, 4, 5] 3 4nums = sorted(nums, key=cmp_to_key(lambda x,y: x-y)) 5print(nums)  python3 丢弃了sorted()中的cmp选项， 全部用 key 选项进行指定， 所以需要cmp_to_key进行转换\n 升序的写法(C++-sort()):\n1// sort()原型 2void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp); 3 4bool cmp(int a, int b){ 5 return a \u0026lt; b; 6} 7 8int main(){ 9 int a[10]={8 ,3 ,10 ,9 ,5}; 10 sort(a,a+10,cmp); 11 return 0; 12} 详解 正如上面所说，cmp 函数的作用是给排序函数一个比较的依据。\n  c 和 python 的 cmp 函数属于同一种，返回的是 int 类型的值，代表的含义是：a 相对于 b 的位置。 返回正数代表 a 在 b 之后，负数则反之。所以用a-b算式就能表达升序排序\n  而 C++返回的则是布尔值，代表的含义是：a 排在 b 的前面吗?，所以用a\u0026lt;b， 也能表达升序排序\n  这样看起来，貌似 c++的写法更好理解一些。\n 有时我们会看到 python 中这样表示升序:\n1lambda x,y: -(x \u0026lt; y) 这其实是和x-y的效果是相同的, 只是有的时候一些类型不能够相减，比如说字符串， 但是可以使用\u0026lt;\u0026gt;比较，所以执行这样一个转换的小 trick。\n ","date":"2023-08-20T17:59:22+08:00","permalink":"https://wangloo.github.io/posts/codestyle/cmp-func/","section":"posts","tags":["c","python"],"title":"C/python: cmp函数应该怎么写"},{"categories":null,"contents":"通过 tag 可以实现对post进行分类，用到的支持是 HUGO Taxonomy Template（分类模板）\n原理 实现tag的功能需要完成两类页面的设计： /tags/ 和 /tags/\u0026lt;one-tag\u0026gt;\n前者属于 Taxonomy Terms（分类术语）页面，用分类术语模板实现， 后者属于 Taxonomy List （分类列表）页面，用分类列表模板实现，他们都属于 Taxonomy 模板。\n不难推测出，分类术语模板规定了如何展现某个分类方式，比如说用云图来展示tag分类方法。 而分类list模板的作用是展示选中某一类之后的页面，比如说在云图中选中了某个tag。\n更加详细的描述可以看官方文档: https://gohugobrasil.netlify.app/templates/taxonomy-templates/\n设计 正与文档中所说，分类terms模板可以有多个查找的优先级：\n  /layouts/taxonomy/.terms.html /layouts/_default/terms.html /themes//layouts/taxonomy/.terms.html /themes//layouts/_default/terms.html   这样的好处是，比如说我有两种terms，tag和categories，我想在分类术语页面对这两种分类展示不用的页面， 就可以定义tags.terms.html和categories.terms.html, 而我目前就用terms.html，简单。\n分类list模板也是，使用最通用的list.html, 和其他的list公用，并没有对分类list做单独的页面。\n 对应的 commit: https://github.com/wangloo/hugo-theme-puer/commit/63d8bb762b16a3d4657ba3523d6b6fb38cf5f9ca\n上面的commit不小心提交了menu.html, 实际不属于taxonomy的目的，所以在这纠正: https://github.com/wangloo/hugo-theme-puer/commit/0af07f66807b540fd9d3be84e8d7faca7f962c4b\n ","date":"2023-08-15T18:39:42+08:00","permalink":"https://wangloo.github.io/posts/hugo/new_theme_5/","section":"posts","tags":["hugo"],"title":"Hugo 主题创建(5): Tag 分类支持"},{"categories":null,"contents":"之前在特斯拉面试的时候被问到了 cache 的 maintain 操作有哪些, 一时间竟想不起一个准确的词来, 这里就再学习一下, 把这个坑填上吧。\n可能不会说的很细，目的只是把一些概念复习，做到心中大致有数。\ncache 是个硬件 cache 的本质是一种 SRAM, 容量很小, 速度很快(ns 级)。\n拿 Cortex-A53 来说，共有三级 Cache：\n L1 cache 是 Core 单独的，分为数据 cache 和指令 cache，容量是 KB 级 L2 cache 一般是 cluster 内共享，容量是 MB 级 L3 cache 是所有 core 共享，容量是 MB 级  cache 控制器 单独的 cache 就是一个存储设备，得有一个控制器告诉它存什么以及什么时候存。\ncache 控制器的任务举个例子说：比如 cache miss 的时候，需要从主存向 cache 回填数据，然而此时 CPU 那边记着要数据，我们都知道 cache 操作的单位 是 cache line 嘛，但这是 cache 控制器会有限填充一个 cache line 中 CPU 要的那一条（或几条），最后在后台默默填充完剩下的。\ncache 控制器的行为是不可配置的，软件不可见，不可编程。\ncache policy（策略） cache policy 就说了两件事：\n cache 分配：执行 load 操作时需要分配入 cache 吗？ cache 更新：执行 str 修改数据时需不需要与主存同步？  cache 的更新方式有两种：\n Write back，写回；即仅修改 cache 中数据，然后设置一个 dirty 标志位 ，当且仅当此 cache line 被 clean 时才对 dirty 数据回写主存 Write through，写直通；即每次修改 cache 都同步修改主存，也就不需要 dirty 标志了  cache 相关的内存属性 一段内存可被设置为 cacheable 或者 uncacheable，uncacheable 的内存直接访问主存。\ncacheable 又可划分为 inner 和 outer 两种：\n inner: 可入L1 cache，或者L2 cache，实现定义 outer: 可入外部板级的 cache(L3 cache)  cache maintain（维护） 为什么需要维护cache？\n 主存中的内容更新了 此部分内存的权限改了或者映射改了  cache的三种维护操作（软件可见）：\n [invalidation]: 设置cache line对应的invalid位。常见于reset时，cache里的内容不可信， 所以需要将所有的cache invalid [clean]: clean的含义是清理，将原有的标记为dirty的line都与主存进行同步。当然， 仅更新策略为 write back的时候才需要 [zero]: 什么也不管，直接将cache line置0，数据丢了我也不关心   以上的三种操作都是有粒度的，包括整个 cache、指定va范围、某一路等。\n  软件只能通过体系结构提供的维护指令来控制 cache。\n ","date":"2023-08-14T22:02:04+08:00","permalink":"https://wangloo.github.io/posts/armv8/cache/","section":"posts","tags":["armv8"],"title":"ARMv8: cache相关知识"},{"categories":null,"contents":"display 是规定元素排列方式的属性，总的来说，元素的排列方式可分两种：block 和 inline。\n block 的含义是，该元素默认情况下的 width 表现为充满整个父元素，height 表现为根据内容决定。 inline 的含义是，该元素的 width 和 height 都是必须根据内容决定，不能使用显示的width和height来改变。  即便 block 可以去设置 width, 比如为 50%, 但是它永远必须独占一行，下面的元素也不会排到它的空白处， 这就是 block 称之为 block 的原因。\n细分来说，其实 display 这个属性共有五种取值： block, inline, inline-block, flex, grid。 我们将依次介绍。\nblock 默认 display 方式为 block 的标签有: p, h1-h6, div, li 等\ninline 默认 display 方式为 inline 的标签有: span, a, strong\ninline-block inline-block 是结合了 block 和 inline 的优势：既不必独占一行，又可以调整 width 和 height。\n一些 button 经常使用的 display 就是 inline-block。\nflex grid 不同 display 文字居中的方法 文字居中是开发中常见的需求，然而根据 display 的不同，决定了实现居中的方式也不同。\n居中大概分为水平居中和垂直居中\n水平居中 对于 inline、inline-block 来说，直接设置text-align=center即可实现。\n对于 block，设置text-align=center的效果是将 block 内部的文字相对与 block 居中，并不是 相对于 block 的父元素。\n但是很多情况下，我们是想让整个 block 同时再相对于父元素居中（因为block的width不一定是100%） 此时需要对 block 元素额外添加margin-left=auto和margin-right=auto属性。\n垂直居中 用 flex 比较方便实现。\n","date":"2023-08-11T22:02:04+08:00","permalink":"https://wangloo.github.io/posts/html-css/display/","section":"posts","tags":["css"],"title":"前端学习: display"},{"categories":null,"contents":"position 属性决定了一个元素在页面中的排放方式, 通过与 top、bottom、left、right 结合可以决定任一元素在页面中应该在什么位置上。\nposition 的取值可以是: static/absolute/relative/fixed/sticky ，下面我将依次对他们的使用方法和场景进行介绍。\nstatic static 是元素默认的 position，它使得元素按照顺序排列（什么样的顺序取决于display)。\n它不能与 top、bottom 等属性结合，就是最简单的依次排布。\nrelative relative 与 static 相比，支持了 tom、bottom 这些属性，使得元素在依次排布的同时 能调整相对于上一个元素的位置变化。\n据我所知，relative 并不常见。\nabsolute absolute 也就是我们常称的\u0026quot;绝对定位\u0026quot;， 产生的效果相对于父元素做了一些偏移，而不是上面所说的上一个元素，只有父元素的位置改变，它才按照偏移数值进行改变。 偏移数值的指定通过 top、bottom 来实现。\nabsolute 可以与 fixed 进行对比，两者相差很小。\n absolute 无视 static。上面说 absolute 是基于父元素进行调整，仅当父元素是 static 时例外，absolute 会跳过这一层，找它的爷爷元素。\n fixed fixed的含义是使元素的排列始终固定在页面的某个位置，换句话也可以说它总是基于body做relative的 排列。当然，偏移是通过top、bottom给出的。\n一些页面的小广告用的排列就是fixed。\nsticky sticky像默认的static，但它也有top、bottom等属性值，这些值有特殊含义： 当元素随着页面滚动变化，而使元素的页面绝对位置（相对于body）达到top、bottom值时， 便固定在那不会再移动，使元素永远不会被移动出页面。\n看起来就好像是用页面的外框对sticky元素画了一个笼子，它永远跑不出页面之外。\nsticky目前被广泛应用与导航栏，只要设置top=0\n sticky是新增的属性，某些浏览器支持的可能不是很好\n ","date":"2023-08-11T21:02:04+08:00","permalink":"https://wangloo.github.io/posts/html-css/position/","section":"posts","tags":["css"],"title":"前端学习: position"},{"categories":null,"contents":"字体替换  commit: https://github.com/wangloo/hugo-theme-puer/commit/861ca01617c06c83b701506c9a574cc2726d36d8\n 修改的参考：\n 一般文字用最近很火的【霞鹜文楷】 代码使用一些比较通用的代码字体，注意用!important提高优先级  ","date":"2023-08-11T18:39:42+08:00","permalink":"https://wangloo.github.io/posts/hugo/new_theme_4/","section":"posts","tags":["hugo"],"title":"Hugo 主题创建(4): 样式打磨"},{"categories":null,"contents":" commit:\n 为什么选择fast search? hugo本身是不支持站内搜索功能的, 如果你写的文章较多就只能按照tag去检索分类. 这样至少也需要三次点击操作, 如果每个页面的边栏或者顶栏有一个搜索框, 能够 搜索文章的内容或者标题、Tag这些，对我来说效率就能得到显著提升。\nfast search 是我检索到的目前比较简单、成熟的方案，它的亮点：\n 最小外部依赖（无需jQuery） 支持实现键盘唤出 无需NPM, grunt等外部工具 无需额外的编译步骤，你只需要像往常一样执行hugo 可以方便地切换到任意可使用json索引的客户端搜索工具  集成 集成的步骤我是参照的这篇文章 , fast search官方也有说明类似的步骤，过程不难，大概可分为：\n  Add index.json file to layouts/_default Add JSON as additional output format in config.toml Add search.js and fuse.js (downloaded from fusejs.io) to static/js Add searchbox html 到你想布局的位置 对searchbox添加样式文件   具体的步骤看博文或者官方文档就行，这里不赘述。\n改动 做了一些让自己舒服的改动：\n 让搜索框常驻，只是搜索结果可以隐藏(ESC) /聚焦搜索框，和vim相同 简化样式，贴合我的主题 搜索结果只显示title就够  这样以后不论在哪，想要切换到一篇文章只需要两次鼠标（或者两次键盘）就能精准定位并打开，不必使用鼠标的方式可能更有作用哈哈。\nTODO  只能搜索标题，不能搜索内容、tag？  ","date":"2023-08-11T16:39:42+08:00","permalink":"https://wangloo.github.io/posts/hugo/new_theme_3/","section":"posts","tags":["hugo"],"title":"Hugo 主题创建(3): 站内搜索"},{"categories":null,"contents":" commit: https://github.com/wangloo/hugo-theme-puer/commit/32abfccc6bafd3763e07b751f0315a5403c6eaff\n 与顶栏相比，我更喜欢侧边栏，现在的屏幕纵向空间很宝贵。\n本文创建了侧边栏模板的框架，预留了未来实现各种功能的布局，这个过程也是第一次接触partials/ 下的文件的作用——页面的某个组成部分。而_default/下的模板则是描述不同类型的页面。\n布局 基于hugo模板的分类思想，侧边栏属于页表的一个部分，所以侧边栏的模板需要放在partials/下， 同理的还有footer、toc、comment等。我们给侧边栏模板起一个名字sidebar.html。\n因为想在站点所有的页面（section、single、list）都显示侧边栏， 所以在baseof.html中需要引入sidebar模板：\n1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html\u0026gt; 3 4\u0026lt;head\u0026gt; 5 6 {{- partial \u0026#34;head.html\u0026#34; . -}} 7 \u0026lt;title\u0026gt; 8 {{ block \u0026#34;title\u0026#34; . }} 9 {{ .Site.Title }} 10 {{ end }} 11 \u0026lt;/title\u0026gt; 12\u0026lt;/head\u0026gt; 13 14\u0026lt;body\u0026gt; 15 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 16 {{- partial \u0026#34;sidebar.html\u0026#34; . -}} 17 \u0026lt;main class=\u0026#34;container\u0026#34;\u0026gt; 18 {{- block \u0026#34;main\u0026#34; . }} 19 {{- end }} 20 \u0026lt;/main\u0026gt; 21 \u0026lt;/div\u0026gt; 22\u0026lt;/body\u0026gt; 23 24\u0026lt;/html\u0026gt; sidebar.html的内容就比较简单了，目前的计划是添加首页、TAG和一个搜索框， 不着急，先展位，以后再实现这些功能，本次先实现框架。\n1\u0026lt;div id=\u0026#34;sideContainer\u0026#34; class=\u0026#34;side-container\u0026#34;\u0026gt; 2 \u0026lt;div class=\u0026#34;nav-link-list\u0026#34;\u0026gt; 3 {{/* TODO: 回到首页 */}} 4 \u0026lt;div class=\u0026#34;a-block nav-link-item \u0026#34; href=\u0026#34;\u0026#34;\u0026gt; 5 BACK 6 \u0026lt;/div\u0026gt; 7 8 {{/* TODO: articles... */}} 9 \u0026lt;div class=\u0026#34;a-block nav-link-item \u0026#34; href=\u0026#34;\u0026#34;\u0026gt; 10 POSTS 11 \u0026lt;/div\u0026gt; 12 13 {{/* TODO: tags */}} 14 \u0026lt;div class=\u0026#34;a-block nav-link-item \u0026#34; href=\u0026#34;\u0026#34;\u0026gt; 15 TAGS 16 \u0026lt;/div\u0026gt; 17 \u0026lt;/div\u0026gt; 18\u0026lt;/div\u0026gt; 样式 这是首次接触样式的修改，也就是用到css语言。顺便说下，我非常敬佩视频网站上那些对CSS玩的很溜 的人，我觉得CSS中的细节远比我的工作中的多，可能你糊弄一下能得到一个相同的效果，但是一个优秀的 前端工程师是要清楚每个属性的作用，他们之间是如何搭配的，绝对不是凑出结果。\n主题中如何添加css文件呢？创建模板时会自动创建目录 static/css/，其中可以放置一些css文件， 比如我为sidebar.html创建的叫style.css, 在样式不多的情况下其他部分的样式也都可以放在这。\n不在一个目录下，如何联系html和css呢？这就不得不提到partials/下的另一个重要模板head.html, 通过baseof.html中它的位置就能大概知道它的作用：\u0026lt;head/\u0026gt;标签的模板，基本上就是描述样式的css语法嘛。 这就是html和css连接的桥梁。\n以下是style.css文件内容：\n1.container { 2 padding-left: 25%; 3 width: 75%; 4 min-height: 100vh; 5 white-space: normal; 6 7} 8 9.side-container { 10 position: fixed; 11 top: 0; 12 height: 100vh; 13 width: 25%; 14 text-align: left; 15 padding: 20px 0 50px 0; 16 display: flex; 17 flex-direction: column; 18 justify-content: space-between; 19} 20 21.nav-link-list { 22 flex-grow: 1; 23 .nav-link-item { 24 margin-bottom: 10px; 25 border-right: 2px solid transparent; 26 /* padding: 8px 28px 8px 30px; */ 27 cursor: hand; 28 transition: all 0.2s linear; 29 } 30 } 有了侧边栏后，我们需要启用内容的wrap line，且目前暂时用padding-left+width=100%的方式 来避免当文字过长出现滚动条时滑动会破坏布局。 本质还是由于侧边栏的实现是通过padding方式，sidebar和内容互相不能感知对方。\n","date":"2023-08-11T15:39:42+08:00","permalink":"https://wangloo.github.io/posts/hugo/new_theme_2/","section":"posts","tags":["hugo"],"title":"Hugo 主题创建(2): 添加侧边栏"},{"categories":null,"contents":" 本次对应的commit，应该属于站点的仓库，因为仅修改 config.toml\n 代码高亮 hugo 内置一套highlight引擎, 参见官网的描述 , 所以我们只需要对站点的配置文件(注意不是模板的配置文件)进行修改, 就能最简单的实现代码高亮.\n如果你需要对其进行自定义, 且将其固化到你的主题中, 那么就可能需要使用highlight.js来完成, 遵循\u0026quot;提前优化是万恶之源\u0026quot;的理论, 暂时使用hugo提供的高亮支持就能符合我们的目标.\n这是我的配置文件config.toml中关于代码高亮的启用:\n1[markup] 2 [markup.highlight] 3 anchorLineNos = false # 行号格式化为\u0026lt;span\u0026gt; 4 codeFences = true # 代码围栏, 不启用高亮无效 5 guessSyntax = true # 自动推断高亮语言 6 hl_Lines = \u0026#39;\u0026#39; # 突出显示某些特定的行 7 hl_inline = false # 高亮 inline code, ver\u0026gt;=0.101.0 8 lineAnchors = \u0026#39;\u0026#39; #　与 anchorLineNos 配合 9 lineNoStart = 1 # 行号开始 10 lineNos = true # 是否显示行号 11 lineNumbersInTable = true # 生成html中分开行号和代码 12 noClasses = true 13 noHl = false 14 style = \u0026#39;vs\u0026#39; 15 tabWidth = 4 参考  hugo代码高亮引擎描述引导页: https://gohugo.io/content-management/syntax-highlighting/ 参数的详细描述: https://gohugo.io/functions/highlight/  ","date":"2023-08-11T07:39:42+08:00","permalink":"https://wangloo.github.io/posts/hugo/new_theme_1/","section":"posts","tags":["hugo"],"title":"Hugo 主题创建(1): 内置样式"},{"categories":null,"contents":" commit: https://github.com/wangloo/hugo-theme-puer/commit/c014d1fae09eea1fcc44e03c69b6dd4d185f91fd\n 背景交代 到现在为止我使用hugo也一年多了, 记了几十条的博客，对于使用频率如此高的工具来说， 有一个顺眼的外观、方便的功能布局简直是梦寐以求。\n然而，试过了这么多的现有主题，始终没有一个让我觉得满意，可能我的要求过于苛刻：\n 搜索；我经常需要翻阅之前的博客/笔记，期望可以检索Tag，且不需要二次点击（ 上方直接是一个搜索框而不是一个按钮）。 TOC；要求可是展开显示三级的目录，且布局好看些。 外观；简洁，不花里胡哨，代码高亮看起来舒服。 xxx  所以，既然Hugo是一个开源的、社区环境较好的工具，那么为什么不尝试打造一款属于自己主题呢。\n我是一名嵌入式开发工程师，对于前端的知识生疏，希望在良好的社区环境下能帮助我早日完成满足我个人需求的主题。\n计划  搭建框架 制作模板，熟悉模板的概念，各个模板负责的区域 在上面的了解过程中逐渐加入对布局的调整，这一块可能需要学习css的知识 观摩学习前人的代码，结合百家之长，磨合出适合自己的布局和功能  开始动手：搭建脚手架 创建的过程可以参考这个博客 , 我主要想按照我的理解对整个框架进行详细的介绍。\n目录结构 1. 2├── layouts 3│ ├── 404.html 4│ ├── _default \u0026lt;--- 此次重点研究 5│ │ ├── baseof.html 6│ │ ├── section.html 7│ │ ├── single.html 8│ │ └── list.html 9│ ├── index.html \u0026lt;--- 此次重点研究 10│ └── partials 11│ ├── footer.html 12│ ├── header.html 13│ ├── head.html 14│ └── script.html 15├── LICENSE 16├── static \u0026lt;--- 目前是空的, 后续再研究 17│ ├── css 18│ └── js 19└── theme.toml \u0026lt;--- 干什么用的不清楚,后续研究 此次重点探讨index.html和_default目录下的文件.\nindex.html 是整个网站的首页, 打开你的站点最先看到的就是它的内容.\n1{{ define \u0026#34;title\u0026#34; }} 2 首页 3{{ end }} 4 5{{ define \u0026#34;main\u0026#34; }} 6 \u0026lt;p\u0026gt; 这里是个人站的首页, 仅展示用, 请DIY自己的首页覆盖它 :] \u0026lt;/p\u0026gt; 7{{ end }} 你可能看不懂这段代码, 这不是正常的html, 但马上你就能明白了.\n_dafult下的文件被hugo称之为模板, 顾名思义他们的存在是为了减少代码的重复度. 不同名称的模板代表了hugo将页面划分为不同的类, 这个在官方文档中应该有介绍, 后续可以插入个链接(TODO).\n single.html: 普通页面的模板, 我们写的博客中的内容页面就算是single page list.html: 列表页面的模板, 好几个博客分布在同一个子目录下, 访问这个目录的 地址就是 list page section.html: content/是hugo工程放置内容的目录, 其下需要建立子目录, 比如posts/代表这是一些博客  baseof.html需要着重介绍, 它相当于模板的模板, 目的是为了消除模板代码中的重复, 其中使用hugo提供的block语法, 建立基础模板, 目前我们baseof.html的内容如下:\n1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html\u0026gt; 3 4\u0026lt;head\u0026gt; 5 {{- partial \u0026#34;head.html\u0026#34; . -}} 6 \u0026lt;title\u0026gt; 7 {{ block \u0026#34;title\u0026#34; . }} 8 {{ .Site.Title }} 9 {{ end }} 10 \u0026lt;/title\u0026gt; 11\u0026lt;/head\u0026gt; 12 13\u0026lt;body\u0026gt; 14 {{- partial \u0026#34;header.html\u0026#34; . -}} 15 \u0026lt;main class=\u0026#34;container\u0026#34;\u0026gt; 16 {{- block \u0026#34;main\u0026#34; . }} 17 {{- end }} 18 \u0026lt;/main\u0026gt; 19 {{- partial \u0026#34;footer.html\u0026#34; . -}} 20 {{- partial \u0026#34;script.html\u0026#34; . -}} 21\u0026lt;/body\u0026gt; 22 23\u0026lt;/html\u0026gt; 这还稍微像一点html, 能看出是一个html的框架, 其中用block声明了title和main变量.\n其他的模板文件中(包括index.html), 只要实现这两个变量, 就相当于把整段的代码都拷过来, 并且将{{ block \u0026quot;xx\u0026quot; }} 和 {{ end }} 之间的内容替换为你define的内容.\n在baseof.html中对{{ block \u0026quot;xx\u0026quot; }} 和 {{ end }} 之间提前填充就实现了, 对网页的title设置了一个默认值, 如果重定义了, 那么覆盖原先的默认值. 看index.html就能明白, 它将网站的title替换成了\u0026quot;首页\u0026quot;, 内容也改变了, 其他的都是相当于和 baseof.html相同.\n 这里不介绍hugo的更多详细语法使用, 官方文档中都有\n  这里先不介绍优先级的概念, 假设这些模板文件在全局中只有一个\n 参考  https://gohugo.io/templates/base/  ","date":"2023-08-10T17:39:42+08:00","permalink":"https://wangloo.github.io/posts/hugo/new_theme_0/","section":"posts","tags":["hugo"],"title":"Hugo 主题创建(0): 脚手架"},{"categories":null,"contents":"构建 openWRT  我在此步骤失败了，后面项目没有依赖完整的编译过程， 所以可能对你不构成参考\n 过程可参考官方教程, 编译过程非常长，使用到的工具非常多，这里提供两个优化的思路:\n提前安装本地依赖，忘了./scripts/feeds update -a还是./scripts/feeds install -a时需要检查系统的各种依赖, 可以提前统一安装一波.\n1sudo apt install g++ 2sudo apt install libncurses5-dev 3sudo apt install zlib1g-dev 4sudo apt install bison 5sudo apt install flex 6sudo apt install unzip 7sudo apt install autoconf 8sudo apt install gawk 9sudo apt install make 10sudo apt install gettext 11sudo apt install gcc 12sudo apt install binutils 13sudo apt install patch 14sudo apt install bzip2 15sudo apt install libz-dev 16sudo apt install asciidoc 17sudo apt install subversion 18sudo apt install python 19sudo apt install git 提前下载dl, dl是默认在编译时下载的一些工具源码, 你可以将他们提前下载好 放到dl/下, 即可省去下载的时间, 特别当你不能翻墙时.\n就像这个仓库这样, 但是它里面 的软件版本可能比较老了而且有的软件是缺失的, 以后如果真的要自己编译, 需要查makefile去替换真正依赖的软件和其对应的版本.\n最终还是因为编译某个模块失败, 且编译时间太长(连交叉编译工具链都需要现场编译) , 导致排查困难, 没有编译成功。好在后面也没有直接依赖编译的结果。\n编译的tips  make V=99 build with verbose  ptgen 正如上面所言, 我最终没有完整的编译成功。但其中的一个小工具ptgen是我 需要用的到，它在过程中被编译出来了，相对独立些。\nptgen是OpenWRT开发的一个用来生成gpt分区表的工具，创建的sdcard镜像， 只有配合分区表才能正确的被bootrom加载起来。\n使用方法及参数 ptgen使用的参数说明:\n1 2ptgen [-v] -h \u0026lt;heads\u0026gt; -s \u0026lt;sectors\u0026gt; -o \u0026lt;outputfile\u0026gt; [-a 0..4] [-l \u0026lt;align kB\u0026gt;] [[-t \u0026lt;type\u0026gt;] -p \u0026lt;size\u0026gt;...] 3 4-v: 指定是否打印调试信息,可选 5-h: 指定起始磁头号 6-s: 指定起始扇区号 7-o: 指定输出文件名 8-a: 指定激活分区为哪个, 可选 9-l: 指定多少KiB对齐,可选，这个参数会决定每个分区的偏移扇区号，非常重要 10-t: 指定文件系统分区标志类型值,是0x83指linux,0x0b指Win95 FAT32,可选 11-p 指定分区大小,可选 ptgen使用案例 这里贴出我使用ptgen创建一个BananaPi M2 Ultra可以识别的sd卡镜像文件， 对bootfs进行挂载可放入一些文件，在uboot下能访问。\n1#!/bin/bash 2 3if [ -f \u0026#34;sd.img\u0026#34; ]; then 4 echo \u0026#34;warning: sd.img already exist, do nothing\u0026#34; 5 exit 6fi 7 8if [ -f \u0026#34;bootfs.ext4\u0026#34; ]; then 9 echo \u0026#34;warning: bootfs.ext4 already exist, do nothing\u0026#34; 10 exit 11fi 12 13BOOTFS_SIZE=16M 14# make ext4 fs which including kernel.bin 15dd bs=\u0026#34;$BOOTFS_SIZE\u0026#34; if=/dev/zero of=bootfs.ext4 count=1 16sudo mkfs.ext4 bootfs.ext4 17[ -d \u0026#34;./mnt\u0026#34; ] || mkdir ./mnt 18sudo mount -o loop bootfs.ext4 ./mnt 19sudo cp kernel.bin ./mnt 20sudo umount ./mnt 21 22 23# create empty image 24dd bs=32M if=/dev/zero of=sd.img count=1 25 26 27# generate parition table 28# -t 0xc: FAT32 29# -t 0x83: ext4 30set $(./ptgen -o sd.img -h 4 -s 63 -l 1024 -t 0x83 -p \u0026#34;$BOOTFS_SIZE\u0026#34;) 31 32 33BOOTFS_OFFSET=\u0026#34;$(($1 / 512))\u0026#34; 34# write in uboot and bootfs 35dd bs=1024 if=u-boot-sunxi-with-spl.bin of=sd.img seek=8 conv=notrunc 36dd bs=512 if=bootfs.ext4 of=sd.img seek=\u0026#34;$BOOTFS_OFFSET\u0026#34; conv=notrunc 37 38 39echo -e \u0026#34;\\n\\nsd.img is ok\u0026#34; 我正是依赖这个工具生成了最终的镜像而已，其他的模块其实并不是特别需要。 本来u-boot也是必须的，但是后面发现我用的硬件(BananaPi M2 Ultra) 在uboot中有直接的defconfig，所以也就不依赖openWRT的编译结果了。\n","date":"2023-08-05T19:28:12+08:00","permalink":"https://wangloo.github.io/posts/embedded/openwrt/","section":"posts","tags":["tools"],"title":"openwrt 开发日记"},{"categories":null,"contents":"Architecture ARMv8  寄存器、指令速查：http://hehezhou.cn/arm/  u-boot 克隆仓库\n1git clone https://github.com/u-boot/u-boot 交叉编译toolchain Linaro 经常用来编译armv7架构的一些项目。\nhttps://releases.linaro.org/components/toolchain/binaries/\nGNU https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads\nC GNU 内联汇编 https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C\n构建工具 跟我一起写makefile PDF：https://seisman.github.io/how-to-write-makefile/Makefile.pdf\n嵌入式开发小工具 网络调试工具 http://free.cmsoft.cn/download/cmsoft/assistant/netassist5.0.3.zip\n 其他  Emoji cheat sheet https://www.webfx.com/tools/emoji-cheat-sheet/  ","date":"2023-08-05T19:28:12+08:00","permalink":"https://wangloo.github.io/posts/tools/useful_sites/","section":"posts","tags":["tools"],"title":"开发资料站集合"},{"categories":null,"contents":"前言 写这篇博客的背景是我实在忍受不了每次换新的开发机器都得费好大的劲来完全恢复以前的环境， 而且，我平常喜欢搜集各种有用的工具、好看的主题，字体这些，如果零零散散的记录，大概率会忘记或者记不得某些细节。\n所以，最后期望达到的是能够使我每次在新机器上搭建环境只需要看这一篇文章就可以了。因此这里会记录：\n 帮助提升开发效率的小工具 好看的字体、主题 配置某些环境的要点及注意事项   🥀 到目前为止，我还未发现一种方式能够完全达到“一键式布置”，这也不是本文的目的。 付出至少半天的时间的一定的，希望未来能发现一种好的方法。\n 字体 Fira Code 这款字体适合做编程字体，蛮好看的。我在 vscode 和 terminal 下都使用了这款字体。\n详情及安装参考github\n霞鹜文楷 开源的中文字体，做博客、PPT 不错。\n详情及安装参考github\nvscode 主题 配置备份 vim vimrc ycm 特别注意 YCM 插件对 python, vim 的版本均有要求。\n下载 可以使用 vim-plug 等工具下载, 也可以下载源码然后拷贝到.vim目录下\n编译 编译用到 python3, 这里是问题最多的一步\n1# 编译并添加对C的提示支持 2python3 install.py --clangd-completer --verbose 3 4Searching Python 3.8 libraries... 5... 6Downloading Clangd from https://github.com/ycm-core/llvm/releases/download/13.0.0/clangd-13.0.0-x86_64-unknown-linux-gnu.tar.bz2... 使用--clangd-completer参数时, 脚本会去下载 clangd-14.0.0-x86_64-unknown-linux-gnu.tar.bz2 文件, 比较慢. 也可以提前根据提示的网站自己手动下载压缩包.\n下载完成后, 放到本地目录下:\n1:~/.vim/plugged/YouCompleteMe/third_party/ycmd/third_party/clangd/cache$ ls 2clangd-14.0.0-x86_64-unknown-linux-gnu.tar.bz2 还需对脚本YouCompleteMe/third_party/ycmd/build.py进行修改, 防止重新下载.\n1def DownloadClangd( printer ): 2 ... 3 MakeCleanDirectory( CLANGD_OUTPUT_DIR ) 4 5 if not p.exists( CLANGD_CACHE_DIR ): 6 os.makedirs( CLANGD_CACHE_DIR ) 7 # 注释下面的语句 8 # elif p.exists( file_name ) and not CheckFileIntegrity( file_name, check_sum ): 9 # printer( \u0026#39;Cached Clangd archive does not match checksum. Removing...\u0026#39; ) 10 # os.remove( file_name ) 11 12 if p.exists( file_name ): 13 printer( f\u0026#39;Using cached Clangd: { file_name }\u0026#39; ) 配置 YCM 配合一个配置文件.ycm_c_c++_conf.py, YCM 搜索的位置在 vimrc 中指定:\n1Plug \u0026#39;rdnetto/YCM-Generator\u0026#39;, { \u0026#39;branch\u0026#39;: \u0026#39;stable\u0026#39; }2let g:ycm_global_ycm_extra_conf = \u0026#34;~/.ycm_c_c++_conf.py\u0026#34;其内容的 example:\n1import os 2import ycm_core 3 4flags = [ 5 \u0026#39;-Wall\u0026#39;, 6 \u0026#39;-Wextra\u0026#39;, 7# \u0026#39;-Werror\u0026#39;, 8 \u0026#39;-Wno-long-long\u0026#39;, 9# \u0026#39;-Wno-variadic-macros\u0026#39;, 10 \u0026#39;-fexceptions\u0026#39;, 11 \u0026#39;-ferror-limit=10000\u0026#39;, 12 \u0026#39;-DNDEBUG\u0026#39;, 13 \u0026#39;-std=c99\u0026#39;, 14 \u0026#39;-xc\u0026#39;, 15 \u0026#39;-isystem/usr/include/\u0026#39;, 16 ] 17 18SOURCE_EXTENSIONS = [ \u0026#39;.cpp\u0026#39;, \u0026#39;.cxx\u0026#39;, \u0026#39;.cc\u0026#39;, \u0026#39;.c\u0026#39;, ] 19 20def FlagsForFile( filename, **kwargs ): 21 return { 22 \u0026#39;flags\u0026#39;: flags, 23 \u0026#39;do_cache\u0026#39;: True 24 } 优化 :small_red_triangle_down: 对于C/C++来说, YCM的使用最好配合compilation database 来使用, 例如compiledb. 否则, 可能头文件的path识别出问题(stackoverflow).\n2022年2月13日我使用的compilation database生成工具从compiledb换成了bear, 因为bear更好的支持递归, 即有make -C的情况.\n需要的compilation database生成工具介绍: Compilation database — Sarcasm notebook\n终端软件安装 源替换 apt 1sudo apt install python3-pip 2sudo apt install tmux 3sudo apt install fzf 4sudo apt install zsh 5sudo apt install cmake pip3 1# CLI 代码高亮 2sudo pip3 install pygments shell zsh oh-my-zsh oh-my-zsh可以看作对zsh的配置文件做一层抽象，使配置更方便。 带来的缺点就是速度变慢。\n 进入git目录下太卡\nTODO： 是主题的原因，可以配置\n 配置文件  .bashrc .zshrc .bash_aliase .bash_path  terminal ubuntu自带的终端我觉得还不错，有些人说Terminitor不错，分屏功能还是挺常用的！\nssh 密钥 1ssh-keygen -t rsa -C \u0026#34;cnwanglu@icloud.com\u0026#34; tmux tmux 在远程开发时比较有用。我们在用ssh连到服务器时经常需要有多窗口的需求， 比起现有terminal软件自带的多窗口功能(Xshell,mobaxterm等)，使用tmux 会更加方便。\n 窗口创建、切换等方式可以做到统一，不用追随终端软件 可以保存现场，即便因为网络问题ssh断开，也能随便恢复到之前的状态。因为 tmux是C/S架构，只要服务器上的server不死，永远可以恢复之前状态！ 甚至，tmux提供了将现场保存到本地文件中的功能。  reference  Tmux使用手册  ","date":"2023-07-17T19:28:12+08:00","permalink":"https://wangloo.github.io/posts/tools/dev_env/","section":"posts","tags":["tools"],"title":"我的开发环境构建指南"},{"categories":null,"contents":"上午结束了特斯拉嵌入式实习生-Linux platform的二面，特斯拉实习生 一共有三轮面试，一轮和二轮都是技术面，三面是主管面。 目前我完成了所有的技术面，且不论结果如何，整个面试过程对我而言还是收获颇丰的， 故以此文整理下自己的欠缺的技术知识，希望下次能够表现的更好。\n二面 首先，此轮面试的面试官显然比上一轮更有礼貌一些，准时与会+介绍自己，不过有一点 是我开了摄像头他没开，也没有进行说明吧。 不过这些都是小事，我们这次主要谈论 技术的内容。\n我在此回顾几个没有回答好的问题，供以后做参考。\nELF 文件的加载流程  原回答\n 拿到 ELF 存储的地址后，先将头部读出来，长度是固定的。头部有校验字段， maigic number, 然后是确认 ELF 编译的架构，位数是否正确。 确认格式正确后，读取程序头表，其中保存了各个需要加载的段的偏移，根据 base+段偏移能够得到该段的位置，然后根据段属性的不同，选择映射到不同 的区域和属性，例如 text 段映射为 RE, 代码段映射为 RW，清空 BSS 等 说明自己没接触过动态库文件，所以对动态加载不是很熟悉   点评如下: 对段表、程序头表，这些概念的区分还不是很熟，不清楚什么时候用 section table， 什么时候用 program header table. 以前都看过，只是 时间长了不用就忘记了，这一部分需要好好的做下笔记。\n全局变量存在哪？谁负责初始化的  原回答\n不知道。\n 全局保量存在的位置：\n 未初始化的全局变量 ==\u0026gt; bss段 const修饰的全局变量 ==\u0026gt; rodata段 其他已初始化的全局变量 ==\u0026gt; data段  对于已初始化的全局变量的访问，编译时，编译器将值存入data段，访问的指令是通过 相对寻址来做，例如相对于data段开头。对于静态链接来说，编译完成后访问指令的 基地址和偏移都是空，当链接时修改指令，即重定位的过程。\naligned_alloc()设计 这是面试最后的程序设计题，我也是没有做好，后面好歹在面试官的无数次提示中， 写出了一个解，题目很棒，只是自己实习不够，怪不得其他。\n原问题 对malloc()和free()进行封装，设计一个返回满足任意字节对齐要求的 align_alloc()和align_free()函数。\n1void *align_alloc(size_t size, size_t align); 2void align_free(void *addr); 3 4int main(void) 5{ 6 size_t alignment[6] = {5, 8, 32, 64, 128, 12}; 7 int i; 8 char *p; 9 10 for (i = 0; i \u0026lt; 6; i++) { 11 p = align_alloc(10, alignment[i]); 12 if ((unsigned long)p % alignment[i]) { 13 printf(\u0026#34;FAILED!, alignment: %ld, addr: %p\\n\u0026#34;, 14 alignment[i], p); 15 exit(1); 16 } 17 memset(p, 0, 10); 18 align_free(p); 19 } 20 printf(\u0026#34;PASS\\n\u0026#34;); 21 return 0; 22} 思路及解决方案 思路也写在代码里了，就是思路比较难想，代码倒是不难写。\nPS: 丢人的是，我在一开始居然还提了: malloc()返回的地址能够保证是参数size对齐的， 真是令人耻笑啊！！\n1#include \u0026lt;stdio.h\u0026gt;2#include \u0026lt;string.h\u0026gt;3#include \u0026lt;stdlib.h\u0026gt;4void *align_alloc(size_t size, size_t align); 5void align_free(void *addr); 6// 如何保证对齐到align? 7// ==\u0026gt; 申请更多空间, 返回对齐的地址 8// 9// 不能保证malloc返回的地址是对齐到哪的，怎么确定多申请多大呢? 10// ==\u0026gt; 多申请align的空间，就能保证这align的地址范围里，总有 11// 满足对齐条件的地址 12// 13// 如何计算返回的地址? 比如malloc(10)=12, align=5, 此时我们会 14// 申请的空间为malloc(10+5), 即(12-27)都是可用的，我们需要 15// 经过计算后返回地址 15 16// ==\u0026gt; 计算的规则是(12+5)-(12+5)%5 17// 18// aligned_free()只接受addr一个参数，如何释放malloc()申请的空间? 19// ==\u0026gt; 传入的addr是经过align之后的，确实需要一定的方法才能 20// 求得malloc()返回的地址，这通过计算是无法得到的，因为 21// 不知道这个地址的align是多少。所以可以想到在p_ret之前 22// 再多借用一个地址的长度来存放malloc()返回的原地址。 23 24void *align_alloc(size_t size, size_t align) 25{ 26 void *p_malloc; 27 void *p_ret; 28 size_t aligned_size; 29 size_t ptr_size; 30 31 ptr_size = sizeof(char *); 32 aligned_size = size + align + ptr_size; 33 34 p_malloc = malloc(aligned_size); 35 p_ret = (p_malloc+ptr_size+align) - 36 ((unsigned long)p_malloc+ptr_size+align) % align; 37 38 *((unsigned long *)p_ret-1) = (unsigned long)p_malloc; 39 40 // debug 41 printf(\u0026#34;[ALLOC] p_malloc: %p, p_ret: %p, align: %ld\\n\u0026#34;, 42 p_malloc, p_ret, align); 43 44 return p_ret; 45} 46void align_free(void *addr) 47{ 48 void *p_malloc; 49 50 p_malloc = (void *)(*((unsigned long *)addr-1)); 51 52 printf(\u0026#34;[ FREE] p_malloc: %p\\n\u0026#34;, p_malloc); 53 free(p_malloc); 54} 55 56 57int main(void) 58{ 59 size_t alignment[6] = {5, 8, 32, 64, 128, 12}; 60 int i; 61 char *p; 62 63 for (i = 0; i \u0026lt; 6; i++) { 64 p = align_alloc(10, alignment[i]); 65 if ((unsigned long)p % alignment[i]) { 66 printf(\u0026#34;FAILED!, alignment: %ld, addr: %p\\n\u0026#34;, 67 alignment[i], p); 68 exit(1); 69 } 70 memset(p, 0, 10); 71 align_free(p); 72 } 73 printf(\u0026#34;PASS\\n\u0026#34;); 74 return 0; 75} ","date":"2023-06-10T08:51:49+08:00","permalink":"https://wangloo.github.io/posts/work/tesla/","section":"posts","tags":["work"],"title":"面试总结：特斯拉实习"},{"categories":null,"contents":"slub 和 slob 是基于 slab 思想针对某些场景下的优化实现。\nSLUB  当 slab 分配器面对过多的申请需求时，cache 中就会有多个 slab (struct slab), 在以前的 slab 分配器设计中， slab 描述符是放在物理页中的，即物理页的结构为： （slab 描述符+freelist+对象 s）,管理数据结构的开销就比较大。后期 SLUB 首先将 slab 描述符与struct page共用（通过 union 实现）。后面该思想被 SLAB 采纳。 SLAB 中每个 cache node 有三个 list: free, partial, full， 管理起来很麻烦， SLUB 中只有一个 partial 链表。 放弃着色，效果不明显  SLOB SLOB 的设计更加简洁，只有 600 行左右代码（SLAB，SLUB 都是 4000+），适合小内存的嵌入式设备。\nSLOB 中没有对象的概念，每个 slab 中分配的小块内存大小可以是不同的， 通过长度+偏移来记录下一个小块内存的位置。\n另外，SLOB 基本上放弃了 cache 的思想，系统中通过创建三个全局的链表: small, medium, large, 分别应对\u0026lt;256b, \u0026lt;1k, \u0026lt;PAGESIZE 的请求， slab 直接挂在这三个链表上，因为 slab 中的内存分配大小可以不同， 用三个链表可以加速查找。\n 从思想上，SLOB 仅仅保留 slab 中分配小块内存的思想，舍弃了 cache 的设计方案，所以实现上非常简单。\n ","date":"2023-05-26T18:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/mem/slab3/","section":"posts","tags":["linux","Operating System"],"title":"linux SLAB 内存分配器(3): SLUB/SLOB"},{"categories":null,"contents":"上一篇介绍了数据结构，这一篇主要介绍 slab 分配器的分配和释放算法。\n最外层接口: kmalloc()/kfree() 最上层的接口是kmalloc(size, flag)。\nslab 分配器维护了多个不同大小的 kmem_cache，放在数组kmem_caches[]中, 其对应的 object 大小和该 kmem_cache 的 name 在另一个数组kmalloc_info[] 中，它们的下标是对应的。使得我们能根据请求分配的大小来找到对应的struct kmem_cache结构。 【代码】\n专用的\u0026quot;cache\u0026quot; 上面的结构，会遍历系统初始化创建的一些内存池，来寻找一个大小满足要求的 object， 但是通常不能找到大小相等的，如果系统中存在的固定 cache 中 object 的大小太稀疏， 就容易发生空间浪费的问题。\n因此，我们可以为某个特定大小的内存请求再创建一个单独的 cache，仅仅用于满足这一类 结构体的申请，也是符合 slab 分配器关于面向对象的设计思想。\nslab 分配器提供的相关接口是:\n kmem_cache_create(): 创建一个专用 cache kmem_cache_alloc()： 从指定的 cache 里分配 object kmem_cache_free(): 释放对象到指定的 cache kmem_cache_destory(): 销毁某个 cache  Reference https://blog.csdn.net/u010923083/article/details/116518646?spm=1001.2014.3001.5502\n","date":"2023-05-20T18:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/mem/slab2/","section":"posts","tags":["linux","Operating System"],"title":"linux SLAB 内存分配器(2): 算法"},{"categories":null,"contents":" 参考的 linux kernel 代码版本 4.12\n slab 是什么 slab 属于 linux 内核内存分配器的一种，满足细粒度的小块内存的请求。 内核中还有其他的内存分配器例如伙伴系统，它是满足页为单位的分配请求。 因为内核中大部分的分配请求都用不到一个页那么大，所以 slab 的出现能够减小 内存碎片的出现。\n另外，非常重要的是，除了基本的小块内存分配， slab 的最初设计开始就基于 对象缓存的思想，加速分配和初始化的过程，下面将详细介绍缓存的设计思想。\n slab 分配器的实现在 linux 中是基于伙伴系统的，slab 管理的内存来源 就是伙伴系统，只是进行“二次管理”， 。\n slab 的设计思想 对象缓存特性 经常会在 slab 接口中看到kmem_cache这个前缀，我最初也有疑问说 slab 不就是一个内存分配算法，和 cache 扯上什么关系呢？\nslab 一般用于分配一些结构的内存，拿struct task来举例，我们通常会为 struct task创建一个内存池，里面包含了若干大小为sizeof(struct task) 的内存块，用的时候从里面取，释放之后回归池子里即可。这是 slab 分配小块内存的 基本思想。\n内核中的很多数据结构，我们在申请完空间之后立马做的一件事，就是初始化对象的成员 为某些特定的值，可以称这个过程为结构体(类)的构造函数，意为所有对象都会 做的那些相同的事。比如说，多核环境下很多结构中会有锁，或者链表，那么申请完空间 之后都会做锁或链表做初始化，这是固定的。实际上这些操作消耗的时间甚至大于申请 一块内存。\n基于以上事实，slab 分配器做的缓存优化是：为每个类别的内存池都绑定一个构造函数 和析构函数，当用完的对象空间被释放时，调用析构函数将某些成员的值恢复为默认状态 ，这样下次申请的时候，直接拿就行了，省略了重复的初始化流程。而构造函数被调用的 情况仅仅是当该小块内存第一次被申请时。\n由于这个思想，整个内存池也就被声明结构 struct kmem_cache, 它是整个 slab 算法的顶层数据结构，其中包含了许多相同大小的小内存块，slab 通过一些算法对其进行 管理。\n整体数据结构的规划 上面说了整个系统的顶层结构是struct kmem_cache, 其中可以再划分为多个\u0026quot;slab\u0026quot;, 这个 slab 就能代表一个或多个连续的物理页嘛，从 buddy 申请来的。\n表示一个 slab 的描述符可以与struct page，即物理页描述符共用，只是有一些 特定的成员不同，但毕竟 slab 描述符含义上来说也是表示一个或多个联系的物理页。 只是这些物理页中可以再此进行划分为小的内存块。\nslab 算法称这些小的内存块为object, 对象, 每个kmem_cache中的所有 slab 中的所有 object 的大小都是一致的。\nslab所指向的连续物理页中的内容=（一大堆 object +辅助快速定位 object 的结构）。 [图]\n这个结构就差不多了，另外，如果让kmem_cache下的所有 slab 都放在一起，不好判断那些 slab 中的 object 已经全部分配了，哪些 slab 是空的？为了方便管理和查找，slab 算法还 封装了一个struct kmem_cache_node结构，组织了三条链表: free, partial, full。 特定状态的 slab 挂在特定的链表上，方便查找。【图】\nReference https://blog.csdn.net/u010923083/article/details/116518248\n","date":"2023-05-20T17:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/mem/slab1/","section":"posts","tags":["linux","Operating System"],"title":"linux SLAB 内存分配器(1): 概述"},{"categories":null,"contents":"软中断、tasklet、工作队列都是中断上下部分离的具体实现方案。\n软中断 我们可以将某些中断配置为软中断，相当于建立一张 INTID 到软中断的映射表，这样在 中断到来时就能判断是否为软中断。\n这张“表”的建立是静态的，即编译时确定的。key 为 INTID，value 为描述一个软中断 的数据结构，在下面会介绍。\n 软中断的服务函数必须是可重入的，即多个 CPU 可以同时执行同一个 softirq 的处理函数，涉及到的全局结构可以用 spinlock 钳制。\n 表示 softirq 的数据结构 struct softirq_action代表一个软中断，系统中所有支持的软中断组成一个数据 softirq_vec[], 所有的软中断按照优先级来分配下标。\n1struct softirq_action { 2 // 指向softirq的处理函数 3 void (*action)(struct softirq_action *); 4}; softirq 的中断流程 在中断的上部，如果识别到当前中断是一个 softirq， 那么系统会标记一个软中断发生， 即raise_softirq()函数。其做的事情包括:\n 标记某个软中断发生，记录的结构是irq_cpustate_t.__softirq_pending (这个字段使loca_softirq_pending()访问) 唤醒ksoftirqd内核线程，之后介绍  光标记不行，那么什么时候执行它们的服务函数呢？\n几个可能的检查点:(1) 中断退出前 (2)ksoftirq被唤醒时\n如果在检查点发现有标记挂起的 softirq(local_softirq_pending() != 0), 内核调用do_softirq()处理它们：\n 如何in_interrupt()返回非 0， 直接返回。此时代表要么禁用了 softirq，要么当前是 在中断嵌套的环境下，也可能正在执行do_softirq()时中断嵌套的，而do_softirq() 函数是不能嵌套执行的。 调用__dosoft_irq(), 对于local_softirq_pending()的每一位都调用其 softirq_vec[nr]-\u0026gt;action()  这里有个重要的问题，此时处于中断下部，即开中断的情况，所以在处理 softirq 时会有新的 softirq 到来，这里就有两种策略：\n 不断的获取最新的local_softirq_pending(), 直到不再有新的 softirq 产生才返回 忽略新来的 softirq，使其在下次检查点再被处理  这两种方案其实各有利弊，首先第一种方案，提高了 softirq 的响应速度，但如何 softirq 过多或者处理时间太长就会导致用户态线程已知得不到运行；而第二种方案则会增加 softirq 的响应延迟。\n实际上，softirq 的处理函数do_softirq()是采用折中的方案，它会在内部循环检查 10 次 （是可配置的），检查有无新的 softirq 到来。对于那些在循环之后到来的 softirq，那么 唤醒 ksoftirqd 线程来处理剩下的，不延迟用户态的运行。\nksoftirqd 内核线程 ksoftirqd 是一个内核线程，每个 CPU 都有，它的任务是不断检查是否存在挂起的 softirq， 并 执行其处理函数。\n1for (;;) { 2 set_current_state(TASK_INTERRUPTABLE); 3 schedule(); 4 while (local_softirq_pending()) { 5 preempt_disable(); 6 do_softirq(); 7 preempt_enable(); 8 } 9} ksoftirqd 的优先级较低，这样当do_softirq()循环 10 次还有新的 softirq 时， 唤醒 ksoftirqd 线程不会耽误用户态的执行，但当系统空闲时间，挂起的 softirq 又 会很快得到处理。\ntasklet tasklet 是基于其中一个软中断(TASKLET_SOFTIRQ)构建，其关系有点像线程与用户态 线程之间那种嵌套关系。\ntasklet 的分配可以是运行时确定的(例如使用 insmod)增加新的 tasklet。\n 内核对 tasklet 的服务函数进行了更加严格的控制：不能在多个 CPU 上同时运行同一个类型的 tasklet 函数(不同类型的 tasklet 可以)。，这样就使得 tasklet 服务函数不必非得 实现为可重入的， 简化驱动开发者的工作。\n 表示 tasklet 的数据结构 描述一个 tasklet 的数据结构为tasklet_struct, 成员包括:\n1struct tasklet_struct { 2 // 指向下一个tasklet，所有tasklet链表串联 3 struct tasklet_struct *next; 4 unsigned long state; 5 // tasklet 对应的处理函数 6 void (*func)(unsigned long); 7 // func 中可以使用的数据 8 unsigned long data; 9}; tasklet 的中断流程 TASKLET_SOFTIRQ的 action 指向遍历所有tasklet_struct的方法，该方法中 执行每个 tasklet 的func()。\n工作队列 工作队列创建了一个内核线程kworker, 原理与ksoftirqd差不多。\n主要的区别是ksoftirqd运行在中断的上下文，因为其调用了do_softirq(), 而中断上下文中是禁用用户抢占的，也就是说不能发生调度(不影响嵌套中断)。\n 中断上下文中禁止抢占的原因是开启了中断嵌套，代价是必须禁止抢占。 如果同时允许中断嵌套和抢占，那么“嵌套的”中断返回时如果发生了调度， 返回别的高优先级的进程去了，此时初级的中断还未结束。如此时在新进程里 又发生了初级类型同样的中断，就很有可能发生数据不一定或者死锁。\n 工作队列是运行在进程的上下文中的，也就是一般情况下。此时当然可以发生 抢占，所以工作队列适用于那种需要中断服务函数需要发生调度的情况， 比如说调用了sleep().\n工作队列 ","date":"2023-05-13T20:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/interrupt/softirq/","section":"posts","tags":["Operating System"],"title":"Linux 中断管理: 软中断/tasklet/工作队列"},{"categories":null,"contents":"linux 内核为创建【用单链表解决冲突的哈希表】设计了专门的数据结构 hlist。\nhlist 整体来说是带头结点的双向链表，头结点的类型为hlist_head, 普通节点 的类型为hlist_node. 为什么要区别两种类型？节约空间， 因为哈希表的 表项类型可以是hlist_head, 它其实不需要prev指针, 比起一般的结点，一个 哈希表能节约一半的空间。\n所以一个哈希表和头结点的结构可表示为:\n1struct hlist_head { 2 struct hlist_node *first; 3}; 4struct hlist_head table[TALBE_SZ]; 二象性 任何事物都具有二象性，区分两种类型节约空间的空间，也带了一个问题： 首个hlist_node结点的prev指向哪呢？\n正常情况下肯定毫不犹豫的指向头结点，即hlist_head，但注意此时类型是 不同的，prev不能同时是struct hlist_head*和struct hlist_node *。\n解决方案有两个，首先可以使首个结点的prev=NULL, 这样虽然避免了类型引发的 问题，也能保证功能正确，但是却破坏了一致性，使得操作的复杂度上升，增加了许多 判断分支。\n1// delelt a node 2void del_node(struct hlist_head *head, struct hlist_node *node) 3{ 4 // 这个if 本来是不需要的，甚至参数的head 也不需要传， 5 // 更好的处理方式见解决方案2 6 if (node == head-\u0026gt;first) { 7 head-\u0026gt;first = node-\u0026gt;next; 8 } 9 else { 10 node-\u0026gt;prev-\u0026gt;next = node-\u0026gt;next; 11 } 12 13 if (node-\u0026gt;next) { 14 node-\u0026gt;next-\u0026gt;prev = node-\u0026gt;prev; 15 } 16} 17// insert a node 18void add_node_before(struct hlist_head *head, struct hlist_node *new 19 struct hlist_node *next) 20{ 21 // 这个if 本来是不需要的，参数head也是不需要传递的 22 if (next == head-\u0026gt;first) { 23 new-\u0026gt;prev = NULL; 24 head-\u0026gt;first = new; 25 } 26 else { 27 new-\u0026gt;prev = next-\u0026gt;prev; 28 new-\u0026gt;prev-\u0026gt;next = new; 29 } 30 new-\u0026gt;next = next; 31 next-\u0026gt;prev = new; 更好的解决方案: **prev 改变struct hlist_node的构成，使用二级指针:\n1struct hlist_node { 2 struct hlist_node *next; 3 struct hlist_node **pprev; 4}; 使得每个结点的pprev = \u0026amp;(prev_node-\u0026gt;next), 首先类型是统一的，其次删除和添加 都无需额外的分支了。\n1void del_node(struct hlist_node *node) 2{ 3 *(node-\u0026gt;pprev) = node-\u0026gt;next; 4 if (node-\u0026gt;next) 5 node-\u0026gt;next-\u0026gt;pprev = node-\u0026gt;pprev; 6} 7void add_node(struct hlist_node *new, struct hlist_node *next) 8{ 9 new-\u0026gt;pprev = next-\u0026gt;pprev; 10 *(new-\u0026gt;pprev) = new; 11 new-\u0026gt;next = next; 12 next-\u0026gt;pprev = \u0026amp;(new-\u0026gt;next); 13} Ref:\n **prev 可以提高删除的效率 stackoverflow  ","date":"2023-05-11T20:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/data_struct/hlist/","section":"posts","tags":["c","linux"],"title":"Linux 内核数据结构 hlist"},{"categories":null,"contents":"管道属于实现进程间通信的一种方式，正如其名，一个进程在一头读，另一个进程在一头写。\n管道被看做是打开的文件，但在已安装的文件系统中没有相应的实体，即并不是一个 真正的文件。\n管道的创建和使用 可以使用pipe()系统调用来创建一个管道(后面会介绍另一个方式)，其返回一对文件 描述符，一个用来写一个用来读。必须返回两个描述符的原因是： POSIX 只定义了半双工 的管道，所以读写需要两个端口。\n POSIX 另外要求使用一个描述符前需要关闭另一个描述符。 但 Linux 中则可以不关闭， 可以实现全双工，但为了可移植性， 一般还是将另一个先关闭。\n 用ls | more组合命令来解释如何使用pipe()实现通信:\n shell 调用pipe(), 返回 fd3(对应读通道),fd4(对应写通道) 两次调用 fork() 创建两个子进程，由于属于不同的地址空间， 所以操作自己的文件描述符不会影响其他进程，但都指向同一个管道 父进程调用close()关闭这两个文件描述符  第一个子进程执行ls程序，其操作如下，\n 调用dup2(fd4, stdout), 执行文件描述符的拷贝，从此stdout 就代表管道的写通道 由于stdout代表写通道，所以可将 fd3 和 fd4 均关闭 exec()执行ls程序，默认情况下，其输出结果到 stdout， 当下即管道的写通道，即向管道中写了数据  第二个子进程执行more程序，其操作如下：\n 调用dup2(fd3, stdin), 从此stdin代表管道的读通道 同样可以将 fd3 和 fd4 关闭 exec()执行more程序，由于现在stdin就是管道的读通道, 上面的子进程向管道中写了数据，所以stdin现在有数据，more 可以正常输出  popen(): 更简单的 API 当管道的使用是单向的，即某个进程仅仅想知道另一个进程的执行输出，或者 某个进程想把数据灌入到另一个进程的输入。\n此时 Linux C 库中的popen()和pclose()简化使用pipe()中 调用dup2(), close()这些繁琐的步骤。\npopen()接受两个参数: 可执行文件的路径和使用方式 type, 返回 一个指向 FILE 的指针。\npopen()做的事包含:\n pipe()创建一个管道 创建一个新进程，执行:  如果使用方式是 r, 绑定管道的写通道到stdout, 否则绑定读通道 到stdin. 关闭pipe()返回的两个描述符 exec()执行指定的可执行文件   回到父进程，如果使用方式是 r, ·关闭管道的写通道。否则关闭读通道 返回管道剩下的文件描述符地址  这样父子进程就能单向通信了，如何使用方式是 r, 父进程可用popen() 返回的 FILE 来读取可执行文件的输出；相反，父进程可向 FILE 中写数据 到可执行文件的输入。\n因为返回的是 FILE 指针，所以通常配合fprintf(), fscanf(), fgets() 这类函数使用。\npclose()等待popen()创建的子进程结束。\npopen()样例 父进程读\n1#include \u0026lt;stdio.h\u0026gt;2#include \u0026lt;unistd.h\u0026gt;3 4int main(void) 5{ 6 FILE *fp = NULL; 7 char s1[32], s2[32]; 8 9 fp = popen(\u0026#34;ls\u0026#34;, \u0026#34;r\u0026#34;); 10 11 // read the first two files and print their name 12 fscanf(fp, \u0026#34;%s %s \u0026#34;, s1, s2); 13 printf(\u0026#34;s1 = %s, s2 = %s\\n\u0026#34;, s1, s2); 14 15 // close the read side of pipe 16 pclose(fp); 17 return 0; 18} 父进程写\n1#include \u0026lt;stdio.h\u0026gt;2#include \u0026lt;unistd.h\u0026gt;3 4int main(void) 5{ 6 FILE *fp = NULL; 7 char s1[32], s2[32]; 8 9 fp = popen(\u0026#34;wc -l\u0026#34;, \u0026#34;w\u0026#34;); 10 fprintf(fp, \u0026#34;one\\ntwo\\nthree\\n\u0026#34;); 11 pclose(fp); 12 13 return 0; 14} ","date":"2023-05-11T20:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/pipe/","section":"posts","tags":["Operating System"],"title":"Linux 进程间通信: 管道"},{"categories":null,"contents":"Linux 中其实并不区别进程和线程，都用task_struct来描述，可以说 它们之间的联系大于区别。\n创建进程的接口是fork()， 创建线程的接口是pthread_create()， 但是它们最终都是调用的clone()系统调用， 只是参数不同而已。\n当一个进程/线程发起创建线程的请求时，不像创建进程那样重新申请mm_struct 和打开的文件等结构， 而是直接将指针赋值为父进程的值，所以它和父进程共享同一个 地址空间这些。\n 上面说的父进程，因为没有父线程的概念，如果创建线程的task_struct也是一个 线程，那么它的地址空间也是最终指向某个进程的，所以父亲和新的线程就是同等 地位了。\n 再说说 PID，PID 能够唯一的标识一个进程，一个进程下所有的线程的 PID 都与父进程 相同，那么问题来了，如何标识线程的从属关系呢？\ntask_struct.tgid标识自己所归属的进程 ID，或者叫主线程 ID，反正就是地址空间 的真正来源。 而进程如何知道自己创建了哪些线程呢？， 通过task_struct.children 链表来查找，但这里面即有子进程又有线程，需要过滤。\n 有的地方会使用一个名词 管理线程， 其实就是线程共享的地址空间这些的原主。\n 内核线程 内核线程是一种特殊的进程，当然也是用task_struct来描述，内核线程的特殊点：\n mm成员=NULL，没有用户空间的数据，不能访问用户空间 每个内核线程有私有数据，用set_child_tid成员指向， 是一个struct kthread结构，用to_kthread()来访问私有数据  内核线程也像普通线程一样参与调度，其创建的地方在内核，使用kthread_create() 创建，不能由用户态创建。\n内核线程一般负责执行一些内核任务，比如软中断 就有一个内核线程，来专门执行到来中断的服务函数中不着急的部分。\n","date":"2023-05-10T20:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/process/thread/","section":"posts","tags":["Operating System"],"title":"Linux 进程与线程的关系"},{"categories":null,"contents":"与 ARMv7 相比的改动  指令集： 新增 A64 指令集， 但也兼容原来的 A32 指令集 权限等级： AArch64 下新增 EL0-EL3 异常等级，对应 V7 的特权等级 通用寄存器：31 个通用寄存器，V7 15 个 虚拟地址长度：64 位的地址长度，理论支持 256TB 的寻址范围  ","date":"2023-05-09T21:19:01+08:00","permalink":"https://wangloo.github.io/posts/armv8/introduce/","section":"posts","tags":["armv8"],"title":"ARMv8 基础概念"},{"categories":null,"contents":"C++几乎是 C 的超集，只有很少的 C 的特性在 C++中不支持\nC++增加了需要方便实现面向对象特性的语法和封装，当然这些用 C 应该也能实现， 只不过 C++使其实现起来更简单。\n C++ 改进了一些 C 中的缺点，比如 new 自动计算大小避免出错 C++ 增加一些语法糖，比如迭代器等 C++ 原生支持一些方便的库文件，比如 STL 库  ","date":"2023-05-09T20:51:49+08:00","permalink":"https://wangloo.github.io/posts/c/c_and_cpp/","section":"posts","tags":["c"],"title":"C 和 C++ 的区别与联系"},{"categories":null,"contents":"想要描述一个变量，必须知道它类型信息，才能知道变量的大小、输出的格式等。\nDwarf 为 C 语言定义了一些描述数据类型的 DIE，包括 basetype, array,pointer, structure\u0026hellip;\nbasetype 今天我们先介绍最简单的 basetype。\nbasetype 是指那些 C 语言自身定义的基础类型，像int, double这些。\nbasetype 类型的 DIE 通常有属性:\n DW_AT_name: basetype 的名称 DW_AT_byte_size: 该 basetype 占空间大小  下面给出描述int和double的 DIE 展示(还是通过objdump工具输出）：\n1 \u0026lt;1\u0026gt;\u0026lt;43\u0026gt;: Abbrev Number: 3 (DW_TAG_base_type) 2 \u0026lt;44\u0026gt; DW_AT_byte_size : 4 3 \u0026lt;45\u0026gt; DW_AT_encoding : 5\t(signed) 4 \u0026lt;46\u0026gt; DW_AT_name : int 5 6 \u0026lt;1\u0026gt;\u0026lt;60\u0026gt;: Abbrev Number: 4 (DW_TAG_base_type) 7 \u0026lt;61\u0026gt; DW_AT_byte_size : 8 8 \u0026lt;62\u0026gt; DW_AT_encoding : 4\t(float) 9 \u0026lt;63\u0026gt; DW_AT_name : (indirect string, offset: 0x9): double Array 数组表示为 DW_TAG_array 的 DIE，通常含有属性:\n DW_AT_type： 指向数组元素的 DIE  数组的长度信息如何表示呢？每个 array DIE 的每个 child 都代表一个维度信息，最左边的 child 描述第一个维度信息。\n描述维度信息的 DIE 为 DW_TAG_subrange_type, 其包含两个属性:\n DW_AT_type: 指向所属 array 的 DIE DW_AT_upper_bound: 表示数据在该维度下的长度, 数值是-1 的  所以要得到一个数组的总长度，需要遍历其 DIE 的所有 child。\n下面给出一个二维数组int var_array[3][5]的相关 DIE 信息:\n1 \u0026lt;1\u0026gt;\u0026lt;43\u0026gt;: Abbrev Number: 3 (DW_TAG_base_type) 2 \u0026lt;44\u0026gt; DW_AT_byte_size : 4 3 \u0026lt;45\u0026gt; DW_AT_encoding : 5\t(signed) 4 \u0026lt;46\u0026gt; DW_AT_name : int 5 \u0026lt;1\u0026gt;\u0026lt;4a\u0026gt;: Abbrev Number: 4 (DW_TAG_array_type) 6 \u0026lt;4b\u0026gt; DW_AT_type : \u0026lt;0x43\u0026gt; 7 \u0026lt;4f\u0026gt; DW_AT_sibling : \u0026lt;0x60\u0026gt; 8 \u0026lt;2\u0026gt;\u0026lt;53\u0026gt;: Abbrev Number: 5 (DW_TAG_subrange_type) 9 \u0026lt;54\u0026gt; DW_AT_type : \u0026lt;0x60\u0026gt; 10 \u0026lt;58\u0026gt; DW_AT_upper_bound : 2 11 \u0026lt;2\u0026gt;\u0026lt;59\u0026gt;: Abbrev Number: 5 (DW_TAG_subrange_type) 12 \u0026lt;5a\u0026gt; DW_AT_type : \u0026lt;0x60\u0026gt; 13 \u0026lt;5e\u0026gt; DW_AT_upper_bound : 4 14 \u0026lt;2\u0026gt;\u0026lt;5f\u0026gt;: Abbrev Number: 0 ","date":"2023-05-09T16:51:49+08:00","permalink":"https://wangloo.github.io/posts/c/dwarf/1_basetype/","section":"posts","tags":["debug"],"title":"Dwarf-数据类型: basetype"},{"categories":null,"contents":"Dwarf 把源文件中每个可描述的模块（例如函数，变量，结构体的声明等）描述为一个 DIE (Debugging Information Entry)，所以每个源文件可以描述为若干 DIE 的组合。\n每个 DIE 由一个 tag 和若干 attribute-val 键值对构成:\n tag: 描述此 DIE 的类型 attribute-val: 描述此 DIE 的一些细节属性，项目根据 DIE 的类型不同而有差别  各个 DIE 之间会相互联系，一个 DIE 可能含有 parent，若干的 child 和 sibling， 它们之间组成树的结构。\n查看一个 ELF 的所有 DIE ELF 文件中的所有 DIE 存储在.debug_info section 中，通过 GNU utils 中的objdump工具 可以解析为可阅读的结构:\n1objdump --dwarf=info \u0026lt;file\u0026gt; 若我们有一个 demo.c 如下:\n1void func(void) { 2 int var_local; 3} 编译为可执行文件后， 执行上述的objdump命令， 可以得到如下的输出（节选）：\n1 \u0026lt;1\u0026gt;\u0026lt;68\u0026gt;: Abbrev Number: 5 (DW_TAG_subprogram) 2 \u0026lt;69\u0026gt; DW_AT_external : 1 3 \u0026lt;69\u0026gt; DW_AT_name : (indirect string, offset: 0x32): func 4 \u0026lt;6d\u0026gt; DW_AT_decl_file : 1 5 \u0026lt;6e\u0026gt; DW_AT_decl_line : 3 6 \u0026lt;6f\u0026gt; DW_AT_decl_column : 6 7 \u0026lt;70\u0026gt; DW_AT_prototyped : 1 8 \u0026lt;70\u0026gt; DW_AT_low_pc : 0x1129 9 \u0026lt;78\u0026gt; DW_AT_high_pc : 0xb 10 \u0026lt;80\u0026gt; DW_AT_frame_base : 1 byte block: 9c (DW_OP_call_frame_cfa) 11 \u0026lt;82\u0026gt; DW_AT_GNU_all_call_sites: 1 12 \u0026lt;2\u0026gt;\u0026lt;82\u0026gt;: Abbrev Number: 6 (DW_TAG_variable) 13 \u0026lt;83\u0026gt; DW_AT_name : (indirect string, offset: 0x28): var_local 14 \u0026lt;87\u0026gt; DW_AT_decl_file : 1 15 \u0026lt;88\u0026gt; DW_AT_decl_line : 4 16 \u0026lt;89\u0026gt; DW_AT_decl_column : 9 17 \u0026lt;8a\u0026gt; DW_AT_type : \u0026lt;0x43\u0026gt; 上述例子中节选了两个 DIE，分别是函数func()和局部变量var_local, 可以看到它们的 tag 是不同的，且都具有一系列属性。\n并且，值得注意的是，这两个 DIE 的关系可以从首列\u0026lt;\u0026gt;中的数字得知，数字代表 DIE 构成树的 深度，此例子中\u0026lt;1\u0026gt;下面紧靠的\u0026lt;2\u0026gt;就表示\u0026lt;2\u0026gt;是\u0026lt;1\u0026gt;的 child。理论上也是如此，因为局部变量 是属于对应的函数体的。\n小结 之后的章节打算介绍 Dwarf 是如何描述源文件中的不同对象的(函数,变量,数据类型等)\n","date":"2023-05-09T15:51:49+08:00","permalink":"https://wangloo.github.io/posts/c/dwarf/0_basic/","section":"posts","tags":["debug"],"title":"Dwarf: 基础"},{"categories":null,"contents":"内存对齐为何被需要 架构规定了数据类型大小的同时，也规定了对这些类型的变量合法访问的对齐要求。 也就是说，变量不能随便的放在内存的任意位置，起始地址必须满足特定的对齐要求， 对不满足要求的变量强行访问就叫做非对齐访问， 非对齐访问通常会触发异常。\n一般数据类型的对齐要求 对于一般的数据类型，比如 int, long, char 这些，要求其变量地址对齐到自身大小， 比如 ARM64 中，int 变量的地址必须对齐到 4 字节，long 变量地址必须对齐到 8 字节等等。\n那么对于*(int *)0x1001 = 1234;, 这类的内存访问就叫非对齐的内存访问。\n 即 （变量 addr % 变量 size) ！= 0, 就称为非对齐内存访问。\n 结构体的对齐要求 上面说的还都是一般的数据类型，对于结构体这种复杂的类型，对齐的要求也复杂些。\n 首先是结构体成员，每个成员都必须满足其自身的对齐要求 然后是结构体变量自身的起始地址的对齐要求是其所有成员的最大对齐要求。  然而两个要求均满足有时候根本不可能，比如一个结构体声明为:\n1struct foo { 2 char mem1; 3 int mem2; 4 short mem3; 5}; 不可能同时做到 foo 变量和其成员 mem2 同时满足对齐到 4 字节，所以编译器会依据 上面的两条要求在成员之间添加 padding。\n除了变量中间添加 padding 外，在末尾也会添加，使得结构体数组容易满足对齐需求。\n最后 foo 变量在内存中的样子可能是:\n1struct foo { 2 char mem1; 3 char _pad1[3]; // 保证结构体和成员均对齐正确 4 int mem2; 5 short mem3; 6 char _pad2[2]; // 保证【结构体数组】对齐正确 7};  若结构体的成员还是一个结构体，嵌套操作就可以了，编译器可以 handle。\n  对于结构体的定义来说，若不想添加 padding，可以使用__attribute((packed)) 来声明。 常用于一些数据包的声明，除非你清楚自己为什么要这么做，要不别用。\n 如何做到内存对齐 上面一节说明了各个类型的变量对于内存对齐的需求，只要是各个类型变量的地址满足要求了， 对所有变量的访问也就 OK 了。那么如何保证每个变量地址都满足需求呢？\n对于静态分配的变量，即在编译链接时期就能确定地址，由编译器完成这项工作。编译器保证 分配给这些变量的地址是满足对齐要求的，这个完全不用担心。\n对于运行时动态分配的变量，例如malloc()接口返回的，其实 malloc 本身不知道要申请 空间的对齐规则，因为它只接受一个 size 作为参数。 所以一般来说，为了保证满足所有的 对齐要求，malloc() 返回的地址总是满足最大的对齐请求，即指针的大小 8 字节。\n malloc() 的实际效果与运行库的实现有关，并不是规定死的。不过我还没有见过不是 按照最大对齐要求分配的实现方法:)\n AArch64 对非对齐访问的支持 非对齐访问的结果是架构定义的， 不同的架构可能造成的结果不同：\n 架构可能支持非对齐访问，成功读取数据 架构不支持非对齐访问，产生异常  AArch64 架构支持 16、32、64 和 128 位的非对齐访问，但是有几个前提条件:\n 关闭系统的对齐检查: SCTLR_ELx.A bit 来控制 exclusive load/store 和 load-acuqire/store-release 两类指令必须是对齐访问的 。这就表示构建信号量和其他锁机制时必须是对齐访问的 非对齐访问仅“普通内存”可用，\u0026quot;Device memory\u0026ldquo;必须是对齐访问的   AArch64 非对齐访问的原理是分解为多次的访存，所以不能保证原子性，且性能是较差的。\n  虽然 AArch64 支持非对齐访问， 但编译器默认还是会生成满足对齐要求的代码。\n ","date":"2023-05-08T17:19:44+08:00","permalink":"https://wangloo.github.io/posts/c/alignment/","section":"posts","tags":["arm64","c","Operating System"],"title":"C语言的内存对齐"},{"categories":null,"contents":"当进程被创建时，就预留了一块特殊的线性区，其开始地址和结束地址单独保存在 mm_struct.start_brk和mm_strcut.brk成员中，并不由vm_area_struct 链接，这块特殊的线性区就叫堆。\n进程使用的malloc()和free()等相关 API 都是操纵的堆空间。\n修改堆空间的接口 对用户态进程来说，提供brk()系统调用来修改自身的堆空间。\nbrk(): 参数addr, 效果是修改mm_struct.brk到 addr，即修改一个堆的结束地址。\nbrk() 系统调用的实现，在内核态是调用do_mmap()扩充堆，或者do_unmap()缩小堆。 并且移动mm_struct.brk的值而已，这是 brk()的实现。\n 用户态进程还有一个接口: sbrk(), 参数是字节，代表扩充的字节数。 其下层还是调用的 brk()。\n malloc()的实现 进程刚创建时，堆空间的大小为 0， 即bkr==start_brk。\n调用malloc()，即对堆空间扩充，上面介绍了修改堆空间的接口， 所以我们可以使用brk()来实现malloc().\n对于进程本身来说，只能通过brk()简单的增加/减少堆的总大小，这样做的效率是比较低的。 比如连续执行了三次malloc(), 如果要将中间的地址 free 掉，其实是无法实现的。\n而且这种最简单的情况下，每次malloc()都要使用brk()系统调用，效率也是很低的。\n所以，通常在 C 库则一层，即malloc()和brk()之间，会有一层对堆内存的管理， 包含碎片回收，内存池等算法来避免频繁的使用系统调用。\n","date":"2023-05-08T10:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/addrspace/heap/","section":"posts","tags":["Operating System"],"title":"Linux 进程地址空间 堆的管理"},{"categories":null,"contents":"当前存在的问题 未启用写时复制时，fork()创建子进程地址空间的流程如下:\n 动态申请子进程的页表 动态申请子进程的物理页面，大小和父进程的相同 创建父进程虚拟地址-新物理页的映射到子进程页表 memcpy()将父进程所有页面拷贝到子进程地址空间下  这样做有什么问题呢？ 在fork()的常规调用环境下，fork()之后 接的一般是exec()类函数，即载入一个新的可执行文件，继续用父进程 的情况不多。\n这样的话，上述过程中memcpy()父进程的页面就是多余的，而且如果 父进程比较大，会非常耗时。\n写时复制的优化 执行 fork() 时，不给子进程分配新的物理页，而是将父进程的页表项 完全的拷贝到子进程中，结果就是父子进程的虚拟地址指向同一个物理地址。\n换句话说，这样做就不需要memcpy()父进程所有的页面，仅仅是memcpy()一份 父进程的页表，给子进程用。\n 那么是否连新页表都不申请，直接用父进程的页表？\n显然是不行的，因为本质上父子进程拥有不同的地址空间， 最后都要分隔开（无论是否执行exec()），所以没必要 推迟页表的申请，本身不怎么耗时。\n但是创建线程时，确实使用同一张页表。\n 当然，仅设计到这步是不行的，因为按理来说父子进程是独立的，对子进程的 修改不应该影响父进程的地址空间。\n所有，在 copy 完页表后，会将父子进程的所有地址空间（实际是页表项）设置 为只读属性，当父/子进程尝试修改地址空间时，触发异常，配合特定的 异常处理机制，为其创建一个新的屋里也，拷贝原来的+执行修改。\n下图是对上述情况的描述，仅给出一个页面的示例，可以推广到整个地址空间：\n1 VMA VMA 2 ┌───────┐ │ ┌───────┐ 3Parent │ │ │ Parent │ │ 4 │ │ │ │ │ 5 ├───────┤ │ ├───────┤ 6 │ ├────┐ │ │ ├────┐ 7 ├───────┤ │ PMA Write │ ├───────┤ │ PMA 8 │ │ │ ┌───────┐ ────┼───► │ │ │ ┌───────┐ 9 │ │ │ │ │ │ │ │ │ │ │ 10 │ │ │ │ │ │ │ │ │ │ │ 11 └───────┘ │ ├───────┤ │ └───────┘ │ ├───────┤ 12 ├────►│ │ Read │ └────►│ │ RW 13 ┌───────┐ │ ├───────┤ only │ ┌───────┐ ├───────┤ 14Child │ │ │ │ │ │ Child │ │ │ │ 15 │ │ │ │ │ │ │ │ ├───────┤ 16 ├───────┤ │ │ │ │ ├───────┤ ┌─►│ │ RW 17 │ ├────┘ └───────┘ │ │ ├───────┘ ├───────┤ 18 ├───────┤ │ ├───────┤ │ │ 19 │ │ │ │ │ └───────┘ 20 │ │ │ │ │ 21 │ │ │ │ │ 22 └───────┘ │ └───────┘ 23 │ 这样就完美了吗 实际上不是的，拷贝父进程的页表和vm_area_struct就不占内存了吗？\n当页表是稀疏的，vm_area_struct的数量过多时，其本身的数据结构 就会占用很大的空间。\n就 AArch64 来说，针对页表过大的问题，提供了 2M 和 1G 的巨型页(Huge Page) 可供选择，能在申请大而稀疏的页面时显著的减少页表的大小，同时也增加了 TLB 的 命中率，因为同样大小的内存大页只需要一个 TLB 表项即可。\n然而，还有一种情况更加严重，若fork()后父进程写了地址空间的内容， 如上所说就要拷贝这些物理页面，此时如果写的页面过多可能发生fork()到exec() 那一段间隔时间里的物理内存占用极高。虽然这种情况极少发生，前提必须是内存 分配稀疏+父进程修改的内存也是稀疏的，但是并不能完全忽略这种情况。\n当然，这个问题不能归根于 COW，而是fork()带来的，fork()应该提供参数 给那些子进程立马调用exec()的场景，就不用拷贝父进程的这些数据结构了。\n","date":"2023-05-08T09:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/addrspace/cow/","section":"posts","tags":["Operating System"],"title":"Linux 进程地址空间 写时复制"},{"categories":null,"contents":"何为进程地址空间? 进程地址空间由允许进程使用的若干线性地址区域(也称\u0026quot;虚拟内存区域\u0026quot;)构成。\n每个线性区域由起始地址、长度和属性来描述。\n在进程刚创建时，其地址空间仅包含 3 个线性区，分别是：代码段、数据段和堆区，其中 堆区的初始大小为 0。\n 栈区虽然也属于进程使用的内存区域，但这个区域对用户是透明的，所以我们一般将其 归于内核管理，并非进程本身。\n 线性区增加的典型情况:\n 使用mmap()为一个文件映射内存空间 创建一个 IPC 共享线性区与其他进程协作 调用malloc()扩张自己的堆区  Linux 描述地址空间的数据结构 在进程的 tcb 中，描述地址空间相关的结构都保存在成员mm中，其类型为struct mm_struct, 其中重要的成员有：\n mmap(struct vm_area_struct*): 指向所有线性区的链表头 mm_rb(struct rb_root): 指向所有线性区对象红黑树的根 pgd(pgd_t *): 指向进程的页表 mmlist(struct list_head): 指向下一个地址空间描述符(所有进程的地址空间描述符 被链接起来)  Linux 描述线性区的数据结构 用struct vm_area_struct描述一个线性去，其中重要的成员有:\n vm_mm(struct mm_struct *): 指向所属的地址空间描述符 vm_start(unsigned long): 此线性区的开始 vm_end(unsigned long): 下一个线性区的开始(此线性区结束地址+1） vm_next(struct vm_area_struct *): 指向进程线性区的 next vm_rb(struct rb_node): 此线性区对应红黑树中的节点  此线性区的大小就可以表示为: vm_end - vm_start.\n进程地址空间所有线性区的组织 进程拥有的所有线性区通过单链表串联（按地址排序），第一个区在mm_struct-\u0026gt;mmap, 下一次 通过vm_area_struct-\u0026gt;vm_next找到，依次类推。并且，mmstruct-\u0026gt;map_count成员 记录了进程所有线性区的数量。\n红黑树优化查找 正常来说，想要查找某个地址是否存在于进程的地址空间，遍历上述链表的效率是 O(n).\n因此，Linux2.6 引入红黑树来优化查找速度， 所有线性区同时组织成一个红黑树， 首部通过mm_struct.mm_rb指向。 然后每个线性区的vm_area_struct.vm_rb 存储节点的颜色和双亲信息。\n现在，当需要插入/删除一个线性区描述符时，用红黑树查找前后元素，再操作链表进行插入。\n分配一个线性区 接口是do_mmap(), 参数为:\n file, offset; 如果有文件映射 addr, len prot; 该线性区的权限  步骤大致包含:\n 用红黑树确定新线性区的前后， 对应find_vma_prepare() slab 分配一个struct vma_area_struct，并初始化 操作链表插入，对应vma_link()  释放一个线性区 接口是do_munmap()\n步骤大致包含:\n 红黑树确定要删除线性区的位置，以及做分割（必要时） 调用detach_vmas_to_unmapped()将其从链表中删除 unmap_region()删除页表项 释放 vma_area_struct 的空间  ","date":"2023-05-07T14:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/addrspace/addrspace/","section":"posts","tags":["Operating System"],"title":"Linux 进程地址空间 概述"},{"categories":null,"contents":"信号是内核通知用户态进程的一种方式，也可用于用户进程间相互通知。\n我更愿称其为通知而不是通信，因为目标进程只能知道信号的 ID，发送方不能 附带更多的信息。\n为什么要引入信号? 使用户态进程能够知道系统中某些事件发生了。\n例如，系统定时器时间到会产生SIGALRM 信号，用户态程序可以捕获此信号做一些事。\n当然有些信号的产生可能不会“轮到”用户态感知，比如SIGKILL信号，由 内核直接将进程给杀死。 但无论怎么说，都是一种提醒该进程某件事发生了， 你该做点什么了的方式。\n信号的两个阶段 信号的生命周期可分为两个阶段:\n 信号生成 信号被处理  下面会详细介绍两个阶段的实现原理，但总体上来说， 信号生成即更新目标进程的数据结构，代表某个信号产生了。\n 注意：信号可以发送给处理任何状态的进程，发送给非运行状态的信号由内核保存 知道进程恢复运行状态。\n而且，目标进程只能同时有一个同种类型的信号处于挂起状态，也就是说，如果 上一个同种信号没有被处理，那么之后到来的同类信号会被忽略。\n 信号被处理可能有三种不同的方式: 忽略、执行默认行为或者调用自定义的 handler。\n信号相关的数据结构 (1) 一个信号可能同时存在多个不同类信号处于挂起状态，所以需要队列来记录它们。 实际上需要两个: 进程组共享和进程私有的挂起队列。 因为某些信号是发送给整个进程组的，比如kill()，而一些是指定某个进程的， 比如tkill().\n(2) 另外，tcb 中还需要记录所有信号的处理函数，缺省的和自定义。\n 所有的数据结构都记录在进程的 tcb 中。\n 信号的产生过程 信号可能来自内核或者其他进程，后者是通过系统调用的形式，故最终都会 转化为内核函数，操作目标进程的数据结构来实现信号发送。\n详细来说就是项目标进程的挂起队列中插入一个项。\n信号的处理过程 信号的整个处理过程包括：内核检查进程上是否有挂起的信号，若有则执行相应操作(忽略、缺省、自定义)。 以上描述对应内核函数do_signal().\n 注意： 这个检查过程仅发生在目标进程将返回用户态时。\n 有一个问题是，自定义的信号处理函数是在用户态的, 而do_signal()是发生在 内核态，所以内核要做一些特殊的操作：\n 创建一个临时的用户栈，不能破坏保存的原来用户态环境 ELR(返回地址) = 自定义处理程序，和其他的用户态环境构建 返回用户态，CPU 会执行处理函数 执行完毕后，通过之前对用户栈的特殊构建，使得程序接下来会运行一个 syscall (sys_sigreturn), 返回内核态 如上述操作检查完所有挂起的信号 当所有信号都被处理完成后，则恢复用户进程的原有环境，继续执行  ","date":"2023-05-05T20:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/signal/","section":"posts","tags":["Operating System"],"title":"OS信号 概述"},{"categories":null,"contents":"操作系统内核为何需要同步互斥机制 内核代码存在临界区，例如某个对内存区域的引用计数操作，或者对 调度队列的修改操作。\n操作系统 必须保证当一个进程（内核进程）在临界区时不会有其他人（或者自己， 当被中断时）再去操作临界资源。\n对于单 CPU 系统来说，保证上述行为的方式很简单: 关中断+关内核抢占\n 关中断能够保证，不会发生当一个内核进程正在操作调度队列时，发生中断 ，恰好中断服务函数也会访问调度队列。 关内核抢占能够保证，不会发生当一个内核进程正在操作调度队列时，发生 中断，中断返回时切换到了别的进程，这个进程的内核态也去操作了调度队列。  多 CPU 情况下，问题就变得负责，就需要配合各种同步互斥机制来实现上述行为要求。\n常见的同步互斥机制 per-cpu 变量  优点：多 CPU 之间互不干扰 缺点：  要求逻辑独立， 极少数临界资源可以实现为 per-CPU 形式 开内核抢占时仍有危险，因为不同进程可能在一个 CPU 上， 使用同一个 per-cpu 变量     per-cpu 变量通常被安排在不同的 cache line，避免 cache 的频繁刷新\n 原子操作 解决多个 CPU 同时修改一个内存值时出现覆盖的问题，当然，单 CPU 没必要用原子操作。\n使用原子操作能够保证: 同时执行读操作总会有一个 CPU 先占据总线，此时将总线上锁，其他 CPU 的读写只能等待占领的 CPU 写入彻底完成后。\n AArch64 实现原子操作\n 屏障 仅使用屏障不能直接保证同步，但是需要同步互斥机制都要用到屏障。 比如实现原子操作需要ldrx和strx组合（虽然有新的 CAS 指令, 暂不考虑） ，但 ARM 架构中编译器会 reorder 指令，CPU 会乱序执行。如果 strx在ldrx 之前执行了， 那么原子操作就必然不能实现。\n架构支持的各类屏障用于解决这些问题。\n优化屏障 优化屏障是指在使用内敛汇编时的，volatile和\u0026quot;memory\u0026quot;关键字，如下示例:\n1asm volatile(\u0026#34;\u0026#34;:::\u0026#34;memory\u0026#34;);  volatile 向编译器说明禁止内敛的语句与其他语句 reorder。但不能保证内部 reorder， 那是下面内存屏障的任务 \u0026quot;memory\u0026quot; 向编译器说明对于所有内存访问操作，不能使用 asm 之前预加载到寄存器中的值 ，而必须在 asm 内部重新加载。保证其内部访问内存值具有可见性和正确性。  内存屏障 类似于防火墙，保证：屏障之后的指令开始执行前，屏障之前的指令都已执行完毕！\n在 ARMv8 架构中，还将内存屏障进行细分:\n ISB: 之后的指令重新 fetch, 常用于例如权限修改后，某些寄存器的读取指令就 可能是非法的 DMB: 防止数据相关的指令 reorder 越过 barrier 先执行 DSB: DMB 的升级版，不只是数据相关指令，而是防止任何指令 reorder 越过 barrier 先执行  加锁 进入临界区时，加锁。 常使用的锁包括：\n 自旋锁 读写锁 顺序锁 RCU  信号量 与锁类似且相对应:\n 二值信号量 - 自旋锁 读写信号量 - 读写锁 \u0026hellip;  区别是：进程若获取不到信号量，不会死等，而是被睡眠。\n如何选择合适的同步互斥机制 (1) 避免使用自旋锁: 获取不到锁的 CPU 会一直死等，浪费 CPU 资源\n(2) 若临界区仅仅是一个共享的整数变量操作，那么用原子操作即可完成，不需要复杂的锁。 例如各类数据结构的引用计数通常声明为 atomic_t。\n","date":"2023-05-04T20:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/sync/","section":"posts","tags":["Operating System"],"title":"OS内核同步互斥机制 概述"},{"categories":null,"contents":"tracepoint 是 Linux trace system 中 data source 之一， 其 trace 的对象是 kernel，属于一种静态的插桩方法。\n 添加和删除需要手动修改内核源码 可以向上提供接口，可以通过 frontend 来开启或者关闭，也可以自定义数据处理方式 在 disable 时， 仅有一次 if 判断的损耗，所以效率还算高。但缺点是不够灵活。  tracepoint 的组成 看其源码struct tracepoint就能知道它的组成结构：\n1struct tracepoint { 2 const char *name; 3#define TP_STATE_DISABLE 0 4#define TP_STATE_ENABLE 1 5 int state; 6 7 // 并非用于注册hook的函数，而是注册hook时的hook 8 int (*reghook)(void); 9 void (*unreghook)(void); 10 11 // 在tracepoint触发时将调用的hook 12 struct tracepoint_hook *hooks; 13};  name: 是该 tracepoint 的名称 state: 用于控制其开关状态 hooks: 是一系列的函数指针，当 tracepoint hit 时，这些函数会被依次调用 reghook/unreghook: 在注册/注销 hook 时将被调用，可以用来输出一些提示信息  为了提供对 tracepoint 操作的接口，定义一个 tracepoint 时，会同时定义一系列功能函数, 包括：\n 放在内核代码之中的插桩函数；其被调用说明 tracepoint hit， 如果 enable 状态， 则依次执行其 hook 用于注册 hook 的接口；为该 tracepoint 添加新的 hook 注销某个 hook 的接口；  tracepoint 工作原理 类似于一般的日志记录函数， 在合适的位置放置trace_##event()作为“插桩”，运行到 此处代表该做一些事了，至于做什么事不是 tracepoint 该管的。它只能负责提供给你一些接口 ，让你能把“做事”的函数与 tracepoint 联系起来，到时候触发时调用它们。\n这就是上面说的，tracepoint 仅负责 data source 这一部分。\n小结 下一节将介绍如何 Linux trace system 中的数据记录组件，毕竟每次触发都输出到控制台还是 太乱了，而且不是 trace 这个系统的工作内容（log 系统应该是干这个的）。\n","date":"2023-04-23T23:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/trace/tracepoint/","section":"posts","tags":["linux","Operating System","trace"],"title":"Linux追踪系统学习(1): tracepoint"},{"categories":null,"contents":"从进入 IRQ/FIQ 中断向量开始，中断处理的完整流程:\n 保存上下文 切换中断栈，为进入“真正的”中断服务程序做准备 执行真正的中断服务程序 恢复之前的上下文  “真正的”中断服务程序 “真正的”意为不算那些对于所有异常、中断来说都相同的“套话” ，只讨论对于中断特有的行为。\n承认一个中断 真正的中断服务程序从接受 CPU Interface 传来的中断 开始算起，这一步的实现通过读取ICC_IAR1_EL1, 返回当前 中断的 INTID。\n拿到 INTID 后，就根据不同的 ID 调用各自对应场景下的服务函数， 比如若 INTID 是对应与时钟中断，那么此步需要清楚状态寄存器、 重新开启时钟定时器。\n标记中断处理完毕 做完相干的事情后，需要将该中断标记为已完成，方便后面的中断进来， 也就是上一节说的优先级下降和中断失效过程。\nGICv3 支持将这两步合为一次操作，实际我们也是这样做的，通过写入 ICC_EOI1_EL1寄存器来完成标记处理完成。此中断的状态也就从 active-\u0026gt;inactive.\n 中断服务程序中，承认中断和标记完成两步操作应该是用 while 循环 包裹起来的。\n反复的读取 IAR、标记中断已完成\u0026hellip; 如果此时该 CPU 上已经没有 中断待处理了，读取 IAR 会返回特殊 INTID: 1023\n 中断的上下部机制 中断服务函数的停留时间应该越短越好，否则影响其他任务占用 CPU，这是老生常谈的。\n以上观点存在的原因是：中断服务函数中是关闭中断的，CPU 只有串行的处理完当前 中断后， 才能继续做下一件事情，即便是高优先级任务也得等待，因为时钟中断被关闭！\n所以 Linux 在 2.6 引入了中断的上下部机制，将整个中断服务函数拆分为上部和下部:\n 上部：那些不能被打断的步骤，比如保存上下文，承认和标记中断完成等 下部：宽松的管理方式，执行过程就算被打断也没关系，指的就是上面说的对应各自中断 应用场景下的服务函数，比如一个按键触发代表的实际行为  ARMv8 如何支持中断上下部 ARMv8 中，进入异常向量是自动关中断的，可执行msr DAIFClr, #imm来手动开启。\n所以说，直到手动开中断之前的所有操作都属于中断的上部。\n那么，应该在何时开启中断呢？我认为分割后的正确中断处理流程应该是：\n 承认一个中断 根据 INTID 标记其应该做的行为，注意只是标记 标记该中断完成 待该 CPU 上的所有中断都完成后，开中断 遍历检查所有标记，如果有待完成的任务在此时执行  上面说的标记和执行过程可以用许多方式实现，包括 softirq, tasklet, workqueue 等， 都属于实现中断上下部机制的实现。\nsoftIRQ softirq 定义了一些中断事件和处理函数，在中断的上半部中，如果 INTID 属于定义的软中断 之一， 则添加标志其处理函数需要被执行，只是标志，并不实际执行。\n当中断服务程序退出之前，会遍历软中断列表中的状态，如果有需要处理的，则调用注册的处理函数。\n注意，软中断处理函数的执行是在中断上下文中，用户进程只能等待中断完成才能有机会被调用， 所以软中断的一个问题是， 如果需要执行的处理函数过多，会导致一般线程长时间不能被调度。\n同样地，因为处理函数的执行在中断上下文，所以也不能执行可能导致进程睡眠的操作， 例如申请锁，可能导致优先级反转。\ntasklet workqueue ","date":"2023-04-13T23:51:49+08:00","permalink":"https://wangloo.github.io/posts/armv8/gicv3/3/","section":"posts","tags":["armv8"],"title":"ARMv8 中断管理(3): 中断服务程序"},{"categories":null,"contents":"抢占的含义 抢占指的是强制使一个任务让出 CPU 给其他任务。\n抢占是调度器做的，每次执行schedule()就可能发生一次抢占，所以 抢占发生的地点是内核，也就是schedule()的执行环境。\n用户抢占 与内核抢占相对应的是用户抢占，用户抢占不是指抢占发生的地点，因为 上面说了抢占发生的地点一定是内核。\n所以用户抢占的含义是：抢占的时机是用户态，换句话说就是抢占发生之前， 系统正处于用户态。\n用户抢占的经典场景是时钟中断，用户进程 1 执行的好好地，被时钟中断打断 然后中断返回时执行重调度，选择了新的用户进程 2。其他的可能用户抢占的场景 还有系统调用返回时， 总之是内核返回用户态时都会发生用户抢占。\n内核抢占 启用内核抢占增加了系统中发生抢占的点，即抢占前系统正处于内核。\n当一个进程正处于内核态执行任务时，比如执行mmap()系统调用的任务，在 未开启内核抢占的情况下，中断返回时只可能继续执行当前进程的任务，不会 发生调度。\n当启用内核抢占时，上述情况下若发生中断，系统在退出中断后，即使此时不是 返回用户态，也可以执行schedule()，即可以发生抢占。此之谓内核抢占。\n抢占发生的条件 启用内核抢占之后，其实抢占的过程也不区分用户态和内核态，只要满足条件都会 执行schedule()。\n执行重调度的条件有两个:\n 是否需要重调度? 是否可以重调度?  是否需要重调度也就是何时执行schedule()的问题，大概包含以下的场景:\n 时钟中断 新进程创建 修改进程的 nice 值 中断返回内核态 内核恢复为可抢占(下面会介绍)  然而有一些情况不可以重新调度，比如内核中一些关键的步骤，那些不能被打断的 原子操作。\n在关键步骤之前，需要调用preempt_disable()，此时 linux 会在 tcb 中会改变 preempt_count的值，这个操作不是关闭中断，而是在中断返回时即使有更高优先级的其他进程， 只要该值不符合要求，重调度也不会发生。\n关键步骤执行完，调用preempt_enable()，此时为了去满足关键区域内可能 有新加入的高优先级进程，会调用一次重调度，这也正是上面所说需要重调度的场景之一。\n","date":"2023-04-13T23:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/schedule/kernel_preempt/","section":"posts","tags":["linux","Operating System"],"title":"Linux 内核抢占"},{"categories":null,"contents":"一个中断完整的生命周期大概包括:\n 产生中断 中断分发: by Distributor or Redistributor 中断传递: deliver to CPU Interface 中断激活: pending-\u0026gt;active 优先级下降: priority drop 中断失效: active-\u0026gt;inactive  中断的产生 外设传来中断信号，或者处理器触发 SGI， GIC 此时将该中断标记为pending状态。\n中断的分发 中断生命周期中的重要部分，根据中断的类型不同可能由 Distributor 和 Redistributor 负责分发工作。\n分发器查配置得到此中断的优先级，目的 CPU 等信息。此时可能有多个中断想要发往同一 CPU， 优先级决定先分发哪个中断。将其顺利分发目的 CPU 的 CPU Interface\n中断传递 CPU Interface 做最后一步检查，是否满足优先级屏蔽? 是否符合抢占条件?\n如果条件都满足，给 CPU 一个信号，CPU 准备激活中断\nTODO: 关于running priority 和 highest pending priority的解释\n中断激活 CPU 此时将触发 IRQ/FIQ，执行对应的中断服务程序。\n中断服务程序中需要显式的执行一些操作将中断状态由 pending 置为 active。\n 异常向量（中断处理函数）的详细步骤见下一节\n 优先级下降和中断失效  优先级下降和中断的失效可以配置为同时发生，实际中我们也是这么使用的。\nTODO: 何种情况下需要将其分开？\n 中断服务函数结束后，需要执行一些额外的步骤来使中断失效，便于在该 CPU 上 pending 的其他中断能够进来。\n优先级下降意味着降低抢占的优先级限制，允许 CPU 上等待的其他中断进来。\n然后执行中断失效过程，将其状态由 active-\u0026gt;inactive， 至此中断的整个生命周期结束。\n小结 中断激活到中断失效的整个过程都属于中断服务程序的部分，由开发者显式控制， 将在下一节进行介绍。\n","date":"2023-04-12T23:51:49+08:00","permalink":"https://wangloo.github.io/posts/armv8/gicv3/2/","section":"posts","tags":["armv8"],"title":"ARMv8 中断管理(2): 中断的生命周期"},{"categories":null,"contents":"ARMv8 中断系统的架构 GIC 的输入为许多的中断线，但输出到 CPU 的只有 IRQ 和 FIQ 两种， 所以就要由 GIC 做中断的分发和过滤工作。\n总体来说，整个中断系统架构从底向上可分为三部分:\n 硬件接口；外设的引脚 中断控制器；桥梁，向下提供引脚连接外设，向上连接 CPU 在合适的时间 触发中断信号，充当中断系统的主管 中断处理函数；GIC 将中断信号传递到 CPU 后，CPU 执行中断处理函数  1+-----------+ +-----------+ 2| Process | | Process | 3+---------+-+ ++----------+ 4 | | 5 +-+--------+----+ 6 | | 7 | GIC | 8 | | 9 +-------+-------+ 10 | 11 +-------------+----------+ 12 | Peripheral Device | 13 +------------------------+ 中断控制器 GICv3  GIC 的有许多版本，本文皆以 GIC version3 为例介绍, 简称为 GICv3\n 如上所述，GIC 在中断系统中充当“管家”的作用。如果将 CPU 比作老板， 到来的中断比作约见老板的员工，那么 GIC 就是秘书，统筹安排何人何时 与老板谈话。\nGICv3 的组成大概可分为 3 部分:\n Distributor Redistributor CPU Interface  如果将上面架构图中的 GIC 拆开，大概的结构如下图所示。能够注意到除了 GIC 被细分外，外设中断源也划分为两部分，在下面中断分类中会详细 介绍。\n1+----------------+ +----------------+ 2| Process | | Process | 3+--+----------+--+ +--+----------+--+ 4 | CPU | | CPU | 5 | Interface| | Interface| 6 +----+-----+ +----+-----+ 7 | | 8 +------+-------+ +------+-------+ 9 | Reditributor | | Reditributor +-----+ 10 +----------+---+ +--+-----------+ | 11 | | | 12 +---+-------------+-----+ | 13 | | | 14 | Distributor | | 15 | | | 16 +-----------+-----------+ | 17 | | 18 +---------+--------+ +-------+---------+ 19 |Peripheral Device | |Peripheral Device| 20 | (SPI) | | (PPI) | 21 +------------------+ +-----------------+ Distributor 负责全局中断的分发\nRedistributor Redistributor 是 GICv3 相较于 v2 新引入的部件，在我看来，引入 Redistributor 的 主要原因是: 提高中断相应的效率。 在以前，无论是全局中断还是私有中断都是通过一个 Distributor 分发，如果中断到来的比较频繁，则可能产生延迟。\nRedistributor 就主要负责私有中断的分发，减轻了 Distributor 的负担。\nCPU Interface 物理结构上依附与 CPU，而不是 GIC。主要负责控制中断被 CPU 接收的过程， 即中断状态 pengding , active, inactive 的切换。\n同时， CPU Interface 还负责优先级的过滤，只有符合优先级条件的中断才会被 CPU 响应。 相关的寄存器有ICC_PMR_EL1，ICC_RPR_EL1等\n中断抢占的配置也是由其完成，详见ICC_BPRx_EL1寄存器。\nGICv3 Affinity Rounting GICv3 以前都是用 target-list, 来设置中断到达的目的 CPU，这种方式类似于位图， 以前只有 8bit 来做这个，所以采用 GICv2 的系统最多支持 8 个 CPU。\n而 GICv3 引入了 Affinity value 来支持更多的 CPU，类似于 IP 地址的方法，用 4 个 8bit 来标识。可以写作a.b.c.d\n c: 一般是指某个 cluster d: 转发时会填入 target-list，指定多个 CPU，最多 8 个(下图的形式还没有将d转为targetlist)      所以用 Affinity value 虽然能指定大于 8 个 CPU，但是一次只能发往一个 cluster 内的最多 8CPU。\n GICv3 中断的分类与标识 在使用 GICv3 的系统上，中断被划分为 4 种类型:\n spi: 全局的中断，可以被路由到任意的一个或多个 CPU。一般对应所有 CPU 共用 的外设，例如串口中断。 ppi: 每个 CPU 私有的中断，只能被路由到该 CPU。对应与 CPU 私有的外设中断， 例如 CPU 内部定时器中断。 sgi: CPU 触发的中断，可以被路由到任意 CPU。一般用于核间通信使用。 lpi: message-based interrupts 这里不做介绍.  中断标识: INTID CPU 如何区分当前来的中断是来自哪个外设的中断信号? 答案是通过 INTID，它是 GIC 定义的中断标识符，CPU 通过读取寄存器ICC_IAR1_EL1就能得知当前处理中断的 INTID。\nINTID 按照中断类型分类的, 对照表如下:\n   INTID 中断类型 Note     0-15 SGI 本地的, 不同 CPU 可使用同一中断号代表不同中断   16-31 PPI 本地的   32-1019 SPI 全局的   1020-1023 特殊中断    1056-1119 扩展的 PPI 本地的   4096 – 5119 扩展的 SPI 全局的     扩展中断号的最大值是实现定义的, 可以在GICD_TYPER.IDbits中读取。\n 特殊中断号  特殊中断不需要 end of interrupt or deactivation 过程.\n   1020:\n  1021:\n  1022:\n  1023: 读ICC_IAR1_EL1 返回该值表明当前的 CPU 上没有待处理的中断， 编程时可当做while退出的标志\n  小结 这节主要总结 ARMv8 中断系统的总体架构和 GICv3 的组成结构，下一节将介绍 一个中断的生命周期，即中断的状态转换，以及在此过程中各个组件的作用。\n","date":"2023-04-12T21:51:49+08:00","permalink":"https://wangloo.github.io/posts/armv8/gicv3/1/","section":"posts","tags":["armv8"],"title":"ARMv8 中断管理(1): 架构与GICv3"},{"categories":null,"contents":"有了虚拟内存系统之后，MMU 可以抽象出一些可配置的内存属性。\n例如，配置某个虚拟内存区域为不可执行、不被 cache 等，不可执行的属性 有助于防范攻击，不进入 cache 经常划分给外设 Memory-mapped 区域。\n内存属性和内存类型 首先，我们没法直接设置内存类型，我们能设置的是一些细粒度的内存属性字段， 比如说权限(WRX)、cacheable、shareable 等。\n我们说的内存类型也就是某些有意义的属性字段相互组合，ARM 给出了两种内存类型: 普通内存和设备内存。\n  普通内存会启用架构提供的所有优化技术，例如合并访存、乱序执行等。所以 普通内存有最高的性能，但同时不是那么的“安全”，需要底层人员手动使用 内存屏障等手段保证某些情况下的顺序性要求。\n  设备内存，顾名思义，常映射到外设的 Memory-mapped 区域。对于设备来说， 那些提高性能的技术会造成一些问题，例如某些寄存器的配置必须按照顺序， 这时就不能使用乱序执行。设备内存就牺牲了性能，优先保证正确性。\n  配置内存类型也是通过页表项中的其中一个属性字段: AttrIndx[2:0], 它与系统寄存器MAIR_EL1配合实现。\n具体表现为: mair_el1寄存器被划分为 8 个字段，我们为每个字段写入 不同的值可代表不同的内存类型和一些配套属性，具体的真值表可以参见 mair_el1寄存器的描述。\n mair_el1中内存类型配套属性只是属性的一部分，是和设备类型绑定的那部分。\n cacheable\u0026amp;shareable 傻傻分不清 先说 cacheable，一段内存被设置为 non-cacheable 属性说明不会进入 cache， inner-cacheable 是实现定义的，可能指进 L1 cache/L2 cache， outer-cacheable 说明会进入 L3 cache。\n要注意，只有普通内存才支持配置是否进入 cache，所有的设备内存需要 non-cacheable。\n 内存支持配置为是否被 cacheable，这在mair_el1的字段中配置。\n shareable 说的是一块内存的外部可见性，外部不可见并不是真的看不到，只是说不保证值的正确性。\nshareable 属性和 cacheable 其实是有关联的，他们俩比如配合使用，不能随便设置:\n 如果一块内存是 cacheable 的，则需要硬件提供 cache 的一致性维护机制。 如果不能保证 cache 的一致性，想要启用 shareable 就必须是 non-cacheable 对于 non-cacheable 的内存，一定是 shareable 的， 不需要配置。因为此时对数据的修改直接操作内存，读取操作亦是如此，一定 是外部可见的  如何设置内存属性  相关内容可以在 ARMv8 arm 手册 D5.3.3 Attuibute fields in stage 1 VMSAv8-64 Block and Page descriptors 中找到参考\n 对于每一个表示内存块(block)的页表项，都有两个属性字段: lower attr 和 upper attr.\n以下任何类型或者属性的设置都是通过这两个字段完成的。\n","date":"2023-04-12T08:01:33+08:00","permalink":"https://wangloo.github.io/posts/armv8/memory_attr/","section":"posts","tags":["armv8"],"title":"AArch64 内存属性与内存类型"},{"categories":null,"contents":"枚举类型的优势 枚举类型完全可被宏定义替代，类如\n1enum Furniture { 2\tDOOR = 1, 3\tDESK, 4\tLOCK, 5} 与下面的代码等效\n1#define DOOR 1 2#define DESK 2 3#define LOCK 3 那么我们如何在两种设计方法中选择呢？在我看来某些情况下使用 enum 会有以下优势：\n 提高代码键入效率；仅适用于所需变量的值是连续的整数，就像上面的情况，可以只给第一个 DOOR 赋值，其余的值累加。如果首个变量的值要求是 0，甚至每一个都无需显式赋值 提高代码的可维护性；可以划定范围，编译器也会检查类型是否正确，偶尔会有用 提高代码的可读性；例如 DOOR, DESK, LOCK\u0026hellip; 都属于家具，均定义在 Furniture 中  枚举类型所占的大小 枚举类型所占内存的大小，即枚举变量的大小。\n由于枚举变量的赋值，一次只能存放枚举结构中的某个常数。所以 枚举变量的大小，实质是常数所占内存空间的大小（常数为 int 类型，当前主流的编译器中一般是 32 位机器和 64 位机器中 int 型都是 4 个字节），枚举类型所占内存大小也是这样。\n所以默认情况下，无论枚举变量的值是多少，都是占用 4 个字节。即执行：\n1printf(\u0026#34;sizeof(enum Furniture) = %d\\n\u0026#34;, sizeof(enum Furniture)); 输入的结果是 4。\n编译选项：-fshort-enums GCC 下关于这个编译选项的介绍：\n -fshort-enums Allocate to an enum type only as many bytes as it needs for the declared range of possible values. Specifically, the enum type is equivalent to the smallest integer type that has enough room. Warning: the -fshort-enums switch causes GCC to generate code that is not binary compatible with code generated without that switch. Use it to conform to a non-default application binary interface.\n 意思是说使用-fshort-enums 后，对改枚举类型所占空间的分配就会按照实际变量的占用空间，而非总是 4 字节。\n启用该选项之后，再打印它的 size 就会是 1，因为用 1 个字节就能表示所有枚举变量的值（DOOR=1，DESK=2，LOCK=3）.\n这个“1”不再是固定的，根据其中枚举变量值的不同，动态调整enum Furniture的大小。\n1enum Furniture { 2\tDOOR = 256, 3\tDESK, 4\tLOCK, 5} 再打印它的 size，结果为 2。因为值 256 无法用 1 个字节存下。\nenum 潜在的可移植性问题 看似好像启用该选项会节约一定的内存空间，是的。但它也有一定的缺点，其一就是可移植性问题。\n例如你编写的应用在编译时没有启用了该“优化”选项，默认采用 4 字节存储枚举变量。而链接的库文件在编译时却使用了“优化”选项，则库内部此枚举类型的大小可能为 1 字节。若此时恰好你有调用某个库 API，将 enum 变量作为参数进行传递，那么就会发生错误。\n为避免不同库和应用程序使用“优化”选项的差异造成潜在的危险，常用的解决方案是强制使 enum 变量占用 4 个字节，无论其是否开启“优化”。实现方式是在 enum 变量末尾添加一个成员 XXXX_END = 0xFFFFF，例如：\n1enum Furniture { 2 DOOR = 1, 3 DESK, 4 LOCK, 5 END = 0xFFFFF, 6} ","date":"2023-03-09T17:18:57+08:00","permalink":"https://wangloo.github.io/posts/c/enum/","section":"posts","tags":["c"],"title":"C语言enum的使用"},{"categories":null,"contents":"函数指针 指针的数组 or 指向数组的指针? 1\u0026gt;\u0026gt; int (*p)[10] p是指针, 指向长度为10的数组. 加括号是为了强调p是一个指针, 区别包含10个指针的array. 2\u0026gt;\u0026gt; int *(p[10]) p是数组, 它的元素类型是int *, 加括号是为了强调p是数组. 3\u0026gt;\u0026gt; int *p[10] 等效于int *(p[10]) 基础架构 1// 函数指针 2\u0026gt;\u0026gt; int (*f)(int) 说明f是一个指向函数的指针, 加括号为了区别返回值为int*的函数 3\u0026gt;\u0026gt; f = function; 函数指针的赋值 4\u0026gt;\u0026gt; (*f)(x) 函数指针指向函数的调用, 可简化为f(x). 但是容易将f误认为是函数. 5 6// 函数指针的数组 7\u0026gt;\u0026gt; int (*(f[10])) (int) f是数组,元素为10个函数指针. 内层括号说明f是数组,外层括号说明元素类型是函数指针 8\u0026gt;\u0026gt; int (*f[10]) (int) 与上面等效. 但外层括号不能省略 9\u0026gt;\u0026gt; f[0] = function() 赋值 10\u0026gt;\u0026gt; (*f[0])() 指向函数的调用, 可简化为f[0]() 11 12// 返回函数指针的函数 13\u0026gt;\u0026gt; void (*signal(int sig, ...))(int); signal是一个函数, 参数有sig.... 它的返回值是一个函数指针, 指向任意返回值为void, 参数为int的函数. typedef帮助理解函数指针 signal()是一个系统调用, 用于告诉系统, 当某种特定\u0026quot;软件中断\u0026quot;发生时调用特定的程序. 它的真正名称应当是: Call that routine when the interrupt comes in.\n看signal()的原型, 非常复杂. 根据上面基础架构的铺垫, 可以看出signal()的返回值是函数指针, 同时它的参数也是一个函数指针. 且这两个函数指针所指向函数的返回值和参数相同.\n1void (*signal(int sig, void(*func)(int)))(int); 可以借用typedef表示通用部分.\n1typedef void (*sighandler_t)(int); 而后signal的声明就是人能看懂的了:\n1sighandler_t signal(int signum, sighandler_t handler); C语言标准 我们在使用C语言编程时很少有人告诉我们C语言各个标准的情况，于是我们在看见一些函数标定支持的C标准（例如仅支持C99及以后），内心不会有什么波澜。\n我们常见这些C标准：K\u0026amp;R C、ANSI C、ISO C、C89、C99、C11、C18。让我们补充点可能很少使用的知识吧。\n什么是K\u0026amp;R C？ 1978年，丹尼斯•里奇（Dennis Ritchie）和布莱恩•柯林汉（Brian ernighan）合作出版了《C程序设计语言》的第一版。书中介绍的C语言标准也被称作“K\u0026amp;R C”。\n最初的C标准与我们现在用的有较大差别，例如它竟然还不支持void类型！\n什么是ANSI C、ISO C、C89、C90标准？ 随着C语言使用得越来越广泛，出现了许多新问题，人们日益强烈地要求对C语言进行标准化。1983年，美国国家标准协会（ANSI）组成了一个委员会，X3J11，为了创立 C 的一套标准。经过漫长而艰苦的过程，该标准于1989年完成，这个版本的语言经常被称作ANSI C，或有时称为C89（为了区别C99）。在1990年，ANSI C标准（带有一些小改动）被美国国家标准协会（ANSI）采纳为ISO/IEC 9899:1990。这个版本有时候称为C90或者ISO C。综上，ANSI C、ISO C、C89、C90其实是同一种标准。\n这一版本的C就更接近我们平常使用的C了，大部分特性都引入了。\n什么是C99标准？ 2000年3月，ANSI 采纳了 ISO/IEC 9899:1999 标准。这个标准通常指C99。\nC99我们最常使用的新特性是：在源代码的中间位置声明变量。\n什么是C11标准？ C11标准是C语言标准的第三版（2011年由ISO/IEC发布），前一个标准版本是C99标准。与C99相比，C11有哪些变化呢？\n11、 对齐处理：alignof(T)返回T的对齐方式，aligned_alloc()以指定字节和对齐方式分配内存，头文件\u0026lt;stdalign.h\u0026gt;定义了这些内容。 22、 _Noreturn：_Noreturn 是个函数修饰符，位置在函数返回类型的前面，声明函数无返回值，有点类似于gcc的__attribute__((noreturn))，后者在声明语句尾部。 33、 _Generic：_Generic支持轻量级范型编程，可以把一组具有不同类型而却有相同功能的函数抽象为一个接口。 44、 _Static_assert()：_Static_assert()，静态断言，在编译时刻进行，断言表达式必须是在编译时期可以计算的表达式，而普通的assert()在运行时刻断言。 55、安全版本的几个函数：gets_s()取代了gets()，原因是后者这个I/O函数的实际缓冲区大小不确定，以至于发生常见的缓冲区溢出攻击，类似的函数还有其它的。 66、 fopen()新模式：fopen()增加了新的创建、打开模式“x”，在文件锁中比较常用。 77、 匿名结构体、联合体。 88、 多线程：头文件\u0026lt;threads.h\u0026gt;定义了创建和管理线程的函数，新的存储类修饰符_Thread_local限定了变量不能在多线程之间共享。 99、 _Atomic类型修饰符和头文件\u0026lt;stdatomic.h\u0026gt;。 1010、改进的Unicode支持和头文件\u0026lt;uchar.h\u0026gt;。 1111、quick_exit()：又一种终止程序的方式，当exit()失败时用以终止程序。 1212、复数宏，浮点数宏。 1313、time.h新增timespec结构体，时间单位为纳秒，原来的timeval结构体时间单位为毫秒。 什么是C18标准？ C18也称C17是于2018年6月发布的 ISO/IEC 9899:2018 的非正式名称，也是目前（截止到2020年6月）为止最新的 C语言编程标准，被用来替代 C11 标准。\nC17 没有引入新的语言特性，只对 C11 进行了补充和修正。\n​\n如何查看自己程序的C标准版本？ 使用宏__STDC_VERSION__可以输出当前使用的C标准版本，是一个长整型：\n1printf(\u0026#34;C std version:%ld\\n\u0026#34;, __STDC_VERSION__); 值与标准的对应关系：\n   标准 宏     C94 _STDC_VERSION_= 199409L   C99 _STDC_VERSION_= 199901L   C11 _STDC_VERSION_= 201112L   C18 _STDC_VERSION_= 201710L    ​\n如何指定按照某个标准执行编译？ 以下的介绍只针对GCC，我没有用过别的编译器。\nGCC中可以添加--std=xxx来指定C标准版本，常用的情况如下：\n1-std=c11 Conform to the ISO 2011 C standard 2-std=c89 Conform to the ISO 1990 C standard 3-std=c90 Conform to the ISO 1990 C standard 4-std=c99 Conform to the ISO 1999 C stand 5 6 7-std=gnu11 Conform to the ISO 2011 C standard with GNU extensions 8-std=gnu89 Conform to the ISO 1990 C standard with GNU extensions 9-std=gnu90 Conform to the ISO 1990 C standard with GNU extensions 10-std=gnu99 Conform to the ISO 1999 C standard with GNU extensions  默认情况下，我电脑上的gcc 5.4.0使用-std-gnu11\n 参考目录 https://blog.csdn.net/zhengnianli/article/details/87387268\nC Dialect Options (Using the GNU Compiler Collection (GCC))\n含糊不清的符号扩展 问题出在哪？ 下面一段代码会输出什么呢？\n1char c = 0xff; 2 3if (c == 0xff) 4 printf(\u0026#34;successful\\n\u0026#34;); 5else 6 printf(\u0026#34;failed\\n\u0026#34;); 答案是取决于不同的编译器设定：\n 当编译器将char识别为signed char时，该判断会失败。因为常数0xff被识别为int类型，所以编译器首先要对c进行符号扩展，判断语句c == 0xff此时等价于(int)c == 0xff。而对于signed char类型是扩展其最高位，即(int)c=0xffffffff，if判断失败。 当编译器将char识别为unsigned char时，判断成功。对于unsigned char类型总是扩展0。   注：gcc可通过添加编译参数 -fsigned-char/ -funsigned-char来指定编译器如何识别char\n 同样的问题也存在与位域(bitfiled)中，详见-fsigned-bitfields/-funsigned-bitfields参数。\n如何避免？ 在使用char类型时，根据情况写清楚unsigned/signed char就ok\n1unsigned char c = 0xff 2 3if (c == 0xff) 4 printf(\u0026#34;successful\\n\u0026#34;); 5else 6 printf(\u0026#34;failed\\n\u0026#34;); 右移和除法 你是否有听说过有符号数不能使用右移操作(\u0026gt;\u0026gt;)来代替除法？ 这篇短文会向你证明它，并尝试向你解释为什么。\nLogical Shift .vs. Arithmetic Shift 若你现在有二进制数x=1110B，对其施加右移操作，请问高位填0还是填1？\n逻辑移位不管造成的影响，总是用0来填充移位操作产生的空缺。但是这样简单的想法在一些情况总会出错。例如若上述x是有符号数，那么简单的填0就会造成错误，起码正负号出错了。\n算数移位支持有符号数的移位操作，在移位后使用符号位进行填充，结合补码的表示方法，就能实现正确的负数移位操作。\n总结来说：在有符号的场景下，使用算数位移；如果你能保证移位操作是无符号的，那么用逻辑位移也无妨.\nx86汇编代码中，shr代表逻辑右移指令，sar代表算数右移指令，我们可以通过以下C代码及其反汇编的结果来更好的理解逻辑移位和算数移位：\n1#include \u0026lt;stdlib.h\u0026gt;2#include \u0026lt;stdio.h\u0026gt;3 4signed int x = -3; 5unsigned int y = 3; 6 7int main() 8{ 9 x \u0026gt;\u0026gt;= 1; 10 y \u0026gt;\u0026gt;= 1; 11 return 0; 12} 1x: 2 .long -3 3y: 4 .long 3 5main: 6 push rbp 7 mov rbp, rsp 8 mov eax, DWORD PTR x[rip] 9 sar eax 10 mov DWORD PTR x[rip], eax 11 mov eax, DWORD PTR y[rip] 12 shr eax 13 mov DWORD PTR y[rip], eax 14 mov eax, 0 15 pop rbp 16 ret https://godbolt.org/z/K4M4Ko4c7\n实践出真知 在我作为一个初级程序员的认知中，/2和\u0026gt;\u0026gt;1是等价的，甚至一起还听说过后者能够优化代码的效率。但是今天我要告诉你， Definitely wrong!\n或许在遥远的古代，我们使用位移操作真的能够对代码进行加速，但是当下编译器已经足够聪明，如果你真的动手反汇编\u0026quot;/2\u0026ldquo;的代码，那么你就会知道编译器已经替你优化为了位移操作。\n更糟糕的是，我们要避免使用移位操作来实现除法或者乘法，不仅仅是因为这两者等价，实际上，他们并不是等价的！并且会造成错误！\n考虑如下的C语言代码：\n1#include \u0026lt;stdlib.h\u0026gt;2#include \u0026lt;stdio.h\u0026gt;3 4signed int x = -3; 5signed int y = -3; 6 7int main() 8{ 9 x \u0026gt;\u0026gt;= 1; 10 y /= 2; 11 return 0; 12} 他们的汇编代码是相同的吗？这里还是拿X86汇编举例：\n1; Following is ‘x \u0026gt;\u0026gt;= 1’ 2mov eax, #-3 ;x 3sar eax 4mov x, eax 5; Following is ‘y/= 2’ 6mov eax, #-3 ;y 7mov edx, eax 8shr edx, 31 9add eax, edx 10sar eax 11mov y, eax 注意：以上的汇编代码省去了一些我认为无关紧要的操作，并不是完全正确的，但是足够表达他们的差别了。\n可以看出，除法比移位多了一步shr edx, 31过程，下面会探讨这个。\n还有一件使你震惊的事件，x, y的值最终是不同的！是的，正是因为那条看似“多余”的shr指令。\n为什么结果不同 首先，我们可以确定的一件事是：编译器真的帮我们将除法操作优化为移位。所以，再也不要说你的代码中使用\u0026gt;\u0026gt;来替代除法是为了增加执行效率了。\n让我们来解释下为什么两者的结果是不同的。\n首先，sar指令在x86指令集中表示算数右移，这个是我们熟悉的，那么-3进行算数右移后的结果就是-2. 意味着\u0026gt;\u0026gt;是向负无穷舍入的.\n那么除法操作又是在干什么呢? 它是将原值加上其符号位.Demo中使用的数据类型是32位int.\n1shr edx, 31 2add eax, edx 这样做必然改变了原值啊，动手算一下就会知道，-3/2的结果为-1. 并且只有负奇数会受影响，对于正数，其符号为0；对于负偶数，其补码的最低位必为0，刚加上的1会被下一步的算数右移丢弃，不对高位产生影响。\nAha, 差别就是向负无穷舍弃还是向0舍弃，一时间竟然不知道哪个是正确的了。\n我们应该如何做 根据最新的[C语言标准草案](ISO/IEC 9899:201x (open-std.org)) 6.5.7章节，负数的右移操作是implementation-defined，即取决于具体的实现：\n The result of E1 \u0026raquo; E2 is E1 right-shifted E2 bit positions. If E1 has an unsigned type or if E1 has a signed type and a nonnegative value, the value of the result is the integral part of the quotient of E1 / 2E2. If E1 has a signed type and a negative value, the resulting value is implementation-defined.\n 因此，理论上它依赖于实现。所以我们在实际应用中为了程序的可移植性，应当避免对有符号数使用移位操作。除非你能确定它的值一定是非负数，在此情况下，请将它用无符号类型来声明。\n对于除法操作，标准中的6.5.5章节规定了，除法操作总是向0舍入. 非常好！\n When integers are divided, the result of the / operator is the algebraic quotient with any fractional part discarded.\n 检查你的代码，恢复所有的“优化”乘除法的行为吧！\n","date":"2023-03-09T17:18:57+08:00","permalink":"https://wangloo.github.io/posts/c/feature/","section":"posts","tags":["c"],"title":"C语言的特点与难点"},{"categories":null,"contents":"头文件的引用形式 C 中引用一个头文件有两种形式 #include \u0026lt;\u0026gt;和#include \u0026quot;\u0026quot;，在应用开发中，需要引用一些系统库文件，我们通常使用\u0026lt;\u0026gt;，对于自己定义的头文件，我们会使用\u0026quot;\u0026quot;。\n然而对于底层软件的开发，比如说操作系统，用到的库都是自己工程中的文件，那么此时用\u0026quot;\u0026quot;和\u0026lt;\u0026gt;有时都能 work，那么它们的区别是什么呢？\n搜索相关关键词得到的结论是: 两种方式的区别是搜索文件的优先级， \u0026quot;\u0026quot;优先搜索的当前目录，而\u0026lt;\u0026gt;优先搜索系统库文件目录。对于这个系统库，即那些使用gcc -I\u0026lt;dir\u0026gt;参数指定的路径。 当然，如果第一优先级位置没有被找到，也会到另一个目录中搜索。这么两种方式均可，实际工程中也有部分人混合使用，毫不在意规则。但是有时会导致一些细节问题，比如说我们经常会用到-MMD或者类似选项生成目标文件的依赖，方便实现增量编译。此时就可能会产生一些问题。\n假设你有一个头文件inc/father.h, 它里面会引用inc/child.h, 对于根目录下的源文件main.c，其引用语句该如何写呢？以下列出的几种形式都可以，任意的排列组合\n1// 编译参数: -I. -MMD 2// main.c 3#include \u0026#34;inc/father.h\u0026#34;4#include \u0026lt;inc/father.h\u0026gt;5 6// father.h 7#include \u0026#34;inc/child.h\u0026#34;8#include \u0026lt;inc/child.h\u0026gt;9#include \u0026#34;child.h\u0026#34;10#include \u0026lt;child.h\u0026gt; 如果 main.c 是使用系统库路径(-I.)来找到的 father.h, 即上面 main.c 的第 2 种情况，那么其生成依赖文件的形式内容都是绝对路径，包括 father.h 中的引用（因为即便 child.h 是相对路径找到的，相对的也是 father.h，其基准就是绝对路径）。例如:main.o: main.c /home/xx/father.h /home/xx/child.h 否则即以相对路径找到 father.h,即上说 main.c 的第 1 种，那么生成 father.h 依赖的方式一定是相对路径，但 child.h 的形式却取决于其本身.  也就是说，如果 child.h 的寻找方式是绝对的（上面的第 1,2,4 种），那么依赖文件的形式就是main.o: main.c inc/father.h /home/xx/child.h. 如果 child.h 的寻找方式是相对的(上面的第 3 种)，那么依赖文件的形式是main.o: main.c inc/father.h inc/child.h    依赖文件的形式很重要，最简单的方式是均使用绝对路径，此时不需要考虑依赖文件在 makefile 中 include 的位置，也就是不需要考虑 make 的“当前路径”。如果非得使用相对路径，那么已经要确定能够 makefile 中 include 时的 make 当前路径就是生成依赖文件的路径，否则不能建立正确的依赖关系。\n实际上，在“基础架构”优秀的项目中，不可能出现或者尽量避免出来两种形式都能找到头文件的情况。比如说，我们会将源文件统一放在子目录src/下与头文件隔离，这样就从根本上避免了相对依赖的生成，只能通过系统库的形式来找头文件。拿上面的例子来说，正确的方式是：main.c 放入 src/中，然后不管是源文件还是头文件，都统一使用#include \u0026quot;inc/xxx\u0026quot;。这样做即统一，也能保证所有的依赖都是绝对路径形式\n 另外说一点，其实依赖文件(.d)中源文件的依赖项形式也是需要考虑的，这不能通过系统架构来解决，只能用 Makefile 的技巧来实现。比如说，我们的 make 当前目录总是根目录，而在建立 OBJS 变量时为其加上绝对路径的前缀， 从而 make 不需要进入各级子目录，生成的依赖文件也都是相对于根目录的，include 依赖文件的行为也是在根目录进行的，保证统一。\n 外部库的使用方式 最近我在开发项目是, 需要使用到 libelf 库, 我在 Github 上找到了其源代码.\n我之前使用一个 lib 都是以链接的形式使用动态库/静态库, 但是既然它提供了源码, 那么我可以直接将源码拷贝到我的项目中吗? 答案肯定是可以, 那么这两种方案该如何抉择呢?\n在查阅了一些资料后, 我总结了以下几个判断依据:\n 库的大小/对编译时间的敏感度; 如果使用源代码, 每次编译项目时需要额外对库文件进行编译(起码是第一次), 而库文件的定义是不常修改的, 如果库文件比较大, 则会延长整个项目的编译时间. 是否需要版本控制; 要使用的库如果需要区分版本, 或者分配给其他的团队成员使用, 那么用库的形式似乎更为方便 发挥 git submodule 的优势;   Ref: c++ - Should I add the source of libraries instead of linking to them? - Software Engineering Stack Exchange\n const 修饰符的妙用 有些时候, 我们设计的结构体中会有name字段, 类型是char *. 在使用时为它分配空间, 不使用时需要回收.\n其实还有另一种情况, 就是name要指向预先定义好的\u0026quot;static name list\u0026quot;, 适用于 name 的取值是确定的范围. 例如, libdwarf 库中的描述 section name 的dss_name 成员.\n这时, 为了防止使用者调用free()来释放它, 我们可以将其声明为const char *, 此时如果调用free(.dss_name), 编译器会给出警告:\n1const.c:16:10: warning: passing argument 1 of ‘free’ discards ‘const’ qualifier from pointer target type [-Wdiscarded-qualifiers] 2 16 | free(dss_name); 3 | ^~~~~~~~ ","date":"2023-02-27T19:20:20+08:00","permalink":"https://wangloo.github.io/posts/c/experience/","section":"posts","tags":["c"],"title":"C语言程序设计的一些经验"},{"categories":null,"contents":"使用VIM 打开一个文件时, 有时会看到例如 ^M 这类字符出现. 下面我会挖一下其出现的原因.\nEOL 字符 EOL 或者说 end-of-line 表示一个新行的开始.\nEOL 字符在不同的操作系统中是不同的. 本文中仅以 Linux 和 Windows 为例说明.\n Windows中是以读到回车\u0026lt;CR\u0026gt;和换行\u0026lt;LF\u0026gt; 表示 EOL. Linux 中仅以换行作为EOL    回车\u0026lt;CR\u0026gt; : Carriage return. 将光标回到行首, 对应C语言中的 \\r 换行\u0026lt;LF\u0026gt; : Line feed. 将光标下移一行, 对应C语言中的 \\n   在 Linux 中打开 Windows 下的文件将多余的回车通常显示成 ^M 或者 Control-M\nRef End Of Line Characters\n","date":"2022-12-24T01:35:24+08:00","permalink":"https://wangloo.github.io/posts/c/end-of-line/","section":"posts","tags":["other"],"title":"行结束符在windows和linux的区别"},{"categories":null,"contents":"我始终以为，C库中常用的 errno 仅是一个全局变量，使用了全局变量就无法保证线程安全了，因为全局变量在所有线程中都是共享的。\n要实现线程安全的errno 就必须将其设置为线程私有的变量，下面就来看看GCC是如何巧妙的实现的。\n正文 现在的errno定义并非一个全局变量, 而是一个宏定义, 以下是在usr/include/errno中的声明:\n1extern int *__errno_location (void); 2# define errno (*__errno_location ()) 这种方式下其实现原理大概是: __errno_location 函数返回一个int指针, 而这个函数的实现中, 返回的就恰好是实际的errno 变量(与宏同名)的地址, 所以对其解引用就相当于对其值进行操作. 所以, 这种定义规则下, 左值和右值表达式均成立.\n1errno = 10; // *__errno_location () = 10 2int x = errno; // x = *__errno_location (); __errno_location 的实现就至关重要, 因为如果其返回的变量地址不包含任何技巧的话, 就和原先直接定义全局变量的方式没差了, 说到底能否实现线程安全, 还得看实际保存errno的变量是否为线程独有的. 目前还没有发掘到其精髓, 只是套壳而已.\n以下给出/csu/errno-loc.c中__errno_location 的实现, 与我们预期一致, 返回变量的地址. 而同名变量errno则定义在/csu/errno.c中, 决定了能够实现errno的线程安全.\n1int * 2__errno_location (void) 3{ 4 return \u0026amp;errno; 5} 1__thread int errno; \u0026ldquo;__thread\u0026rdquo; 是GCC提供的扩展前缀, 表示该变量将被库处理为线程私有的, 注意这一步是C库完成的, 对程序员透明. 相关的理论叫 Thread-local Storage, AArch64 架构实现的原理是利用TPIDR_EL0 寄存器, 其他架构可以参考此PDF\n :question: 以上源文件中有注释为 non-threaded版本的实现, 是代表什么含义呢?\n ​\n虽然我暂时没有查阅到errno的其他线程安全的实现原理, 但起码GCC下该方式这是可行的. 依靠的是\u0026quot;__thread\u0026ldquo;的支持, 与换成宏定义的方式无关, 不排除可能为了考虑兼容其他实现方式的可能性.\n参考 c - How is thread-safe errno initialized if #define substitutes errno symbol? - Stack Overflow\n","date":"2022-12-21T19:08:22+08:00","permalink":"https://wangloo.github.io/posts/os/errno_thread_safe/","section":"posts","tags":["Operating System"],"title":"浅谈 errno 的线程安全问题"},{"categories":null,"contents":"合并操作: git merge merge 有两种方式:\n fast-forward three-way merger  Fast-forward Merge 假设合并的双方为main为dev, 如果其中一个是另一个的祖先, 此时直接移动 HEAD 到前方即可, 称为 fast-forward.\n例如, 当前在 main, 执行git merge dev的过程如下:\n1 main main 2 | | 3M1 --- M2 ===\u0026gt; M1 --- M2 -- F1 4 \\ | 5 \\--- F1 dev 6 | 7 dev three-way Merge 合并的两者不构成直接的祖先-孩子关系, 产生了分叉. 此时进行合并就需要有个基准(参考), 对于两边相较于基准的每个 diff 来说:\n 合并的两者都在基准上进行了改动, 且改动不一致, 标记为冲突 如果该 diff仅在其中一方有改动, 那么就保留此次改动  合并时使用的参考就是两个合并 commit 的最近公共祖先, 这种借助三个 commit(main, dev, 公共祖先)才能完成的合并操作就叫做 three-way merge.\n例如, 当前在 main, 执行git merge dev的过程如下:\n1 main main 2 | | 3M1 --- M2 --- M3 ===\u0026gt; M1 --- M2 --- M3 --- M4 4 \\ \\ / 5 \\--- F1 \\--- F1 --- 6 | | 7 dev dev  three-way 的合并方式如果发生了冲突, 会产生一次额外的 merge commit, 下面介绍它\n 什么情况下 merge commit 没有任何 diff? 按照上面的例子, three-way merge 发生冲突后会产生一次额外的 merge commit, 即 M4. 如果这是去查看 M4 相较前一次 commit 的 diff, 有时是没有的, 有时又会产生 diff.\n如果在解决冲突的过程中, 我们仅仅是接收了 M2,M3 或者 F1 的修改, 那么此时 merge commit 就不会有 diff.\n然而, 在解决冲突时, 我们也可以不采用来自两条路径的修改, 做一次新的修改(可以说, 同时接收两条 diff 就是这种情况), 此时查看 merge commit 的 diff 就是有内容的.\n变基: rebase rebase 命令需要指定一个基准分支，git rebase \u0026lt;base-branch\u0026gt;， rebase 会将当前所处分支整体移动到base-branch之后，即改变了当前分支的历史。\n1// before rebase 2[A]---[B]---[C]---[D]\u0026lt;-dev 3 \\ 4 \\--[E]\u0026lt;-master 5 6// after rebase 7[A]---[E]---[B]---[C]---[D]\u0026lt;-dev 8 | 9 master 交互式 rebase 交互式 rebase 是一种更高级的用法。基础的 rebase 上面说了是将当前分支的所有提交移动到 base-branch 之后。而交互式 rebase 提供一个方法，在移动之前\u0026quot;挑选\u0026quot;当前分支的 commit。\n实际工程中，通常来说，我们将开发分支移动到 master 之前，可以经过交互 rebase 来整理开发分支中混乱的 commit 记录。\n具体的使用方法是，为git rebase指令提供-i参数:\n1git checkout dev 2git rebase -i master 这个命令会打开一个文本编辑器，列出当前 feature 分支的所有提交:\n1pick 33d5b7a Message for commit #1 2pick 9480b3d Message for commit #2 3pick 5c67e61 Message for commit #3 列出的内容就能完整的表示 dev 分支的所有提交，按照顺序。而我们不仅可以任意的重排这些 commit，而且修改pick关键字就能对这些 commit 做改动。举个例子，我们可能发现 commit2 只是对于 commit1 做了一个很小的改动，它们完全可以合并为一个 commit，那么直接 commit2 的pick修改为fixup，整个内容变为:\n1pick 33d5b7a Message for commit #1 2fixup 9480b3d Message for commit #2 3pick 5c67e61 Message for commit #3 当你保存并退出这个文件时，改动就会生效，不仅将 dev 整体移动到了 master 后，并且合并了前两个 commit。\n1// after rebase interactive 2[A]---[E]---[B]---[D]\u0026lt;-dev 3 | 4 master rebase 整理多个 commit 如上面交互式 rebase 所述，当你开发完 dev 分支，需要merge到 main 分支时，可以先利用交互式 rebase\u0026quot;整理\u0026quot;一下 dev 分支的 commit。\n这里其实要用到一个小 trick，上面说过 rebase 命令需要指定一个 base-branch，实际上是一个 base-commit，这种场景下我们不是要合并其他分支，所以base-branch可以选择当前 dev 分支的前面某一次 commit。\n1git checkout dev 2git rebase -i HEAD~3 以上指令实现的功能就是给你整理最后 3 次提交的机会，但不会合并其他分支的东西。\n那如果我想整理整个 dev 分支呢？是向上找到 dev 的第一次 commit 吗？ Git 提供了一个方便找到 dev 分叉出来的那次 commit，将其输出传递给git rebase -i即可实现整理整个 dev 的所有 commit。\n1git merger-base dev main git merege vs git rebase 准则   如果分支已经被提交到远程仓库，就不能再改变他的历史了，即不能使用 rebase。 git 也会阻止你这么做，因为分支的历史已经被修改，除非 force-push。\n  你能进行 rebase 的分支是本地的”私人分支”，私人表示为: 只有你自己在使用，别人不会基于你的分支做东西。\n  dev 同步主分支的改动: rebase 假设我们正在本地的 dev 分支开发一个特性，此时你的同事在 main(也可以是其他的远程分支)上提交了一个重要的 commit，以至于你需要它来继续你的开发任务。\n这种情况我们使用 rebase 和 merge 都能完成目标，但是 rebase 是更好的选择。\n 首先满足 rebase 的使用条件，我们仅仅是破坏了本地 dev 分支的历史，并没有动到其他的远程分支，所以就不存在干涉别人 其次，在 dev 上 merge 其他分支会产生一次不必要的merge commit，其不代表任何实际意义，没必要存在的  合并 dev 到主分支: merge 很简单的逻辑，主分支或者其他合作开发的分支并不是你一个人在用，并且需要最后同步到远程仓库，不符合使用 rebase 的准则\ngit log 参数:    Parameter Description     non-param 列出所有历史提交的 SHA、作者、提交日期和 commit   -p 按补丁显示每次更新，比\u0026ndash;stat 更全   \u0026ndash;stat 显示每次更新修改文件的名称及添加（删除）的行数。比\u0026ndash;name-only 更全   \u0026ndash;name-only 显示文件清单   \u0026ndash;name-status 显示文件清单及改动方式(新增、删除、修改)   \u0026ndash;oneline 只显示前 6 位 SHA 值和 commit   -n 显示前 n 条 log   \u0026lt;branch\u0026gt; 查看某个分支的历史提交。该参数只能 log 命令之后   \u0026lt;branch1\u0026gt;..\u0026lt;branch2\u0026gt;             参考网站：https://www.cnblogs.com/bellkosmos/p/5923439.html\nExample 1: 彩色显示重要信息 1git log --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit Example 2: 查看本地分支和对应远程分支的 commit 差异 1git log --oneline main..origin/main 子模块: submodule 新增一个子模块  将子模块上传到远端仓库上\n  执行git submodule add [url] [path]\n  此时执行git status 会有两个changes，分别是：\n .gitmodules: 记录子模块的path和url [子模块同名的文件]: 记录主项目追踪的是子模块的哪个commit.   也就是说主项目中惠济路自己跟踪子模块的commit，并不一定总是最新的。\n   git add这两处改动，git commit -m \u0026quot;add submodule xxx\u0026quot;\n  clone一个使用子模块的项目  用常规的git clone命令将主项目拿下，此时子模块不会自动下载，只是一个空的目录 git submodule init，这个命令其实是带参数的，指定你想更新哪些子模块， 缺省代表所有子模块。该命令实际的行为是将.gitmodule中的内容写入.git/config git submodule update, 按照.git/config指定的子模块去下载，注意下载的 commit不一定是最新的，上面讲过   :question: git submodule init命令是否有意义？\n有时我们并不想同步所有的子模块，而是其中的某几个，因为可能想自己重写一些，这时可以添加参数 指定想要同步的那些子模块。\n  :two::three:可以合并为一条命令： git submodule update --init， 同步所有子模块。\n 修改更新子模块 如果仅仅是使用子模块，并不做修改，那不用关注这个。但如果你同时参与submodule的开发，那就需要注意。\n 修改子模块并提交；这一步很常规，cd到子模块中，做完修改commit即可 此时会发现在主项目中也多了一个额外的change，是刚才修改子模块的同名文件， 查看diff会发现改动为commit id改为了刚才提交的那次子模块修改  Q1: 这次改动代表什么含义？\n我们知道，子模块同名文件中记录主项目跟踪此子模块的commit，也是git commit update 会达到的 commit。含义是主项目配合子模块的这个commit是ok的。而这次改动也就代表跟踪的commit想要 发生变化，由于你刚才对子模块修改造成的，git自动猜测你想同时改动主项目的追踪。\nQ2: 对这个改动应该做什么操作？\n分两种场景: (1)如果子项目的这些更新有意义同步到主项目中，那么就add并commit这个同名文件的改动， message为\u0026quot;更新submodule\u0026quot;。 (2)如若只是更新子项目而已，或许是为了其他依赖的项目所改的，并不 想涉及到本主项目，那么就restore此次更新，或者重新执行submodule update即可(前提是对子模块 的修改已经push)。\n所以说，同意主项目中的这次change的人必须是更新这次子模块的人，由他决定是否同步到主项目。 其他人甚至在使用期间都不需要cd进入子模块做git pull的，这样也就不会有决策产生，即便 子项目在远端更新了，你要做的就是关注那个同名文件就行，当同名文件更新了，在主项目中 submodule update即可，\n子模块的优缺点 TODO\n","date":"2022-12-13T17:39:42+08:00","permalink":"https://wangloo.github.io/posts/tools/git/git/","section":"posts","tags":["git","tools"],"title":"git 宝典"},{"categories":null,"contents":"..\nnm - 列出符号 nm (GNU Binary Utilities) (sourceware.org)\n","date":"2022-12-03T19:08:22+08:00","permalink":"https://wangloo.github.io/posts/os/gnu_tools/","section":"posts","tags":["Operating System"],"title":"GNU 二进制工具集"},{"categories":null,"contents":"伪目标的依赖关系 Makefile 中的依赖关系指的是目标和依赖之间建立的关系，目标对应规则中的语句是否执行取决于依赖的状态。\n最简单的依赖关系可以拿两个文件来举例:\n1# gcc语句执行当前仅当 main.c 新于 main.elf 2main.elf: main.c 3 gcc main.c -o main.elf make 在执行main.elf的规则时，会先判断依赖关系。拿上面的例子来说， gcc 语句是否执行取决于main.c 和 main.elf的修改时间，只有当 依赖新与目标时，规则语句才会执行。\n然而许多情况下，目标或者依赖并不是一个文件，而是虚拟目标。虚拟目标 并不是一个文件，即它没有修改时间这个属性，此时 make 就不能作比较，结果就是 如果目标是伪目标，那么不管依赖如何都执行规则语句；如果依赖是伪目标， 那么目标的规则语句也永远被执行。下面是两个例子：\n1# 伪目标作为目标文件出现 2# build finish总是输出， 而gcc语句仅当main.c比main.elf新时才执行 3.PHONY : all 4all: main.elf 5\t@echo \u0026#39;build finish\u0026#39; 6main.elf: main.c 7\tgcc $\u0026lt; -o $@ 1# 伪目标作为依赖文件中出现 2# 不管main.c是否比main.elf更新，因为pre-work是伪目标 3# 所以gcc语句总是执行 4.PHONY : pre-work 5main.elf: main.c pre-work 6\tgcc $\u0026lt; -o $@ 上面的代码的效果是：两条规则中的语句都会执行，即使你并没有对 main.c 做任何修改！\n恐怖的空格 Makefile 中的变量结合很常见，例如$(FIXDEP)=$(FIXDEP_PATH)/build/fixdep.\n特别是当我们这些语句是从某些地方粘贴过来，要特别注意变量中是否有空格，Makefile 非常重视这个。假如$(FIXDEP_PATH)中有一个空格，那么$(FIXDEP)就变成两个宏了（不知道叫宏合不合适）。而且 Make 的执行过程很难检查出来。\n规则的执行顺序 如果不从命令行传入目标, Makefile 中定义的规则其实是以从上而下的顺序执行的, 但是我习惯把 all 这种默认规则放在最下面, 所以一般我们可以看到很多 Makefile 会在开头写一句规则all:, 作用就是告诉 make 默认(不显式指定)的目标是all.\n Busybox 根目录 Makefile 中的做法示例\n1# That\u0026#39;s our default target when \u0026gt;none is given on the command line 2.PHONY: _all 3_all:  函数的魔法 patsubst 1$(patsubst \u0026lt;pattern\u0026gt;,\u0026lt;replacement\u0026gt;,\u0026lt;text\u0026gt;) 功能：查找\u0026lt;text\u0026gt;中的单词（以空格，tab，回车，换行分割），看其是否符合\u0026lt;pattern\u0026gt;, 如果符合，将其使用\u0026lt;replacement\u0026gt;替换。可以使用通配符%。\n以下两对是等效的, 明显还是直接使用变量的替换语法操作简单:\n1$(patsubst \u0026lt;pattern\u0026gt;,\u0026lt;replacement\u0026gt;,$(var)) 2$(var:\u0026lt;pattern\u0026gt;=\u0026lt;replacement\u0026gt;;) 3 4$(patsubst %\u0026lt;suffix\u0026gt;,%\u0026lt;replacement\u0026gt;,$(var)) 5$(var:\u0026lt;suffix\u0026gt;=\u0026lt;replacement\u0026gt;) 使用 shell 变量 Make 将 $$var 转义为$var, 供 shell 处理.\ndemo(源自 6.828 根目录GNUmakefile):\n1handin-check: 2 @if test -n \u0026#34;`git status -s`\u0026#34;; then \\ 3 git status -s; \\ 4 read -p \u0026#34;Untracked files will not be handed in. Continue? [y/N] \u0026#34; r; \\ 5 test \u0026#34;$$r\u0026#34; = y; \\ 6 fi  以上 demo 还使用了 test 命令来终止 make 的执行, 如果用户没有输入y, make 将会终止执行\n 使用另一个 Makefile 常见的有三种方式， make -C, make -f 和 include\nmake -C \u0026lt;dir\u0026gt; 的作用等价与 cd \u0026lt;dir\u0026gt;+make, 常见于在一个工程 的主目录下，依次编译生成其他子目录的目标文件。有cd命令的效果，会切换 当前目录。\nmake -f \u0026lt;file\u0026gt; 更像临时使用某个 Makefile 来执行一些操作，在指定的 Makefile 中如果想使用之前的变量，需要export. 目前还没有发现有必要的 应用场景，大部分用include方式替代。\ninclude \u0026lt;file\u0026gt; 一般用于引入一些通用规则，就像 C 语言的 include 头文件 一样，变量无需export.\n","date":"2022-12-03T19:08:22+08:00","permalink":"https://wangloo.github.io/posts/c/makefile_tricks/","section":"posts","tags":["makefile"],"title":"Makefile 一些技巧"},{"categories":["Operating system"],"contents":" ..\n环境变量相关 内存操作 网络操作 EMMC和SD卡 BOOT操作指令 bootm go 其他命令 启动相关\nmd\nmmcinfo\ncp\n","date":"2022-11-27T22:03:48+08:00","permalink":"https://wangloo.github.io/posts/os/uboot/commands/","section":"posts","tags":null,"title":"Uboot: 常用命令"},{"categories":null,"contents":"开发 mkfs.ext4 格式化文件为ext4分区\n1mkfs.ext4 \u0026lt;file\u0026gt; # 将file格式化为ext4 dd https://www.runoob.com/linux/linux-comm-dd.html\nmount 1sudo mount [file] [dir] # 挂载file到dir 2sudo umount [dir] 3sudo mount # 输出当前已经挂载的分区 通用 where and which which 查看可执行文件的位置\n1$ which python3 2/usr/bin/python3 whereis 除了可执行文件还能搜索其他类型的文件, 不常用, 详见 man whereis\n- 的妙用 一些命令支持使用 - 代替文件名, 输入输出都可以:\n 代替标准输出; 一些命令会将-o/-O 后面的-判定为输出到STDOUT, 详见下面示例. 代替标准输入;  下面给出两个同时代替输入输出的例子:\n1# 将标准输入(STDIN)的内容作为gcc的输入, 编译后的结果输出到标准输出(STDOUT) 2echo \u0026#39;void foo() {}\u0026#39; | gcc -x c -o - - 3# 将下载的文件输出到标准输出, 同时作为tar命令的输入文件, 进行解压 4wget -O - \u0026#34;https://www.dropbox.com/download?plat=lnx.x86_64\u0026#34; | tar xzf -  - 如何被解析是取决于命令的实现, 非标准. 比如 cd - 就有特殊的含义\n ","date":"2022-11-27T14:45:58+08:00","permalink":"https://wangloo.github.io/posts/shell/shell-commands/","section":"posts","tags":["shell","bash"],"title":"常用的 shell 命令"},{"categories":null,"contents":"TODO: inline 的发展历程: Myth and reality about inline in C99 – Jens Gustedt\u0026rsquo;s Blog (wordpress.com)\nGNU89: 函数的实现之前添加不同的关键字:\n  inline: 表明这个函数可能被优化. 如果没有被优化, 编译器就会视为一个常规函数的定义.\n  extern inline: 表明这个函数可能被优化. 如果没有被优化, 编译器就将这个函数的定义转换为该函数的声明, 即 extern inline func(); 因此当此函数被调用时, 可以调用一个外部的函数来替代. 如果没有函数调用它, 那么也可以没有外部的替代函数实现.\n  static inline: 表明这个函数可能被优化. 如果没有被优化, 编译器就会视为一个常规静态函数.\n  C99: 函数的实现之前添加不同的关键字:\n inline: 等效于gnu89中的extern inline extern inline: 等效于gnu89中的inline static inline: 与gnu89相同含义.  C++: 只有inline一个关键字, 如果不能优化就定义为普通函数\n Ref:\nc++ - What does extern inline do? - Stack Overflow\nMyth and reality about inline in C99 – Jens Gustedt\u0026rsquo;s Blog (wordpress.com)\n  C demo 关于以上的各种情况\n ","date":"2022-11-24T01:35:24+08:00","permalink":"https://wangloo.github.io/posts/c/inline/","section":"posts","tags":["c"],"title":"C语言 'inline' 关键字"},{"categories":null,"contents":"计算数组元素的个数 1#define nelem(array) sizeof(array)/sizeof(array[0]) ","date":"2022-11-24T01:35:24+08:00","permalink":"https://wangloo.github.io/posts/c/c-macros/","section":"posts","tags":["c"],"title":"C语言工具宏"},{"categories":null,"contents":"符合调用约定使得调用函数能够正常获取参数, callee结束之后能够回到原来位置继续执行.\nX86 调用约定 函数调用 x86架构中, 函数调用以一条call指令为分界.\n在call指令执行之前, 所有的参数必须都躺在栈中, 参数入栈的规则是: 第一个参数最后入栈.\n另外, 执行call指令之前, 必须确保栈指针esp是16-byte对齐. 这项工作是编译器完成的, 如果它判断参数入栈之后的esp 不满足对齐条件, 则会手动调整esp使之对齐. 实现方式见下面例子.\ncall 指令的语义是:\n1push pc+1 ;push next insttuction 2mov pc, func ;set pc = new function call 指令之后的下一条指令就是callee的内容了, 至此就算是进入新函数的地盘.\n但是在执行新的任务之前, callee还需要完成栈的转换, 因为此时使用的栈还是caller的.\n1push ebp ;preserve location of caller\u0026#39;s stack 2mov ebp, esp ;new ebp is old esp 此时esp也就是栈指针等于ebp, 这是callee栈的初始条件. 万事俱备, 可以开始执行callee的实际任务了.\n ebp在整个函数执行过程中是固定的, 好处是: 能够快速的或者函数参数, 返回地址.\n 函数返回 callee执行完毕后, 需要返回到caller继续执行. 刚才说过, callee的返回地址在栈中, 所以我们要做的是找到返回地址所在的位置, 然后使pc = 返回地址. 当然, 还有另一个重要的任务就是恢复caller的栈.\n上述任务的实现使用两条汇编语句就可完成: leave 和 ret.\nleave 负责搞定栈, 其语义为:\n1mov esp, ebp ;回滚栈空间 2pop ebp ;恢复caller的ebp ret 负责搞定pc, 其语义为:\n1pop ebx ;取出返回地址 2mov pc, ebx ;jmp to 返回地址 ret 之后, 就算是返回caller的地盘了. 还有一件小事别忘了做: 用于保存参数的栈空间还没有回收, 回到caller之后需要先将esp的位置进行调整.\nExample: 函数的调用和返回 一个关于函数调用和返回实现的完整例子.\n1void caller() 2{ 3 Func(1, 2, 3); 4} 5void Func(int a, int b, int c) 6{ 7 /* Do something */ 8} (以下汇编是AT\u0026amp;T格式的, 请见谅).\n1; Caller 2sub $0x4,%esp ;make 16-bytes align before call. 0x4 是由编译器计算的 3push $0x3 ;push 参数, 顺序是从右到左 4push $0x2 5push $0x1 6call f01000ad \u0026lt;Func\u0026gt; ;Func()\u0026#39;addr is f01000ad 7;===========\u0026gt;\u0026gt; Turn to callee 8 9 ;Func() 10 push %ebp ;preserve old ebp 11 mov %esp,%ebp ;set new ebp, ebp=esp now 12 /* Do something */ 13 leave ;restore stack 14 ret ;restore instruction point 15 16;\u0026lt;\u0026lt;=========== Back to caller 17add $0x10,%esp ;recycle stack(12 bytes parameters plus 4 bytes alignment) Armv8 调用约定 大体的思想与x86相似, 只是细节有些许不同\n函数调用 ARMv8架构中, 函数调用以一条bl指令为分界.\n执行bl指令之前, 需要将参数准备好. 注意, ARMv8中, 少于8个参数的函数在传参时, 参数是放在x0-x7中, 最左边的参数先使用x0, 以此类推. 参数超过8个的情况下才使用栈, 这与x86的方式不同.\nbl指令保存返回地址, 并跳转到callee执行, 其语义是:\n1mov lr, pc+1 ;preserve return address 2 ;lr specially used for preservering return addr 3mov pc, new_func ;set pc = new function 与x86相同, 跳转到callee之后必须先进行栈的设置, Arm与x86不同的是它不需要管理栈底寄存器. 因为参数大部分是通过寄存器来传递, 返回地址也是存储在lr(x30)寄存器中, 没必要为了极少的情况来做优化.\n1sub sp, sp, #enough-space 函数返回 要完成两件事: (1) 恢复栈 (2)返回原来位置执行\n先说(2), 由于lr寄存器始终保存返回地址, 直接 mov sp, lr 就能返回caller继续执行. 这也就是ret指令的语义.\n(1)恢复栈的这件事同x86一样由callee完成,\n1add sp, sp, #enough-space 参考  x86 call 指令执行前需要esp对齐到 16-byte: x86 - What are the following instructions after this call (assembly) - Stack Overflow x86栈帧原理 - 知乎 (zhihu.com)  结语 能够正确达到函数调用和返回的实现方式有很多, 不是仅有这一种方式, 约定仅仅是一个约定, 大家都这样去做降低了开发的难度.\n","date":"2022-11-21T10:30:35+08:00","permalink":"https://wangloo.github.io/posts/os/function-call-conventions/","section":"posts","tags":["armv8","x86","Operating System"],"title":"x86/ARMv8 函数调用约定"},{"categories":null,"contents":"问题源于我在知乎刷到的一个回答: 能分享你C指针用得最灵活（飘）的一次吗?\n文中提到了Linus关于无头节点单项链表的删除操作给出的一种新的思路, 我觉得对理解指针非常有帮助, 所以在这里详细描述一下这件事.\n从我学习数据结构起, 对不含头节点的单向链表的删除操作, 做法常是: 借用pre指针搜索. 这种情况下避免不了对于链表中第一个节点的特判(第一个节点没有pre).\nLinus提到了一种借助二级指针避免该分支的方法.\n1void remove_if(node ** head, remove_fn rm) 2{ 3 for (node** curr = head; *curr; ) 4 { 5 node * entry = *curr; 6 if (rm(entry)) 7 { 8 *curr = entry-\u0026gt;next; 9 free(entry); 10 } 11 else 12 curr = \u0026amp;entry-\u0026gt;next; 13 } 14} 指针的内容就是地址, int *p = a 也就意味着变量p 中保存着变量a的地址. 所以参数head在内存中的含义为:\n假如要删除node2, 那么改变*curr实际上就是改了node1的next成员.\n","date":"2022-11-20T23:40:30+08:00","permalink":"https://wangloo.github.io/posts/c/pointers-pointers-list/","section":"posts","tags":["c"],"title":"二级指针操作链表"},{"categories":null,"contents":" 大小端问题的由来 为什么计算机世界需要区分大小端? 内存里存取的单位是字节, 如果所有的数据类型长度都是一个字节, 那就完全不需要大小端了, 每个变量都仅占据单独一个字节.\n例如, 三个变量 a=10, b=20, c=30, 在内存中的布局可能就是:\n1 ┌────────────┐ 2 │ │ 3 │ 10 │ a 4 ├────────────┤ 5 │ │ 6 │ 20 │ b 7 ├────────────┤ 8 │ │ 9 │ 30 │ c 10 ├────────────┤ 11 │ │ 12 │ │ 13 │ │ 14 │ │ 15 │ │ 16 └────────────┘ 但是我们最常使用的数据类型肯定有超过一个字节的, int类型在64位的系统中就占4个字节. 例如变量a=0xaabbccdd\n一个变量的大小一旦超过4个字节, 内存的存取又是以字节位单位的, 那么要把它塞到内存里就必然会产生两种不同存放方式: 先放0xaa还是先放0xdd\n首先, 0xdd是变量a的低8位, 0xaa是最高8位, 这是确定的.\n  如果先放0xaa, 即低地址放高位, 就叫做大端, 如左图;\n  如果先放0xdd, 即低地址放低位, 就叫小端, 如右图.\n  1 2 start addr of `a` start addr of `a` 3 ┌────────────┐ ┌────────────┐ 4 │ │ │ │ 5 │ aa │ │ dd │ 6 ├────────────┤ ├────────────┤ 7 │ │ │ │ 8 │ bb │ │ cc │ 9 ├────────────┤ ├────────────┤ 10 │ │ │ │ 11 │ cc │ │ bb │ 12 ├────────────┤ ├────────────┤ 13 │ │ │ │ 14 │ dd │ │ aa │ 15 ├────────────┤ ├────────────┤ 16 │ │ │ │ 17 │ │ │ │ 18 └────────────┘ └────────────┘ 什么情况? 看下面的代码, 猜测输出的结果\n1unsigned int i = 0x00646c72; 2printf(\u0026#34;Hello Wo%s\u0026#34;, \u0026amp;i); %s 会按字节一直打印内存中的字符, 直到遇到\\0. 首先打印的字符便是变量i的地址处的内容.\n如果是小端存储方式, 变量i的地址处的一个字节值是0x72, 即字符r. 以此类推, 所以如果CPU的字节序是小端形式, 那么printf的结果是: Hello world\n大小端形式的优缺点 小端的优势:\n  以不同的长度读取变量非常方便, 不用计算地址. 例如u64 a=0x1234, 当(u16)a时, CPU不需要重新计算读取的起始位置, 永远都是变量a的起始地址.\n  Easily to do mathematical computations “because of the 1:1 relationship between address offset and byte number (offset 0 is byte 0), multiple precision math routines are correspondingly easy to write.”\n  ","date":"2022-11-17T10:30:35+08:00","permalink":"https://wangloo.github.io/posts/os/big-little-endian/","section":"posts","tags":["Operating System"],"title":"大小端问题"},{"categories":null,"contents":"本文基于AArch64执行环境, 介绍现代操作系统中上下文切换的相关内容.\n什么是上下文？ 上下文又称“现场”,\n为什么需要上下文切换? (TODO: 为什么说线程是调度的单位?)\n现代操作系统中同时存在着成千上百个线程, 但是一个CPU同一时刻只能运行一个线程, 他们是轮流的占用CPU, 也叫并发执行. (TODO: 如何查看线程切换的间隔?) 线程高频率的切换, 操作系统是如何保证切换到下一个执行的线程时, 它能够继续上次的工作呢?\n什么是上下文? 我们正在看一本书的时候如果被其他的事情打断, 返回时为了能够从上次被打断的位置继续读, 就要在被打断的时候记下来当前是读到了哪个第几页的第几行.\n操作系统对待线程也是如此, 需要保存的用于恢复线程执行的信息就称为线程的上下文.\n那么对于线程来说需要记下的内容有什么呢? 寄存器和栈即可. 拿AArch64架构来距离, 线程的上下文就是:\n 通用寄存器x0-x29: 函数调用的参数, 某些计算过程的中间值, 都要用到这些寄存器. 线程的执行流可能在任何时候被打断, 当然这些内容也不能丢. 通用寄存器lr(x30): lr 保存着返回地址, 即当前函数结束之后该返回到哪执行. 栈顶指针 sp: 栈的重要性无需多言. 但是需要说明的是我们保存栈的方式并非将栈中的所有内容保存, 而是保存栈的位置即可. 因为操作系统有别的机制(TODO), 能够保证即便线程不在执行, 属于该线程的栈也不会被破坏. 程序计数器 pc: 被打断的线程如果再次执行, 从哪里执行呢? 显然是被打断指令的下一条(或者重新执行当前). 这个指令的地址当然也需要被保存好. PSTATE: 想一下, 有了以上的内容就能够保证线程完整的恢复之前的环境吗? 其他的例如中断是开还是关, 有哪些标志位(NZCV)被设置了. 这些信息在AArch64中是保存在PSTATE的各个字段中.  如果我们能够有一个适当的逻辑, 在线程切换出去的时候将上下文保存起来, 然后恢复新线程的上下文, 是不是线程切换这件事就能做到了. 如何组织这个保存和恢复的过程在下面会介绍到.\nLinux 如何处理上下文切换 另一种处理上下文切换的思路 协程的上下文 协程是用户级别的线程,\n 协程之间的切换不进入内核 切换协程只能是某个协程主动放弃控制权  我们在这里讨论一下协程切换时需要保存的上下文是否与线程有所不同.\n首先, PC一定属于, 这个毋庸置疑. 其次是栈顶指针sp, 每个协程都有单独的栈, 如果不保存栈的位置, 那么协程内部定义局部变量就没法访问了(局部变量的访问指令都是以sp为base的偏移来做的).\n另外, 关于通用寄存器, 由于协程的切换需要主动调用某个函数(通常叫做yield()), 在函数的最后将PC设置为新协程的上下文PC. 保存当前协程上下文的操作也在这个函数中, 而其参数我们并不关心, 即x0-x7没必要保存. 同样的, caller-saved寄存器也是没必要保存的, 因为这些寄存器作为函数调用使用的临时变量, 当再次返回该协程时, PC=yield()返回地址, caller如果关心这些寄存器应当自己执行保存和恢复. 但是callee-saved寄存器必须要保存到上下文中, 因为在yield()中, 我们如果修改了callee-saved寄存器, 就需要在返回时(也就是再次调度到该协程时) 恢复, 这是callee该做的, 也就是上下文中应该有的唯一通用寄存器组.\n","date":"2022-11-14T22:13:06+08:00","permalink":"https://wangloo.github.io/posts/os/context/","section":"posts","tags":["Operating System"],"title":"操作系统——上下文切换"},{"categories":null,"contents":"介绍 setjmp() and longjmp() 是一对组合使用的函数, 可以实现全局的goto.\nsetjmp() 构造一个运行环境, 调用longjmp() 则将执行流切换到该环境.\n1/* setjmp() 保存当前的运行环境(上下文)到 env 参数中 */ 2int setjmp(jmp_buf env); 3 4/* longjmp() 将控制流切换到 env 指定的运行环境 */ 5void longjmp(jmp_buf env, int val); 使用方法 1#include \u0026lt;setjmp.h\u0026gt;2#include \u0026lt;stdio.h\u0026gt;3 4jmp_buf e; 5 6void foo() { 7 longjmp(e, 1); 8} 9 10int main(void) { 11 int ret; 12 13 /* After calling longjmp(), the execution flow back to setjmp(), 14and setjmp() will return not 0. */ 15 ret = setjmp(e); 16 if (ret == 0) { 17 printf(\u0026#34;Return from setjmp\\n\u0026#34;); 18 foo(); 19 } else { 20 printf(\u0026#34;Return from longjmp\\n\u0026#34;); 21 } 22 23 return 0; 24} 基于 AArch64 的实现 需要保存的上下文包括\n callee-saved 通用寄存器, 因为可能第一次调用 setjmp() 之后的执行流修改了这些寄存器, 从第二次回到 setjmp() 的角度来看, 就是执行setjmp() 中破坏的. caller-saved 寄存器则不必, 因为本来即便看作是 setjmp() 破坏的, 也是正常的.  1.macro func _name 2.global \\_name 3.type \\_name, %function 4\\_name: 5.endm 6 7.macro endfunc _name 8.size \\_name, .-\\_name 9.endm 10 11 12/** 13 * setjmp (jmp_buf env) 14 * 15 * See also: 16 * longjmp 17 * 18 * @return 0 - if returns from direct call, 19 * nonzero - if returns after longjmp. 20 */ 21 22func setjmp 23 stp x19, x20, [x0], #16 24 stp x21, x22, [x0], #16 25 stp x23, x24, [x0], #16 26 stp x25, x26, [x0], #16 27 stp x27, x28, [x0], #16 28 stp x29, x18, [x0], #16 29 mov x9, sp 30 stp lr, x9, [x0], #16 31 mov x0, #0 32 33 ret 34endfunc setjmp 35 36/** 37 * longjmp (jmp_buf env, int val) 38 * 39 * Note: 40 * if val is not 0, then it would be returned from setjmp, 41 * otherwise - 1 would be returned. 42 * 43 * See also: 44 * setjmp 45 */ 46 47func longjmp 48 ldp x19, x20, [x0], #16 49 ldp x21, x22, [x0], #16 50 ldp x23, x24, [x0], #16 51 ldp x25, x26, [x0], #16 52 ldp x27, x28, [x0], #16 53 ldp x29, x18, [x0], #16 54 ldp lr, x9, [x0], #16 55 mov sp, x9 56 57 mov x0, x1 58 cbnz x0, 1f 59 add x0, x0, #1 601: 61 62 ret 63endfunc longjmp setjmp() 实现 try-catch ","date":"2022-11-01T23:38:54+08:00","permalink":"https://wangloo.github.io/posts/c/setjmp_and_longjmp/","section":"posts","tags":["armv8","c"],"title":"基于ARM64实现setjmp/longjmp"},{"categories":null,"contents":" Kernel Monitor 是什么 Kernel Monitor 是一个适配我们微内核操作系统的 Kernel 调试和监控系统. 它能实现内核的动态调试和监控. 同时, 它还接管内核的同步异常和系统错误, 使开发者能够了解发生异常时系统的状态.\nKernel Monitor 具有一定的可扩展性, 例如通过统计内核中存储的 TCB 来实时监控系统中所有线程的状态. 可根据开发者的需求添加统计的对象, 如 Endpoint, Capability等.\n Kernel Monitor 总体设计 Kernel Monitor 系统包含 Clinet 和 Server 两个部分. 简单来说, Client 负责处理用户输入, 并将输入进行解析, 封装为 一系列基础命令. 发送给 Server. Server 负责执行这些 基础的命令, 如设置断点, 查看某个地址的值等.\n整个系统有两种架构: 本地 Monitor 和远程 Monitor.\n本地monitor 和远程 monitor 的区别是: Monitor Client 的位置在哪, 是否与 Server 在同一个机器上.\n 先说 Monitor Server, 它必须嵌入要调试的 Kernel 中, 位于一个地址空间, 方便操作 Kernel 的内存.\n 本地 Monitor 在本地 Monitor 中, client 和 sever 都位于目标机(Target)上, 目标机通常是开发板.\n对于 AArch64 体系结构来说, 最多有四个异常等级(EL0-EL3). Client 可以运行在EL2.\n远程 Monitor 远程 Monitor 架构则不同, Clinet 运行在宿主机(Host)上, 通常是Linux. 它与 Server 的通信是通过网络/UART实现的.\n Monitor Client 运行在本地和远程对于实现的难度和用户体验有影响.\n  如果 Client 实现在本地, 则 Client 无需实现网口和串口的驱动, 但Monitor 输入输出的串口与操作系统本身的串口相同, 信息冗杂在一起不易查看; 同时, 如果 Client 实现在本地, 那么对于ELF的解析需要在无操作系统提供的库支持下完成, 可能比较复杂.\n  如果 Client 实现在远程, 即为 Linux 上的一个APP. 那么它和 Server 的通信就需要通过外部的网口或者串口(对于我们使用的64位开发板只引出了一个串口, 所以只能使用网口). 需要在 Server 上实现网口的驱动, 这部分比较复杂. 但是好处是 Client 的实现简单很多, 因为有 Linux APP 运行环境的支持. 同时, 远程 Monitor 架构下, Monitor 和 操作系统自身的输入输出分开, 用户可读性更好.\n   Server 是嵌入到Kernel的代码中, 与Client进行交互. 它是整个 Monitor 系统的后端, 负责实现基础的调试操作. 例如, 设置断点, 内存的读写, 寄存器的读写等.\n 由于Server与 Kernel 位于同一个地址空间, 所以查看/修改内存的值是非常方便的. 对于寄存器也是同理. 断点(Breakpoint), 监视点(Watchpoint), 单步执行(Soft step)的实现依赖与 ARMv8 提供的的 self-hosted debug 支持.  同时, Server 还负责监视系统中所有的 同步异常和系统错误. 一旦发生, 可在 Monitor 中查看某些内存, 寄存器的值定位问题发生的原因.\nMonitor Client 设计 Client 的构成可分为三个模块 :\n 用户交互模块 符号处理模块 消息收发模块  用户交互模块负责处理用户的输入输出, 调用其他两个模块完成调试命令.\n符号处理模块负责解析可执行文件(ELF), 并建立静态符号表, 存储符号和地址的对应关系. 将用户输入的符号解析为虚拟地址, 或者反向解析.\n消息收发模块负责处理用户的输入, 将其转化为基础, 标准的命令, 发送给Server执行. Client 和 Server之间通信的数据包协议可以使用 GDB Remote Serial Protocol (以下简称RSP协议), 或者自己规定一个协议也是可行的.\n RSP协议支持三种基础命令:\n 寄存器相关 内存相关 程序控制命令   启用 Monitor 时 Kernel 启动流程  Kernel 首先做必要的初始化, GIC, 异常向量表, MMU等. 将控制权交给 Monitor, 等待用户输入.   Kernel debug 过程示例 示例一: 查看变量 var 的值  用户输入 print var 指令. 由符号处理模块, 将var符号转为var 虚拟地址. 由消息收发指令将请求封装为RSP协议包格式, 并发送到 Monitor Server. 执行流程交给 Monitor Server, 它访问该地址, 将内容封装发回 Monitor Client. Client 输出var的值, 继续等待用户输入  示例二: 添加断点到 main 函数  用户输入 break main 指令 由符号处理模块, 解析得到 main 函数的地址. 消息收发模块将请求封装为RSP包格式, 发送到Monitor Server. 执行流程交给 Server. 它执行 breakpoint exception 指令, 并设置相关软件断点相关寄存器 执行流交给 Kernel, 直到达到断点处(可使用地址+ContextID双重验证), 触发Debug异常 Debug异常属于同步异常, 由 Monitor 系统接管, 回到 Client 继续等待用户输入  示例三: 单步执行  用户输入 step 指令 消息收发模块将请求封装为RSP包格式, 发送到 Monitor Server. 执行流程交给 Server, 启用 software step. 然执行一次异常返回, 回到Kernel 继续执行. 因为启用了 Software step, 回到 Kernel 执行完一条指令后, 就会触发 Debug异常 Debug 异常属于同步异常, 由 Monitor 系统接管, 回到 Client 继续等待用户输入   其他拓展功能 back trace\n性能分析\n","date":"2022-10-28T22:56:19+08:00","permalink":"https://wangloo.github.io/posts/os/monitor/","section":"posts","tags":null,"title":"Armv8 Kernel Monitor"},{"categories":null,"contents":"Introduction MMU: 专用于将虚拟地址转换为物理地址. 通常配合分页机制来工作.\n页表: 页表中的表项包含提供虚拟地址和物理地址之间的映射.\nMMU就是直接访问页表, 并且通过将频繁使用的映射缓存到TLB中.\nMMU 的结构 MMU是一种硬件, 可以通过在适当的安全状态下对其进行配置. 每个Core都有自己的MMU, 每个MMU包括:\n 一个TLB, 缓存最近访问的映射. 一个Table Walk Unit, 从内存中查询页表, 得到最终的虚拟地址-物理地址的映射.  MMU 控制着整个系统的缓存策略, 内存属性和访问权限. MMU开启后, 软件发出的所有内存访问都使用虚拟地址, 要求MMU为每次访问进行地址转换.\nMMU 的配置 在启用MMU前, 必须告知其页表存放的位置.\nMMU 地址转换的过程 对于每个转换请求, MMU首先检查TLB是否已经对该地址缓存, 如果该地址未缓存, 则需要遍历页表.\n页表遍历单元在页表中搜索相关的映射表项.\n 一旦找到映射, MMU就会检查权限和属性. 决定允许本次访问, 或者发出故障信号. 若未找到映射, 则触发缺页异常.  页表的工作原理 页表的工作方式是将虚拟地址空间和物理地址空间划分为大小相等的块, 称为页面.\n页表中的每个表项对应着一块虚拟地址空间中的块, 表项的值就是这块虚拟地址空间对应的物理地址块, 以及访问物理地址时要使用的属性.\n在查表过程中, 将虚拟地址分为两部分:\n 高阶位用作页表的索引. 用来找到对应的物理块 低地址是块内的偏移量, 不会因为映射而改变. 页表项中的物理地址与该偏移组合形成用于访问内存的物理地址.  多级页表 实际实现中, 多采用多级页表的方案, 各级页表自定向下组成树的形式, 协作实现虚拟到物理地址的转换.\n树中的分支成为页目录, 页目录中的表项不是直接存储目标物理地址, 而是下一级页表的地址; 最后一级页表的表项中保存着目标物理地址.\n 多级页表是减小页表占用存储空间过大的有效方案.\n 顶级页表将地址空间划分为大块, 每个表项可以指向大小相等的内存块. 也可以指向将块进行再次细分的下一级页表. 支持大块的优点:\n 大的内存块需要查表的次数更少 提升TLB的效率, 因为一个TLB表项覆盖更大的内存区域.  凡事都是有利有弊, 使用大块也增加了内存浪费, 实际使用时需要根据需要来权衡.\n内存类型 普通类型内存 普通类型的内存是弱一致性的(weakly ordered)内存模型, 没有额外的约束, 可以提供最高的内存访问性能.\n通常代码段, 数据段以及其他数据都放在普通内存中.\n普通内存允许处理器做很多优化, 如分支预测, 数据预取, Cache line预取, 乱序执行等.\n设备类型内存 CPU访问设备内存会有很多限制, 如不能进行数据预取等. 设备类型的内存严格按照指令的顺序来执行的.\n设备类型内容通常留给设备来访问, 例如中断控制器(GIC), 串口, 定时器等.\n两套页表  当CPU访问的地址属于用户空间时, MMU会自动选择TTBR0指向的页表. 当CPU访问的地址属于内核空间时. MMU会自动选择TTBR1指向的页表  EL2和EL3没有TTBR1, 只有TTBR0. 也就意味着:\n• If EL2 is using AArch64, it can only use Virtual Addresses in the range 0x0 to 0x0000FFFF_FFFFFFFF. • If EL3 is using AArch64, it can only use Virtual Addresses in the range 0x0 to 0x0000FFFF_FFFFFFFF.\n越权, 越界 在未使用虚拟地址空间之前, 所有的用户程序都可以访问全部的物理内存, 所以恶意程序可以修改其他程序的内存数据, 这使得整个系统处于危险的状态. 每个进程的地址空间都要受到保护, 以免被其他进程有意/无意的破坏.\n现代操作系统中, 每个进程都有独立的虚拟地址空间. 在进程的角度上, 它拥有整个虚拟地址空间. 不同的进程可以同时使用一个虚拟地址, MMU通过页表将其映射到合适的物理地址.\n两个物理地址空间 ARMv8 体系结构定义两个物理地址空间: secure address space 和 non-secure address space.\n理论上, 安全和非安全的地址空间是相互独立的, 然而现实中大多数系统都将安全和非安全视为访问控制的属性. 正常(非安全)世界只能访问非安全的物理内存; 而安全世界可以访问这两个地址空间.\nARMv8 MMU权限控制 程序请求某个地址时, MMU需要进行权限检查. 如果请求的地址是数据, 则检查读写权限; 如果请求的是地址, 则检查其可执行权限.\nARMv8 页表项的AP字段控制该不同异常等级下, 页面的读写权限.\n[表格]\nARMv8 页表项的PNX字段和XN/UXN字段来设置CPU是否对这个页面有执行权限.\n  当系统有两套页表时, UXN是用来设置用户空间页面是否有可执行权限; PXN 用来设置特权空间的页面是否有可执行权限.\n  若系统只有一套页表, 则通过XN字段控制\n  页表的结构 地址宽度 48bit\n页面粒度 页面粒度表示一次最小分配内存块的大小. AArch64支持三种页的大小, 4KB, 16KB, 64KB. 支持哪一种是由实现定义的。创建页表的代码能够读取系统寄存器ID_AA64MMFR0_EL1，以找出哪些是受支持的大小。Cortex-A53处理器支持所有三种尺寸，但有些处理器的早期版本并非如此，例如Cortex-A57，它不支持16K粒度。\nAArch64 页表项结构 无效页表项 table block 页表结构(4KB页面为例) 以4KB页面粒度, 虚拟地址宽度为 48位. 使用4级页表.\n48位地址每层转换有9个地址位，即每层512个条目，最后12位选择4kB内的一个字节，直接来自原始地址\n虚拟地址到物理地址的转换过程 当处理器为获取指令或数据访问发出一个64位的虚拟地址时，MMU硬件将虚拟地址转换为相应的物理地址。对于虚拟地址，前16位[63:47]必须全部为0或1，否则地址将触发故障。\nNon-secure and secure access ARMv8-A架构定义了两种安全状态:安全的和非安全的。它还定义了两个物理地址空间:安全的和非安全的. 正常(非安全)世界只能访问非安全物理地址空间。安全世界可以访问两个物理地址空间。这也是通过转换表来控制的。\n在非安全状态下，转换表中的NS位和NSTable位将被忽略。只能访问非安全内存。在安全状态下，NS位和NSTable位控制虚拟地址转换为安全物理地址还是非安全物理地址。\nYou can use SCR_EL3.SIF 来禁用安全世界访问非安全地址.\n相关的寄存器 与地址转换相关的寄存器主要有以下几个:\n 转换控制寄存器(TCR) 系统控制寄存器(SCTLR) 页表基地址寄存器(TTBR)  TCR IPS: 配置地址转换后输出物理地址的最大值\nTxSz: 配置输入地址的最大值, 即虚拟地址的宽度\nTG1: 配置TTBR1页表的页面粒度大小\nSHx: 配置TTBRx相关内存的Cache共享属性\nORGNx:\nIRGNx:\nSCTLR M: Disable/Enable MMU地址转换\nC: Disable/Enable Data Cache\nI: Disable/Enable Instruction Cache\nTTBR 存储页表的基地址\nAArch32 虚拟内存系统 ARMv8 AArch32 的虚拟内存系统向后兼容ARMv7, 与ARMv7的基本一致.\n","date":"2022-09-29T08:01:33+08:00","permalink":"https://wangloo.github.io/posts/armv8/mmu/","section":"posts","tags":["armv8"],"title":"ARMv8-A MMU介绍"},{"categories":null,"contents":"ARMv8 异常返回指令 当异常处理程序结束后，需要执行异常返回指令恢复进入异常之前的状态.\n具体要做的事情包括:\n  恢复发生异常前的PC\n  从SPSR中恢复PSTATE寄存器(现场)\n  异常返回的指令根据当前执行状态为AArch32还是AArch64有所不同.\nAArch32 AArch32的异常返回指令在不同的模式下也有所不同:\n若异常是在Hyp模式下处理: 仅可执行ERET指令从异常返回.\n若异常是在其他模式下处理, AArch32提供了以下的异常返回指令:\n  ERET 指令\n  使用带S后缀的数据处理指令直接操作PC(例如, MOVS, PC, LR), 恢复PSTATE\n  RFE 指令: RFE \u0026lt;Rn\u0026gt;. 从基址寄存器指向的地址依次加载PC和PSTATE\n  LDM 指令: LDM \u0026lt;Rn\u0026gt; {pc..}. 若目标寄存器中包含PC, 则会同时恢复PSTATE\n  AArch64 AArch64下统一使用 ERET 指令进行异常返回.\n指令格式及用法参考 ERET ERET指令完成了:\n  从ELR_ELx中恢复PC指针\n  从SPSR_ELx中恢复PSTATE寄存器的状态.\n  LDM(Load Multiple) 格式: LDM \u0026lt;Rn\u0026gt; {registers}\n含义: 从基址寄存器\u0026lt;Rn\u0026gt;指向的地址开始依次加载多个寄存器值. 若目标寄存器中包含PC, 则同时恢复PSTATE.\n例如: LDM \u0026lt;r0\u0026gt; {pc, r1} 等价于:\n1pc = [r0] 2r1 = [r0+4] 3PSTATE = SPSR ;仅当目标寄存器包含PC时自动完成 RFE(Return From Exception) 格式: LDM \u0026lt;Rn\u0026gt; \n含义: 从基址寄存器\u0026lt;Rn\u0026gt;指向的地址依次加载PC和PSTATE.\n例如: RFE \u0026lt;r0\u0026gt; 等价于:\n1pc = [r0] 2PSTATE = [r0+4] ","date":"2022-09-24T21:19:01+08:00","permalink":"https://wangloo.github.io/posts/armv8/exception_return/","section":"posts","tags":["armv8"],"title":"AArch64/32 异常返回过程"},{"categories":null,"contents":"语句结构 1asm asm-qualifiers ( AssemblerTemplate 2 : OutputOperands 3 : InputOperands 4 : Clobbers 5 : GotoLabels) The asm keyword is a GNU extension. 当使用编译选项 -ansi 或 -std 时, 使用 __asm__代替 asm.\nQualifiers  volatile: 避免编译器的过分优化 goto inline  Parameters AssemblerTemplate: 字符串, 汇编代码的模板\nOutputOperands: 输出操作数; 指令将会修改的变量集合\nInputOperands: 输入操作数; 指令将读取的变量集合\nClobbers: ???TODO\nGotoLabels: 仅当 qualifiers 使用goto时, 声明label集合.\n The total number of input + output + goto operands is limited to 30.\n  Param #1: AssemblerTemplate 多条语句可以放在一个asm字符串中, 但是更常见的是每条汇编语句使用一个字符串, 并在结束时使用换行符和制表符(\\n, \\t)来表示换行.\n 貌似对于 arm 汇编, 只用 \\n 也OK?\n  Param #2: OutputOperands 多个 OutputOperands 之间使用,隔开, 每个 OutputOperands 的格式如下:\n1[ [asmSymbolicName] ] constraint (cvariablename) asmSymbolicName: 指定该操作数的名称\nconstraint: 对该操作数的一些限制\n1// 描述操作数的权限, 输出操作数的约束必须以此开头 2= 忽略现有值 3+ 读写, 当原先值有意义时用它 4\u0026amp; 禁止编译器将该操作数与不相关的输入操作数分配同一个寄存器 5 6// 描述输出操作数所在位置, 如果你不知道, 可以同时设置, 编译器会帮你决定 7r 寄存器 8m 内存 9 10// 架构相关的 11z AArch64中存在. 表达可以使用零寄存器(XZR or WZR). Useful when combined 12 with `r` to represent an operand that can be either a general-purpose register 13 or the zero register. cvariablename: 输出到的 C 语言变量名\n Param #3: Input Operands 输入操作数的格式与输出操作数基本一致:\n1[ [asmSymbolicName] ] constraint (cexpression)  对于输入操作数, 一般没有别的限制, 仅使用\u0026quot;r\u0026quot;(val)\n  Param #4: Clobbers 每个 clobber 都是用双引号括起来, 并用逗号分隔的字符串常量.\n常用的 clobber 参数:\n  \u0026ldquo;memory\u0026rdquo;\n告诉编译器, 这段内联汇编代码对输入和输出操作数中列出的项以外的内存读取或写入操作(例如，访问输入参数之一指向的内存). 为确保内存包含正确的值，GCC可能需要在执行ASM之前将特定寄存器值刷新到内存。此外, 阻止编译器越过该 ASM 语句进行 reorder, 形成针对编译器的 memory barrier. 注意, 此 clobber 不会阻止处理器在ASM语句之后执行推测性读取。为了防止出现这种情况，您需要特定于处理器的防护指令。\n  \u0026ldquo;cc\u0026rdquo;\nThis stands for \u0026ldquo;condition codes\u0026rdquo;. Since the add instruction will affect the carry flag amongst other things, we need to tell gcc about it. Otherwise it might want to split a test-and-branch around our code. If it did so, the branch might go the wrong way due to the condition codes being corrupted. Basically, any inline asm that does arithmetic should explicitly clobber the flags like this.\n   Param #5: GotoLabels 尽量不使用, 可以在ASM的内部直接定义 label\nTODO\n 样例 最简单的模板 1int src = 1; 2int dst; 3 4asm (\u0026#34;mov %1, %0\\n\\t\u0026#34; 5 \u0026#34;add $1, %0\u0026#34; 6 : \u0026#34;=r\u0026#34; (dst) 7 : \u0026#34;r\u0026#34; (src)); 8 9printf(\u0026#34;%d\\n\u0026#34;, dst); 操作数使用 asmSymbolicName 1uint32_t c = 1; 2uint32_t d; 3uint32_t *e = \u0026amp;c; 4 5asm (\u0026#34;mov %[e], %[d]\u0026#34; 6 : [d] \u0026#34;=rm\u0026#34; (d) 7 : [e] \u0026#34;rm\u0026#34; (*e)); 内部定义 label 1 long temp; 2 long ret; 3\tasm volatile( 4 \u0026#34;1: \\n\u0026#34; 5 \u0026#34;ldxr %0, [%2]\\n\u0026#34; 6 \u0026#34;sub %0, %0, %3\\n\u0026#34; 7 \u0026#34;stxr %w1, %0, [%2]\\n\u0026#34; 8 \u0026#34;cbnz %w1, 1b\\n\\t\u0026#34; 9 : \u0026#34;=\u0026amp;r\u0026#34;(ret), \u0026#34;=\u0026amp;r\u0026#34;(temp) 10 : \u0026#34;r\u0026#34;(p), \u0026#34;r\u0026#34;(val) 11 : \u0026#34;memory\u0026#34; 12 ); Reference Extended Asm (Using the GNU Compiler Collection (GCC))\nAArch64 Constraint codes\n","date":"2022-09-24T16:48:58+08:00","permalink":"https://wangloo.github.io/posts/c/inline-asm/","section":"posts","tags":["c"],"title":"GNU C内联汇编学习笔记"},{"categories":["weapons"],"contents":":information_source: 以下命令/脚本的执行环境均为 bash.\n统计代码量  使用到的命令包含: find, wc, xargs, sort 等\n 列出所有的文件及其代码行数, 只统计.c 和.h, 过滤./scripts目录.\n1find -name \u0026#39;*.[c|h]\u0026#39; ! -path \u0026#39;./scripts/*\u0026#39; | xargs wc -l +将内容按照代码行数降序排列\n1find -name \u0026#39;*.[c|h]\u0026#39; ! -path \u0026#39;./scripts/*\u0026#39; | xargs wc -l | sort -rn 若仅列出总的代码行数, 去除空行\n1(find ./ -name \u0026#39;*.[c|h]\u0026#39; -print0 | xargs -0 cat) | sed \u0026#39;/^\\s*$/d\u0026#39; | wc -l 删除目录下所有的可执行文件 1find . -maxdepth 1 -executable -type f | xargs rm 判断执行脚本时带的参数 1if [ $# -ne 1 ]; then 2 echo \u0026#34;ONE parameter is needed\u0026#34; 3 exit -1 4fi 5 6if [ $1 == \u0026#39;build\u0026#39; ]; then 7 # do something 8elif [ $1 == \u0026#39;run\u0026#39; ]; then 9 # do something 10elif [ $1 == \u0026#39;gdb\u0026#39; ]; then 11 # do something 12else 13 echo \u0026#34;Not supported command\u0026#34; 14fi 自动拷贝文件到 SD Card  TODO\n 添加进度条   1#!/bin/bash 2sd_path=$(find /media/$USER -maxdepth 1 -type d -name \u0026#34;*-*\u0026#34;) 3 4while [ ! -d \u0026#34;${sd_path}\u0026#34; ] 5do 6 sleep 1 7 echo \u0026#34;waiting for inserting SD-Card\u0026#34; 8done 9 10echo \u0026#34;SD-Card is inserted\u0026#34; 11cp ./output/kernel/kernel.bin ${sd_path} 12echo \u0026#34;Copy completely\u0026#34; 获取所有文件信息(可递归进入子目录) 获取dir路径下的所有文件的信息, 这里获取的是文件的完整路径.\n TODO\n 操作数组下标的方式可能有待改进? filenum感觉没必要, 暂时还不会改 通过拼接获得文件信息(路径)的方式也有点怪异   1dir=./ 2files=() 3filenum=0 4function getfiles() 5{ 6 for file in `ls $dir`; 7 do 8 if [ -d $file ]; then 9 cd $file 10 getfiles 11 cd .. 12 else 13 files[$filenum]=$(pwd $file)/$(basename $file) 14 # echo file=$(pwd $file)/$(basename $file) 15 let filenum++ 16 fi 17 done 18} 带颜色的输出 使用ANSI escape code\n1Black 0;30 Dark Gray 1;30 2Red 0;31 Light Red 1;31 3Green 0;32 Light Green 1;32 4Brown/Orange 0;33 Yellow 1;33 5Blue 0;34 Light Blue 1;34 6Purple 0;35 Light Purple 1;35 7Cyan 0;36 Light Cyan 1;36 8Light Gray 0;37 White 1;37 Code example:\n1#!/bin/bash 2 3RED=\u0026#39;\\033[0;31m\u0026#39; 4GREEN=\u0026#39;\\033[0;32m\u0026#39; 5YELLOW=\u0026#39;\\033[1;33m\u0026#39; 6BLUE=\u0026#39;\\033[0;34m\u0026#39; 7CYAN=\u0026#39;\\033[0;36m\u0026#39; 8NC=\u0026#39;\\033[0m\u0026#39; # No Color 9 10echo -e \u0026#34;${YELLOW}HELLO, YELLOW${NC}\u0026#34; 11echo -e \u0026#34;${GREEN}HELLO, GREEN${NC}\u0026#34; 12echo -e \u0026#34;${RED}HELLO, RED${NC}\u0026#34; 13echo -e \u0026#34;${BLUE}HELLO, BLUE${NC}\u0026#34; 14echo -e \u0026#34;${CYAN}HELLO, CYAN${NC}\u0026#34; 15 16######################################################### 17# generic functions ##################################### 18 19function ERROR(){ 20 echo -e \u0026#34;${RED}[error] $*${NC}\u0026#34;; 21 exit 1 22} 23 24function INFO { 25 echo -e \u0026#34;${BLUE}[info] $*${NC}\u0026#34;; 26} 27 28function WARN { 29 echo -e \u0026#34;${YELLOW}[warn] $*${NC}\u0026#34;; 30} 31 32function LOG { 33 echo -e \u0026#34;${GREEN}[log] $*${NC}\u0026#34; \u0026gt;\u0026gt; $LOG 34} 35 36INFO \u0026#34;This is an infomation\u0026#34; 37WARN \u0026#34;This is a log\u0026#34; ","date":"2022-07-20T11:54:13+08:00","permalink":"https://wangloo.github.io/posts/shell/shell-script/","section":"posts","tags":["shell","bash"],"title":"武器库: shell scripts"},{"categories":null,"contents":"连续内存取n bit 1#include \u0026lt;stdio.h\u0026gt;2#include \u0026lt;stdint.h\u0026gt;3#include \u0026lt;assert.h\u0026gt;4 5#define bitmask(n) ((1ul \u0026lt;\u0026lt; (n)) - 1) 6 7/* 8* 从ptr指向的内存开始，抽取第start个bit开始的连续n个bit 9* 限制: n \u0026lt; 32 10*/ 11uint32_t extract_bits(uint8_t *ptr, uint32_t start, uint32_t n) 12{ 13 uint32_t start_byte = start / 8; 14 uint32_t start_offset = start % 8; 15 uint32_t *pstart = (uint32_t *)(ptr + start_byte); 16 17 uint32_t end = start + n - 1; 18 uint32_t end_byte = end / 8; 19 uint32_t end_offset = end % 8; 20 uint32_t *pend = (uint32_t *)(ptr + end_byte); 21 22 uint32_t data = *pstart \u0026gt;\u0026gt; start_offset; 23 24 if (n \u0026gt; 32 - start_offset) { 25 /* 由于n \u0026lt; 32, 所以补齐*pend一定就够了， 26* end_offset对齐到最后一位(n-1). 27* 28* 严谨性证明: n 一定\u0026gt; end_offset + 1 29* 因为n \u0026gt; 32-start_offset ==\u0026gt; n \u0026gt; 25, 30* 且end_offset + 1 \u0026lt; 9, 故得证 31*/ 32 data |= *pend \u0026lt;\u0026lt; (n - end_offset - 1); 33 } 34 35 return data \u0026amp; bitmask(n); 36} 37 38void test_val(uint32_t val, uint32_t expect) 39{ 40 if (val != expect) { 41 printf(\u0026#34;error: val: 0x%x, expect: 0x%x\\n\u0026#34;, val, expect); 42 } 43 assert(val == expect); 44} 45 46 47int main(void) 48{ 49 uint32_t vals[] = {0x11223344, 0x11223344}; 50 uint32_t ret; 51 52 ret = extract_bits((uint8_t *)vals, 31, 30); 53 test_val(ret, 0x22446688); 54 55 56 printf(\u0026#34;Test Passed!\\n\u0026#34;); 57 return 0; 58} 一个数取连续n bit 1/* 2* 从一个数中取第start个bit开始的连续n个bit 3*/ 4uint32_t extract_bits (uint32_t val, uint32_t start, uint32_t n) 5{ 6 return (val \u0026gt;\u0026gt; start) \u0026amp; bitmask(n); 7} 判断一个数是否为2的幂 1unsigned int v; 2 3if ((v \u0026amp; (v - 1)) == 0) 4 printf(\u0026#34;v is a power of 2\\n\u0026#34;); 5else 6 printf(\u0026#34;v is not a power of 2\\n\u0026#34;);  统计一个数的二进制中1的数量 依然是利用v \u0026amp; (v -1)的运算结果会将v的最低位的1(如果有的话)置0.\n循环执行此操作就可统计v中1的数量.\n1int numberof1(int v) { 2 int count = 0; 3 4 while(v) { 5 count++; 6 v = v \u0026amp; (v -1); 7 } 8 return count; 9}  将一个数向上取整为2的幂 用一个1一直左移, 直到比这个数大为止.\n1uint32_t roundup_pow_of_two(const uint32_t x) { 2 uint32_t ret = 1; 3 4 while (ret \u0026lt; x) { 5 ret = ret \u0026lt;\u0026lt; 1; 6 } 7 return ret; 8} Linux内核中使用了一种更快的方案, amazing!!!\n1static __inline__ int generic_fls(int x) 2{ 3\tint r = 32; 4 5\tif (!x) 6\treturn 0; 7\tif (!(x \u0026amp; 0xffff0000u)) { 8\tx \u0026lt;\u0026lt;= 16; 9\tr -= 16; 10\t} 11\tif (!(x \u0026amp; 0xff000000u)) { 12\tx \u0026lt;\u0026lt;= 8; 13\tr -= 8; 14\t} 15\tif (!(x \u0026amp; 0xf0000000u)) { 16\tx \u0026lt;\u0026lt;= 4; 17\tr -= 4; 18\t} 19\tif (!(x \u0026amp; 0xc0000000u)) { 20\tx \u0026lt;\u0026lt;= 2; 21\tr -= 2; 22\t} 23\tif (!(x \u0026amp; 0x80000000u)) { 24\tx \u0026lt;\u0026lt;= 1; 25\tr -= 1;1 26\t} 27\treturn r; 28} 29 30static inline unsigned long __attribute_const__ roundup_pow_of_two(unsigned long x) 31{ 32\treturn (1UL \u0026lt;\u0026lt; generic_fls(x - 1)); 33}  向上/向下对齐, 检查是否对齐 1/* uintptr_t 代表指针的位数 2* 加uintptr_t转换的原因是: (void *)不能进行运算 3*/ 4#define IS_ALIGNED(X, align) (((uintptr_t)(const void *)(X)) % (align) == 0) 5#define ALIGN_UP(X, align) (((X) + ((align) - 1)) \u0026amp; ~((align) - 1)) 6#define ALIGN_DOWN(x, align) ((X) \u0026amp; ~((align) - 1)) 7 8#define X (0x12345675) 9#define align (1 \u0026lt;\u0026lt; 2) 10 11int main() 12{ 13 int v = IS_ALIGNED(X, align); 14 15 if (0 == v) { 16 printf(\u0026#34;Given X(0x%x) is not align to 0x%08x\\n\u0026#34;, X, align); 17 printf(\u0026#34;After align up, new X = 0x%x\\n\u0026#34;, ALIGN_UP(X, align)); 18 printf(\u0026#34;After align down, new X = 0x%x\\n\u0026#34;, ALIGN_DOWN(X, align)); 19 } else { 20 printf(\u0026#34;Give X(0x%x) is aligned to 0x%08x\\n\u0026#34;, X, align); 21 printf(\u0026#34;After align up, new X = 0x%x\\n\u0026#34;, ALIGN_UP(X, align)); 22 printf(\u0026#34;After align down, new X = 0x%x\\n\u0026#34;, ALIGN_DOWN(X, align)); 23 } 24 25 return 0; 26}  检查两个有符号数是否异号 1int x,y; 2 3if ((x ^ y) \u0026lt; 0) 4 printf(\u0026#34;They have opposite signs\\n\u0026#34;); 5else 6 printf(\u0026#34;They have same signs\\n\u0026#34;);  大小端转换  对某个位的get/set/clear操作 1#define GET_BIT(x, bit) ( ((x) \u0026amp; (1ULL \u0026lt;\u0026lt; (bit))) \u0026gt;\u0026gt; (bit) ) 2#define SET_BIT(x, bit) ( (x) |= (1ULL \u0026lt;\u0026lt; (bit)) ) 3#define CLEAR_BIT(x, bit) ( (x) \u0026amp;= ~(1ULL \u0026lt;\u0026lt; (bit)) )  Release note:\n 添加对unsigned long long长度的支持    Sign extending from a varaiable bit-width 1 int bits = 2 * 8; // number of bits representing the number in x 2 int x = 0xFFC1; // ready to get sign-extended 3 int rst; // resulting sign-extended number 4 int const mask = 1U \u0026lt;\u0026lt; (bits - 1); // mask can be pre-computed if bits if fixed. 5 6 x = x \u0026amp; ((1U \u0026lt;\u0026lt; bits) - 1); // cut x if it holds more bits 7 rst = (x ^ mask) - mask; // excellent trick! 8 9 printf(\u0026#34;INPUT: 0x%x, RESULT: 0x%x\\n\u0026#34;, x, rst);  字符/字符数组的大小写转换 1#define TO_LOWER(c) (unsigned char)((c \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;Z\u0026#39;) ? (c | 0x20) : c) 2#define TO_UPPER(c) (unsigned char)((c \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;z\u0026#39;) ? (c \u0026amp; ~0x20) : c) 3 4#define TO_LOWER_STR(s, len) { \\ 5for (int i = 0; i \u0026lt; len \u0026amp;\u0026amp; s[i] != \u0026#39;\\0\u0026#39;; i++) { \\ 6s[i] = TO_LOWER(s[i]); \\ 7} \\ 8} 9 10#define TO_UPPER_STR(s, len) {\\ 11for (int i = 0; i \u0026lt; len \u0026amp;\u0026amp; s[i] != \u0026#39;\\0\u0026#39;; i++) { \\ 12s[i] = TO_UPPER(s[i]); \\ 13} \\ 14} ","date":"2022-07-03T09:44:13+08:00","permalink":"https://wangloo.github.io/posts/c/bitops/","section":"posts","tags":["c"],"title":"C 语言位操作技巧"},{"categories":["Operating system"],"contents":" 堆的含义 我们都知道malloc动态申请的变量是存放在堆中. 所以相比栈来说, 堆是动态的.\n堆占据进程虚拟地址空间的大部分, 我们可能通过堆来申请1GB的数组, 但是栈通常不行 , 大多也就几兆的空间.\n 堆空间的管理 进程中堆空间的管理是运行库负责的, 在Linux中是GLIBC.\n运行库在初始化时会像操作系统申请一大块的堆空间, 再为每个进行分别分配需求. 当然, 如果某些程序的需求过大, 运行库也可以使用mmap系统调用直接向操作系统申请, 然后 返回给用户进程.\n GLIBC的malloc函数的处理方式是: 对于小于128KB的申请, 会从运行库\u0026quot;批发的\u0026quot;堆空间 里分出一块来; 但若申请的空间过大, 则使用mmap系统调用来创建匿名空间分配给用户.\n  Linux中虚拟地址块(VMA)的管理使用了红黑树, 可以用于运行库管理自己向操作系统 \u0026ldquo;批发\u0026quot;的堆空间. 使得用户程序动态申请和释放内存性能提高.\n ","date":"2022-06-28T16:41:54+08:00","permalink":"https://wangloo.github.io/posts/os/stack-and-heap/","section":"posts","tags":["Operating system","Virtual memory"],"title":"Stack and Heap"},{"categories":null,"contents":"静态链接带来的问题   像是libc这种几乎每个程序都要用到的库, 如果是静态的, 那么不仅意外着每个程序的 可执行文件很大, 浪费磁盘空间. 并且当程序加载到内存时, 可能许多程序都会用到printf , 使得内存中会存在好多份的printf源码.\n  维护和更新难. 一旦静态链接的其中一个目标文件更新, 所有的可执行程序都要重新链接.\n  不满足局部性原理. 上面提到, 内存中同时存在多份的printf源码会破坏局部性原理的. 显然如果所有的程序共享一份printf源码的想法更好. 即动态加载.\n  可移植性差. 静态链接, 只要有一个依赖目标文件的实现不同, 软件厂商就得专门发布一个 版本. 而动态链接则信赖客户电脑上的动态库, 相当于一个中间层.\n   动态链接的过程 对比静态链接使用ld链接器在编译后即执行链接, 动态链接则是将链接过程推迟到运行时, 即装载到内存时.\n这样, 链接器在链接产生可执行文件时就有两种做法:\n 对于静态符号, 按照静态链接的规则进行地址引用重定位 对于动态符号, 链接器则仅标记其为动态链接中的符号, 不进行处理. 而是等到装载时由 专门的动态链接器来完成动态符号的链接工作.  :interrobang: 链接器如何确定一个符号是静态的or动态的?\n在动态共享对象(.so)中保存了完整的动态符号表*, 表中存在的符号即为动态的, 否则为静态.\n Linux的C语言运行库glib的动态链接版本叫libc.so. 它在外存上只保存一份, 所有的程序 都可以在运行时使用它. 所以千万不要删掉它.\n  动态链接有一定的性能损失, 因为每次运行程序时都要重新链接, 并不像静态链接是一劳永逸的. 也有例如延迟绑定对性能进行优化的方法, 大概仅有5%的损耗, 与带来的便利相比可以忽略不计.\n  地址无关代码 PIC GCC生成动态库时需要添加参数-fPIC, 含义就是生成地址无关码\n地址无关码的含义是代码中不包含任何的绝对地址引用, 全都是相对地址.\n 对于模块内的跳转/数据引用, 使用相对的跳转/加载指令. 例如ARM指令集中的B, ADR, 经过汇编器之后, 目标的地址都会转为相对于该指令(PC)的偏移. 对于模块间的跳转/数据引用, 借用GOT表来间接实现地址无关.  而如果该动态库中全部使用相对地址, 那么加载时也就不需要进行重定位, 即所有的程序都可以 共享这些地址无关代码.\n 上面说PIC的动态库不需要重定位其实是错误的, 只不过它的重定位过程不需要修改代码段, 而是设置了一个放置在数据段的GOT表来实现代码段部分的地址无关特性.\n  现在貌似GCC ARM版本在编译动态库时强制使用-fPIC选项, 否则会报错. 对此我不是 非常确定!\n  一般来说, 不将主程序编译为地址无关码. 因为主程序不需要共享, 而且地址无关码的调用 需要两个指令: 计算地址 + 跳转. 多了一步根据偏移得到绝对地址.\n ","date":"2022-06-26T19:50:45+08:00","permalink":"https://wangloo.github.io/posts/os/dynamic-link/","section":"posts","tags":["Operating System"],"title":"动态链接"},{"categories":null,"contents":"ELF不只是可执行文件 Files in ELF format includes:\n   Type description 实例     Relocatable File 这些文件包含了代码和data, 可以被用来链接成可执行文件或共享目标文件. .o, .a   Executable File 直接可执行的文件 /bin/ls   Shared Object File Including code and data. 链接器可将其与其他Relocatable File或Shared Object File结合, 生成新的目标文件. 动态链接器可将其与Executable File结合, 作为进程映像的一部分来运行. .so   Core Dump File Restore critical infomation when process is terminated unexpectedly core dump     :pushpin: file command in Linux can output the format of a file.\n ELF 文件组成的结构 1+---------------------------------+ 2| ELF Header | 包含描述整个ELF的基本信息, 如版本, 入口地址... 3+---------------------------------+ 4| .text | 5+---------------------------------+ 6| .data | 7+---------------------------------+ 紧接着是各个段 8| .bss | 9+---------------------------------+ 10| ... | 11| other sections | 12+---------------------------------+ 13| | 与section相关最重要的结构 14| Section Header table | 描述了每个section的名称,长度,权限... 15| | 16+---------------------------------+ 17| | 与segment相关最重要的结构 18| Program Header table | 描述了每个segment的位置、属性(RWX)、size... 19| | 20+---------------------------------+ 21| String tables | 22| Symbol tables | 23+---------------------------------+ ELF Header    字段 含义     e_machine 目标架构   e_entry 入口地址   e_machine 目标架构   e_phnum number of entries in the program header table   e_shnum number of entries in the section header table   e_shoff offset, in bytes, of the section header table   e_phoff offset, in bytes, of the program header table   e_machine 目标架构   e_machine 目标架构    Program Header Table 每个表项对应一个segment，表明其位置、属性(LOAD?动态链接用?)、memory size和file size，权限(RWX)等。\n Memory Size \u0026gt;= Segment Size, 因为有BSS段存在。\n Section Header Table 相应地，每个表项指定一个section的信息，包括名字、大小、地址等。\n为什么要区分section和segment segment是加载关心的, section是链接过程关心的。\n segment中包含了多个section, 这些section地址相连、属性类似, 加载器只按照segment去加载。 而链接时, 链接器会对每个section进行重定位, 同时也需要 .rel* section来完成重定位。 调试信息也是按照section进行存储的，调试器依赖他们得到符号信息。  加载ELF时要将AUX信息放在栈底， AUX是什么 AUX全称Auxiliary Information，即辅助信息。\n输出一个ELF的AUX:\n1~ $ LD_SHOW_AUXV=1 /bin/ls 2AT_SYSINFO_EHDR: 0x7ffc3b3de000 3AT_HWCAP: 1f8bfbff 4AT_PAGESZ: 4096 5AT_CLKTCK: 100 6AT_PHDR: 0x55a318711040 7AT_PHENT: 56 8AT_PHNUM: 13 9AT_BASE: 0x7f0f5ac91000 10AT_FLAGS: 0x0 11AT_ENTRY: 0x55a3187177d0 12AT_UID: 1000 13AT_EUID: 1000 14AT_GID: 1000 15AT_EGID: 1000 16AT_SECURE: 0 17AT_RANDOM: 0x7ffc3b272ab9 18AT_HWCAP2: 0x2 19AT_EXECFN: /bin/ls 20AT_PLATFORM: x86_64 AUX是内核加载用户程序时可以将ELF的一些信息传到用户态，该应用可以读取。 通常用于加载某个外部解释器，一般程序员用不到。\n链接 链接即多个.o生成最终可执行程序的过程，编译时对于外部的函数，编译器无法确定实际跳转的地址， 只能先写0，链接过程会对这个值进行修改。\n主要包含两个过程：（1）地址空间分配（2）重定位\n 地址空间分配：这么多.o，这么多section，他们结合为可执行文件后地址怎么规划呢？是不是有的 section 可以合并，比如多个代码段。 重定位：对于外部调用的函数，这些实际的值也需要更正，或者采用别的方法来间接寻址（动态链接）  静态链接 重定位\n合并后的每个section都有一个重定位表，.rel.xx， 里面的内容大概是:\n1RELOCATION RECORDS FOR [.text]: 2OFFSET TYPE VALUE 30000001c R_386_32 shared 400000027 R_386_PC32 swap 对于每个需要重定位的指令，都会在这里表里对应到，所以链接时需要遍历它，填充上真正的地址。\n动态链接 静态链接的做法就决定了，程序A和B不能共享同一份库，浪费内存。库编进了可执行文件中，所以生成的可执行文件就很大， 另外这样如果要修改库的话就需要对所有依赖的A和B都重新编译。\n动态链接是目的是解决上面的问题，也就是说，库不编到ELF里，ELF在运行的时候能找到它就行。 这样一个程序编译链接后其实不能确定库的地址\nELF加载  废了半天劲编译生成的ELF文件, 想要最终跑起来则包含的instruction and data必须要在内存中.\n 我们能想到的最简单的办法是: 把整个ELF的所有指令和数据在运行之前就全部load到内存中. 这就是静态加载.\n更加高效的做法是: 充分利用局部性原理, 将指令和数据划分为模块, 只有当该模块被使用时, 才load进内存, 否则就在外存中老老实实呆着. 这就是动态加载.\n静态加载  读取ELF header, 校验magic number和架构是否正确 根据ELF header中指定的 program header table地址去读 segments 加载segments 中属性为LOAD的segment, 先要分配对应的虚拟空间, 根据ELF的LMA 加载程序为ELF分配栈空间，并填充argc, argv，env等。 将PC设置为ELF header中entry point, 返回到用户态开始执行  动态加载 没什么好说的，就是第一次加载时只分配页表，建立映射，并不实际分配物理空间。\n分析ELF文件的工具 1. objdump 2. readelf 常用参数:\n1readelf -S xxx.elf # display section header table 2readelf -h xxx.elf # display ELF header 为什么目标文件中代码和数据要分开放? 一方面, 程序被加载进内存后, 代码段和数据段分别被映射到两个virtual memory region. 通过MMU的支持, 可以将代码段的区域设置为只读, 防止恶意篡改.\n另一方面, 当下CPU Cache多划分为Instruction Cache和Data Cache, 再配合互相独立的 地址区域能够提高局部性原理的效果.\n最后, 代码段可以被多个进程共享(例如都调用同一外部函数), 节省内存空间.\n 针对嵌入式设备, 如果内存空间不够大, 只读的代码段可存放在ROM中\n  关于静态库 一个静态库可以简单的看作是 a set of object file.\n这些 object file 可能包括: 输入输出相关的printf.o, scanf.o, 日期时间相关的time.o, date.o等.\n:question: 为什么不直接提供这些目标文件呢?\n这些零散的文件若直接提供给使用者, 很大程度上造成文件传输, 管理等方面的不便.\n于是人们通常使用ar压缩程序将这些目标文件压缩到一起.\n:question: 如何查看一个静态库是由哪些object file压缩到一起的?\nShell commandar -t libc.a 可以查看libc.a中包含的所有object files.\n 段地址对齐技术  由前面动态加载的步骤可知, ELF文件中的代码和数据被按page划分. 并只有在用到时才被加载到内存, 并建立虚拟内存-物理内存的映射.\n 假设一个ELF有三个段需要被LOAD, ELF段表如下:\n   Segment Length offset     SEG 0 127 B 34 B   SEG 1 9899 B 164 B   SEG 2 1988 B 0 B    :question: 这三个段在ELF文件中的布局如何? 根据前面ELF文件格式的介绍, 这三个段必然是挨着的(简单考虑, ELF中仅有这三个段).\n:question: 这三个段在物理内存中的布局? 发生page fault之后, OS会为页面分配合适的物理页面, 如利用buddy system等.\n可以保证段内的连续, 不能保证段与段是连续的.\n 未使用段对齐技术之前, SEG0的长度不足一页, 但是也给它分配一页的空间. 同理为SEG1分配两页, SEG2分配一页. 总共占用 1+2+1=5个物理页.\n :question: 这三个段在用户virtual addrspace下的布局如何? todo\n:question: 何为段地址对齐技术? 上面说了, 在为这三个段分配物理内存时, 虽然他们的真实大小远小于5个页面, 但由于简单采用: 每个段的开头必须是page align, 导致实际上产生了巨大的内部碎片.\n段地址对齐实际上就是在为ELF文件中的段分配物理内存时, 不考虑其段的独立性, 强制按照page来划分. 划分的行为如下图所示. 结果就是仅需占用3个物理页面.\n1+---+---------------+ 2| P | SEG0 | 3| A +---------------+ 4| G | | 5| E | | 6+---+ | 7| P | SEG1 | 8| A | | 9| G | | 10| E | | 11+---+ | 12| P +---------------+ 13| A | | 14| G | SEG2 | 15| E | | 16+---+---------------+  目前, gcc(更准确是说是GUN ld)默认启用段对齐技术. 各个段的虚拟地址并不是page align.\n  :four_leaf_clover: 物理页面到虚拟页面的映射阶段, 那些同时包含两个段的页面会被映射两次, 即一个物理页面对应两个 虚拟页.\n原因是: 在一个页面的不同段可能权限不同, 所以不能使用同一映射.\n ","date":"2022-06-20T16:21:27+08:00","permalink":"https://wangloo.github.io/posts/os/elf-format/","section":"posts","tags":["Operating System"],"title":"ELF 文件的链接与加载"},{"categories":null,"contents":"添加更多的编译选项(comiler options)来防止bug 对于我常用的GCC, 推荐开启一下的compiler options:\n  -Wall: enable a lot of common warnings\n  -Wno-format-truncation: warns about the snprintf output buffer not being large enough for a corresponding “%s” in the format string.\n  -Werror: turn warnings into errors.\n   动态申请的空间到底要不要释放 When using a barebones embedded OS, you absolutely need to tightly manage your memory.\n但是, 如果你是写应用业务的代码, 特别是在内存足够的场景下. 最好不要手动释放内存, 因为当线程/进程退出时, 操作系统会自动帮我们释放. 某些情况下, 释放内存的操作会很大程度上增加逻辑的复杂度.\n 如果你是一个内核程序员, 则必须手动的释放. 不用怀疑.\n  尽可能在创建变量时赋初值 放置某些变量创建后是 magic value. 而使用这些变量可能不会立马导致错误, 但是这是一个隐患.\n但这会产生一个问题, 有时我们定义变量之后的不久之后就会对其赋予正确的值, 这时候初值就是 多余的. 而且维护者可能认为这个值是meaningful, 这就要求我们如果要赋初值, 就要说明这个值 仅仅是无意义的初值.\n 使用#define, enum 对于代码在不同地方使用的同一个值, 应使用#define来声明使得代码maintainable.\n如果这些值有多个且能规划为同一类别, 则还可将#define的方式换为enum. 这会使代码更加meaningful\n 使用enum使还要注意其所占内存空间在不同架构中可能不同的问题, see enum的优势和漏洞\n  使用typedef优化function pointer  重定义一套自己的类型 在开发大项目时, 需要考虑可移植性的情况下, 最好利用typedef对类型进行重定义.\n1#if SYSTEM1 2 typedef int INT32; 3 ... 4#else 5 typedef long INT32; 6 ... 7#endif 如上, 对于某些架构int类型可能不是32bit, 此时就要使用long. 这种定义的方式会保证我们的系统 在任何架构中都不会出现类型的bug. 而且也增加了代码的readability.\n 善用~0 在做嵌入式编程时, 有时在设置掩码(mask)或者其他情况会要用到全1的变量值, 你是否经常这样声明?\n1int mask = 0xffff; 暂且不谈int类型到底占多少字节的问题. 就像上面一样, 我们程序员经常忘记某个类型的大小, 而少添加了f. 会导致变量mask的值不是全1(32位情况下).\n这是要变换一下思维, 使用~0的定义方法就可轻松化解, 无需管变量的类型是什么.\n1int mask = ~0;  合理的使用goto语句 在大学课堂中, 我们老师说过禁止使用goto语句, 但却没有给出明确的原因.\n实际上, 合理的使用goto能够极大的减少程序的冗余度.\ngoto语句常用于程序出现错误要退出时, 可能有多个情况会使用重复的代码处理, 例如释放一些allocated memory. 相较于使用flag, 使用goto显然更加clearly and readability.\n所以, 在面对重复的错误处理代码时, 想想能不能用goto进行优化. 当然, 避免过早优化.\n 注意, goto出现的场景其实很受限. Never use a backward goto or jump into control statements.\n  定义合理, 正确的结构体 结构体是C语言编程应用中常用的数据结构, 关于结构体也有许多要注意的点.\n#1 Flexible Array Member C99开始支持Flexible Array Member. 且看我lstring库的结构体定义:\n1struct str { 2 int length; 3 int size; 4 char data[]; // Flexible array member - C99 only 5}; 对于这种不定长的数组元素, 我之前都是定义一个指针, 占用一个sizeof(char *)的空间. 而Flexible Array Member本身不占用空间. 需要在malloc时为他单独声明空间.\n1int n = 100 2struct str *s = malloc(sizeof(struct str) + sizeof(char[n]));  这里也有一个小trick, 使用sizeof(char[n]) 比 sizeof(char) * n 更简洁!\n # 2 Padding and Packed 有关结构体的大小, 和地址对齐的问题. 假设我有一个结构体如下:\n1struct mystruct_A 2{ 3 char a; int b; char c; 4} x; Padding是编译器对结构体默认做的事情. 它会在成员之间插入一些 gap 来保证地址对齐:\n1struct mystruct_A { 2 char a; 3 char gap_0[3]; /* inserted by compiler: for alignment of b */ 4 int b; /* int 在32位上其地址是4字节对齐的 */ 5 char c; 6 char gap_1[3]; /* -\u0026#34;-: for alignment of the whole struct in an array */ 7} x;  除了保证每个成员的地址是对齐的, 整个结构体的地址也是按照其最大的成员类型来对齐, 即对齐到int(4字节).\n 如果你不想要这些 gap, 那么可以对结构体声明使用 __attribute__((__packed__))关键字. 整个结构体大小仅为6个字节.\n1struct __attribute__((__packed__)) mystruct_A { 2 char a; 3 int b; 4 char c; 5};  永远为你的函数设置error return value 一旦你的函数可能被其他人调用, 那么养成设置return value的习惯. 即便你现在的实现 并不会产生任何错误, 也请返回success.\n这样做的原因是, caller可以根据你的定义做错误判断, 即便以后你的实现加上了出错情况, 上层的代码也不需要修改.\n 变量类型的选择  名字, 特定不变的字符串使用const char *, 甚至const char const* 长度使用size_t 表示类型的参数尽可能使用enum 循环变量i使用signed, 避免溢出后出错   Reference How I Improve My (C) Code Quality\nTen Fallacies of Good C Code\n","date":"2022-06-14T17:59:22+08:00","permalink":"https://wangloo.github.io/posts/codestyle/improve_quality/","section":"posts","tags":["c"],"title":"写高质量的C语言工程的技巧"},{"categories":null,"contents":"seL4 Capabilities In seL4, capabilities are stored in C-space. C-space is a hierarchical data structure very similar to page table.\n page table is a mapping from virtual address to physical address. C-space is a mapping from object ID to capability. Kernel object is made up of several C-nodes, just like a page table made up of individual page tables. Each C-nodes is an array of cap slots, which contain capability.  Inaccessible to userland, you can never hold an actual capability\n You can only hold a reference to capability, which pointers into C-space(slot addresses) These C-space addresses are called CPTRs   You don\u0026rsquo;t need to do the transform, because this is typically extracted in some libs.\n Capabilities convey specific privilege (acces rights)\n Read, Write, Execute, GrantReply(call), Grant(cap transfer)  Main operations on capabilities:\n Invokeperform operation on object referred to by cap.  For example, map some frame into memory. You need to have capabilities to both the frame and address space.   Copy|Mint|Grant: create copy of cap with same/lesser privilege. Move|Mutate: transfer to different address with same/lesser privilege.  Between C-space or within C-space.   Delete: invalidate slot(cleans up object if this is the only cap to it) Revoke: delete any derived(eg. copied or minted) caps  Capability Derivation MINT OPERATION The Mint operation creates a new, less powerful cap\n Can add badge Can strip access rights, eg RW-\u0026gt;RO  1mint(dest, src, rights, badge)  The first two arguement are capability pointers(CPTR) to a C-space(represented by C-node), which are references inside C-node. The destination C-node cap must allow modification Then you have the rights and the batch of the new cap.  :pushpin: This is an alternative of sending addressed capabilities by IPC operation. That is what operating system do to set up protection domains for user level process.\nCOPY OPERATION  Copy as a version of Mint.\n  seL4 Kernel Objects In file libsel4\\include\\sel4\\objecttype.h\n1typedef enum api_object { 2 seL4_UntypedObject, 3 seL4_TCBObject, 4 seL4_EndpointObject, 5 seL4_NotificationObject, 6 seL4_CapTableObject, 7#ifdef CONFIG_KERNEL_MCS 8 seL4_SchedContextObject, 9 seL4_ReplyObject, 10#endif 11 seL4_NonArchObjectTypeCount, 12} seL4_ObjectType;  seL4 System Calls seL4 has 11 syscalls:\nYield(): invokes scheduler\n does NOT require a capability!  Send(),Recv() and variants/combinations thereof: IPC operations\n Call(),ReplyRecv(): usually invokes by client/server Send(), NBSend(): send-only and non-blocking version of it. Recv(), NBRecv(), NBSendRecv() Wait(), NBWait(), NBSendWait()   We just use Call() normally, the others are only for bootstrapping protocols and exception handling.\n Call() is atomic Send() + reply-object setup + Wait()\n cannot be simulated with one-way operations!  ReplyRecv() is NBSend() + Recv()\nDifferent object support different operations ENDPOINTS Endpoints support all 10 IPC variants.\nNOTIFICATIONS Notifications support:\n NBSend() - aliased as Signal() Wait() NBWait() - aliased as Poll()  OTHER OBJECTS Other objects only supports Call() operation.\n Appear as (kernel-implemented) servers. If you invoking a method on an object, this is done by treating the object as a kernel-implemented server. And you invoke it with a call() operation just as you do a normal server invocation. Each of these kernel objects has a different kernel-defined protocol  operations encoded in message tag parameters passed in message words   Mostly hidden behind syscall wrappers, user do not need to know this details.   seL4 IPC  IPC in seL4 is a way to realize cross-domain invocation.\n seL4 IPC is not a mechanism for shipping data. Transfering data is axillary but not the primary purpose.\nseL4 IPC is a protected procedure call, a user-controlled context switch(from clients context into server context).\n seL4 Threads Creating a thread  Obtain a TCB object Set attributes: V-space, C-space, fault endpoint, IPC buffer Set Scheduling parameters:  priority, scheduling context, timeout endpoint(maybe MCP)   Set architecture-related registers  Threads and Stacks Stacks are completely user-managed, kernel doesn\u0026rsquo;t care!\n Kernel only preserves SP.. on context switch\n Stack location, allocation, size must be managed by userland.\nKernel beware of stack overflow\n","date":"2022-06-04T11:52:51+08:00","permalink":"https://wangloo.github.io/posts/microkernel/sel4/","section":"posts","tags":null,"title":"MicroKernel Learning: SeL4"},{"categories":["hugo"],"contents":"HuGo 基础学习 本章将解答Hugo是什么, 以及Hugo是如何工作的. 只有了解Hugo的工作机制之后, 才能发挥想象力进行DIY.\n本章内容大多来自官方手册或者搜索引擎提供的结果.\nHugo 项目目录结构 一个hugo 项目通常包含以下内容:\n1. 2├── archetypes 3├── config.toml 4├── content 5├── data 6├── layouts 7├── public 8├── static 9└── themes 这里面有些是必须的, 有些是可选的.\narchetypes\n定义新创建post时, header的格式.\nasserts\n Note: assets directory is not created by default.\n config\nHugo uses the config.toml, config.yaml, or config.json (if found in the site root) as the default site config file.\nThe user can choose to override that default with one or more site config files using the command-line --config switch.\n1hugo --config debugconfig.toml 2hugo --config a.toml,b.toml,c.toml  Note: config directory is not created by default.\n content\n显然, 存储所有的post.\ndata\nThis directory is used to store configuration files that can be used by Hugo when generating your website.\n像是你 website 的一个mini 数据库, 你可以放置 toml, yaml, json格式的文件.\nlayouts\nStores templates in the form of .html files that specify how views of your content will be rendered into a static website. Templates include list pages, your homepage, taxonomy templates, partials, single page templates, and more.\npublic\n保存build生成的站点. 当运行hugo [flag]时生成.\n拷贝该目录下的内容, 可以部署到web 服务器上了.\nstatic\nStores all the static content: images, CSS, JavaScript, etc. 当Hugo构建您的站点时，静态目录中的所有资源都会按原样复制。\n即当构建website时, static/下的所有文件都会复制到 public/下.\nThe static files are served on the site root path (eg. if you have the file static/image.png you can access it using http://{server-url}/image.png, to include it in a document you can use ![Example image](/image.png) ).\nresources\n一些缓存文件\n Note: resources directory is not created by default.\n Hugo CLI 命令 hugo 支持的所有命令可以通过 hugo help 命令来查看. 每一条命令的具体用法, 可以执行 hugo [command] help 来查看\n1Usage: 2 hugo [flags] 3 hugo [command] Hugo completion 用来配置补全 hugo command 和 flag 的. 该命令会输出一段脚本, 将该脚本复制到你的 shell 的配置文件中就可以使用 hugo tab 补全了.\nhugo config 打印hugo的配置文件, 即根目录下的 config.toml.\nhugo env 打印 hugo 的版本和环境信息\nhugo list 打印所有post的info, 包含标题, 发布日志, 链接等.\nhugo new 非常重要的命令, 可以用来新建一个 website, 主题, 或者一篇post(常用). 带有许多 flag可以使用.\nhugo server 执行hugo server之后, 首先构建了你的网站(但是默认并不在本地创建文件, 而是放在内存), 然后启动hugo 自带的 web服务器让我们能看见网站的效果.\n同时, 默认情况下, server 会同步你的本地更改, 然后实时的reload你的页面. 这样你就能同时看到修改的效果.\nhugo server 的常用flag:\n1-D 包含标记为草稿的post. 默认不构建草稿. 2--theme strings 使用[strings]主题进行构建 hugo [flags] hugo 自身就是一个命令, 用于build website, 放到 public/目录下.\n常用 Flag(All supported flags):\n1--gc 在build后会清除一些cache文件. 与 resource/有关 2--minify minify any supported output format (HTML, XML etc.)  hugo 命令不会删除之前的文件. 而是仅新增改动. 所以每次build时需要你手动删除 public/ 目录.\n Hugo 内容管理 hugo build 后的website页面的布局和你源文件的布局相同, 所有源文件都放置在 content/ 目录下.\n1└── content 2 ├── _index.md // \u0026lt;- https://example.com 3 | 4 ├── about 5 | └── index.md // \u0026lt;- https://example.com/about/ 6 ├── posts 7 | ├── _index.md // https://example.com/posts/ 8 | ├── firstpost.md // \u0026lt;- https://example.com/posts/firstpost/ 9 | ├── happy 10 | | └── ness.md // \u0026lt;- https://example.com/posts/happy/ness/ 11 | └── secondpost.md // \u0026lt;- https://example.com/posts/secondpost/ 12 └── quote 13 ├── first.md // \u0026lt;- https://example.com/quote/first/ 14 └── second.md // \u0026lt;- https://example.com/quote/second/  hugo 将content/ 下的那级目录(例如 content/posts)特殊看待, 称为 section.\n 页面资源(Page Resources) 页面资源指每个页面私有的图片, 文档等静态资源. 与static/ 中全局的资源不同.\n页面资源放在content/下的任意位置, 但不是所有页面都能访问. page bundles 中的index.md or _index.md 能够访问该 bundles 下的资源.\n1content 2└── post 3 ├── first-post 4 │ ├── images 5 │ │ ├── a.jpg 6 │ │ ├── b.jpg 7 │ │ └── c.jpg 8 │ ├── index.md (root of page bundle, 能够访问first-post/下的所有资源) 9 │ ├── notice.md 不能访问任何资源, 但其自身作为一个资源可被index.md访问 10 │ ├── office.mp3 11 │ ├── pocket.mp4 12 │ ├── rating.pdf 13 │ └── safety.txt 14 └── second-post 15 └── index.md (root of page bundle, 但不能访问first-post/下的资源) 内容分类(Taxonomy) Taxonomy: How to group the content together. Two default taxonomies are tags and categories.\n代码高亮(Syntax Highlighter) 代码高亮的配置(in config.toml):\n页面分类 从布局上来看, 页面可以分为两类: List page 和 single page.\n显而易见, list page比较特殊, 它负责列出当前目录下的所有post. 所以一个目录地址必然是一个list page.\n在下面的例子中, https://example.com , https://example.com/posts/happy/ 都可以叫做 list page.\n  https://example.com/posts/happy/ 是list page, 目录下的_index.md 不是必须的, hugo 会默认仅显示所有post的title. 详见\n  https://example.com/about/ 不是list page, 因为其目录下有index.md, 强制表明这是一个 single page. 详见\n  1└── content 2 ├── _index.md // \u0026lt;- https://example.com 3 | 4 ├── about 5 | └── index.md // \u0026lt;- https://example.com/about/ 6 └── posts 7 ├── _index.md // https://example.com/posts/ 8 ├── firstpost.md // \u0026lt;- https://example.com/posts/firstpost/ 9 ├── happy 10 | └── ness.md // \u0026lt;- https://example.com/posts/happy/ness/ 11 └── secondpost.md // \u0026lt;- https://example.com/posts/secondpost/  Homepage 和 section page 都属于特殊的 list page.\n homepage 特指 content/_index.md section page 特指 content/[section]/_index.md   shortcodes shortcode 可以理解为 hugo 为了封装了一些代码块, 通过 shortcode 来调用.\n模板(Template) 模板是hugo的一个高级用法, 用来定义你网站的style. 模板不等同与主题(themes), 可以理解为主题是一套模板的集合. 我们可以在使用模板的同时添加DIY的 style. 😎 Hugo 会有优先级的判断.\n不同的页面类型需要定义不同的模板. List page 的模板称为 List template, single page 的模板称为 single template. 同理还有 homepage template, section template.\n存储模板的目录为layout/, 上面介绍hugo的目录结构时已经说过. 如果你使用了一个 theme, 那么themes/[your-theme]/layout/就是该theme的模板.\nhomepage 模板 Base 模板 对应layouts/_default/baseof.html\nbase 模板是整个website的核心. 所有的模板包括 list template, single template, homepage template\u0026hellip; 都是独立的, base template 将其他的模板联系到一起.\npartial 模板 包含网站的许多元素, 增加模块化. 我可以为网站的 header 或者 footer 写一个模板(html), 这些HTML可以嵌入其他的模板.\n模板优先级 既然同一种页面的模板可以定义在多个位置, 如果他们同时存在时, 优先级规则必然存在. 常见的情况比如我们使用了某个模板, 然而, 我们对模板中的一些布局不满意, 直接修改模板中的文件显然不是一个好方法, 那么该怎么做呢?\n一般来说, 如果你只想重写theme中的某个模板, 例如section template. 那么你只需要新建 layout/_default/section.html 即可, hugo 构建你的网站时, 如果检测到本地和theme的layout/_default下都有 section.html, 它会使用我们自己定义的那个.\n 完整的, 多级的优先级规则: Hugo\u0026rsquo;s Lookup Order | Hugo (gohugo.io)\n 变量(Variables) ❗ Hugo 变量仅设计给模板使用, 即在layouts/下的html文件.\nPage Variables 与post相关的变量, 定义在post 的 front matter中.\n1// Define Page variables in front matter of post 2---------------- 3title: \u0026#34;使用 HuGo 搭建个人网站\u0026#34; 4description: 学习正确的 Hugo 食用方式, DIY 属于自己的 website~ 5Myvar: \u0026#34;my value\u0026#34; 6---------------- 7 8// Use Page Variables 9{{.Description}} // Get the description of the post 10{{.Params.Myvar}} // Get the value of Myvar, that is, \u0026#34;my value\u0026#34; Site Variables 站点层面的变量大部分是网站配置相关.\n函数(Functions) 函数是hugo为你封装的一些方法你可以直接调用.\n❗ Hugo 函数仅设计给模板使用, 即在layouts/下的html文件. Same as variables.\nHugo pipes DIY My Own Website 支持 Emoji Adding emoji tutorial\nEmoji chart\nTODO List  深色和浅色模式使用 不同的代码高亮 格式 Post section page 添加简介 Single template 调整 Header\u0026rsquo;s margin  ","date":"2022-05-21T17:39:42+08:00","permalink":"https://wangloo.github.io/posts/hugo/basic/","section":"posts","tags":["hugo"],"title":"使用 HuGo 搭建个人网站"},{"categories":["motivation"],"contents":"Content Fourteen years ago, Steve stood on this stage and told your predecessors \u0026ldquo;Your time is limited. So don\u0026rsquo;t waste is living someone else\u0026rsquo;s life.\u0026rdquo;\nSo what is true then is true now. Don\u0026rsquo;t waste your time living someone else\u0026rsquo;s life. Don\u0026rsquo;t try to emulate the people who came before you to the exclusion of everything else, contorting into a shape that doesn\u0026rsquo;t fit.\nGraduates, the fact is, when your time comes, and it will, you will never be ready. But you\u0026rsquo;re not suppposed to be. Find the hope in the unexpected. Find the hope int the challenge. Find your vision on the solitary road. Don\u0026rsquo;t get distracted. There are too many people who want credit without responsibility. Too many who show up for the ribbon cutting without building anything worth a damn.\nBe different. Leave something worthy. And always remember that you can\u0026rsquo;t take it with you. You\u0026rsquo;re going to have to pass it on.\nThank you very much. And Congratulations to the Class of 2019!\nYouTube vidio\n","date":"2022-05-18T19:32:38+08:00","permalink":"https://wangloo.github.io/posts/motivation/2019-stanford-commencement-timcook/","section":"posts","tags":["tim cook","address"],"title":"2019 Stanford Commencement Timcook"},{"categories":["note"],"contents":"Get start What is HTML\u0026amp;CSS?   HTML is resonsible for the content of the page. That\u0026rsquo;s the text, images, buttons, etc.\n  CSS is resonsible for the presentation of the content. That\u0026rsquo;s the color, layout, etc.\n  Web designers create the overall look and fell of a website.\n  Web developers implement the design using HTML, CSS and JavaScript code.\n  Configure VIM as HTML code-editor  Finally in the arms of vscode :hear_no_evil:\n Add vim plugin:\n emmet: Coding HTML faster.  CSS autocomplete key: \u0026lt;C-x\u0026gt; \u0026lt;C-o\u0026gt;\nHTML and CSS live previes plugin: bracey\n urlopen error solution   HTML Fundamentals Anatomy of an HTML element 1\u0026lt;p\u0026gt; THML is a markup language\u0026lt;/p\u0026gt; The HTML element is composed of opening tag, content, closing tag.\nHTML good styles  \u0026lt;img/\u0026gt; element should add alt attritube at all time, for the convenience of the blind. An important principle in web design is making the HTML elements meaningful. That is semantic HTML.   CSS Fundamentals CSS describes the visual style and presentation of the contend in HTML.\nAnatomy of an HTML element 1h1 { 2 color: blue; 3 text-align: center; 4 font-size: 20px; 5} h1 is Seletor, every style has proporty and value.\nCSS good styles  Class selector is more commonly used than ID selector, as ID is unique in HTML. For scalability, remember always using class selector. We should always specify all the four state of \u0026lt;a\u0026gt; element in order, which including link, visited, hover and active.  Priority conflicts between selectors CSS style priority from high to low:\n Inline style(style attribute in HTML) ID selector class or pseudo-class selector element selector universal element selector   The CSS box model The box model defines how elements are displayed on a webpage and how they are sized.\nIn the box model, every element on a webpage can be seen as a rectangular box.\n Universal element \u0026amp; \u0026lt;body\u0026gt; element Styles in \u0026lt;body\u0026gt; selector take effect because of inheritance. But the text-independent elements do not support inheritance.\nThat is where universal element selector is needed. It\u0026rsquo;s styles take effect on all element.\nWhen we want to set padding and margin of all elements to 0. Must put the code in universal element selector.\n Inline elements \u0026amp; Block elements Inline elements:\n Occupies only the space necessary for its content. Box model applies in different way: heights and widths do no apply. Paddings and margins are applied only horizontally(left and right).  Block elements:\n 100% of parent\u0026rsquo;s width vertivally, one after another  Inline-Block elements:\n Good example is \u0026lt;img\u0026gt;.   The 3 ways of building layouts with CSS Float Layouts: The old way of building layouts, using the float CSS property. Still used, but getting outdated fase.\n Element is removed from the normal flow: out of flow. Like absolutely positioning. Text and inline elements will wrap around the floated elements. Different from absolutely elements. The container will NOT adjust its height to the elements.  FlexBox: Modern way of laying out elements in a 1-dimensional row without using floats. Prefect for component layouts.\n One of its most useful applications is vertical centering. Flex container property:  gap: To create space between items. justify-content: To align items along main axis(horizontally, by default) align-items: To align items along cross axis(vertically, by dedauly) flex-wrap: To allow items to wrap into a new line if they are too large align-content: Only applies when there are multiple lines(flex-wrap: wrap)   Flex Items property:  align-self: To overwrite align-items for individual flex items. flex-grow: To allow an element to grow. flex-shrink: To allow an element to shrink. flex-basis: To define an item\u0026rsquo;s width, instead of the width property. flex: Recommended shorthand for flex-grow, -shrink, -basis.    CSS Grid: For laying out elements in a fully-fledged 2-dimensional grid. Perfect for page layouts and complex components.\n  CSS grid is a set of CSS properties for building 2-dimensional layouts\n  The main idea behind CSS Grid is that we divide a container element into rows and columns that can be filled with its child elements\n  CSS grid is not meant to replace flexbox!. Instead, they work perfectly together. Need a 1D layouts? Use flexbox. Need a 2D layout? Use CSS grid\n  Grid container\n grid-template-rows/grid-template-columns: To establish the grid row and column tracks. One length uniit for each track. Any unit can be used, new fr fills unused space row-gap/colum-gap: To create empty space between tracks justify-items/align-items: To align items inside rows/columns(horizontally/vertically)    Grid items\n grid-column/grid-row: To place a grid item into a specific cell, based on line numbers. span keyword can be used to span an item across more cells justify-self/align-self: To overwrite justify-items/align-items for single items    ","date":"2022-05-17T11:02:04+08:00","permalink":"https://wangloo.github.io/posts/html-css/0/","section":"posts","tags":["html","css"],"title":"Html Css Learning note (0)"},{"categories":["vim"],"contents":"Search a word quickly: put cursor on the word, press / and press \u0026lt;C-R\u0026gt; \u0026lt;C-W\u0026gt;.\n 缩写的含义(Meaning of abbreviations) Operation\n d - delete y - yank(copy, 因为c被占了) c - change r - replace v - visual select  Scope or location\n i - inside a - around f - forward t - to  Object\n w - word s - sentence p - paragraph   书签: Bookmark ma: create bookmark a inside file.\nmA: create global bookmark A.\n`a: jump to bookmark a.\n:marks: display all bookmarks\ntag 目前用的生成tags文件工具是 ctag, 感觉还可以。\n1ta \u0026lt;tag\u0026gt; \u0026#34; 跳转到一个tag，如果有多个应该是随机一个 2CTRL-] \u0026#34; 快捷键跳转到当前光标下的tag 3ts \u0026lt;tag\u0026gt; \u0026#34; 多个tag时，可以选择跳转到哪一个 45help tag \u0026#34; 查看更多帮助 缩进: indent   \u0026gt;: increase indent , \u0026lt;: decrease indent ,=: auto indent\n  \u0026gt;\u0026gt;: 增加当前行的缩进\n  gg=G: 缩进全文, 无论当前光标在哪\n   以上命令都可以配合visual mode使用\n 自动缩进的规则 主要有四种可用缩进的方式, 分别是:\n1\u0026#39;autoindent\u0026#39; 沿用上一行的缩进。 2\u0026#39;smartindent\u0026#39; 类似 \u0026#39;autoindent\u0026#39;，但是可以识别一些 C 语法以能在合适的地方 3 增加 / 减少缩进。 4\u0026#39;cindent\u0026#39; 比上面两个更聪明；可以设置不同的缩进风格。 5\u0026#39;indentexpr\u0026#39; 最灵活的一个: 根据表达式来计算缩进。若此选项非空，则优先于其它 6 选项覆盖。参见 indent-expression 。 自定义的快速命令:\n1command IndentOff setl noai nocin nosi indentexpr=\u0026#34;\u0026#34;2command IndentOn setl ai cin si \u0026#34;indentexpr can\u0026#39;t be re-enabled.3command IndentStatus set ai? si? cin? indentexpr? cindent 不一定对所有的语言都有效果. 只是 C-like 风格, 其中一个要求是顶层函数必须在第一列中含有 {.\n  只有当indentexpr计算不出当前需要缩进几格时(return -1), 才使用上面的三个规则. 它是优先级最高的.\n Find and Tail f(: 从当前cursor处向右查找下一个(, 并将光标移动到(处.\nF(: Like f(, but 向左查找.\nt(: Like f(, but 将cursor移动到(的前一个.\nT(: You can guess.\nTrick vt(c: With visual, 删除当前光标到下一个(前的所有内容.\n;/,: 查找下一个/上一个 f/F/t/T 的内容.\n Substitute and Global  See: :help :s and :help :g\n 这两个都属于vim的命令. vim 的替换和sed 的s命令使用方式基本一致. 就不多介绍了.\n而 vim 的 global 命令和sed有些许差别. 使用Sed删除包含个字符串的行的指令为: sed '/STRING/d' input_file, 而在vim中则多了一个g前缀, :g/STRING/d.\nglobal 可以和 substitute 结合使用, 例如想要在包含某个字符串的行中替换good为excellent\n1:g/STRING/s/good/excellent/  TODO:\n More [cmd] in global. Power of g | Vim Tips Wiki | Fandom vim subtitute使用的正则表达式集包含 \\zs和\\ze, 然而 sed 没有(Sed 为 POSIX Basic Regular Expression).    大小写转换    cmd description     g~ 翻转大小写   gu 转换为小写   gU 转换为大写    以上命令(严格来说叫操作符)需要配合动作命令来使用.\n gUaw: 将光标所在位置的单词转为大写 gUap: 将光标所在位置的段落转为大写   Search and replace case 1: search and convert to uppercase/lowercase 我直觉想到的方式是%s/html/HTML/gc\n这种方式在简单情况下也行, 比较灵活且直观, 但是对于复杂文件不够通用且容易出错\n还有一种方式是先搜索, 然后一步步替换\n 搜索: /\\vhtml\\C 替换: 执行命令gUgn, 然后使用n和.来重复操作下一个选中项.   gn命令进对于sreach的匹配项使用, 类似于n, 但会将下一个匹配项(若光标停在match上, 那则选中当前匹配项) 转为visual模式选中的状态.\n  其实对于简单的文本, n和.也可以简化为.. 唯一的坏处就是如果两个匹配的距离太大, 你不能确认是否search了你想要的内容.\n case 2: search the text seleted in visual mode  vim 本身并未提供这个功能, 需要借助一个脚本来完成\n search the text selected in visual mode\n Visual Block 模式   选中后, 编辑所有行: I(captial i), 编辑完成后按两次ESC\n  重复visual 选中上次的 block: Normal模式下gv即可.\n   单词间跳转 w: Move cursor to begin of next word.\nb: Move cursor to begin of last word.\ne: Move cursor to end of next word.\nTrick w/b配合ce使用可达到在某一行中快速移动到某个单词, 然后删除该单词开始edit.\ndaw: 即 Delete A Word, 可以删除一个完整的单词, 无论当前光标的位置在哪.\n 编辑二进制/十六进制文件 可以使用xxd命令将一个文件中的文本转换为hex格式显示. 在vim中键入:%!xxd 即可. 得到的效果如下:\n10000000: 5468 6973 2069 7320 6120 7465 7374 0a41 This is a test.A 20000010: 6e6f 7468 6572 206c 696e 650a 416e 6420 nother line.And 30000020: 7965 7420 616e 6f74 6865 720a yet another. 后面的对应文本是自动生成的, 仅需要修改十六进制的部分即可. 修改完成后, 要返回原本的模式, 键入:%!xxd -r.\n 可通过设置文本格式对十六进制内存高亮显示 set ft=xxd.\n  删除光标前/后的所有字符  d^ \u0026ndash; delete to first non-whitespace character in the line d0 \u0026ndash; delete to beginning of the line c-u in insert mode. Same as bash command shortkeys, see here   文件恢复/swp文件 正确对待swp文件的姿势:\n vim 打开原文件, 此时会提示Found a swap file the name .xxx.swp, 显然选择(R)ecover 来恢复未保存的内容. 使用:w将恢复的内容保存下来 但是此时原本的swp文件还是存在, 此时我们执行:e刷新一下当前bufffer, 仍然会提示恢复的选项, 但此时文件内容已经恢复, 选择(D)elete 就可将对应的swp文件删除了   删除当前目录中所有swp file的脚本?\n需要确保:\n 所有文件内容已恢复 当前窗口或者其他窗口没有vim正在打开文件(会生成swp file)  1find . -type f -name \u0026#34;.*.sw[klmnop]\u0026#34; -delete  How to handle swapfiles in Vim (longwood.edu)\n Debug VIM key mapping https://vi.stackexchange.com/a/7723/43494\n 如何同步 VIM Dotfiles vim 的 dotfiles 主要包含.vimrc和.vim/中的插件.\n  对于.vimrc, 我选择使用mackup 软件和其他system dotfiles 一起备份. Git repo\n  对于 plugins, 传统的管理插件的方式(使用vim-plug), 也就是放在~/.vim/plugged/目录中的, 可以通过:PlugInstall命令在新机器上重新从网上克隆. 能够保证使用的是新版本.\n  VIM 8.0 之后, 引入 pack system 新的插件管理方式. 对于这类的插件, 我们直接利用submodule加入另一个备份的 Git repo. 使用方法见README.\n   Good plugins  Reference: The Ultimate vimrc\n TODO Installed NERD Commneter - 快速注释\nNERD Tree - 目录树\nOpen File Under Cursor - 打开光标处的文件目录\n 不支持vim-plug安装. 直接clone源码到plugged目录即可. Usage: gf: 在当前window打开文件. \u0026lt;C-w\u0026gt;\u0026lt;C-f\u0026gt;: new vertical windows中打开文件.  Ack.vim - 快速定位内容\nLeaderF - Like Ctrlp but better?\nbarbaric - normal模式切换英文输入法\n Helpful script search text selected in visual mode 1xnoremap * :\u0026lt;C-u\u0026gt;call \u0026lt;SID\u0026gt;VSetSearch(\u0026#39;/\u0026#39;)\u0026lt;CR\u0026gt;/\u0026lt;C-R\u0026gt;=@/\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt;2xnoremap # :\u0026lt;C-u\u0026gt;call \u0026lt;SID\u0026gt;VSetSearch(\u0026#39;?\u0026#39;)\u0026lt;CR\u0026gt;?\u0026lt;C-R\u0026gt;=@/\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt;3function! s:VSetSearch(cmdtype)4let temp = @s5norm! gv\u0026#34;sy6let @/ = \u0026#39;\\V\u0026#39; . substitute(escape(@s, a:cmdtype.\u0026#39;\\\u0026#39;), \u0026#39;\\n\u0026#39;, \u0026#39;\\\\n\u0026#39;, \u0026#39;g\u0026#39;)7let @s = temp8endfunction","date":"2022-05-09T19:28:12+08:00","permalink":"https://wangloo.github.io/posts/vim/basic/","section":"posts","tags":["vim"],"title":"我的 vim 调教随笔"},{"categories":null,"contents":"Change code theme Default use monokai.css. see 官方文档\n修改需要下载新的css放到plugin/highlight/目录下.\n其他可用的css在highlight.js仓库中下载.\nAlign Slide Align 取消center对齐方式:\n1Reveal.initialize({ 2 ... 3 center: false, 4 ... }) 所有slide左对齐: https://github.com/hakimel/reveal.js/issues/1897\n用markdown写的方式下使某一幻灯片左对齐: https://github.com/hakimel/reveal.js/issues/890#issuecomment-129735291\n","date":"2022-05-08T19:34:44+08:00","permalink":"https://wangloo.github.io/posts/revealjs/","section":"posts","tags":null,"title":"reveal.js Tutorial"},{"categories":null,"contents":"Load/Store 指令 寻址模式 Base register - w0=[x1]\n1ldr w0, [x1] Offset addressing mode - w0=[x1+12]\n1ldr w0, [x1, 12] Pre-index addressing mode - x1+=12; w0=[x1]\n1ldr w0, [x1, 12]! Post-index addressing mode - w0=[x1]; x1+=12\n1ldr w0, [x1], 12 更多示例 1// load a byte from x1 2ldrb w0, [x1] 3 4// load a signed byte from x1 5ldrsb w0, [x1] 6 7// store a 32-bit word to address in x1 8str w0, [x1] 9 10// load two 32-bit words from stack, then add 8-byte to sp 11ldp w0, w1, [sp], 8 12 13// store two 64-bit words at [sp-96] and subtract 96-byte from sp. 14stp x1, x2, [sp, -96]! 15 16// LDR伪指令. load 32-bit immediate from literal pool(addr: 0x12345678) 17ldr w0, =0x12345678 数据处理指令 Bitfield 操作指令 Bitfield 指令常用于设置/提取寄存器的某个字段.\n1;BFI(Bit Field Insert) 2BFI w0, w0, #9, #6 ;w0[0, 5] = w0[9, 14] 3 4;BFC(Bit Field Clear) 5BFC w0, #4, #2 ;w0[4, 5] = 0 6 7;UBFX(Unsigned Bit Field Extract) 8UBFX w1, w0, #18, #7 ;w1=w0[18, 24]  与 UBFX 相对的是 SBFX, 若提取后的字段高位为 1, 会进行符号扩展\n 分支/控制指令 获得地址的相关指令 写汇编中，常常会获取一个变量或者函数(label)的地址，A64 中一共有几种获取地址的指令， 包括adr, adrp, adrl, ldr等，下面我就对这些指令进行介绍。\nADR 首先是 adr，它的作用是加载 PC 相对地址，adr 指令的格式是:\n1adr reg, offset 输入一个 offset，输出 PC+offset 的值，但我们常用的是 offset 填某一个 label，例如函数 或者变量，此时 reg 中存的就是此函数的地址了。例如，\n1adr x0, a_func # x0 = addr(a_func) adr 指令中留给 offset 的位数是 21，所以最大的寻址范围为+-1MB。\nADRP adrp 的指令格式与 adr 相同，不同点是会将计算的结果向下对齐到 4k，但这样直接计算的 地址结果往往是不正确的，因为少了页内的偏移。需要一个额外的 add 指令进行纠正，一般来说 是组合起来用的：\n1adrp x0, a_func 2add x0, x0, :lo12:a_func 显然 adrp 这样做是为了更大的寻址空间，能到+-4GB。\nLDR 伪指令 如果 ldr 指令的参数是=\u0026lt;label\u0026gt;，那就代表伪指令，作用是加载 label 的绝对地址，即 VMA。好处是可以获取到一个位于任意 label 的地址，不受寻址空间的约束。\n 注意label是一个 offset, =label是一个绝对地址。\n  当目前指令执行地址不等于它们的虚拟地址时，比如当 MMU 未开始时通过 uboot 加载到内存 中直接运行的那段程序，此时用adr/adrp这些加载 pc 相对地址的指令就会正确的返回 label 的实际运行地址；而ldr则是永远返回其编译链接后绑定的虚拟地址。这种情况下 如果寻址范围允许，用adr*指令更方便。\n 有趣特性/常见误区 \u0026lsquo;#\u0026rsquo; before the immediate value  A64 assembly language does not require the # to introduce constant immediate value. But the assembler can also indentify the #. In armv7, there must be a # or $ before other than using .syntax unified. About syntax unified.   Agreed Recommendation\nUse .syntax unified in v7 code, and never use # on any literal on either v7 or v8. Unified syntax is newer and better, and those # and $ signs are just more code noise.\n ","date":"2022-05-07T21:19:01+08:00","permalink":"https://wangloo.github.io/posts/armv8/a64/","section":"posts","tags":["arm64"],"title":"ARM64: A64指令集"},{"categories":null,"contents":"寄存器分类 通用寄存器  x0-x7 参数寄存器: Restore function parameters and return vaule. x9-x15 caller-saved 临时寄存器: callee 默认可以直接使用来保存临时变量, 不需要保存和恢复. 如果 caller 在里面存储了非临时信息, 那么在函数调用之前应当由 caller 负责保存. x19-x28 callee-saved 寄存器: callee 应该避免使用. 如果必须要使用，那么在返回前必须恢复. special registers:  x8 restore indirect result. Commonly used when returning a struct. x18 platform reserved register. x29 frame pointer register(FP). x30 link register(LR).     All general-purpose register xN is 64-bit width. They all have corresponding wN register using the lower 32-bit of xN. And write to wN will clear the upper 32bit of xN.\n  💫 The different between Caller-saved and callee-saved registers\n Caller-saved 寄存器又称为临时寄存器, 常用来存放临时变量. 例如A() 调用 B(), 那么 B() 可以直接使用 caller-saved 寄存器, 也就是说 A() 在调用 B() 之前不会在这些寄存器里保存重要信息(编译器实现), 不能保证调用 B() 前后其值不变. 如果必须要保证, 那么保存和恢复(利用栈)这件事是 A() 来做. Callee-saved 寄存器则相反, 通常持续使用的值会保存到这些寄存器中. 还是拿 A() call B() 来举例. 如果 A() 中的一个变量需要在调用 B() 前后持续有效, 那么它应当保存到 callee-saved 寄存器中. 而且 B() 正常来说不应该动这些寄存器, 如果非得动(例如寄存器不够用), 那么 B() 需要在使用他们的前后进行保存和恢复(利用栈).   每个EL的特殊寄存器  sp_el0/1/2/3 stack pointer register of each EL. elr_el1/2/3 exception link register of each EL except EL0. spsr_el1/2/3 save program status register of each EL except EL0.   sp is an alias of sp_el0. Do NOT treat sp as general-purpose register.\n ","date":"2022-05-07T20:19:44+08:00","permalink":"https://wangloo.github.io/posts/armv8/register/","section":"posts","tags":["armv8"],"title":"ARMv8-A 寄存器"},{"categories":null,"contents":"考试大纲 :dart: To Reader:\nThis blog is JUST FOR EXAMINATION! If you are interested in numberical analysis, please quit this web. I try to sort out the knowledge points of the course, just to pass the exam.\nBased on the course of Professor Zhong Erjie of UESTC.\n:anger: I hate mathematics!\n 第二章 非线性方程/方程组的求解 1. 二分法及迭代  二分法误差估计定理  2. 不动点迭代  不动点及不动点迭代的概念 迭代格式的选择? 是否收敛? 迭代的初值是否合适?  3. 牛顿法解非线性方程  背景: 如果函数f(x)是线性的, 那么它的求根问题就会简化. 牛顿法实质上是一种线性化方法, 将非线性方程逐步归结为某种线性方程来求解.\n 牛顿法的迭代格式: $$ x^{k+1} = x^k - \\frac{f(x^k)}{f^\u0026rsquo;(x^k)} $$\n4. 弦截法  背景: 弦截法是牛顿法的一个改进. 牛顿法求根时需要计算f'(x), 而导数的计算往往困难. 弦截法使用差商来回避导数的计算.\n 5. 收敛阶 6. 非线性方程组的牛顿迭代格式  雅可比矩阵是什么?   第三章 直接法解线性方程组 1. Gauss消元法 求解过程的算法复杂度为O(n^2), 消元过程的算法复杂度为O(n^3).\n2. 直接三角分解法(Doolittle分解法)  背景: 直接意味着可以由A的元素直接计算L和U, 不需要任何的中间步骤.\n 一旦L和U得到, 求解Ax=b就可以等价表示为求解两个三角形方程组:\n Ly=b, 求y Ux=y. 求x   第四章 迭代法解线性方程组  背景: 对于线性方程组Ax=b, 当A为低阶稠密矩阵时, [选主元消去法]是求解的有效方法.\n但是实际情况中A大都是巨型的稀疏矩阵, 这是采用迭代法来求解是合适的. 迭代法可以利用A中有大量零元素的特点.\n  迭代法不一定最终能够逼近方程组的解, 认识误差向量的概念.  1. Jacobi迭代 雅可比迭代格式和收敛性的判别\n快速计算Bj的特征值\nJacobi迭代由A直接看出Bj\n2. Seidel迭代 Seidel迭代收敛格式和收敛性的判别\nSeidel迭代独有的判断收敛性的方式: 若A为对称阵, 且A正定, 那么迭代收敛.\n 第五章 插值法 1. 插值方法与插值问题  背景: 仅已知某些点和该点的函数值的情况下, 如何模拟一个插值函数P(x), 使得误差最小.\n  什么是插值函数P(x)? 被插函数? 插值节点? 插值余项?  2. 多项式插值  可证明多项式P(x)存在唯一. 多项式插值通过解方程组就能得到解(a0, a1,..., an).  3. 拉格朗日插值公式  背景: 虽然上面的多项式插值能否解决n+1个点的光滑函数, 且解是唯一的. 但是解方程组是很麻烦的.\n 拉格朗日插值公式: $$ L_n(x) = l_0(x)y_0 + l_1(x)y_1 + \\dots + l_n(x)y_n $$ 插值基函数:\n插值条件(插值系数): $$ y_0 = f(x_0), y_1 = f(x_1), \\dots,y_n = f(x_n) $$\n误差余项Rn(x)\n4. 牛顿插值公式  背景: 给定5个插值节点及其函数值, 可以得到L4(x); 由于某种原因, 需要加入一个新的插值节点. Lagrange插值法之前的计算结果(l)均失效, 需要重新计算. 非常的不方便.\n  牛顿法是基于差商的概念. 导数是差商的极限. 差商的差商是高阶差商.  牛顿插值法的插值函数(以二次插值举例): $$ P(x) = a_0 + a_1(x-x_0) + a_2(x-x_0)(x-x_1) $$ 需要做的就是解出系数a0,a1,....\n所以引入差商的符号: $$ a_1=f[x_0,x_1]=\\frac{f(x_1)-f(x_0)}{x_1-x_0} $$ $$ a_2=f[x_0,x_1,x_2]=\\frac{f[x_1,x_2]-f[x_0,x_1]}{x_2-x_0} $$\n5. Hermite插值  背景: 有时我们已知的条件不都是函数值, 也有导数值. 例如已知两个点的函数值和两个点的导数值, 可以应用Heimite插值法得到三次多项式.\n 求Hermite插值函数的方法: 构造差商表, 重复节点特殊处理.\nHermite插值方法的余项证明与Langrange插值法相同.\n6. 分段低次插值  背景: 次数太高的多项式插值的效果不好. 比如龙格现象.\n  分段: 把被插值函数所在的大区间分成一个个的小区间. 低次: 每个小区间上用次数不超过3的函数来逼近  6.1 分段线性插值 就是分段折线\n分段线性插值的优点:\n 简单 当二阶导数趋近0时, 一定收敛  分段线性插值的缺点:\n 分段折线不光滑, 分段点处不能求导.  6.2 分段Hermite插值  背景: 为了解决分段线性插值的缺点(存在尖点).\n 已知函数在(n+1)个点的函数值值以及其导数值, 去构造一阶连续可导函数.\n分段Hermite插值根据(n+1)个已知点划分为(n+1)个区间. 这样在每个小区间上都已知4个条件, 可以使用3次Hermite插值.\n结论: 已知(2n+2)个条件的情况下, 居然只得到一阶连续可微函数. 结论太差!\n 第六章 拟合 :mag: 插值, 拟合, 逼近的区别\n1. 最佳平方逼近 2. 最小二乘法  背景: 已知不共线的三点, 如何确定一条可信的直线.\n 三个点可以用插值来模拟二次多项式, 但题目要求了用一次多项式, 这是插值无法做到的.\n不共线的三点不可能同时经过一条直线, 所以要用逼近的思想. 找一条近似的直线, 使得误差最小.\n 与插值的区别: 插值是明确给出n+1个插值条件, 得到n次多项式. 如何定义误差最小?: 函数间的距离.  1. 线性拟合 拟合的函数是n次多项式, 可转化为超定方程GX.\n 其中规定G为系数矩阵, X为变量的列向量. 同时定义列向量F为给出的函数值. GX=F是超定方程组, 没有准确解. 得到残差最小的解的方法即最小二乘法.  所以线性拟合的残差r = |GX - F|, 而找到目标函数的宗旨就是使r最小. 使用初等变分原理将这个问题转化为正规方程组求解的问题.\n 第七章 数值积分  背景: 定积分的计算中可能无法找到原函数的情况. 考虑定积分的本质是一句具体的数, 我们的目标就是找到这个数的近似值, 越接近越好.\n 解决的两种思路: 积分中值定理 和 插值型求积公式(近似被积函数).\n1. 积分中值定理 基本的积分中值定理: $$ \\int_{a}^{b}f(x)dx = f(\\xi)(b-a) $$\n将一个区域的面积转化为矩形的面积. 如何确定矩形的高呢? 左矩阵, 右矩阵, 中间矩阵, 梯形公式.\n更常用的积分公式是 在乘积函数积分中, 如果g(x)不变号, 则有: $$ \\int_{a}^{b}g(x)f(x)dx =f(\\xi)\\int_{a}^{b}g(x)dx $$\n2. 插值型求积公式 在被积函数很复杂的情况下, 可以对其进行近似处理, 例如使用Lagrange插值法.\n二次插值: Simpson公式 取二次插值的步长h=(b-a)/2, 即增加一个插值节点(b-a)/2, Simpson公式化简的结果为: $$ \\int_{a}^{b}f(x)dx = \\frac{b-a}{6}[f(a)+4f(\\frac{a+b}{2})+f(b)]+R[f] $$\n:pushpin: Simpson公式满足3阶代数精度. 虽然它只是二次插值得到的.\n3. 余项  插值型求积公式的余项, 即对应的插值方法(如Lagrange, Newton)的余项在区间上的积分. 梯形公式方法的余项可以用积分中值定理来优化. Simpson公式的余项不能使用积分中值定理来优化, 因为不满足保号的条件.  4. 衡量求积公式的好坏 代数精度: 不是一种误差, 而是对误差的描述.\n如何得知某个公式的代数精度: 只要带入一个m次多项式验证余项是否为0即可.\n5.复合求积公式 为了提高精度通常把积分区间分为若干个子区间, 再在每个子区间上应用低阶求积公式.\n 复合梯形公式: 将区间等分. 复合simpson公式: 将区间偶数等分.   第八章 常微分方程初值问题数值解法 将研究的内容进一步限定为: 一阶初值问题, 单步法.\n 背景: 在无法给出解析表达式时如果利用数值方法求出y的近似解?\n 1. 简单的数值方法 1.1 Euler公式 使用一阶向前差商近似替代y'. 得到递推的数列表达式: $$ y_{n+1} = y_{n} + hf(x_n,y_n), n=0,1,2,\u0026hellip; $$\n误差: Euler法使用的近似代替只有一阶精度, 所以误差很大. 此时有两种解决方案:\n 加细步长h, 若不行再加细. 总是能得到正确的, 如果你不嫌弃带来的计算变得缓慢的问题. 换方法.  1.2 梯形公式  背景:为得到比Euler法精度更高的计算公式. 梯形公式具有二阶精度.\n 对y' = f(x,y)的两端进行局部的积分, 然后用梯形公式近似计算右边.\n1.3 改进Euler公式 先用欧拉公式求得一个近似的yn+1, 带入梯形公式, 得到矫正的yn+1.\n","date":"2022-05-07T18:04:58+08:00","permalink":"https://wangloo.github.io/posts/numberical-analysis/","section":"posts","tags":["Math","Examination"],"title":"Numberical Analysis Exam"},{"categories":["vim"],"contents":"Use plugin vimtex Vim build-in support of LaTeX files is just OK. When we need more excellent exprience, good plugins is very recommended.\nvimtex is a nice and modern vim plugin for LaTeX files.\nUseful Futures of vimtex IMO\n \u0026lt;leader\u0026gt;ll Complier. By default, it will auto-complier when you type :w. \u0026lt;leader\u0026gt;lt Open content tree as a sidebar. \u0026lt;leader\u0026gt;lv View PDF with configured PDF viewer. \u0026lt;leader\u0026gt;li File information. cse Change surrounding \\begin \\end environment. tse Exchange between \\begin{env} and \\begin{env*}. tsc Exchange between \\command{} and \\command*{}.   Add Support of Simplified Chinese Install xetex I use xetex to add supports for Chinese fonts in LaTex files. Actually the magician is amacro package of xetex named xeCJK.\nAnd xetex is included intexlive. so we install it from source:\n1sudo apt install texlive-xetex Install Chinese Font If there is no Chinese font in your system, you must install one. I choose WinQingYuan microhei as a instance.\n1sudo apt install ttf-wqy Excute fc-list to check if install successfully, here is excepted output:\n1fc-list | grep wqy 1/usr/share/fonts/truetype/wqy/wqy-microhei.ttc: WenQuanYi Micro Hei,文泉驛微米黑,文泉驿微米黑:style=Regular 2/usr/share/fonts/truetype/wqy/wqy-microhei.ttc: WenQuanYi Micro Hei Mono,文泉驛等寬微米黑,文泉驿等宽微米黑:style=Regular Configure your tex file 1\\documentclass {article} 2\\usepackage{xeCJK} 3\\setCJKmainfont{WenQuanYi Micro Hei} 4 5\\begin{document} 6Hello, LaTeX! 7 8你好, LaTex! 9 10\\end{document} Complier it and see, the Chinese font is displayed!\n Confusing Tools Difference between {pdf,lua,xe}Tex and {pdf,lua,xe}LaTeX If a .texfile starts with \\documentclass, it\u0026rsquo;s a LaTex format file rather than the Plain Tex format file.\nThe LaTeX format file has some specific macro like \\documentclass that cannot be compliered by [pdf]Tex, so that\u0026rsquo;s the job of [pdf]LaTeX. Same goes for other engines.\nWhat is xetex/xelatex? xetex/xelatex is one of the TeX/LaTeX engines. Others are pdfTex, LuaTex, etc. Wiki\nxetex/xelatex add fonts and character sets support for TeX/LaTeX file.\n Treat input as Unicode Allow us to use many system fonts in LaTeX file easily  What is latexmk? LaTeXmk 是一个集成化的命令行工具, it must work with one LaTeX engine.\nThe fundamental issue that latexmk solves is that the number of runs of [pdf]latex is highly dynamically dependent on the document and the class file used. latex just need to be run once a time.\nDifferent between CTeX/MiKTeX/TeXlive ? They are all 包含与.tex文件关联的各种编辑、查看工具、常用宏包及文档.\nCTex packages add complete Chinese support based on MiKTeX.\n CTex is only avilable in windows.  ","date":"2022-05-04T17:07:51+08:00","permalink":"https://wangloo.github.io/posts/latex-vim-tutorial/","section":"posts","tags":["LaTeX","vim","Tutorial"],"title":"LaTeX Vim Tutorial"},{"categories":null,"contents":"When reading C standard documents, we usually see phrases like \u0026ldquo;Implementation-defined\u0026rdquo;, \u0026ldquo;Unspecified\u0026rdquo;,.etc.\nSo, what do they really mean?\n术语 我们将这些难以直接理解的词汇称为术语，在ANSI C中，术语可以分为描述不可移植代码(unportable), 坏代码(bad), 可移植的代码(portable)三类.\nunportable code Implementation-defined\n需要由编译器设计者决定采取何种行为，他们可能不同，但都不能说是错误的.\n例如：当整型数右移时，是否需要扩展符号位. 右移代替除法可能导致的灾难.\nunspecified\n在某些正确情况下的做法，标准并未明确规定应该怎样做.\n例如：参数求值的顺序.\nbad code undefined\n在某些不正确情况下的做法，但标准并未规定应该怎样做。意味着你可以采取任何行动，可以什么都不做，也可以发出一条警告信息, 或者终止CPU重启等等. 你甚至可以发射核导弹(只要你安装了能发射核导弹的硬件系统).\n例如：当一个有符号整数溢出时该采取什么行动.\nconstraint\n这是一个必须遵守的限制或要求. 如果你不遵守, 那么你的程序的行为就会变成如上所说的undefined. 这出现了一种很有意思的情况: 分辨某种东西是否是一个constaint是很容易的, 因为每个标准的主题都附有一个constraint小节, 列出了所有的约束条件。\n例如: %操作符的操作数必须为整型. 所以,在非整型数据上使用%操作符肯定会导致undefined.\nportable code strictly conforming\n严格遵守标准的. 符合该条件的程序应当是:\n 只使用已确定的特性 不突破任何由编译器实现(Implementation-defined)的限制. 不使用unspecified和undefined特性  这样规定的目的是最大程序保证代码的可移植性. 但符合该术语的代码并不常见, 例如INT_MAX的值在不同架构的机器上结果可能不同.\ncomforming\n遵循标准的; 一个遵循标准的程序可以依赖一些对于某种编译器特有的不可移植的特性. 这样一个程序对于某个编译器可能是遵循标准的, 但对于另外一个编译器又是不遵循标准的.\n","date":"2022-05-01T16:41:35+08:00","permalink":"https://wangloo.github.io/posts/reading-notes/expert_c_programming/portability_issues/","section":"posts","tags":null,"title":"Portability Issues"},{"categories":null,"contents":"","date":"2022-05-01T16:41:35+08:00","permalink":"https://wangloo.github.io/posts/third-blog/","section":"posts","tags":null,"title":"Third Blog"},{"categories":null,"contents":"As we all know, there are huge number of parameters for GCC. With them, we can make many things possible. Now we talk about -M and related ones. After reading this article, you will know the meaning of there magic parameters. And I will put some little demos follows. Finally, we will see what can they do in really project. Let\u0026rsquo;s go ahead.\n实例规则 以下的分析都是基于这样一个生成目标文件的规则, 应该来说具有一定的通用性。\n1build/obj/main.o: src/main.c 2 $(CC) $(CFLAGS) $(INCLUDES) -c $\u0026lt; -o $@ main.c中的内容：\n1/* File: main.c */ 2#include \u0026lt;stdio.h\u0026gt; // system header file3#include \u0026#34;header.h\u0026#34; // user defined header file4int main() { 5 return 0; 6} -M Output the dependencies of the input source file. Incluing the names of itself and all included files.\n-M(and 下面的-MM)和-o 不能同时使用，因为都隐含-E。 假设我们只想输出依赖文件，我们可以将示例中的规则如此改造：\n1build/obj/main.o: src/main.c 2 $(CC) $(CFLAGS) $(INCLUDES) -c $\u0026lt; -M We will get messy output like following. Notice that the first two words is object filename and a colon.\n1main.o: src/main.c /usr/include/stdc-predef.h /usr/include/stdio.h \\ 2 /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \\ 3 /usr/include/features.h /usr/include/x86_64-linux-gnu/sys/cdefs.h \\ 4 /usr/include/x86_64-linux-gnu/bits/wordsize.h \\ 5 /usr/include/x86_64-linux-gnu/bits/long-double.h \\ 6 /usr/include/x86_64-linux-gnu/gnu/stubs.h \\ 7 /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \\ 8 /usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h \\ 9 /usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h \\ 10 /usr/include/x86_64-linux-gnu/bits/types.h \\ 11 /usr/include/x86_64-linux-gnu/bits/timesize.h \\ 12 /usr/include/x86_64-linux-gnu/bits/typesizes.h \\ 13 /usr/include/x86_64-linux-gnu/bits/time64.h \\ 14 /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \\ 15 /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \\ 16 /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \\ 17 /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \\ 18 /usr/include/x86_64-linux-gnu/bits/types/FILE.h \\ 19 /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \\ 20 /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \\ 21 /usr/include/x86_64-linux-gnu/bits/sys_errlist.h 22 src/header.h -MM Like -M but do NOT output system header files.\n1main.o: src/main.c src/header.h -MF \u0026lt;file\u0026gt; Use with -M or -MM. Specify output dependencies to file instead of STDOUT.\n注意，只要使用追加上-MF，就可以和-o选项并存了，可以写在一条语句中\n-MD -MD is same as -M -MF \u0026lt;file\u0026gt;. But the filename is basd on the object file but replacing .o with .d.\n如果将示例中的代码换成：\n1build/obj/main.o: src/main.c FORCE 2 $(CC) $(CFLAGS) $(INCLUDES) -c $\u0026lt; -o $@ -MD 1$ ll build/obj/ 2 3total 16 4drwxrwxr-x 2 soben soben 4096 3月 23 20:45 ./ 5drwxrwxr-x 3 soben soben 4096 3月 23 20:35 ../ 6-rw-rw-r-- 1 soben soben 1144 3月 23 20:45 main.d 7-rw-rw-r-- 1 soben soben 1368 3月 23 20:45 main.o  Note: -MD and -MMD 因为有-MT，也不隐含 -E.\n -MMD -MMD is same as -MM -MF \u0026lt;file\u0026gt;. Also named on object file but replacing .o with .d.\n-MT \u0026lt;target\u0026gt; MT 是一个单独的选项，不与上面的冲突。作用是改变生成依赖规则的目标格式。在此之前，默认的格式是文件名.o，去除任何前缀目录。\n而使用-MT之后可以自定义规则中目标的格式， 由\u0026lt;target\u0026gt;指定。\n例如，对于前面的选项，依赖规则目前总是main.o，很多使用，我们需要的是其编译规则中目标的形式，包含路径，并不仅仅是文件名本身。这时我们就需要使用-MT，可以将示例中的规则做如下修改:\n1build/obj/main.o: src/main.c FORCE 2 $(CC) $(CFLAGS) $(INCLUDES) -c $\u0026lt; -o $@ -MMD -MT $@ 依赖文件的内容就变为:\n1build/obj/main.o: src/main.c src/header.h  实际上，从我的开发经验来看，大项目中编译规则的目标并不直接是目标文件，总有一个路径前缀，例如：$(objdir)/%.o: $(srcdir)/%c, 这时如果 include 的依赖文件的目标只是一个文件名，其实没什么意义。 所以 -MT 应该是在开发大型项目中很常见的。\n -MQ \u0026lt;target\u0026gt; 与MT类似，而且我没有验证成功官网说出的和 MT 的区别. 所以，这是一个 TODO。\nApplication Here is an important question you may ask me: Why do we struggle to get the dependencies formats? What can they do?\nIf you are familiar with make and Makefile, aha, that\u0026rsquo;s it! With the help of M-related parameters, you can easily handle the problem of tracing header files.\nGive you a little demo about my point.\n1-include *.d 2%.o:%.c 3 $(CC) $(CFLAGS) $(INCLUDES) $\u0026lt; -c -MMD -o $@ Actually, we do two things in order:\n When complieing source files, we generate dependency files xxx.d at the same time. After geting xxx.d, we include them in makefile. As its format is exactly the dependency format required by makefile.  Summary Hope this article can give you a clear understanding of M-related parameters in GCC. We can sometimes find them in large projects\u0026rsquo; makefile. It\u0026rsquo;s very useful to automatic build dependency for header files. So try to use them in your current or next project.\nReference  GNU GCC options GCC -M, -MM, -MMD, -MF, -MT  ","date":"2022-04-26T19:08:22+08:00","permalink":"https://wangloo.github.io/posts/c/gcc_-m_related/","section":"posts","tags":["c","makefile"],"title":"GCC '-M' and Related Parameters"},{"categories":null,"contents":"This is my second blog.\n Wish you have a good life.\n  happy smile   sunset   ","date":"2022-04-26T15:32:11+08:00","permalink":"https://wangloo.github.io/posts/second-blog/second-blog/","section":"posts","tags":null,"title":"Second Blog"},{"categories":null,"contents":"This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog.\n1#include \u0026lt;stdio.h\u0026gt;2 3int main(void) { 4 printf(\u0026#34;hello, hugo\\n\u0026#34;); 5 return 0; 6} ","date":"2022-04-26T15:13:07+08:00","permalink":"https://wangloo.github.io/posts/first-blog/first-blog/","section":"posts","tags":null,"title":"First Blog"},{"categories":null,"contents":"编译Linux 源码 上海交通大学镜像站\n1# get linux source code 2wget http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/ 3# extract 4tar xvf linux-4.12.1.tar.gz 5# enter dir 6cd linux-4.12.1/ 7 8# generate .config 9make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- defconfig 10make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- menuconfig 11# compile  12make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- Image -j16 构建根文件系统 使用 Busybox 构建, 下载源码时可能比较慢, 暂时没有发现国内镜像站\n1# Download busybox source code 2wget https://busybox.net/downloads/busybox-1.35.0.tar.bz2 3 4# menuconfig - generate .config 5make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- menuconfig 6# compile 7make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- -j16 8 9make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- install 10 11# create rootfs 12cd ../ 13qemu-img create -f raw qemu_rootfs.img 128M 14# set ext4 filesystem 15mkfs.ext4 qemu_rootfs.img 16# mount on host 17mkdir mnt-tmp 18sudo mount -o loop qemu_rootfs.img ./mnt-tmp 19# copy file 20sudo cp busybox-1.35.0/_install/* mnt-tmp/ -r 21cd mnt-tmp 22# create other path 23sudo mkdir proc sys dev etc etc/init.d 在etc/init.d/rcS中写入启动脚本\n1#!/bin/sh 2mount -t proc none /proc 3mount -t sysfs none /sys 4/sbin/mdev -s 赋予rcS可执行权限\n1sudo chmod +x rcS 改为mount -a 之后启动脚本会自动挂在/etc/fstab文件中声明的所有分区\nfstab 在 Linux 开机以后自动配置哪些需要自动挂载的分区\n1#device mount-point type options dump fsck order 2proc /proc proc defaults 0 0 3tmpfs /tmp tmpfs defaults 0 0 4sysfs /sys sysfs defaults 0 0 5tmpfs /dev tmpfs defaults 0 0 6debugfs /sys/kernel/debug debugfs defaults 0 0 7tracefs /sys/kernel/tracing tracefs defaults 0 0 添加软件 perf perf已经集成到了Linux 主分支中，源码的位置在tools/perf\n编译命令:\nstrace 下载源码：Releases · strace/strace (github.com)\n编译\u0026amp;\u0026amp;安装:\n1# 确定编译的参数 2./configure \\ 3--host=aarch64-linux \\ 4--prefix=/home/soben/linux-qemu/strace-6.0/_install \\ 5--enable-mpers=no \\ 6CC=aarch64-none-linux-gnu-gcc \\ 7LD=aarch64-none-linux-gnu-ld \\ 8RANLIB=aarch64-none-linux-gnu-ranlib 9 10# 编译为静态链接方式 11make LDFLAGS+=\u0026#39;-static -pthread\u0026#39; -j16 12 13# 拷贝到 _install 目录 14make install 启动 QEMU 运行 Linux ","date":"0001-01-01T00:00:00Z","permalink":"https://wangloo.github.io/posts/os/arm64-linux-qemu/","section":"posts","tags":null,"title":""},{"categories":null,"contents":"名词解释 probe 一个probe是一个位置或者活动, 动态追踪工具可以在probe上绑定一些action. 例如记录栈帧位置, 查看参数等.\nprobe就像是一个可编程的传感器, 你可以为他设定触发的事件或者指令. 当probe 触发时, 可以执行你提前绑定的函数, 了解此时系统的状态\n","date":"0001-01-01T00:00:00Z","permalink":"https://wangloo.github.io/posts/os/trace/","section":"posts","tags":null,"title":""}]