[{"categories":null,"contents":" 岗位: 嵌入式软件开发 结果: 未知  感悟  礼貌; 面试官大哥非常的有礼貌, 我每次回答他的问题都会得到响应, 即便是没有回答上来也会被告知\u0026quot;没关系\u0026quot;. 结束的时候还说了\u0026quot;谢谢你的时间\u0026quot;, 这是我参加了这么多场面试以来听到的第一句, 给人留下很好的印象 专业性; 这次的难度小于地平线, 问的问题比较基础, 但是也契合你简历上写的内容, 总体上来说专业性还是不错  回顾 手撕代码: 用单链表实现栈的出栈和入栈操作 本科和硕士成绩 本科和硕士课程 NorFlash和NandFlash的区别? GICv3相比GICv2有什么提升? 你做的内存分配器是什么思路? 参考slab分配器, 做了一些简化.\nslab分配器的核心思想是\nARMv8的页表属性和权限 ARMv8Cache分为几级,分别位于哪里 ARMv8有几个通用寄存器? 拿64位来说, 有31个通用寄存器, x0~x30\nARMv8分为哪几个异常等级, 分别用作实现什么? 共有四个异常等级: EL0-EL3\n EL3: Secure monitor, 负责安全世界和非安全世界的切换 EL2: Hypervisior, 实现虚拟化, 管理虚拟机 EL1: 非安全EL1实现普通OS, 安全EL1跑安全OS, 例如OP-TEE EL0: 跑用户态程序  ARMv8的异常分为哪几类?  同步异常: 可细分位指令预取异常/Data Abort/MMU翻译错误等 IRQ FIQ System Error  反问 ","date":"2023-08-28T08:51:49+08:00","permalink":"https://wangloo.github.io/posts/work/xiaoduan/","section":"posts","tags":["work"],"title":"面试总结：希奥端秋招一面"},{"categories":null,"contents":"构建 openWRT  我在此步骤失败了，后面项目没有依赖完整的编译过程， 所以可能对你不构成参考\n 过程可参考官方教程, 编译过程非常长，使用到的工具非常多，这里提供两个优化的思路:\n提前安装本地依赖，忘了./scripts/feeds update -a还是./scripts/feeds install -a时需要检查系统的各种依赖, 可以提前统一安装一波.\n1sudo apt install g++ 2sudo apt install libncurses5-dev 3sudo apt install zlib1g-dev 4sudo apt install bison 5sudo apt install flex 6sudo apt install unzip 7sudo apt install autoconf 8sudo apt install gawk 9sudo apt install make 10sudo apt install gettext 11sudo apt install gcc 12sudo apt install binutils 13sudo apt install patch 14sudo apt install bzip2 15sudo apt install libz-dev 16sudo apt install asciidoc 17sudo apt install subversion 18sudo apt install python 19sudo apt install git 提前下载dl, dl是默认在编译时下载的一些工具源码, 你可以将他们提前下载好 放到dl/下, 即可省去下载的时间, 特别当你不能翻墙时.\n就像这个仓库这样, 但是它里面 的软件版本可能比较老了而且有的软件是缺失的, 以后如果真的要自己编译, 需要查makefile去替换真正依赖的软件和其对应的版本.\n最终还是因为编译某个模块失败, 且编译时间太长(连交叉编译工具链都需要现场编译) , 导致排查困难, 没有编译成功。好在后面也没有直接依赖编译的结果。\n编译的tips  make V=99 build with verbose  ptgen 正如上面所言, 我最终没有完整的编译成功。但其中的一个小工具ptgen是我 需要用的到，它在过程中被编译出来了，相对独立些。\nptgen是OpenWRT开发的一个用来生成gpt分区表的工具，创建的sdcard镜像， 只有配合分区表才能正确的被bootrom加载起来。\n使用方法及参数 ptgen使用的参数说明:\n1 2ptgen [-v] -h \u0026lt;heads\u0026gt; -s \u0026lt;sectors\u0026gt; -o \u0026lt;outputfile\u0026gt; [-a 0..4] [-l \u0026lt;align kB\u0026gt;] [[-t \u0026lt;type\u0026gt;] -p \u0026lt;size\u0026gt;...] 3 4-v: 指定是否打印调试信息,可选 5-h: 指定起始磁头号 6-s: 指定起始扇区号 7-o: 指定输出文件名 8-a: 指定激活分区为哪个, 可选 9-l: 指定多少KiB对齐,可选，这个参数会决定每个分区的偏移扇区号，非常重要 10-t: 指定文件系统分区标志类型值,是0x83指linux,0x0b指Win95 FAT32,可选 11-p 指定分区大小,可选 ptgen使用案例 这里贴出我使用ptgen创建一个BananaPi M2 Ultra可以识别的sd卡镜像文件， 对bootfs进行挂载可放入一些文件，在uboot下能访问。\n1#!/bin/bash 2 3if [ -f \u0026#34;sd.img\u0026#34; ]; then 4 echo \u0026#34;warning: sd.img already exist, do nothing\u0026#34; 5 exit 6fi 7 8if [ -f \u0026#34;bootfs.ext4\u0026#34; ]; then 9 echo \u0026#34;warning: bootfs.ext4 already exist, do nothing\u0026#34; 10 exit 11fi 12 13BOOTFS_SIZE=16M 14# make ext4 fs which including kernel.bin 15dd bs=\u0026#34;$BOOTFS_SIZE\u0026#34; if=/dev/zero of=bootfs.ext4 count=1 16sudo mkfs.ext4 bootfs.ext4 17[ -d \u0026#34;./mnt\u0026#34; ] || mkdir ./mnt 18sudo mount -o loop bootfs.ext4 ./mnt 19sudo cp kernel.bin ./mnt 20sudo umount ./mnt 21 22 23# create empty image 24dd bs=32M if=/dev/zero of=sd.img count=1 25 26 27# generate parition table 28# -t 0xc: FAT32 29# -t 0x83: ext4 30set $(./ptgen -o sd.img -h 4 -s 63 -l 1024 -t 0x83 -p \u0026#34;$BOOTFS_SIZE\u0026#34;) 31 32 33BOOTFS_OFFSET=\u0026#34;$(($1 / 512))\u0026#34; 34# write in uboot and bootfs 35dd bs=1024 if=u-boot-sunxi-with-spl.bin of=sd.img seek=8 conv=notrunc 36dd bs=512 if=bootfs.ext4 of=sd.img seek=\u0026#34;$BOOTFS_OFFSET\u0026#34; conv=notrunc 37 38 39echo -e \u0026#34;\\n\\nsd.img is ok\u0026#34; 我正是依赖这个工具生成了最终的镜像而已，其他的模块其实并不是特别需要。 本来u-boot也是必须的，但是后面发现我用的硬件(BananaPi M2 Ultra) 在uboot中有直接的defconfig，所以也就不依赖openWRT的编译结果了。\n","date":"2023-08-05T19:28:12+08:00","permalink":"https://wangloo.github.io/posts/embedded/openwrt/","section":"posts","tags":["tools"],"title":"openwrt 开发日记"},{"categories":null,"contents":"Architecture ARMv8  寄存器、指令速查：http://hehezhou.cn/arm/  u-boot 克隆仓库\n1git clone https://github.com/u-boot/u-boot 交叉编译toolchain Linaro 经常用来编译armv7架构的一些项目。\nhttps://releases.linaro.org/components/toolchain/binaries/\nGNU https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads\nC GNU 内联汇编 https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C\n构建工具 跟我一起写makefile PDF：https://seisman.github.io/how-to-write-makefile/Makefile.pdf\n其他  Emoji cheat sheet https://www.webfx.com/tools/emoji-cheat-sheet/  ","date":"2023-08-05T19:28:12+08:00","permalink":"https://wangloo.github.io/posts/tools/useful_sites/","section":"posts","tags":["tools"],"title":"开发资料站集合"},{"categories":null,"contents":"前言 写这篇博客的背景是我实在忍受不了每次换新的开发机器都得费好大的劲来完全恢复以前的环境， 而且，我平常喜欢搜集各种有用的工具、好看的主题，字体这些，如果零零散散的记录，大概率会忘记或者记不得某些细节。\n所以，最后期望达到的是能够使我每次在新机器上搭建环境只需要看这一篇文章就可以了。因此这里会记录：\n 帮助提升开发效率的小工具 好看的字体、主题 配置某些环境的要点及注意事项   🥀 到目前为止，我还未发现一种方式能够完全达到“一键式布置”，这也不是本文的目的。 付出至少半天的时间的一定的，希望未来能发现一种好的方法。\n 字体 Fira Code 这款字体适合做编程字体，蛮好看的。我在 vscode 和 terminal 下都使用了这款字体。\n详情及安装参考github\n霞鹜文楷 开源的中文字体，做博客、PPT 不错。\n详情及安装参考github\nvscode 主题 vim vimrc ycm 特别注意 YCM 插件对 python, vim 的版本均有要求。\n下载 可以使用 vim-plug 等工具下载, 也可以下载源码然后拷贝到.vim目录下\n编译 编译用到 python3, 这里是问题最多的一步\n1# 编译并添加对C的提示支持 2python3 install.py --clangd-completer --verbose 3 4Searching Python 3.8 libraries... 5... 6Downloading Clangd from https://github.com/ycm-core/llvm/releases/download/13.0.0/clangd-13.0.0-x86_64-unknown-linux-gnu.tar.bz2... 使用--clangd-completer参数时, 脚本会去下载 clangd-14.0.0-x86_64-unknown-linux-gnu.tar.bz2 文件, 比较慢. 也可以提前根据提示的网站自己手动下载压缩包.\n下载完成后, 放到本地目录下:\n1:~/.vim/plugged/YouCompleteMe/third_party/ycmd/third_party/clangd/cache$ ls 2clangd-14.0.0-x86_64-unknown-linux-gnu.tar.bz2 还需对脚本YouCompleteMe/third_party/ycmd/build.py进行修改, 防止重新下载.\n1def DownloadClangd( printer ): 2 ... 3 MakeCleanDirectory( CLANGD_OUTPUT_DIR ) 4 5 if not p.exists( CLANGD_CACHE_DIR ): 6 os.makedirs( CLANGD_CACHE_DIR ) 7 # 注释下面的语句 8 # elif p.exists( file_name ) and not CheckFileIntegrity( file_name, check_sum ): 9 # printer( \u0026#39;Cached Clangd archive does not match checksum. Removing...\u0026#39; ) 10 # os.remove( file_name ) 11 12 if p.exists( file_name ): 13 printer( f\u0026#39;Using cached Clangd: { file_name }\u0026#39; ) 配置 YCM 配合一个配置文件.ycm_c_c++_conf.py, YCM 搜索的位置在 vimrc 中指定:\n1Plug \u0026#39;rdnetto/YCM-Generator\u0026#39;, { \u0026#39;branch\u0026#39;: \u0026#39;stable\u0026#39; }2let g:ycm_global_ycm_extra_conf = \u0026#34;~/.ycm_c_c++_conf.py\u0026#34;其内容的 example:\n1import os 2import ycm_core 3 4flags = [ 5 \u0026#39;-Wall\u0026#39;, 6 \u0026#39;-Wextra\u0026#39;, 7# \u0026#39;-Werror\u0026#39;, 8 \u0026#39;-Wno-long-long\u0026#39;, 9# \u0026#39;-Wno-variadic-macros\u0026#39;, 10 \u0026#39;-fexceptions\u0026#39;, 11 \u0026#39;-ferror-limit=10000\u0026#39;, 12 \u0026#39;-DNDEBUG\u0026#39;, 13 \u0026#39;-std=c99\u0026#39;, 14 \u0026#39;-xc\u0026#39;, 15 \u0026#39;-isystem/usr/include/\u0026#39;, 16 ] 17 18SOURCE_EXTENSIONS = [ \u0026#39;.cpp\u0026#39;, \u0026#39;.cxx\u0026#39;, \u0026#39;.cc\u0026#39;, \u0026#39;.c\u0026#39;, ] 19 20def FlagsForFile( filename, **kwargs ): 21 return { 22 \u0026#39;flags\u0026#39;: flags, 23 \u0026#39;do_cache\u0026#39;: True 24 } 优化 :small_red_triangle_down: 对于C/C++来说, YCM的使用最好配合compilation database 来使用, 例如compiledb. 否则, 可能头文件的path识别出问题(stackoverflow).\n2022年2月13日我使用的compilation database生成工具从compiledb换成了bear, 因为bear更好的支持递归, 即有make -C的情况.\n需要的compilation database生成工具介绍: Compilation database — Sarcasm notebook\n终端软件安装 源替换 apt 1sudo apt install python3-pip 2sudo apt install tmux 3sudo apt install fzf 4sudo apt install zsh pip3 1# CLI 代码高亮 2sudo pip3 install pygments shell zsh oh-my-zsh oh-my-zsh可以看作对zsh的配置文件做一层抽象，使配置更方便。 带来的缺点就是速度变慢。\n 进入git目录下太卡\nTODO： 是主题的原因，可以配置\n 配置文件  .bashrc .zshrc .bash_aliase .bash_path  terminal ubuntu自带的终端我觉得还不错，有些人说Terminitor不错，分屏功能还是挺常用的！\ntmux ssh 密钥 1ssh-keygen -t rsa -C \u0026#34;cnwanglu@icloud.com\u0026#34; ","date":"2023-07-17T19:28:12+08:00","permalink":"https://wangloo.github.io/posts/tools/dev_env/","section":"posts","tags":["tools"],"title":"我的开发环境构建指南"},{"categories":null,"contents":"上午结束了特斯拉嵌入式实习生-Linux platform的二面，特斯拉实习生 一共有三轮面试，一轮和二轮都是技术面，三面是主管面。 目前我完成了所有的技术面，且不论结果如何，整个面试过程对我而言还是收获颇丰的， 故以此文整理下自己的欠缺的技术知识，希望下次能够表现的更好。\n二面 首先，此轮面试的面试官显然比上一轮更有礼貌一些，准时与会+介绍自己，不过有一点 是我开了摄像头他没开，也没有进行说明吧。 不过这些都是小事，我们这次主要谈论 技术的内容。\n我在此回顾几个没有回答好的问题，供以后做参考。\nELF 文件的加载流程  原回答\n 拿到 ELF 存储的地址后，先将头部读出来，长度是固定的。头部有校验字段， maigic number, 然后是确认 ELF 编译的架构，位数是否正确。 确认格式正确后，读取程序头表，其中保存了各个需要加载的段的偏移，根据 base+段偏移能够得到该段的位置，然后根据段属性的不同，选择映射到不同 的区域和属性，例如 text 段映射为 RE, 代码段映射为 RW，清空 BSS 等 说明自己没接触过动态库文件，所以对动态加载不是很熟悉   点评如下: 对段表、程序头表，这些概念的区分还不是很熟，不清楚什么时候用 section table， 什么时候用 program header table. 以前都看过，只是 时间长了不用就忘记了，这一部分需要好好的做下笔记。\n全局变量存在哪？谁负责初始化的  原回答\n不知道。\n 全局保量存在的位置：\n 未初始化的全局变量 ==\u0026gt; bss段 const修饰的全局变量 ==\u0026gt; rodata段 其他已初始化的全局变量 ==\u0026gt; data段  对于已初始化的全局变量的访问，编译时，编译器将值存入data段，访问的指令是通过 相对寻址来做，例如相对于data段开头。对于静态链接来说，编译完成后访问指令的 基地址和偏移都是空，当链接时修改指令，即重定位的过程。\naligned_alloc()设计 这是面试最后的程序设计题，我也是没有做好，后面好歹在面试官的无数次提示中， 写出了一个解，题目很棒，只是自己实习不够，怪不得其他。\n原问题 对malloc()和free()进行封装，设计一个返回满足任意字节对齐要求的 align_alloc()和align_free()函数。\n1void *align_alloc(size_t size, size_t align); 2void align_free(void *addr); 3 4int main(void) 5{ 6 size_t alignment[6] = {5, 8, 32, 64, 128, 12}; 7 int i; 8 char *p; 9 10 for (i = 0; i \u0026lt; 6; i++) { 11 p = align_alloc(10, alignment[i]); 12 if ((unsigned long)p % alignment[i]) { 13 printf(\u0026#34;FAILED!, alignment: %ld, addr: %p\\n\u0026#34;, 14 alignment[i], p); 15 exit(1); 16 } 17 memset(p, 0, 10); 18 align_free(p); 19 } 20 printf(\u0026#34;PASS\\n\u0026#34;); 21 return 0; 22} 思路及解决方案 思路也写在代码里了，就是思路比较难想，代码倒是不难写。\nPS: 丢人的是，我在一开始居然还提了: malloc()返回的地址能够保证是参数size对齐的， 真是令人耻笑啊！！\n1#include \u0026lt;stdio.h\u0026gt;2#include \u0026lt;string.h\u0026gt;3#include \u0026lt;stdlib.h\u0026gt;4void *align_alloc(size_t size, size_t align); 5void align_free(void *addr); 6// 如何保证对齐到align? 7// ==\u0026gt; 申请更多空间, 返回对齐的地址 8// 9// 不能保证malloc返回的地址是对齐到哪的，怎么确定多申请多大呢? 10// ==\u0026gt; 多申请align的空间，就能保证这align的地址范围里，总有 11// 满足对齐条件的地址 12// 13// 如何计算返回的地址? 比如malloc(10)=12, align=5, 此时我们会 14// 申请的空间为malloc(10+5), 即(12-27)都是可用的，我们需要 15// 经过计算后返回地址 15 16// ==\u0026gt; 计算的规则是(12+5)-(12+5)%5 17// 18// aligned_free()只接受addr一个参数，如何释放malloc()申请的空间? 19// ==\u0026gt; 传入的addr是经过align之后的，确实需要一定的方法才能 20// 求得malloc()返回的地址，这通过计算是无法得到的，因为 21// 不知道这个地址的align是多少。所以可以想到在p_ret之前 22// 再多借用一个地址的长度来存放malloc()返回的原地址。 23 24void *align_alloc(size_t size, size_t align) 25{ 26 void *p_malloc; 27 void *p_ret; 28 size_t aligned_size; 29 size_t ptr_size; 30 31 ptr_size = sizeof(char *); 32 aligned_size = size + align + ptr_size; 33 34 p_malloc = malloc(aligned_size); 35 p_ret = (p_malloc+ptr_size+align) - 36 ((unsigned long)p_malloc+ptr_size+align) % align; 37 38 *((unsigned long *)p_ret-1) = (unsigned long)p_malloc; 39 40 // debug 41 printf(\u0026#34;[ALLOC] p_malloc: %p, p_ret: %p, align: %ld\\n\u0026#34;, 42 p_malloc, p_ret, align); 43 44 return p_ret; 45} 46void align_free(void *addr) 47{ 48 void *p_malloc; 49 50 p_malloc = (void *)(*((unsigned long *)addr-1)); 51 52 printf(\u0026#34;[ FREE] p_malloc: %p\\n\u0026#34;, p_malloc); 53 free(p_malloc); 54} 55 56 57int main(void) 58{ 59 size_t alignment[6] = {5, 8, 32, 64, 128, 12}; 60 int i; 61 char *p; 62 63 for (i = 0; i \u0026lt; 6; i++) { 64 p = align_alloc(10, alignment[i]); 65 if ((unsigned long)p % alignment[i]) { 66 printf(\u0026#34;FAILED!, alignment: %ld, addr: %p\\n\u0026#34;, 67 alignment[i], p); 68 exit(1); 69 } 70 memset(p, 0, 10); 71 align_free(p); 72 } 73 printf(\u0026#34;PASS\\n\u0026#34;); 74 return 0; 75} ","date":"2023-06-10T08:51:49+08:00","permalink":"https://wangloo.github.io/posts/work/tesla/","section":"posts","tags":["work"],"title":"面试总结：特斯拉实习"},{"categories":null,"contents":"linux 内核为创建【用单链表解决冲突的哈希表】设计了专门的数据结构 hlist。\nhlist 整体来说是带头结点的双向链表，头结点的类型为hlist_head, 普通节点 的类型为hlist_node. 为什么要区别两种类型？节约空间， 因为哈希表的 表项类型可以是hlist_head, 它其实不需要prev指针, 比起一般的结点，一个 哈希表能节约一半的空间。\n所以一个哈希表和头结点的结构可表示为:\n1struct hlist_head { 2 struct hlist_node *first; 3}; 4struct hlist_head table[TALBE_SZ]; 二象性 任何事物都具有二象性，区分两种类型节约空间的空间，也带了一个问题： 首个hlist_node结点的prev指向哪呢？\n正常情况下肯定毫不犹豫的指向头结点，即hlist_head，但注意此时类型是 不同的，prev不能同时是struct hlist_head*和struct hlist_node *。\n解决方案有两个，首先可以使首个结点的prev=NULL, 这样虽然避免了类型引发的 问题，也能保证功能正确，但是却破坏了一致性，使得操作的复杂度上升，增加了许多 判断分支。\n1// delelt a node 2void del_node(struct hlist_head *head, struct hlist_node *node) 3{ 4 // 这个if 本来是不需要的，甚至参数的head 也不需要传， 5 // 更好的处理方式见解决方案2 6 if (node == head-\u0026gt;first) { 7 head-\u0026gt;first = node-\u0026gt;next; 8 } 9 else { 10 node-\u0026gt;prev-\u0026gt;next = node-\u0026gt;next; 11 } 12 13 if (node-\u0026gt;next) { 14 node-\u0026gt;next-\u0026gt;prev = node-\u0026gt;prev; 15 } 16} 17// insert a node 18void add_node_before(struct hlist_head *head, struct hlist_node *new 19 struct hlist_node *next) 20{ 21 // 这个if 本来是不需要的，参数head也是不需要传递的 22 if (next == head-\u0026gt;first) { 23 new-\u0026gt;prev = NULL; 24 head-\u0026gt;first = new; 25 } 26 else { 27 new-\u0026gt;prev = next-\u0026gt;prev; 28 new-\u0026gt;prev-\u0026gt;next = new; 29 } 30 new-\u0026gt;next = next; 31 next-\u0026gt;prev = new; 更好的解决方案: **prev 改变struct hlist_node的构成，使用二级指针:\n1struct hlist_node { 2 struct hlist_node *next; 3 struct hlist_node **pprev; 4}; 使得每个结点的pprev = \u0026amp;(prev_node-\u0026gt;next), 首先类型是统一的，其次删除和添加 都无需额外的分支了。\n1void del_node(struct hlist_node *node) 2{ 3 *(node-\u0026gt;pprev) = node-\u0026gt;next; 4 if (node-\u0026gt;next) 5 node-\u0026gt;next-\u0026gt;pprev = node-\u0026gt;pprev; 6} 7void add_node(struct hlist_node *new, struct hlist_node *next) 8{ 9 new-\u0026gt;pprev = next-\u0026gt;pprev; 10 *(new-\u0026gt;pprev) = new; 11 new-\u0026gt;next = next; 12 next-\u0026gt;pprev = \u0026amp;(new-\u0026gt;next); 13} Ref:\n **prev 可以提高删除的效率 stackoverflow  ","date":"2023-05-11T20:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/data_struct/hlist/","section":"posts","tags":["c","linux"],"title":"Linux 内核数据结构 hlist"},{"categories":null,"contents":"内存对齐为何被需要 架构规定了数据类型大小的同时，也规定了对这些类型的变量合法访问的对齐要求。 也就是说，变量不能随便的放在内存的任意位置，起始地址必须满足特定的对齐要求， 对不满足要求的变量强行访问就叫做非对齐访问， 非对齐访问通常会触发异常。\n一般数据类型的对齐要求 对于一般的数据类型，比如 int, long, char 这些，要求其变量地址对齐到自身大小， 比如 ARM64 中，int 变量的地址必须对齐到 4 字节，long 变量地址必须对齐到 8 字节等等。\n那么对于*(int *)0x1001 = 1234;, 这类的内存访问就叫非对齐的内存访问。\n 即 （变量 addr % 变量 size) ！= 0, 就称为非对齐内存访问。\n 结构体的对齐要求 上面说的还都是一般的数据类型，对于结构体这种复杂的类型，对齐的要求也复杂些。\n 首先是结构体成员，每个成员都必须满足其自身的对齐要求 然后是结构体变量自身的起始地址的对齐要求是其所有成员的最大对齐要求。  然而两个要求均满足有时候根本不可能，比如一个结构体声明为:\n1struct foo { 2 char mem1; 3 int mem2; 4 short mem3; 5}; 不可能同时做到 foo 变量和其成员 mem2 同时满足对齐到 4 字节，所以编译器会依据 上面的两条要求在成员之间添加 padding。\n除了变量中间添加 padding 外，在末尾也会添加，使得结构体数组容易满足对齐需求。\n最后 foo 变量在内存中的样子可能是:\n1struct foo { 2 char mem1; 3 char _pad1[3]; // 保证结构体和成员均对齐正确 4 int mem2; 5 short mem3; 6 char _pad2[2]; // 保证【结构体数组】对齐正确 7};  若结构体的成员还是一个结构体，嵌套操作就可以了，编译器可以 handle。\n  对于结构体的定义来说，若不想添加 padding，可以使用__attribute((packed)) 来声明。 常用于一些数据包的声明，除非你清楚自己为什么要这么做，要不别用。\n 如何做到内存对齐 上面一节说明了各个类型的变量对于内存对齐的需求，只要是各个类型变量的地址满足要求了， 对所有变量的访问也就 OK 了。那么如何保证每个变量地址都满足需求呢？\n对于静态分配的变量，即在编译链接时期就能确定地址，由编译器完成这项工作。编译器保证 分配给这些变量的地址是满足对齐要求的，这个完全不用担心。\n对于运行时动态分配的变量，例如malloc()接口返回的，其实 malloc 本身不知道要申请 空间的对齐规则，因为它只接受一个 size 作为参数。 所以一般来说，为了保证满足所有的 对齐要求，malloc() 返回的地址总是满足最大的对齐请求，即指针的大小 8 字节。\n malloc() 的实际效果与运行库的实现有关，并不是规定死的。不过我还没有见过不是 按照最大对齐要求分配的实现方法:)\n AArch64 对非对齐访问的支持 非对齐访问的结果是架构定义的， 不同的架构可能造成的结果不同：\n 架构可能支持非对齐访问，成功读取数据 架构不支持非对齐访问，产生异常  AArch64 架构支持 16、32、64 和 128 位的非对齐访问，但是有几个前提条件:\n 关闭系统的对齐检查: SCTLR_ELx.A bit 来控制 exclusive load/store 和 load-acuqire/store-release 两类指令必须是对齐访问的 。这就表示构建信号量和其他锁机制时必须是对齐访问的 非对齐访问仅“普通内存”可用，\u0026quot;Device memory\u0026ldquo;必须是对齐访问的   AArch64 非对齐访问的原理是分解为多次的访存，所以不能保证原子性，且性能是较差的。\n  虽然 AArch64 支持非对齐访问， 但编译器默认还是会生成满足对齐要求的代码。\n ","date":"2023-05-08T17:19:44+08:00","permalink":"https://wangloo.github.io/posts/c/alignment/","section":"posts","tags":["arm64","c","Operating System"],"title":"C语言的内存对齐"},{"categories":null,"contents":"有了虚拟内存系统之后，MMU 可以抽象出一些可配置的内存属性。\n例如，配置某个虚拟内存区域为不可执行、不被 cache 等，不可执行的属性 有助于防范攻击，不进入 cache 经常划分给 外设 Memory-mapped 区域。\n设置内存属性  相关内容可以在 ARMv8 arm 手册 D5.3.3 Attuibute fields in stage 1 VMSAv8-64 Block and Page descriptors 中找到参考\n 对于每一个表示内存块(block)的页表项，都有两个属性字段: lower attr 和 upper attr.\n以下任何类型或者属性的设置都是通过这两个字段完成的。\n大类: 内存类型 AArch64 提供两种内存类型: 普通内存和设备内存。\n  普通内存会启用架构提供的所有优化技术，例如合并访存、乱序执行等。所以 普通内存有最高的性能，但同时不是那么的“安全”，需要底层人员手动使用 内存屏障等手段保证某些情况下的顺序性要求。\n  设备内存，顾名思义，常映射到外设的 Memory-mapped 区域。对于设备来说， 那些提高性能的技术会造成一些问题，例如某些寄存器的配置必须按照顺序， 这时就不能使用乱序执行。设备内存就牺牲了性能，优先保证正确性。\n  配置内存类型也是通过页表项中的其中一个属性字段: AttrIndx[2:0], 它与系统寄存器MAIR_EL1配合实现。\n具体表现为: mair_el1寄存器被划分为 8 个字段，我们为每个字段写入 不同的值可代表不同的内存类型和一些配套属性，具体的真值表可以参见 mair_el1寄存器的描述。\n mair_el1中内存类型配套属性只是属性的一部分，是和设备类型绑定的 那部分。\n 更细分的描述(1): cacheable 内存支持配置为是否被 cache，这在mair_el1的字段中配置。\n要注意，只有普通内存才支持配置是否进入 cache，所有的设备内存 都是 non-cacheable 的。\n更细分的描述(2): shareable shareable 说的是一块内存的外部可见性，也可分为 inner/outer shareable.\nshareable 的设置需要参考此内存的 cacheable 属性:\n  如果一块内存是 cacheable 的，则需要硬件提供 cache 的一致性维护机制。 如果不能保证 cache 的一致性，想要启用 shareable 就必须是 non-cacheable\n  对于 non-cacheable 的内存，一定是 shareable 的， 不需要配置。因为此时对数据的修改直接操作内存，读取操作亦是如此，一定 是外部可见的\n  更细分的描述(x): \u0026hellip; TODO\n","date":"2023-04-12T08:01:33+08:00","permalink":"https://wangloo.github.io/posts/armv8/memory_attr/","section":"posts","tags":["armv8"],"title":"AArch64 内存属性与内存类型"},{"categories":null,"contents":"枚举类型的优势 枚举类型完全可被宏定义替代，类如\n1enum Furniture { 2\tDOOR = 1, 3\tDESK, 4\tLOCK, 5} 与下面的代码等效\n1#define DOOR 1 2#define DESK 2 3#define LOCK 3 那么我们如何在两种设计方法中选择呢？在我看来某些情况下使用 enum 会有以下优势：\n 提高代码键入效率；仅适用于所需变量的值是连续的整数，就像上面的情况，可以只给第一个 DOOR 赋值，其余的值累加。如果首个变量的值要求是 0，甚至每一个都无需显式赋值 提高代码的可维护性；可以划定范围，编译器也会检查类型是否正确，偶尔会有用 提高代码的可读性；例如 DOOR, DESK, LOCK\u0026hellip; 都属于家具，均定义在 Furniture 中  枚举类型所占的大小 枚举类型所占内存的大小，即枚举变量的大小。\n由于枚举变量的赋值，一次只能存放枚举结构中的某个常数。所以 枚举变量的大小，实质是常数所占内存空间的大小（常数为 int 类型，当前主流的编译器中一般是 32 位机器和 64 位机器中 int 型都是 4 个字节），枚举类型所占内存大小也是这样。\n所以默认情况下，无论枚举变量的值是多少，都是占用 4 个字节。即执行：\n1printf(\u0026#34;sizeof(enum Furniture) = %d\\n\u0026#34;, sizeof(enum Furniture)); 输入的结果是 4。\n编译选项：-fshort-enums GCC 下关于这个编译选项的介绍：\n -fshort-enums Allocate to an enum type only as many bytes as it needs for the declared range of possible values. Specifically, the enum type is equivalent to the smallest integer type that has enough room. Warning: the -fshort-enums switch causes GCC to generate code that is not binary compatible with code generated without that switch. Use it to conform to a non-default application binary interface.\n 意思是说使用-fshort-enums 后，对改枚举类型所占空间的分配就会按照实际变量的占用空间，而非总是 4 字节。\n启用该选项之后，再打印它的 size 就会是 1，因为用 1 个字节就能表示所有枚举变量的值（DOOR=1，DESK=2，LOCK=3）.\n这个“1”不再是固定的，根据其中枚举变量值的不同，动态调整enum Furniture的大小。\n1enum Furniture { 2\tDOOR = 256, 3\tDESK, 4\tLOCK, 5} 再打印它的 size，结果为 2。因为值 256 无法用 1 个字节存下。\nenum 潜在的可移植性问题 看似好像启用该选项会节约一定的内存空间，是的。但它也有一定的缺点，其一就是可移植性问题。\n例如你编写的应用在编译时没有启用了该“优化”选项，默认采用 4 字节存储枚举变量。而链接的库文件在编译时却使用了“优化”选项，则库内部此枚举类型的大小可能为 1 字节。若此时恰好你有调用某个库 API，将 enum 变量作为参数进行传递，那么就会发生错误。\n为避免不同库和应用程序使用“优化”选项的差异造成潜在的危险，常用的解决方案是强制使 enum 变量占用 4 个字节，无论其是否开启“优化”。实现方式是在 enum 变量末尾添加一个成员 XXXX_END = 0xFFFFF，例如：\n1enum Furniture { 2 DOOR = 1, 3 DESK, 4 LOCK, 5 END = 0xFFFFF, 6} ","date":"2023-03-09T17:18:57+08:00","permalink":"https://wangloo.github.io/posts/c/enum/","section":"posts","tags":["c"],"title":"C语言enum的使用"},{"categories":null,"contents":"函数指针 指针的数组 or 指向数组的指针? 1\u0026gt;\u0026gt; int (*p)[10] p是指针, 指向长度为10的数组. 加括号是为了强调p是一个指针, 区别包含10个指针的array. 2\u0026gt;\u0026gt; int *(p[10]) p是数组, 它的元素类型是int *, 加括号是为了强调p是数组. 3\u0026gt;\u0026gt; int *p[10] 等效于int *(p[10]) 基础架构 1// 函数指针 2\u0026gt;\u0026gt; int (*f)(int) 说明f是一个指向函数的指针, 加括号为了区别返回值为int*的函数 3\u0026gt;\u0026gt; f = function; 函数指针的赋值 4\u0026gt;\u0026gt; (*f)(x) 函数指针指向函数的调用, 可简化为f(x). 但是容易将f误认为是函数. 5 6// 函数指针的数组 7\u0026gt;\u0026gt; int (*(f[10])) (int) f是数组,元素为10个函数指针. 内层括号说明f是数组,外层括号说明元素类型是函数指针 8\u0026gt;\u0026gt; int (*f[10]) (int) 与上面等效. 但外层括号不能省略 9\u0026gt;\u0026gt; f[0] = function() 赋值 10\u0026gt;\u0026gt; (*f[0])() 指向函数的调用, 可简化为f[0]() 11 12// 返回函数指针的函数 13\u0026gt;\u0026gt; void (*signal(int sig, ...))(int); signal是一个函数, 参数有sig.... 它的返回值是一个函数指针, 指向任意返回值为void, 参数为int的函数. typedef帮助理解函数指针 signal()是一个系统调用, 用于告诉系统, 当某种特定\u0026quot;软件中断\u0026quot;发生时调用特定的程序. 它的真正名称应当是: Call that routine when the interrupt comes in.\n看signal()的原型, 非常复杂. 根据上面基础架构的铺垫, 可以看出signal()的返回值是函数指针, 同时它的参数也是一个函数指针. 且这两个函数指针所指向函数的返回值和参数相同.\n1void (*signal(int sig, void(*func)(int)))(int); 可以借用typedef表示通用部分.\n1typedef void (*sighandler_t)(int); 而后signal的声明就是人能看懂的了:\n1sighandler_t signal(int signum, sighandler_t handler); C语言标准 我们在使用C语言编程时很少有人告诉我们C语言各个标准的情况，于是我们在看见一些函数标定支持的C标准（例如仅支持C99及以后），内心不会有什么波澜。\n我们常见这些C标准：K\u0026amp;R C、ANSI C、ISO C、C89、C99、C11、C18。让我们补充点可能很少使用的知识吧。\n什么是K\u0026amp;R C？ 1978年，丹尼斯•里奇（Dennis Ritchie）和布莱恩•柯林汉（Brian ernighan）合作出版了《C程序设计语言》的第一版。书中介绍的C语言标准也被称作“K\u0026amp;R C”。\n最初的C标准与我们现在用的有较大差别，例如它竟然还不支持void类型！\n什么是ANSI C、ISO C、C89、C90标准？ 随着C语言使用得越来越广泛，出现了许多新问题，人们日益强烈地要求对C语言进行标准化。1983年，美国国家标准协会（ANSI）组成了一个委员会，X3J11，为了创立 C 的一套标准。经过漫长而艰苦的过程，该标准于1989年完成，这个版本的语言经常被称作ANSI C，或有时称为C89（为了区别C99）。在1990年，ANSI C标准（带有一些小改动）被美国国家标准协会（ANSI）采纳为ISO/IEC 9899:1990。这个版本有时候称为C90或者ISO C。综上，ANSI C、ISO C、C89、C90其实是同一种标准。\n这一版本的C就更接近我们平常使用的C了，大部分特性都引入了。\n什么是C99标准？ 2000年3月，ANSI 采纳了 ISO/IEC 9899:1999 标准。这个标准通常指C99。\nC99我们最常使用的新特性是：在源代码的中间位置声明变量。\n什么是C11标准？ C11标准是C语言标准的第三版（2011年由ISO/IEC发布），前一个标准版本是C99标准。与C99相比，C11有哪些变化呢？\n11、 对齐处理：alignof(T)返回T的对齐方式，aligned_alloc()以指定字节和对齐方式分配内存，头文件\u0026lt;stdalign.h\u0026gt;定义了这些内容。 22、 _Noreturn：_Noreturn 是个函数修饰符，位置在函数返回类型的前面，声明函数无返回值，有点类似于gcc的__attribute__((noreturn))，后者在声明语句尾部。 33、 _Generic：_Generic支持轻量级范型编程，可以把一组具有不同类型而却有相同功能的函数抽象为一个接口。 44、 _Static_assert()：_Static_assert()，静态断言，在编译时刻进行，断言表达式必须是在编译时期可以计算的表达式，而普通的assert()在运行时刻断言。 55、安全版本的几个函数：gets_s()取代了gets()，原因是后者这个I/O函数的实际缓冲区大小不确定，以至于发生常见的缓冲区溢出攻击，类似的函数还有其它的。 66、 fopen()新模式：fopen()增加了新的创建、打开模式“x”，在文件锁中比较常用。 77、 匿名结构体、联合体。 88、 多线程：头文件\u0026lt;threads.h\u0026gt;定义了创建和管理线程的函数，新的存储类修饰符_Thread_local限定了变量不能在多线程之间共享。 99、 _Atomic类型修饰符和头文件\u0026lt;stdatomic.h\u0026gt;。 1010、改进的Unicode支持和头文件\u0026lt;uchar.h\u0026gt;。 1111、quick_exit()：又一种终止程序的方式，当exit()失败时用以终止程序。 1212、复数宏，浮点数宏。 1313、time.h新增timespec结构体，时间单位为纳秒，原来的timeval结构体时间单位为毫秒。 什么是C18标准？ C18也称C17是于2018年6月发布的 ISO/IEC 9899:2018 的非正式名称，也是目前（截止到2020年6月）为止最新的 C语言编程标准，被用来替代 C11 标准。\nC17 没有引入新的语言特性，只对 C11 进行了补充和修正。\n​\n如何查看自己程序的C标准版本？ 使用宏__STDC_VERSION__可以输出当前使用的C标准版本，是一个长整型：\n1printf(\u0026#34;C std version:%ld\\n\u0026#34;, __STDC_VERSION__); 值与标准的对应关系：\n   标准 宏     C94 _STDC_VERSION_= 199409L   C99 _STDC_VERSION_= 199901L   C11 _STDC_VERSION_= 201112L   C18 _STDC_VERSION_= 201710L    ​\n如何指定按照某个标准执行编译？ 以下的介绍只针对GCC，我没有用过别的编译器。\nGCC中可以添加--std=xxx来指定C标准版本，常用的情况如下：\n1-std=c11 Conform to the ISO 2011 C standard 2-std=c89 Conform to the ISO 1990 C standard 3-std=c90 Conform to the ISO 1990 C standard 4-std=c99 Conform to the ISO 1999 C stand 5 6 7-std=gnu11 Conform to the ISO 2011 C standard with GNU extensions 8-std=gnu89 Conform to the ISO 1990 C standard with GNU extensions 9-std=gnu90 Conform to the ISO 1990 C standard with GNU extensions 10-std=gnu99 Conform to the ISO 1999 C standard with GNU extensions  默认情况下，我电脑上的gcc 5.4.0使用-std-gnu11\n 参考目录 https://blog.csdn.net/zhengnianli/article/details/87387268\nC Dialect Options (Using the GNU Compiler Collection (GCC))\n含糊不清的符号扩展 问题出在哪？ 下面一段代码会输出什么呢？\n1char c = 0xff; 2 3if (c == 0xff) 4 printf(\u0026#34;successful\\n\u0026#34;); 5else 6 printf(\u0026#34;failed\\n\u0026#34;); 答案是取决于不同的编译器设定：\n 当编译器将char识别为signed char时，该判断会失败。因为常数0xff被识别为int类型，所以编译器首先要对c进行符号扩展，判断语句c == 0xff此时等价于(int)c == 0xff。而对于signed char类型是扩展其最高位，即(int)c=0xffffffff，if判断失败。 当编译器将char识别为unsigned char时，判断成功。对于unsigned char类型总是扩展0。   注：gcc可通过添加编译参数 -fsigned-char/ -funsigned-char来指定编译器如何识别char\n 同样的问题也存在与位域(bitfiled)中，详见-fsigned-bitfields/-funsigned-bitfields参数。\n如何避免？ 在使用char类型时，根据情况写清楚unsigned/signed char就ok\n1unsigned char c = 0xff 2 3if (c == 0xff) 4 printf(\u0026#34;successful\\n\u0026#34;); 5else 6 printf(\u0026#34;failed\\n\u0026#34;); 右移和除法 你是否有听说过有符号数不能使用右移操作(\u0026gt;\u0026gt;)来代替除法？ 这篇短文会向你证明它，并尝试向你解释为什么。\nLogical Shift .vs. Arithmetic Shift 若你现在有二进制数x=1110B，对其施加右移操作，请问高位填0还是填1？\n逻辑移位不管造成的影响，总是用0来填充移位操作产生的空缺。但是这样简单的想法在一些情况总会出错。例如若上述x是有符号数，那么简单的填0就会造成错误，起码正负号出错了。\n算数移位支持有符号数的移位操作，在移位后使用符号位进行填充，结合补码的表示方法，就能实现正确的负数移位操作。\n总结来说：在有符号的场景下，使用算数位移；如果你能保证移位操作是无符号的，那么用逻辑位移也无妨.\nx86汇编代码中，shr代表逻辑右移指令，sar代表算数右移指令，我们可以通过以下C代码及其反汇编的结果来更好的理解逻辑移位和算数移位：\n1#include \u0026lt;stdlib.h\u0026gt;2#include \u0026lt;stdio.h\u0026gt;3 4signed int x = -3; 5unsigned int y = 3; 6 7int main() 8{ 9 x \u0026gt;\u0026gt;= 1; 10 y \u0026gt;\u0026gt;= 1; 11 return 0; 12} 1x: 2 .long -3 3y: 4 .long 3 5main: 6 push rbp 7 mov rbp, rsp 8 mov eax, DWORD PTR x[rip] 9 sar eax 10 mov DWORD PTR x[rip], eax 11 mov eax, DWORD PTR y[rip] 12 shr eax 13 mov DWORD PTR y[rip], eax 14 mov eax, 0 15 pop rbp 16 ret https://godbolt.org/z/K4M4Ko4c7\n实践出真知 在我作为一个初级程序员的认知中，/2和\u0026gt;\u0026gt;1是等价的，甚至一起还听说过后者能够优化代码的效率。但是今天我要告诉你， Definitely wrong!\n或许在遥远的古代，我们使用位移操作真的能够对代码进行加速，但是当下编译器已经足够聪明，如果你真的动手反汇编\u0026quot;/2\u0026ldquo;的代码，那么你就会知道编译器已经替你优化为了位移操作。\n更糟糕的是，我们要避免使用移位操作来实现除法或者乘法，不仅仅是因为这两者等价，实际上，他们并不是等价的！并且会造成错误！\n考虑如下的C语言代码：\n1#include \u0026lt;stdlib.h\u0026gt;2#include \u0026lt;stdio.h\u0026gt;3 4signed int x = -3; 5signed int y = -3; 6 7int main() 8{ 9 x \u0026gt;\u0026gt;= 1; 10 y /= 2; 11 return 0; 12} 他们的汇编代码是相同的吗？这里还是拿X86汇编举例：\n1; Following is ‘x \u0026gt;\u0026gt;= 1’ 2mov eax, #-3 ;x 3sar eax 4mov x, eax 5; Following is ‘y/= 2’ 6mov eax, #-3 ;y 7mov edx, eax 8shr edx, 31 9add eax, edx 10sar eax 11mov y, eax 注意：以上的汇编代码省去了一些我认为无关紧要的操作，并不是完全正确的，但是足够表达他们的差别了。\n可以看出，除法比移位多了一步shr edx, 31过程，下面会探讨这个。\n还有一件使你震惊的事件，x, y的值最终是不同的！是的，正是因为那条看似“多余”的shr指令。\n为什么结果不同 首先，我们可以确定的一件事是：编译器真的帮我们将除法操作优化为移位。所以，再也不要说你的代码中使用\u0026gt;\u0026gt;来替代除法是为了增加执行效率了。\n让我们来解释下为什么两者的结果是不同的。\n首先，sar指令在x86指令集中表示算数右移，这个是我们熟悉的，那么-3进行算数右移后的结果就是-2. 意味着\u0026gt;\u0026gt;是向负无穷舍入的.\n那么除法操作又是在干什么呢? 它是将原值加上其符号位.Demo中使用的数据类型是32位int.\n1shr edx, 31 2add eax, edx 这样做必然改变了原值啊，动手算一下就会知道，-3/2的结果为-1. 并且只有负奇数会受影响，对于正数，其符号为0；对于负偶数，其补码的最低位必为0，刚加上的1会被下一步的算数右移丢弃，不对高位产生影响。\nAha, 差别就是向负无穷舍弃还是向0舍弃，一时间竟然不知道哪个是正确的了。\n我们应该如何做 根据最新的[C语言标准草案](ISO/IEC 9899:201x (open-std.org)) 6.5.7章节，负数的右移操作是implementation-defined，即取决于具体的实现：\n The result of E1 \u0026raquo; E2 is E1 right-shifted E2 bit positions. If E1 has an unsigned type or if E1 has a signed type and a nonnegative value, the value of the result is the integral part of the quotient of E1 / 2E2. If E1 has a signed type and a negative value, the resulting value is implementation-defined.\n 因此，理论上它依赖于实现。所以我们在实际应用中为了程序的可移植性，应当避免对有符号数使用移位操作。除非你能确定它的值一定是非负数，在此情况下，请将它用无符号类型来声明。\n对于除法操作，标准中的6.5.5章节规定了，除法操作总是向0舍入. 非常好！\n When integers are divided, the result of the / operator is the algebraic quotient with any fractional part discarded.\n 检查你的代码，恢复所有的“优化”乘除法的行为吧！\n","date":"2023-03-09T17:18:57+08:00","permalink":"https://wangloo.github.io/posts/c/feature/","section":"posts","tags":["c"],"title":"C语言的特点与难点"},{"categories":null,"contents":"头文件的引用形式 C 中引用一个头文件有两种形式 #include \u0026lt;\u0026gt;和#include \u0026quot;\u0026quot;，在应用开发中，需要引用一些系统库文件，我们通常使用\u0026lt;\u0026gt;，对于自己定义的头文件，我们会使用\u0026quot;\u0026quot;。\n然而对于底层软件的开发，比如说操作系统，用到的库都是自己工程中的文件，那么此时用\u0026quot;\u0026quot;和\u0026lt;\u0026gt;有时都能 work，那么它们的区别是什么呢？\n搜索相关关键词得到的结论是: 两种方式的区别是搜索文件的优先级， \u0026quot;\u0026quot;优先搜索的当前目录，而\u0026lt;\u0026gt;优先搜索系统库文件目录。对于这个系统库，即那些使用gcc -I\u0026lt;dir\u0026gt;参数指定的路径。 当然，如果第一优先级位置没有被找到，也会到另一个目录中搜索。这么两种方式均可，实际工程中也有部分人混合使用，毫不在意规则。但是有时会导致一些细节问题，比如说我们经常会用到-MMD或者类似选项生成目标文件的依赖，方便实现增量编译。此时就可能会产生一些问题。\n假设你有一个头文件inc/father.h, 它里面会引用inc/child.h, 对于根目录下的源文件main.c，其引用语句该如何写呢？以下列出的几种形式都可以，任意的排列组合\n1// 编译参数: -I. -MMD 2// main.c 3#include \u0026#34;inc/father.h\u0026#34;4#include \u0026lt;inc/father.h\u0026gt;5 6// father.h 7#include \u0026#34;inc/child.h\u0026#34;8#include \u0026lt;inc/child.h\u0026gt;9#include \u0026#34;child.h\u0026#34;10#include \u0026lt;child.h\u0026gt; 如果 main.c 是使用系统库路径(-I.)来找到的 father.h, 即上面 main.c 的第 2 种情况，那么其生成依赖文件的形式内容都是绝对路径，包括 father.h 中的引用（因为即便 child.h 是相对路径找到的，相对的也是 father.h，其基准就是绝对路径）。例如:main.o: main.c /home/xx/father.h /home/xx/child.h 否则即以相对路径找到 father.h,即上说 main.c 的第 1 种，那么生成 father.h 依赖的方式一定是相对路径，但 child.h 的形式却取决于其本身.  也就是说，如果 child.h 的寻找方式是绝对的（上面的第 1,2,4 种），那么依赖文件的形式就是main.o: main.c inc/father.h /home/xx/child.h. 如果 child.h 的寻找方式是相对的(上面的第 3 种)，那么依赖文件的形式是main.o: main.c inc/father.h inc/child.h    依赖文件的形式很重要，最简单的方式是均使用绝对路径，此时不需要考虑依赖文件在 makefile 中 include 的位置，也就是不需要考虑 make 的“当前路径”。如果非得使用相对路径，那么已经要确定能够 makefile 中 include 时的 make 当前路径就是生成依赖文件的路径，否则不能建立正确的依赖关系。\n实际上，在“基础架构”优秀的项目中，不可能出现或者尽量避免出来两种形式都能找到头文件的情况。比如说，我们会将源文件统一放在子目录src/下与头文件隔离，这样就从根本上避免了相对依赖的生成，只能通过系统库的形式来找头文件。拿上面的例子来说，正确的方式是：main.c 放入 src/中，然后不管是源文件还是头文件，都统一使用#include \u0026quot;inc/xxx\u0026quot;。这样做即统一，也能保证所有的依赖都是绝对路径形式\n 另外说一点，其实依赖文件(.d)中源文件的依赖项形式也是需要考虑的，这不能通过系统架构来解决，只能用 Makefile 的技巧来实现。比如说，我们的 make 当前目录总是根目录，而在建立 OBJS 变量时为其加上绝对路径的前缀， 从而 make 不需要进入各级子目录，生成的依赖文件也都是相对于根目录的，include 依赖文件的行为也是在根目录进行的，保证统一。\n 外部库的使用方式 最近我在开发项目是, 需要使用到 libelf 库, 我在 Github 上找到了其源代码.\n我之前使用一个 lib 都是以链接的形式使用动态库/静态库, 但是既然它提供了源码, 那么我可以直接将源码拷贝到我的项目中吗? 答案肯定是可以, 那么这两种方案该如何抉择呢?\n在查阅了一些资料后, 我总结了以下几个判断依据:\n 库的大小/对编译时间的敏感度; 如果使用源代码, 每次编译项目时需要额外对库文件进行编译(起码是第一次), 而库文件的定义是不常修改的, 如果库文件比较大, 则会延长整个项目的编译时间. 是否需要版本控制; 要使用的库如果需要区分版本, 或者分配给其他的团队成员使用, 那么用库的形式似乎更为方便 发挥 git submodule 的优势;   Ref: c++ - Should I add the source of libraries instead of linking to them? - Software Engineering Stack Exchange\n const 修饰符的妙用 有些时候, 我们设计的结构体中会有name字段, 类型是char *. 在使用时为它分配空间, 不使用时需要回收.\n其实还有另一种情况, 就是name要指向预先定义好的\u0026quot;static name list\u0026quot;, 适用于 name 的取值是确定的范围. 例如, libdwarf 库中的描述 section name 的dss_name 成员.\n这时, 为了防止使用者调用free()来释放它, 我们可以将其声明为const char *, 此时如果调用free(.dss_name), 编译器会给出警告:\n1const.c:16:10: warning: passing argument 1 of ‘free’ discards ‘const’ qualifier from pointer target type [-Wdiscarded-qualifiers] 2 16 | free(dss_name); 3 | ^~~~~~~~ ","date":"2023-02-27T19:20:20+08:00","permalink":"https://wangloo.github.io/posts/c/experience/","section":"posts","tags":["c"],"title":"C语言程序设计的一些经验"},{"categories":null,"contents":"使用VIM 打开一个文件时, 有时会看到例如 ^M 这类字符出现. 下面我会挖一下其出现的原因.\nEOL 字符 EOL 或者说 end-of-line 表示一个新行的开始.\nEOL 字符在不同的操作系统中是不同的. 本文中仅以 Linux 和 Windows 为例说明.\n Windows中是以读到回车\u0026lt;CR\u0026gt;和换行\u0026lt;LF\u0026gt; 表示 EOL. Linux 中仅以换行作为EOL    回车\u0026lt;CR\u0026gt; : Carriage return. 将光标回到行首, 对应C语言中的 \\r 换行\u0026lt;LF\u0026gt; : Line feed. 将光标下移一行, 对应C语言中的 \\n   在 Linux 中打开 Windows 下的文件将多余的回车通常显示成 ^M 或者 Control-M\nRef End Of Line Characters\n","date":"2022-12-24T01:35:24+08:00","permalink":"https://wangloo.github.io/posts/c/end-of-line/","section":"posts","tags":["other"],"title":"行结束符在windows和linux的区别"},{"categories":null,"contents":"我始终以为，C库中常用的 errno 仅是一个全局变量，使用了全局变量就无法保证线程安全了，因为全局变量在所有线程中都是共享的。\n要实现线程安全的errno 就必须将其设置为线程私有的变量，下面就来看看GCC是如何巧妙的实现的。\n正文 现在的errno定义并非一个全局变量, 而是一个宏定义, 以下是在usr/include/errno中的声明:\n1extern int *__errno_location (void); 2# define errno (*__errno_location ()) 这种方式下其实现原理大概是: __errno_location 函数返回一个int指针, 而这个函数的实现中, 返回的就恰好是实际的errno 变量(与宏同名)的地址, 所以对其解引用就相当于对其值进行操作. 所以, 这种定义规则下, 左值和右值表达式均成立.\n1errno = 10; // *__errno_location () = 10 2int x = errno; // x = *__errno_location (); __errno_location 的实现就至关重要, 因为如果其返回的变量地址不包含任何技巧的话, 就和原先直接定义全局变量的方式没差了, 说到底能否实现线程安全, 还得看实际保存errno的变量是否为线程独有的. 目前还没有发掘到其精髓, 只是套壳而已.\n以下给出/csu/errno-loc.c中__errno_location 的实现, 与我们预期一致, 返回变量的地址. 而同名变量errno则定义在/csu/errno.c中, 决定了能够实现errno的线程安全.\n1int * 2__errno_location (void) 3{ 4 return \u0026amp;errno; 5} 1__thread int errno; \u0026ldquo;__thread\u0026rdquo; 是GCC提供的扩展前缀, 表示该变量将被库处理为线程私有的, 注意这一步是C库完成的, 对程序员透明. 相关的理论叫 Thread-local Storage, AArch64 架构实现的原理是利用TPIDR_EL0 寄存器, 其他架构可以参考此PDF\n :question: 以上源文件中有注释为 non-threaded版本的实现, 是代表什么含义呢?\n ​\n虽然我暂时没有查阅到errno的其他线程安全的实现原理, 但起码GCC下该方式这是可行的. 依靠的是\u0026quot;__thread\u0026ldquo;的支持, 与换成宏定义的方式无关, 不排除可能为了考虑兼容其他实现方式的可能性.\n参考 c - How is thread-safe errno initialized if #define substitutes errno symbol? - Stack Overflow\n","date":"2022-12-21T19:08:22+08:00","permalink":"https://wangloo.github.io/posts/os/errno_thread_safe/","section":"posts","tags":["Operating System"],"title":"浅谈 errno 的线程安全问题"},{"categories":null,"contents":"合并操作: git merge merge 有两种方式:\n fast-forward three-way merger  Fast-forward Merge 假设合并的双方为main为dev, 如果其中一个是另一个的祖先, 此时直接移动 HEAD 到前方即可, 称为 fast-forward.\n例如, 当前在 main, 执行git merge dev的过程如下:\n1 main main 2 | | 3M1 --- M2 ===\u0026gt; M1 --- M2 -- F1 4 \\ | 5 \\--- F1 dev 6 | 7 dev three-way Merge 合并的两者不构成直接的祖先-孩子关系, 产生了分叉. 此时进行合并就需要有个基准(参考), 对于两边相较于基准的每个 diff 来说:\n 合并的两者都在基准上进行了改动, 且改动不一致, 标记为冲突 如果该 diff仅在其中一方有改动, 那么就保留此次改动  合并时使用的参考就是两个合并 commit 的最近公共祖先, 这种借助三个 commit(main, dev, 公共祖先)才能完成的合并操作就叫做 three-way merge.\n例如, 当前在 main, 执行git merge dev的过程如下:\n1 main main 2 | | 3M1 --- M2 --- M3 ===\u0026gt; M1 --- M2 --- M3 --- M4 4 \\ \\ / 5 \\--- F1 \\--- F1 --- 6 | | 7 dev dev  three-way 的合并方式如果发生了冲突, 会产生一次额外的 merge commit, 下面介绍它\n 什么情况下 merge commit 没有任何 diff? 按照上面的例子, three-way merge 发生冲突后会产生一次额外的 merge commit, 即 M4. 如果这是去查看 M4 相较前一次 commit 的 diff, 有时是没有的, 有时又会产生 diff.\n如果在解决冲突的过程中, 我们仅仅是接收了 M2,M3 或者 F1 的修改, 那么此时 merge commit 就不会有 diff.\n然而, 在解决冲突时, 我们也可以不采用来自两条路径的修改, 做一次新的修改(可以说, 同时接收两条 diff 就是这种情况), 此时查看 merge commit 的 diff 就是有内容的.\n变基: rebase rebase 命令需要指定一个基准分支，git rebase \u0026lt;base-branch\u0026gt;， rebase 会将当前所处分支整体移动到base-branch之后，即改变了当前分支的历史。\n1// before rebase 2[A]---[B]---[C]---[D]\u0026lt;-dev 3 \\ 4 \\--[E]\u0026lt;-master 5 6// after rebase 7[A]---[E]---[B]---[C]---[D]\u0026lt;-dev 8 | 9 master 交互式 rebase 交互式 rebase 是一种更高级的用法。基础的 rebase 上面说了是将当前分支的所有提交移动到 base-branch 之后。而交互式 rebase 提供一个方法，在移动之前\u0026quot;挑选\u0026quot;当前分支的 commit。\n实际工程中，通常来说，我们将开发分支移动到 master 之前，可以经过交互 rebase 来整理开发分支中混乱的 commit 记录。\n具体的使用方法是，为git rebase指令提供-i参数:\n1git checkout dev 2git rebase -i master 这个命令会打开一个文本编辑器，列出当前 feature 分支的所有提交:\n1pick 33d5b7a Message for commit #1 2pick 9480b3d Message for commit #2 3pick 5c67e61 Message for commit #3 列出的内容就能完整的表示 dev 分支的所有提交，按照顺序。而我们不仅可以任意的重排这些 commit，而且修改pick关键字就能对这些 commit 做改动。举个例子，我们可能发现 commit2 只是对于 commit1 做了一个很小的改动，它们完全可以合并为一个 commit，那么直接 commit2 的pick修改为fixup，整个内容变为:\n1pick 33d5b7a Message for commit #1 2fixup 9480b3d Message for commit #2 3pick 5c67e61 Message for commit #3 当你保存并退出这个文件时，改动就会生效，不仅将 dev 整体移动到了 master 后，并且合并了前两个 commit。\n1// after rebase interactive 2[A]---[E]---[B]---[D]\u0026lt;-dev 3 | 4 master rebase 整理多个 commit 如上面交互式 rebase 所述，当你开发完 dev 分支，需要merge到 main 分支时，可以先利用交互式 rebase\u0026quot;整理\u0026quot;一下 dev 分支的 commit。\n这里其实要用到一个小 trick，上面说过 rebase 命令需要指定一个 base-branch，实际上是一个 base-commit，这种场景下我们不是要合并其他分支，所以base-branch可以选择当前 dev 分支的前面某一次 commit。\n1git checkout dev 2git rebase -i HEAD~3 以上指令实现的功能就是给你整理最后 3 次提交的机会，但不会合并其他分支的东西。\n那如果我想整理整个 dev 分支呢？是向上找到 dev 的第一次 commit 吗？ Git 提供了一个方便找到 dev 分叉出来的那次 commit，将其输出传递给git rebase -i即可实现整理整个 dev 的所有 commit。\n1git merger-base dev main git merege vs git rebase 准则   如果分支已经被提交到远程仓库，就不能再改变他的历史了，即不能使用 rebase。 git 也会阻止你这么做，因为分支的历史已经被修改，除非 force-push。\n  你能进行 rebase 的分支是本地的”私人分支”，私人表示为: 只有你自己在使用，别人不会基于你的分支做东西。\n  dev 同步主分支的改动: rebase 假设我们正在本地的 dev 分支开发一个特性，此时你的同事在 main(也可以是其他的远程分支)上提交了一个重要的 commit，以至于你需要它来继续你的开发任务。\n这种情况我们使用 rebase 和 merge 都能完成目标，但是 rebase 是更好的选择。\n 首先满足 rebase 的使用条件，我们仅仅是破坏了本地 dev 分支的历史，并没有动到其他的远程分支，所以就不存在干涉别人 其次，在 dev 上 merge 其他分支会产生一次不必要的merge commit，其不代表任何实际意义，没必要存在的  合并 dev 到主分支: merge 很简单的逻辑，主分支或者其他合作开发的分支并不是你一个人在用，并且需要最后同步到远程仓库，不符合使用 rebase 的准则\ngit log 参数:    Parameter Description     non-param 列出所有历史提交的 SHA、作者、提交日期和 commit   -p 按补丁显示每次更新，比\u0026ndash;stat 更全   \u0026ndash;stat 显示每次更新修改文件的名称及添加（删除）的行数。比\u0026ndash;name-only 更全   \u0026ndash;name-only 显示文件清单   \u0026ndash;name-status 显示文件清单及改动方式(新增、删除、修改)   \u0026ndash;oneline 只显示前 6 位 SHA 值和 commit   -n 显示前 n 条 log   \u0026lt;branch\u0026gt; 查看某个分支的历史提交。该参数只能 log 命令之后   \u0026lt;branch1\u0026gt;..\u0026lt;branch2\u0026gt;             参考网站：https://www.cnblogs.com/bellkosmos/p/5923439.html\nExample 1: 彩色显示重要信息 1git log --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit Example 2: 查看本地分支和对应远程分支的 commit 差异 1git log --oneline main..origin/main 子模块: submodule 新增一个子模块  将子模块上传到远端仓库上\n  执行git submodule add [url] [path]\n  此时执行git status 会有两个changes，分别是：\n .gitmodules: 记录子模块的path和url [子模块同名的文件]: 记录主项目追踪的是子模块的哪个commit.   也就是说主项目中惠济路自己跟踪子模块的commit，并不一定总是最新的。\n   git add这两处改动，git commit -m \u0026quot;add submodule xxx\u0026quot;\n  clone一个使用子模块的项目  用常规的git clone命令将主项目拿下，此时子模块不会自动下载，只是一个空的目录 git submodule init，这个命令其实是带参数的，指定你想更新哪些子模块， 缺省代表所有子模块。该命令实际的行为是将.gitmodule中的内容写入.git/config git submodule update, 按照.git/config指定的子模块去下载，注意下载的 commit不一定是最新的，上面讲过   :question: git submodule init命令是否有意义？\n有时我们并不想同步所有的子模块，而是其中的某几个，因为可能想自己重写一些，这时可以添加参数 指定想要同步的那些子模块。\n  :two::three:可以合并为一条命令： git submodule update --init， 同步所有子模块。\n 修改更新子模块 如果仅仅是使用子模块，并不做修改，那不用关注这个。但如果你同时参与submodule的开发，那就需要注意。\n 修改子模块并提交；这一步很常规，cd到子模块中，做完修改commit即可 此时会发现在主项目中也多了一个额外的change，是刚才修改子模块的同名文件， 查看diff会发现改动为commit id改为了刚才提交的那次子模块修改  Q1: 这次改动代表什么含义？\n我们知道，子模块同名文件中记录主项目跟踪此子模块的commit，也是git commit update 会达到的 commit。含义是主项目配合子模块的这个commit是ok的。而这次改动也就代表跟踪的commit想要 发生变化，由于你刚才对子模块修改造成的，git自动猜测你想同时改动主项目的追踪。\nQ2: 对这个改动应该做什么操作？\n分两种场景: (1)如果子项目的这些更新有意义同步到主项目中，那么就add并commit这个同名文件的改动， message为\u0026quot;更新submodule\u0026quot;。 (2)如若只是更新子项目而已，或许是为了其他依赖的项目所改的，并不 想涉及到本主项目，那么就restore此次更新，或者重新执行submodule update即可(前提是对子模块 的修改已经push)。\n所以说，同意主项目中的这次change的人必须是更新这次子模块的人，由他决定是否同步到主项目。 其他人甚至在使用期间都不需要cd进入子模块做git pull的，这样也就不会有决策产生，即便 子项目在远端更新了，你要做的就是关注那个同名文件就行，当同名文件更新了，在主项目中 submodule update即可，\n子模块的优缺点 TODO\n","date":"2022-12-13T17:39:42+08:00","permalink":"https://wangloo.github.io/posts/tools/git/git/","section":"posts","tags":["git","tools"],"title":"git 宝典"},{"categories":null,"contents":"..\nnm - 列出符号 nm (GNU Binary Utilities) (sourceware.org)\n","date":"2022-12-03T19:08:22+08:00","permalink":"https://wangloo.github.io/posts/os/gnu_tools/","section":"posts","tags":["Operating System"],"title":"GNU 二进制工具集"},{"categories":null,"contents":"伪目标的依赖关系 Makefile 中的依赖关系指的是目标和依赖之间建立的关系，目标对应规则中的语句是否执行取决于依赖的状态。\n最简单的依赖关系可以拿两个文件来举例:\n1# gcc语句执行当前仅当 main.c 新于 main.elf 2main.elf: main.c 3 gcc main.c -o main.elf make 在执行main.elf的规则时，会先判断依赖关系。拿上面的例子来说， gcc 语句是否执行取决于main.c 和 main.elf的修改时间，只有当 依赖新与目标时，规则语句才会执行。\n然而许多情况下，目标或者依赖并不是一个文件，而是虚拟目标。虚拟目标 并不是一个文件，即它没有修改时间这个属性，此时 make 就不能作比较，结果就是 如果目标是伪目标，那么不管依赖如何都执行规则语句；如果依赖是伪目标， 那么目标的规则语句也永远被执行。下面是两个例子：\n1# 伪目标作为目标文件出现 2# build finish总是输出， 而gcc语句仅当main.c比main.elf新时才执行 3.PHONY : all 4all: main.elf 5\t@echo \u0026#39;build finish\u0026#39; 6main.elf: main.c 7\tgcc $\u0026lt; -o $@ 1# 伪目标作为依赖文件中出现 2# 不管main.c是否比main.elf更新，因为pre-work是伪目标 3# 所以gcc语句总是执行 4.PHONY : pre-work 5main.elf: main.c pre-work 6\tgcc $\u0026lt; -o $@ 上面的代码的效果是：两条规则中的语句都会执行，即使你并没有对 main.c 做任何修改！\n恐怖的空格 Makefile 中的变量结合很常见，例如$(FIXDEP)=$(FIXDEP_PATH)/build/fixdep.\n特别是当我们这些语句是从某些地方粘贴过来，要特别注意变量中是否有空格，Makefile 非常重视这个。假如$(FIXDEP_PATH)中有一个空格，那么$(FIXDEP)就变成两个宏了（不知道叫宏合不合适）。而且 Make 的执行过程很难检查出来。\n规则的执行顺序 如果不从命令行传入目标, Makefile 中定义的规则其实是以从上而下的顺序执行的, 但是我习惯把 all 这种默认规则放在最下面, 所以一般我们可以看到很多 Makefile 会在开头写一句规则all:, 作用就是告诉 make 默认(不显式指定)的目标是all.\n Busybox 根目录 Makefile 中的做法示例\n1# That\u0026#39;s our default target when \u0026gt;none is given on the command line 2.PHONY: _all 3_all:  函数的魔法 patsubst 1$(patsubst \u0026lt;pattern\u0026gt;,\u0026lt;replacement\u0026gt;,\u0026lt;text\u0026gt;) 功能：查找\u0026lt;text\u0026gt;中的单词（以空格，tab，回车，换行分割），看其是否符合\u0026lt;pattern\u0026gt;, 如果符合，将其使用\u0026lt;replacement\u0026gt;替换。可以使用通配符%。\n以下两对是等效的, 明显还是直接使用变量的替换语法操作简单:\n1$(patsubst \u0026lt;pattern\u0026gt;,\u0026lt;replacement\u0026gt;,$(var)) 2$(var:\u0026lt;pattern\u0026gt;=\u0026lt;replacement\u0026gt;;) 3 4$(patsubst %\u0026lt;suffix\u0026gt;,%\u0026lt;replacement\u0026gt;,$(var)) 5$(var:\u0026lt;suffix\u0026gt;=\u0026lt;replacement\u0026gt;) 使用 shell 变量 Make 将 $$var 转义为$var, 供 shell 处理.\ndemo(源自 6.828 根目录GNUmakefile):\n1handin-check: 2 @if test -n \u0026#34;`git status -s`\u0026#34;; then \\ 3 git status -s; \\ 4 read -p \u0026#34;Untracked files will not be handed in. Continue? [y/N] \u0026#34; r; \\ 5 test \u0026#34;$$r\u0026#34; = y; \\ 6 fi  以上 demo 还使用了 test 命令来终止 make 的执行, 如果用户没有输入y, make 将会终止执行\n ","date":"2022-12-03T19:08:22+08:00","permalink":"https://wangloo.github.io/posts/c/makefile_tricks/","section":"posts","tags":["makefile"],"title":"Makefile 一些技巧"},{"categories":["Operating system"],"contents":" ..\n环境变量相关 内存操作 网络操作 EMMC和SD卡 BOOT操作指令 bootm go 其他命令 启动相关\nmd\nmmcinfo\ncp\n","date":"2022-11-27T22:03:48+08:00","permalink":"https://wangloo.github.io/posts/os/uboot/commands/","section":"posts","tags":null,"title":"Uboot: 常用命令"},{"categories":null,"contents":"开发 mkfs.ext4 格式化文件为ext4分区\n1mkfs.ext4 \u0026lt;file\u0026gt; # 将file格式化为ext4 dd https://www.runoob.com/linux/linux-comm-dd.html\nmount 1sudo mount [file] [dir] # 挂载file到dir 2sudo umount [dir] 3sudo mount # 输出当前已经挂载的分区 通用 where and which which 查看可执行文件的位置\n1$ which python3 2/usr/bin/python3 whereis 除了可执行文件还能搜索其他类型的文件, 不常用, 详见 man whereis\n- 的妙用 一些命令支持使用 - 代替文件名, 输入输出都可以:\n 代替标准输出; 一些命令会将-o/-O 后面的-判定为输出到STDOUT, 详见下面示例. 代替标准输入;  下面给出两个同时代替输入输出的例子:\n1# 将标准输入(STDIN)的内容作为gcc的输入, 编译后的结果输出到标准输出(STDOUT) 2echo \u0026#39;void foo() {}\u0026#39; | gcc -x c -o - - 3# 将下载的文件输出到标准输出, 同时作为tar命令的输入文件, 进行解压 4wget -O - \u0026#34;https://www.dropbox.com/download?plat=lnx.x86_64\u0026#34; | tar xzf -  - 如何被解析是取决于命令的实现, 非标准. 比如 cd - 就有特殊的含义\n ","date":"2022-11-27T14:45:58+08:00","permalink":"https://wangloo.github.io/posts/shell/shell-commands/","section":"posts","tags":["shell","bash"],"title":"常用的 shell 命令"},{"categories":null,"contents":"TODO: inline 的发展历程: Myth and reality about inline in C99 – Jens Gustedt\u0026rsquo;s Blog (wordpress.com)\nGNU89: 函数的实现之前添加不同的关键字:\n  inline: 表明这个函数可能被优化. 如果没有被优化, 编译器就会视为一个常规函数的定义.\n  extern inline: 表明这个函数可能被优化. 如果没有被优化, 编译器就将这个函数的定义转换为该函数的声明, 即 extern inline func(); 因此当此函数被调用时, 可以调用一个外部的函数来替代. 如果没有函数调用它, 那么也可以没有外部的替代函数实现.\n  static inline: 表明这个函数可能被优化. 如果没有被优化, 编译器就会视为一个常规静态函数.\n  C99: 函数的实现之前添加不同的关键字:\n inline: 等效于gnu89中的extern inline extern inline: 等效于gnu89中的inline static inline: 与gnu89相同含义.  C++: 只有inline一个关键字, 如果不能优化就定义为普通函数\n Ref:\nc++ - What does extern inline do? - Stack Overflow\nMyth and reality about inline in C99 – Jens Gustedt\u0026rsquo;s Blog (wordpress.com)\n  C demo 关于以上的各种情况\n ","date":"2022-11-24T01:35:24+08:00","permalink":"https://wangloo.github.io/posts/c/inline/","section":"posts","tags":["c"],"title":"C语言 'inline' 关键字"},{"categories":null,"contents":"计算数组元素的个数 1#define nelem(array) sizeof(array)/sizeof(array[0]) ","date":"2022-11-24T01:35:24+08:00","permalink":"https://wangloo.github.io/posts/c/c-macros/","section":"posts","tags":["c"],"title":"C语言工具宏"},{"categories":null,"contents":"符合调用约定使得调用函数能够正常获取参数, callee结束之后能够回到原来位置继续执行.\nX86 调用约定 函数调用 x86架构中, 函数调用以一条call指令为分界.\n在call指令执行之前, 所有的参数必须都躺在栈中, 参数入栈的规则是: 第一个参数最后入栈.\n另外, 执行call指令之前, 必须确保栈指针esp是16-byte对齐. 这项工作是编译器完成的, 如果它判断参数入栈之后的esp 不满足对齐条件, 则会手动调整esp使之对齐. 实现方式见下面例子.\ncall 指令的语义是:\n1push pc+1 ;push next insttuction 2mov pc, func ;set pc = new function call 指令之后的下一条指令就是callee的内容了, 至此就算是进入新函数的地盘.\n但是在执行新的任务之前, callee还需要完成栈的转换, 因为此时使用的栈还是caller的.\n1push ebp ;preserve location of caller\u0026#39;s stack 2mov ebp, esp ;new ebp is old esp 此时esp也就是栈指针等于ebp, 这是callee栈的初始条件. 万事俱备, 可以开始执行callee的实际任务了.\n ebp在整个函数执行过程中是固定的, 好处是: 能够快速的或者函数参数, 返回地址.\n 函数返回 callee执行完毕后, 需要返回到caller继续执行. 刚才说过, callee的返回地址在栈中, 所以我们要做的是找到返回地址所在的位置, 然后使pc = 返回地址. 当然, 还有另一个重要的任务就是恢复caller的栈.\n上述任务的实现使用两条汇编语句就可完成: leave 和 ret.\nleave 负责搞定栈, 其语义为:\n1mov esp, ebp ;回滚栈空间 2pop ebp ;恢复caller的ebp ret 负责搞定pc, 其语义为:\n1pop ebx ;取出返回地址 2mov pc, ebx ;jmp to 返回地址 ret 之后, 就算是返回caller的地盘了. 还有一件小事别忘了做: 用于保存参数的栈空间还没有回收, 回到caller之后需要先将esp的位置进行调整.\nExample: 函数的调用和返回 一个关于函数调用和返回实现的完整例子.\n1void caller() 2{ 3 Func(1, 2, 3); 4} 5void Func(int a, int b, int c) 6{ 7 /* Do something */ 8} (以下汇编是AT\u0026amp;T格式的, 请见谅).\n1; Caller 2sub $0x4,%esp ;make 16-bytes align before call. 0x4 是由编译器计算的 3push $0x3 ;push 参数, 顺序是从右到左 4push $0x2 5push $0x1 6call f01000ad \u0026lt;Func\u0026gt; ;Func()\u0026#39;addr is f01000ad 7;===========\u0026gt;\u0026gt; Turn to callee 8 9 ;Func() 10 push %ebp ;preserve old ebp 11 mov %esp,%ebp ;set new ebp, ebp=esp now 12 /* Do something */ 13 leave ;restore stack 14 ret ;restore instruction point 15 16;\u0026lt;\u0026lt;=========== Back to caller 17add $0x10,%esp ;recycle stack(12 bytes parameters plus 4 bytes alignment) Armv8 调用约定 大体的思想与x86相似, 只是细节有些许不同\n函数调用 ARMv8架构中, 函数调用以一条bl指令为分界.\n执行bl指令之前, 需要将参数准备好. 注意, ARMv8中, 少于8个参数的函数在传参时, 参数是放在x0-x7中, 最左边的参数先使用x0, 以此类推. 参数超过8个的情况下才使用栈, 这与x86的方式不同.\nbl指令保存返回地址, 并跳转到callee执行, 其语义是:\n1mov lr, pc+1 ;preserve return address 2 ;lr specially used for preservering return addr 3mov pc, new_func ;set pc = new function 与x86相同, 跳转到callee之后必须先进行栈的设置, Arm与x86不同的是它不需要管理栈底寄存器. 因为参数大部分是通过寄存器来传递, 返回地址也是存储在lr(x30)寄存器中, 没必要为了极少的情况来做优化.\n1sub sp, sp, #enough-space 函数返回 要完成两件事: (1) 恢复栈 (2)返回原来位置执行\n先说(2), 由于lr寄存器始终保存返回地址, 直接 mov sp, lr 就能返回caller继续执行. 这也就是ret指令的语义.\n(1)恢复栈的这件事同x86一样由callee完成,\n1add sp, sp, #enough-space 参考  x86 call 指令执行前需要esp对齐到 16-byte: x86 - What are the following instructions after this call (assembly) - Stack Overflow x86栈帧原理 - 知乎 (zhihu.com)  结语 能够正确达到函数调用和返回的实现方式有很多, 不是仅有这一种方式, 约定仅仅是一个约定, 大家都这样去做降低了开发的难度.\n","date":"2022-11-21T10:30:35+08:00","permalink":"https://wangloo.github.io/posts/os/function-call-conventions/","section":"posts","tags":["armv8","x86","Operating System"],"title":"x86/ARMv8 函数调用约定"},{"categories":null,"contents":"问题源于我在知乎刷到的一个回答: 能分享你C指针用得最灵活（飘）的一次吗?\n文中提到了Linus关于无头节点单项链表的删除操作给出的一种新的思路, 我觉得对理解指针非常有帮助, 所以在这里详细描述一下这件事.\n从我学习数据结构起, 对不含头节点的单向链表的删除操作, 做法常是: 借用pre指针搜索. 这种情况下避免不了对于链表中第一个节点的特判(第一个节点没有pre).\nLinus提到了一种借助二级指针避免该分支的方法.\n1void remove_if(node ** head, remove_fn rm) 2{ 3 for (node** curr = head; *curr; ) 4 { 5 node * entry = *curr; 6 if (rm(entry)) 7 { 8 *curr = entry-\u0026gt;next; 9 free(entry); 10 } 11 else 12 curr = \u0026amp;entry-\u0026gt;next; 13 } 14} 指针的内容就是地址, int *p = a 也就意味着变量p 中保存着变量a的地址. 所以参数head在内存中的含义为:\n假如要删除node2, 那么改变*curr实际上就是改了node1的next成员.\n","date":"2022-11-20T23:40:30+08:00","permalink":"https://wangloo.github.io/posts/c/pointers-pointers-list/","section":"posts","tags":["c"],"title":"二级指针操作链表"},{"categories":null,"contents":" 大小端问题的由来 为什么计算机世界需要区分大小端? 内存里存取的单位是字节, 如果所有的数据类型长度都是一个字节, 那就完全不需要大小端了, 每个变量都仅占据单独一个字节.\n例如, 三个变量 a=10, b=20, c=30, 在内存中的布局可能就是:\n1 ┌────────────┐ 2 │ │ 3 │ 10 │ a 4 ├────────────┤ 5 │ │ 6 │ 20 │ b 7 ├────────────┤ 8 │ │ 9 │ 30 │ c 10 ├────────────┤ 11 │ │ 12 │ │ 13 │ │ 14 │ │ 15 │ │ 16 └────────────┘ 但是我们最常使用的数据类型肯定有超过一个字节的, int类型在64位的系统中就占4个字节. 例如变量a=0xaabbccdd\n一个变量的大小一旦超过4个字节, 内存的存取又是以字节位单位的, 那么要把它塞到内存里就必然会产生两种不同存放方式: 先放0xaa还是先放0xdd\n首先, 0xdd是变量a的低8位, 0xaa是最高8位, 这是确定的.\n  如果先放0xaa, 即低地址放高位, 就叫做大端, 如左图;\n  如果先放0xdd, 即低地址放低位, 就叫小端, 如右图.\n  1 2 start addr of `a` start addr of `a` 3 ┌────────────┐ ┌────────────┐ 4 │ │ │ │ 5 │ aa │ │ dd │ 6 ├────────────┤ ├────────────┤ 7 │ │ │ │ 8 │ bb │ │ cc │ 9 ├────────────┤ ├────────────┤ 10 │ │ │ │ 11 │ cc │ │ bb │ 12 ├────────────┤ ├────────────┤ 13 │ │ │ │ 14 │ dd │ │ aa │ 15 ├────────────┤ ├────────────┤ 16 │ │ │ │ 17 │ │ │ │ 18 └────────────┘ └────────────┘ 什么情况? 看下面的代码, 猜测输出的结果\n1unsigned int i = 0x00646c72; 2printf(\u0026#34;Hello Wo%s\u0026#34;, \u0026amp;i); %s 会按字节一直打印内存中的字符, 直到遇到\\0. 首先打印的字符便是变量i的地址处的内容.\n如果是小端存储方式, 变量i的地址处的一个字节值是0x72, 即字符r. 以此类推, 所以如果CPU的字节序是小端形式, 那么printf的结果是: Hello world\n大小端形式的优缺点 小端的优势:\n  以不同的长度读取变量非常方便, 不用计算地址. 例如u64 a=0x1234, 当(u16)a时, CPU不需要重新计算读取的起始位置, 永远都是变量a的起始地址.\n  Easily to do mathematical computations “because of the 1:1 relationship between address offset and byte number (offset 0 is byte 0), multiple precision math routines are correspondingly easy to write.”\n  ","date":"2022-11-17T10:30:35+08:00","permalink":"https://wangloo.github.io/posts/os/big-little-endian/","section":"posts","tags":["Operating System"],"title":"大小端问题"},{"categories":null,"contents":"本文基于AArch64执行环境, 介绍现代操作系统中上下文切换的相关内容.\n什么是上下文？ 上下文又称“现场”,\n为什么需要上下文切换? (TODO: 为什么说线程是调度的单位?)\n现代操作系统中同时存在着成千上百个线程, 但是一个CPU同一时刻只能运行一个线程, 他们是轮流的占用CPU, 也叫并发执行. (TODO: 如何查看线程切换的间隔?) 线程高频率的切换, 操作系统是如何保证切换到下一个执行的线程时, 它能够继续上次的工作呢?\n什么是上下文? 我们正在看一本书的时候如果被其他的事情打断, 返回时为了能够从上次被打断的位置继续读, 就要在被打断的时候记下来当前是读到了哪个第几页的第几行.\n操作系统对待线程也是如此, 需要保存的用于恢复线程执行的信息就称为线程的上下文.\n那么对于线程来说需要记下的内容有什么呢? 寄存器和栈即可. 拿AArch64架构来距离, 线程的上下文就是:\n 通用寄存器x0-x29: 函数调用的参数, 某些计算过程的中间值, 都要用到这些寄存器. 线程的执行流可能在任何时候被打断, 当然这些内容也不能丢. 通用寄存器lr(x30): lr 保存着返回地址, 即当前函数结束之后该返回到哪执行. 栈顶指针 sp: 栈的重要性无需多言. 但是需要说明的是我们保存栈的方式并非将栈中的所有内容保存, 而是保存栈的位置即可. 因为操作系统有别的机制(TODO), 能够保证即便线程不在执行, 属于该线程的栈也不会被破坏. 程序计数器 pc: 被打断的线程如果再次执行, 从哪里执行呢? 显然是被打断指令的下一条(或者重新执行当前). 这个指令的地址当然也需要被保存好. PSTATE: 想一下, 有了以上的内容就能够保证线程完整的恢复之前的环境吗? 其他的例如中断是开还是关, 有哪些标志位(NZCV)被设置了. 这些信息在AArch64中是保存在PSTATE的各个字段中.  如果我们能够有一个适当的逻辑, 在线程切换出去的时候将上下文保存起来, 然后恢复新线程的上下文, 是不是线程切换这件事就能做到了. 如何组织这个保存和恢复的过程在下面会介绍到.\nLinux 如何处理上下文切换 另一种处理上下文切换的思路 协程的上下文 协程是用户级别的线程,\n 协程之间的切换不进入内核 切换协程只能是某个协程主动放弃控制权  我们在这里讨论一下协程切换时需要保存的上下文是否与线程有所不同.\n首先, PC一定属于, 这个毋庸置疑. 其次是栈顶指针sp, 每个协程都有单独的栈, 如果不保存栈的位置, 那么协程内部定义局部变量就没法访问了(局部变量的访问指令都是以sp为base的偏移来做的).\n另外, 关于通用寄存器, 由于协程的切换需要主动调用某个函数(通常叫做yield()), 在函数的最后将PC设置为新协程的上下文PC. 保存当前协程上下文的操作也在这个函数中, 而其参数我们并不关心, 即x0-x7没必要保存. 同样的, caller-saved寄存器也是没必要保存的, 因为这些寄存器作为函数调用使用的临时变量, 当再次返回该协程时, PC=yield()返回地址, caller如果关心这些寄存器应当自己执行保存和恢复. 但是callee-saved寄存器必须要保存到上下文中, 因为在yield()中, 我们如果修改了callee-saved寄存器, 就需要在返回时(也就是再次调度到该协程时) 恢复, 这是callee该做的, 也就是上下文中应该有的唯一通用寄存器组.\n","date":"2022-11-14T22:13:06+08:00","permalink":"https://wangloo.github.io/posts/os/context/","section":"posts","tags":["Operating System"],"title":"操作系统——上下文切换"},{"categories":null,"contents":"介绍 setjmp() and longjmp() 是一对组合使用的函数, 可以实现全局的goto.\nsetjmp() 构造一个运行环境, 调用longjmp() 则将执行流切换到该环境.\n1/* setjmp() 保存当前的运行环境(上下文)到 env 参数中 */ 2int setjmp(jmp_buf env); 3 4/* longjmp() 将控制流切换到 env 指定的运行环境 */ 5void longjmp(jmp_buf env, int val); 使用方法 1#include \u0026lt;setjmp.h\u0026gt;2#include \u0026lt;stdio.h\u0026gt;3 4jmp_buf e; 5 6void foo() { 7 longjmp(e, 1); 8} 9 10int main(void) { 11 int ret; 12 13 /* After calling longjmp(), the execution flow back to setjmp(), 14and setjmp() will return not 0. */ 15 ret = setjmp(e); 16 if (ret == 0) { 17 printf(\u0026#34;Return from setjmp\\n\u0026#34;); 18 foo(); 19 } else { 20 printf(\u0026#34;Return from longjmp\\n\u0026#34;); 21 } 22 23 return 0; 24} 基于 AArch64 的实现 需要保存的上下文包括\n callee-saved 通用寄存器, 因为可能第一次调用 setjmp() 之后的执行流修改了这些寄存器, 从第二次回到 setjmp() 的角度来看, 就是执行setjmp() 中破坏的. caller-saved 寄存器则不必, 因为本来即便看作是 setjmp() 破坏的, 也是正常的.  1.macro func _name 2.global \\_name 3.type \\_name, %function 4\\_name: 5.endm 6 7.macro endfunc _name 8.size \\_name, .-\\_name 9.endm 10 11 12/** 13 * setjmp (jmp_buf env) 14 * 15 * See also: 16 * longjmp 17 * 18 * @return 0 - if returns from direct call, 19 * nonzero - if returns after longjmp. 20 */ 21 22func setjmp 23 stp x19, x20, [x0], #16 24 stp x21, x22, [x0], #16 25 stp x23, x24, [x0], #16 26 stp x25, x26, [x0], #16 27 stp x27, x28, [x0], #16 28 stp x29, x18, [x0], #16 29 mov x9, sp 30 stp lr, x9, [x0], #16 31 mov x0, #0 32 33 ret 34endfunc setjmp 35 36/** 37 * longjmp (jmp_buf env, int val) 38 * 39 * Note: 40 * if val is not 0, then it would be returned from setjmp, 41 * otherwise - 1 would be returned. 42 * 43 * See also: 44 * setjmp 45 */ 46 47func longjmp 48 ldp x19, x20, [x0], #16 49 ldp x21, x22, [x0], #16 50 ldp x23, x24, [x0], #16 51 ldp x25, x26, [x0], #16 52 ldp x27, x28, [x0], #16 53 ldp x29, x18, [x0], #16 54 ldp lr, x9, [x0], #16 55 mov sp, x9 56 57 mov x0, x1 58 cbnz x0, 1f 59 add x0, x0, #1 601: 61 62 ret 63endfunc longjmp setjmp() 实现 try-catch ","date":"2022-11-01T23:38:54+08:00","permalink":"https://wangloo.github.io/posts/c/setjmp_and_longjmp/","section":"posts","tags":["armv8","c"],"title":"基于ARM64实现setjmp/longjmp"},{"categories":null,"contents":" Kernel Monitor 是什么 Kernel Monitor 是一个适配我们微内核操作系统的 Kernel 调试和监控系统. 它能实现内核的动态调试和监控. 同时, 它还接管内核的同步异常和系统错误, 使开发者能够了解发生异常时系统的状态.\nKernel Monitor 具有一定的可扩展性, 例如通过统计内核中存储的 TCB 来实时监控系统中所有线程的状态. 可根据开发者的需求添加统计的对象, 如 Endpoint, Capability等.\n Kernel Monitor 总体设计 Kernel Monitor 系统包含 Clinet 和 Server 两个部分. 简单来说, Client 负责处理用户输入, 并将输入进行解析, 封装为 一系列基础命令. 发送给 Server. Server 负责执行这些 基础的命令, 如设置断点, 查看某个地址的值等.\n整个系统有两种架构: 本地 Monitor 和远程 Monitor.\n本地monitor 和远程 monitor 的区别是: Monitor Client 的位置在哪, 是否与 Server 在同一个机器上.\n 先说 Monitor Server, 它必须嵌入要调试的 Kernel 中, 位于一个地址空间, 方便操作 Kernel 的内存.\n 本地 Monitor 在本地 Monitor 中, client 和 sever 都位于目标机(Target)上, 目标机通常是开发板.\n对于 AArch64 体系结构来说, 最多有四个异常等级(EL0-EL3). Client 可以运行在EL2.远程 Monitor 远程 Monitor 架构则不同, Clinet 运行在宿主机(Host)上, 通常是Linux. 它与 Server 的通信是通过网络/UART实现的.\n Monitor Client 运行在本地和远程对于实现的难度和用户体验有影响.\n  如果 Client 实现在本地, 则 Client 无需实现网口和串口的驱动, 但Monitor 输入输出的串口与操作系统本身的串口相同, 信息冗杂在一起不易查看; 同时, 如果 Client 实现在本地, 那么对于ELF的解析需要在无操作系统提供的库支持下完成, 可能比较复杂.\n  如果 Client 实现在远程, 即为 Linux 上的一个APP. 那么它和 Server 的通信就需要通过外部的网口或者串口(对于我们使用的64位开发板只引出了一个串口, 所以只能使用网口). 需要在 Server 上实现网口的驱动, 这部分比较复杂. 但是好处是 Client 的实现简单很多, 因为有 Linux APP 运行环境的支持. 同时, 远程 Monitor 架构下, Monitor 和 操作系统自身的输入输出分开, 用户可读性更好.\n   Server 是嵌入到Kernel的代码中, 与Client进行交互. 它是整个 Monitor 系统的后端, 负责实现基础的调试操作. 例如, 设置断点, 内存的读写, 寄存器的读写等.\n 由于Server与 Kernel 位于同一个地址空间, 所以查看/修改内存的值是非常方便的. 对于寄存器也是同理. 断点(Breakpoint), 监视点(Watchpoint), 单步执行(Soft step)的实现依赖与 ARMv8 提供的的 self-hosted debug 支持.  同时, Server 还负责监视系统中所有的 同步异常和系统错误. 一旦发生, 可在 Monitor 中查看某些内存, 寄存器的值定位问题发生的原因.\nMonitor Client 设计 Client 的构成可分为三个模块 :\n 用户交互模块 符号处理模块 消息收发模块  用户交互模块负责处理用户的输入输出, 调用其他两个模块完成调试命令.\n符号处理模块负责解析可执行文件(ELF), 并建立静态符号表, 存储符号和地址的对应关系. 将用户输入的符号解析为虚拟地址, 或者反向解析.\n消息收发模块负责处理用户的输入, 将其转化为基础, 标准的命令, 发送给Server执行. Client 和 Server之间通信的数据包协议可以使用 GDB Remote Serial Protocol (以下简称RSP协议), 或者自己规定一个协议也是可行的.\n RSP协议支持三种基础命令:\n 寄存器相关 内存相关 程序控制命令   启用 Monitor 时 Kernel 启动流程  Kernel 首先做必要的初始化, GIC, 异常向量表, MMU等. 将控制权交给 Monitor, 等待用户输入.   Kernel debug 过程示例 示例一: 查看变量 var 的值  用户输入 print var 指令. 由符号处理模块, 将var符号转为var 虚拟地址. 由消息收发指令将请求封装为RSP协议包格式, 并发送到 Monitor Server. 执行流程交给 Monitor Server, 它访问该地址, 将内容封装发回 Monitor Client. Client 输出var的值, 继续等待用户输入  示例二: 添加断点到 main 函数  用户输入 break main 指令 由符号处理模块, 解析得到 main 函数的地址. 消息收发模块将请求封装为RSP包格式, 发送到Monitor Server. 执行流程交给 Server. 它执行 breakpoint exception 指令, 并设置相关软件断点相关寄存器 执行流交给 Kernel, 直到达到断点处(可使用地址+ContextID双重验证), 触发Debug异常 Debug异常属于同步异常, 由 Monitor 系统接管, 回到 Client 继续等待用户输入  示例三: 单步执行  用户输入 step 指令 消息收发模块将请求封装为RSP包格式, 发送到 Monitor Server. 执行流程交给 Server, 启用 software step. 然执行一次异常返回, 回到Kernel 继续执行. 因为启用了 Software step, 回到 Kernel 执行完一条指令后, 就会触发 Debug异常 Debug 异常属于同步异常, 由 Monitor 系统接管, 回到 Client 继续等待用户输入   其他拓展功能 back trace\n性能分析\n","date":"2022-10-28T22:56:19+08:00","permalink":"https://wangloo.github.io/posts/os/monitor/","section":"posts","tags":null,"title":"Armv8 Kernel Monitor"},{"categories":null,"contents":"Introduction MMU: 专用于将虚拟地址转换为物理地址. 通常配合分页机制来工作.\n页表: 页表中的表项包含提供虚拟地址和物理地址之间的映射.\nMMU就是直接访问页表, 并且通过将频繁使用的映射缓存到TLB中.\nMMU 的结构 MMU是一种硬件, 可以通过在适当的安全状态下对其进行配置. 每个Core都有自己的MMU, 每个MMU包括:\n 一个TLB, 缓存最近访问的映射. 一个Table Walk Unit, 从内存中查询页表, 得到最终的虚拟地址-物理地址的映射.  MMU 控制着整个系统的缓存策略, 内存属性和访问权限. MMU开启后, 软件发出的所有内存访问都使用虚拟地址, 要求MMU为每次访问进行地址转换.\nMMU 的配置 在启用MMU前, 必须告知其页表存放的位置.\nMMU 地址转换的过程 对于每个转换请求, MMU首先检查TLB是否已经对该地址缓存, 如果该地址未缓存, 则需要遍历页表.\n页表遍历单元在页表中搜索相关的映射表项.\n 一旦找到映射, MMU就会检查权限和属性. 决定允许本次访问, 或者发出故障信号. 若未找到映射, 则触发缺页异常.  页表的工作原理 页表的工作方式是将虚拟地址空间和物理地址空间划分为大小相等的块, 称为页面.\n页表中的每个表项对应着一块虚拟地址空间中的块, 表项的值就是这块虚拟地址空间对应的物理地址块, 以及访问物理地址时要使用的属性.\n在查表过程中, 将虚拟地址分为两部分:\n 高阶位用作页表的索引. 用来找到对应的物理块 低地址是块内的偏移量, 不会因为映射而改变. 页表项中的物理地址与该偏移组合形成用于访问内存的物理地址.  多级页表 实际实现中, 多采用多级页表的方案, 各级页表自定向下组成树的形式, 协作实现虚拟到物理地址的转换.\n树中的分支成为页目录, 页目录中的表项不是直接存储目标物理地址, 而是下一级页表的地址; 最后一级页表的表项中保存着目标物理地址.\n 多级页表是减小页表占用存储空间过大的有效方案.\n 顶级页表将地址空间划分为大块, 每个表项可以指向大小相等的内存块. 也可以指向将块进行再次细分的下一级页表. 支持大块的优点:\n 大的内存块需要查表的次数更少 提升TLB的效率, 因为一个TLB表项覆盖更大的内存区域.  凡事都是有利有弊, 使用大块也增加了内存浪费, 实际使用时需要根据需要来权衡.\n内存类型 普通类型内存 普通类型的内存是弱一致性的(weakly ordered)内存模型, 没有额外的约束, 可以提供最高的内存访问性能.\n通常代码段, 数据段以及其他数据都放在普通内存中.\n普通内存允许处理器做很多优化, 如分支预测, 数据预取, Cache line预取, 乱序执行等.\n设备类型内存 CPU访问设备内存会有很多限制, 如不能进行数据预取等. 设备类型的内存严格按照指令的顺序来执行的.\n设备类型内容通常留给设备来访问, 例如中断控制器(GIC), 串口, 定时器等.\n两套页表  当CPU访问的地址属于用户空间时, MMU会自动选择TTBR0指向的页表. 当CPU访问的地址属于内核空间时. MMU会自动选择TTBR1指向的页表  EL2和EL3没有TTBR1, 只有TTBR0. 也就意味着:\n• If EL2 is using AArch64, it can only use Virtual Addresses in the range 0x0 to 0x0000FFFF_FFFFFFFF. • If EL3 is using AArch64, it can only use Virtual Addresses in the range 0x0 to 0x0000FFFF_FFFFFFFF.\n越权, 越界 在未使用虚拟地址空间之前, 所有的用户程序都可以访问全部的物理内存, 所以恶意程序可以修改其他程序的内存数据, 这使得整个系统处于危险的状态. 每个进程的地址空间都要受到保护, 以免被其他进程有意/无意的破坏.\n现代操作系统中, 每个进程都有独立的虚拟地址空间. 在进程的角度上, 它拥有整个虚拟地址空间. 不同的进程可以同时使用一个虚拟地址, MMU通过页表将其映射到合适的物理地址.\n两个物理地址空间 ARMv8 体系结构定义两个物理地址空间: secure address space 和 non-secure address space.\n理论上, 安全和非安全的地址空间是相互独立的, 然而现实中大多数系统都将安全和非安全视为访问控制的属性. 正常(非安全)世界只能访问非安全的物理内存; 而安全世界可以访问这两个地址空间.\nARMv8 MMU权限控制 程序请求某个地址时, MMU需要进行权限检查. 如果请求的地址是数据, 则检查读写权限; 如果请求的是地址, 则检查其可执行权限.\nARMv8 页表项的AP字段控制该不同异常等级下, 页面的读写权限.\n[表格]\nARMv8 页表项的PNX字段和XN/UXN字段来设置CPU是否对这个页面有执行权限.\n  当系统有两套页表时, UXN是用来设置用户空间页面是否有可执行权限; PXN 用来设置特权空间的页面是否有可执行权限.\n  若系统只有一套页表, 则通过XN字段控制\n  页表的结构 地址宽度 48bit\n页面粒度 页面粒度表示一次最小分配内存块的大小. AArch64支持三种页的大小, 4KB, 16KB, 64KB. 支持哪一种是由实现定义的。创建页表的代码能够读取系统寄存器ID_AA64MMFR0_EL1，以找出哪些是受支持的大小。Cortex-A53处理器支持所有三种尺寸，但有些处理器的早期版本并非如此，例如Cortex-A57，它不支持16K粒度。\nAArch64 页表项结构 无效页表项 table block 页表结构(4KB页面为例) 以4KB页面粒度, 虚拟地址宽度为 48位. 使用4级页表.\n48位地址每层转换有9个地址位，即每层512个条目，最后12位选择4kB内的一个字节，直接来自原始地址\n虚拟地址到物理地址的转换过程 当处理器为获取指令或数据访问发出一个64位的虚拟地址时，MMU硬件将虚拟地址转换为相应的物理地址。对于虚拟地址，前16位[63:47]必须全部为0或1，否则地址将触发故障。\nNon-secure and secure access ARMv8-A架构定义了两种安全状态:安全的和非安全的。它还定义了两个物理地址空间:安全的和非安全的. 正常(非安全)世界只能访问非安全物理地址空间。安全世界可以访问两个物理地址空间。这也是通过转换表来控制的。\n在非安全状态下，转换表中的NS位和NSTable位将被忽略。只能访问非安全内存。在安全状态下，NS位和NSTable位控制虚拟地址转换为安全物理地址还是非安全物理地址。\nYou can use SCR_EL3.SIF 来禁用安全世界访问非安全地址.\n相关的寄存器 与地址转换相关的寄存器主要有以下几个:\n 转换控制寄存器(TCR) 系统控制寄存器(SCTLR) 页表基地址寄存器(TTBR)  TCR IPS: 配置地址转换后输出物理地址的最大值\nTxSz: 配置输入地址的最大值, 即虚拟地址的宽度\nTG1: 配置TTBR1页表的页面粒度大小\nSHx: 配置TTBRx相关内存的Cache共享属性\nORGNx:\nIRGNx:\nSCTLR M: Disable/Enable MMU地址转换\nC: Disable/Enable Data Cache\nI: Disable/Enable Instruction Cache\nTTBR 存储页表的基地址\nAArch32 虚拟内存系统 ARMv8 AArch32 的虚拟内存系统向后兼容ARMv7, 与ARMv7的基本一致.\n","date":"2022-09-29T08:01:33+08:00","permalink":"https://wangloo.github.io/posts/armv8/mmu/","section":"posts","tags":["armv8"],"title":"ARMv8-A MMU介绍"},{"categories":null,"contents":"ARMv8 异常返回指令 当异常处理程序结束后，需要执行异常返回指令恢复进入异常之前的状态.\n具体要做的事情包括:\n  恢复发生异常前的PC\n  从SPSR中恢复PSTATE寄存器(现场)\n  异常返回的指令根据当前执行状态为AArch32还是AArch64有所不同.\nAArch32 AArch32的异常返回指令在不同的模式下也有所不同:\n若异常是在Hyp模式下处理: 仅可执行ERET指令从异常返回.\n若异常是在其他模式下处理, AArch32提供了以下的异常返回指令:\n  ERET 指令\n  使用带S后缀的数据处理指令直接操作PC(例如, MOVS, PC, LR), 恢复PSTATE\n  RFE 指令: RFE \u0026lt;Rn\u0026gt;. 从基址寄存器指向的地址依次加载PC和PSTATE\n  LDM 指令: LDM \u0026lt;Rn\u0026gt; {pc..}. 若目标寄存器中包含PC, 则会同时恢复PSTATE\n  AArch64 AArch64下统一使用 ERET 指令进行异常返回.\n指令格式及用法参考 ERET ERET指令完成了:\n  从ELR_ELx中恢复PC指针\n  从SPSR_ELx中恢复PSTATE寄存器的状态.\n  LDM(Load Multiple) 格式: LDM \u0026lt;Rn\u0026gt; {registers}\n含义: 从基址寄存器\u0026lt;Rn\u0026gt;指向的地址开始依次加载多个寄存器值. 若目标寄存器中包含PC, 则同时恢复PSTATE.\n例如: LDM \u0026lt;r0\u0026gt; {pc, r1} 等价于:\n1pc = [r0] 2r1 = [r0+4] 3PSTATE = SPSR ;仅当目标寄存器包含PC时自动完成 RFE(Return From Exception) 格式: LDM \u0026lt;Rn\u0026gt; \n含义: 从基址寄存器\u0026lt;Rn\u0026gt;指向的地址依次加载PC和PSTATE.\n例如: RFE \u0026lt;r0\u0026gt; 等价于:\n1pc = [r0] 2PSTATE = [r0+4] ","date":"2022-09-24T21:19:01+08:00","permalink":"https://wangloo.github.io/posts/armv8/exception_return/","section":"posts","tags":["armv8"],"title":"AArch64/32 异常返回过程"},{"categories":null,"contents":"语句结构 1asm asm-qualifiers ( AssemblerTemplate 2 : OutputOperands 3 : InputOperands 4 : Clobbers 5 : GotoLabels) The asm keyword is a GNU extension. 当使用编译选项 -ansi 或 -std 时, 使用 __asm__代替 asm.\nQualifiers  volatile: 避免编译器的过分优化 goto inline  Parameters AssemblerTemplate: 字符串, 汇编代码的模板\nOutputOperands: 输出操作数; 指令将会修改的变量集合\nInputOperands: 输入操作数; 指令将读取的变量集合\nClobbers: ???TODO\nGotoLabels: 仅当 qualifiers 使用goto时, 声明label集合.\n The total number of input + output + goto operands is limited to 30.\n  Param #1: AssemblerTemplate 多条语句可以放在一个asm字符串中, 但是更常见的是每条汇编语句使用一个字符串, 并在结束时使用换行符和制表符(\\n, \\t)来表示换行.\n 貌似对于 arm 汇编, 只用 \\n 也OK?\n  Param #2: OutputOperands 多个 OutputOperands 之间使用,隔开, 每个 OutputOperands 的格式如下:\n1[ [asmSymbolicName] ] constraint (cvariablename) asmSymbolicName: 指定该操作数的名称\nconstraint: 对该操作数的一些限制\n1// 描述操作数的权限, 输出操作数的约束必须以此开头 2= 忽略现有值 3+ 读写, 当原先值有意义时用它 4\u0026amp; 禁止编译器将该操作数与不相关的输入操作数分配同一个寄存器 5 6// 描述输出操作数所在位置, 如果你不知道, 可以同时设置, 编译器会帮你决定 7r 寄存器 8m 内存 9 10// 架构相关的 11z AArch64中存在. 表达可以使用零寄存器(XZR or WZR). Useful when combined 12 with `r` to represent an operand that can be either a general-purpose register 13 or the zero register. cvariablename: 输出到的 C 语言变量名\n Param #3: Input Operands 输入操作数的格式与输出操作数基本一致:\n1[ [asmSymbolicName] ] constraint (cexpression)  对于输入操作数, 一般没有别的限制, 仅使用\u0026quot;r\u0026quot;(val)\n  Param #4: Clobbers 每个 clobber 都是用双引号括起来, 并用逗号分隔的字符串常量.\n常用的 clobber 参数:\n  \u0026ldquo;memory\u0026rdquo;\n告诉编译器, 这段内联汇编代码对输入和输出操作数中列出的项以外的内存读取或写入操作(例如，访问输入参数之一指向的内存). 为确保内存包含正确的值，GCC可能需要在执行ASM之前将特定寄存器值刷新到内存。此外, 阻止编译器越过该 ASM 语句进行 reorder, 形成针对编译器的 memory barrier. 注意, 此 clobber 不会阻止处理器在ASM语句之后执行推测性读取。为了防止出现这种情况，您需要特定于处理器的防护指令。\n  \u0026ldquo;cc\u0026rdquo;\nThis stands for \u0026ldquo;condition codes\u0026rdquo;. Since the add instruction will affect the carry flag amongst other things, we need to tell gcc about it. Otherwise it might want to split a test-and-branch around our code. If it did so, the branch might go the wrong way due to the condition codes being corrupted. Basically, any inline asm that does arithmetic should explicitly clobber the flags like this.\n   Param #5: GotoLabels 尽量不使用, 可以在ASM的内部直接定义 label\nTODO\n 样例 最简单的模板 1int src = 1; 2int dst; 3 4asm (\u0026#34;mov %1, %0\\n\\t\u0026#34; 5 \u0026#34;add $1, %0\u0026#34; 6 : \u0026#34;=r\u0026#34; (dst) 7 : \u0026#34;r\u0026#34; (src)); 8 9printf(\u0026#34;%d\\n\u0026#34;, dst); 操作数使用 asmSymbolicName 1uint32_t c = 1; 2uint32_t d; 3uint32_t *e = \u0026amp;c; 4 5asm (\u0026#34;mov %[e], %[d]\u0026#34; 6 : [d] \u0026#34;=rm\u0026#34; (d) 7 : [e] \u0026#34;rm\u0026#34; (*e)); 内部定义 label 1 long temp; 2 long ret; 3\tasm volatile( 4 \u0026#34;1: \\n\u0026#34; 5 \u0026#34;ldxr %0, [%2]\\n\u0026#34; 6 \u0026#34;sub %0, %0, %3\\n\u0026#34; 7 \u0026#34;stxr %w1, %0, [%2]\\n\u0026#34; 8 \u0026#34;cbnz %w1, 1b\\n\\t\u0026#34; 9 : \u0026#34;=\u0026amp;r\u0026#34;(ret), \u0026#34;=\u0026amp;r\u0026#34;(temp) 10 : \u0026#34;r\u0026#34;(p), \u0026#34;r\u0026#34;(val) 11 : \u0026#34;memory\u0026#34; 12 ); Reference Extended Asm (Using the GNU Compiler Collection (GCC))\nAArch64 Constraint codes\n","date":"2022-09-24T16:48:58+08:00","permalink":"https://wangloo.github.io/posts/c/inline-asm/","section":"posts","tags":["c"],"title":"GNU C内联汇编学习笔记"},{"categories":null,"contents":"GICV3(Generic Interrupt Controller - version 3) 关于GIC GIC即中断控制器, 负责管理中断的接收, 屏蔽, 路由等相关任务, 并向系统程序员提供配置的接口.\nGIC与异常模型协作完成中断的整个生命周期, GIC主要负责中断源-产生IRQ/FIQ信号这段路, 关于处理IRQ/FIQ则是由CPU内部的异常模型来完成.\n对比 GICv2  支持更多的处理器, 用affinity routing 方案来做中断路由. 支持中断分组, 为了配合ARMv8的异常等级模型 新增中断类型: SGI, 软件生成中断 新增中断类型: SPI, Shared Peripheral Interrupts 对于CPU interface的寄存器, 可直接使用系统寄存器接口(system register interface)来访问, 比memory-mapped的方式快. ITS, Interrupt Translation Service 暂不介绍 LPI, Locality-specific Peripheral Interrupts . 暂不介绍   GICv3支持ARMv8-A或ARMv8-R系列处理器, 但没有必然的绑定关系. ARMv8-A也可以使用GICv2.\n 中断类型 Locality-specific Peripheral Interrupt (LPI) LPIs are always message-based interrupts interrupts. 这里不做介绍.wiki\nPrivate Peripheral Interrupt (PPI) PPI是路由到单个CPU的外设中断, 不同的CPU可以使用相同的中断号. 例如, 所有CPU都可以使用中断号16表示私有的定时器中断.\nShared Peripheral Interrupt (SPI) SPI是可路由到一组CPU的外设中断, Distributor 负责SPI路由.\nSoftware Generated Interrupt (SGI) SGI是由某个CPU产生, 路由到系统中的一个或多个CPU, 通常用于处理器间通信.\nGICv3 的组件 GICv3架构由以下逻辑组件构成:\n A Distributor A Redistributor for each CPU A CPU interface for each CPU Interrupt Translation Service components (ITS). 可选, 暂不介绍  The Distributor, Redistributor 一起组成了 IRI(Interrupt Routing Infrastructure).\n{width=\u0026ldquo;10px\u0026rdquo;}\nDistributor 控制SPI和SGI的路由. 对于 SPI, 提供了一下接口:\n 启动/禁用 SPI 设置 SPI 的优先级 配置对于 SPI 的路由 设置 SPI 的触发方式 生成 message-based SPI 为每个 SPI 分组 控制 SPI 的 pending and active 状态  对于Distributor的大部分配置通过GICD_CTLR实现. 包括:\n 启用 Affinity routing 禁用安全性 中断分组的配置.   关于Distributor 寄存器都含有 GICD_ 前缀, 通过 memory-mapped 方式访问.\n Redistributor  启动/禁用 SGI 和 PPI 设置 SGI 和 PPI 的优先级 设置 SGI 和 PPI 的触发方式 为 SGI 和 PPI 分配组 控制 SGI 和 PPI 的 pending 状态和 active 状态 与之链接的 CPU 的电源管理.   关于Redistributor 寄存器都含有 GICR_ 前缀, 通过 memory-mapped 方式访问.\n CPU interface  Acknowledge 一个中断 执行 End Of Interrupt Deactivate 一个中断 设置 CPU 的优先级Mask 配置中断抢占   关于 CPU interface 寄存器是以 ICC_ 为前缀, 还有 ICV for vitual interrupt, ICH for hypervisor configuration.\n 中断的状态转换  生成中断. 中断可能来自外部信号, 或者软件生成(SGI) Distribute. IRI 负责中断的分组, 优先级屏蔽等. 将合适的中断发送到CPU Interface. Deliver. CPU interface 将中断发送到连接的CPU. Activate. CPU读取IAR寄存器, 即发送ACK. 该中断的状态转为active. Priority drop. 处理程序结束之后, 写ICC_EOIR寄存器, end of interrupt Deactivation. 写ICC_DIR寄存器清除中断的active标志位. 一般来说, end of interrupt 和 deactivation 可配置成同时发生.   ICC_CTLR_ELx.EOImode 位控制是否 end of interrupt 同时导致 deactivation.\n:question: EOI 和 deactivated 分开进行暂时还不知道应用场景.\n 中断ID: INTID INTID 是中断的标识符, 它的最大值是实现定义的, 可以在GICD_TYPER.IDbits中读取。\nINTID按照中断类型分类的, 对照表如下:\n   INTID 中断类型 Note     0-15 SGI 本地的, 不同CPU可使用同一中断号代表不同中断   16-31 PPI 本地的   32-1019 SPI 全局的   1020-1023 特殊中断    1056-1119 扩展的PPI 本地的   4096 – 5119 扩展的SPI 全局的    特殊中断号  These INTIDs do not require an end of interrupt or deactivation.\n 1020:\n1021:\n1022:\n1023: 读ICC_IAR1_EL1 返回该值表明当前的CPU上没有待处理的中断.\n中断分组 为了配合 ARMv8 的异常模型和安全模型, GICv3 支持为每个中断配置不同的组. 不同组的中断只能路由到特定的异常等级和安全状态进行处理.\n共包含三个分组: Gourp 0, Secure Group 1, Non-secure Group 1.\n Group 0的中断需要在EL3 处理. Secure Group1 的中断需要在 Secure EL1 或者 Secure EL2(如果启用了虚拟化)处理. Non-secure Group 1 的中断需要在 Non-secure EL2 or Non-secure EL1 if not using virtualization  同时, 中断位于哪个组也决定了其触发的是FIQ还是IRQ. 对于 AArch64 来说, 对应关系可见下表:\n   当前异常等级 Group 0 的中断 Secure Group 1 的中断 Non-secure Group 1     Secure EL1/0/2 FIQ IRQ FIQ   Non-secure EL1/0/2 FIQ FIQ IRQ   EL3 FIQ FIQ FIQ     Group 0 的中断, 需要在EL3处理, 其优先级较高, 所以均属于 FIQ  中断路由   PPIs are routed directly from the source to the local Redistributor .\n  SPIs are routed from the source through the Distributor to the target Redistributor and the associated CPU interface.\n  SGIs are generated by software through the CPU interface and Redistributor. They are then routed through the Distributor to one or more target Redistributors and the associated CPU interfaces\n  What is Affinity Routing? Affinity routing 是一种基于地址的标识多个CPU的方法, 用于中断的路由. Affinity value 由4个8bit字段组成, 结构是aff3.aff2.aff1.aff0.\n由于 PPI 的中断源是直连 Redistributor 的, 所以仅 SPI 和 SGI 可以使用 Affinity routing.\n 对于 SPI, 目标CPU的 affinity value 通过GICD_IROUTER\u0026lt;n\u0026gt; 设置. 对于 SGI, 在生成时即可同时配置, 详见 ICC_SGI0R_EL1 和 ICC_SGI1R_EL1.   Aff3.Aff2.Aff1.Aff0 与 Aff3.Aff2.Aff2.TargetList\n对于SPI, 目标的CPU只能是一个, 故Aff0表示该CPU的ID. 而SGI可以配置同时发给多个CPU, 所以TargetList是基于位操作的, 每个位表示一个CPU.\n 编程指导 初始化 由于 Distributor 整个系统共享的, 所以必须在其他核启动之前, 由主核完成初始化. 然后当所有核都启动后, 各自完成各自 Redistributor 和 CPU interface 的初始化工作.\n","date":"2022-09-10T21:51:49+08:00","permalink":"https://wangloo.github.io/posts/armv8/gicv3/","section":"posts","tags":["armv8"],"title":"GICv3 介绍"},{"categories":["weapons"],"contents":":information_source: 以下命令/脚本的执行环境均为 bash.\n统计代码量  使用到的命令包含: find, wc, xargs, sort 等\n 列出所有的文件及其代码行数, 只统计.c 和.h, 过滤./scripts目录.\n1find -name \u0026#39;*.[c|h]\u0026#39; ! -path \u0026#39;./scripts/*\u0026#39; | xargs wc -l +将内容按照代码行数降序排列\n1find -name \u0026#39;*.[c|h]\u0026#39; ! -path \u0026#39;./scripts/*\u0026#39; | xargs wc -l | sort -rn 若仅列出总的代码行数, 去除空行\n1(find ./ -name \u0026#39;*.[c|h]\u0026#39; -print0 | xargs -0 cat) | sed \u0026#39;/^\\s*$/d\u0026#39; | wc -l 删除目录下所有的可执行文件 1find . -maxdepth 1 -executable -type f | xargs rm 判断执行脚本时带的参数 1if [ $# -ne 1 ]; then 2 echo \u0026#34;ONE parameter is needed\u0026#34; 3 exit -1 4fi 5 6if [ $1 == \u0026#39;build\u0026#39; ]; then 7 # do something 8elif [ $1 == \u0026#39;run\u0026#39; ]; then 9 # do something 10elif [ $1 == \u0026#39;gdb\u0026#39; ]; then 11 # do something 12else 13 echo \u0026#34;Not supported command\u0026#34; 14fi 自动拷贝文件到 SD Card  TODO\n 添加进度条   1#!/bin/bash 2sd_path=$(find /media/$USER -maxdepth 1 -type d -name \u0026#34;*-*\u0026#34;) 3 4while [ ! -d \u0026#34;${sd_path}\u0026#34; ] 5do 6 sleep 1 7 echo \u0026#34;waiting for inserting SD-Card\u0026#34; 8done 9 10echo \u0026#34;SD-Card is inserted\u0026#34; 11cp ./output/kernel/kernel.bin ${sd_path} 12echo \u0026#34;Copy completely\u0026#34; 获取所有文件信息(可递归进入子目录) 获取dir路径下的所有文件的信息, 这里获取的是文件的完整路径.\n TODO\n 操作数组下标的方式可能有待改进? filenum感觉没必要, 暂时还不会改 通过拼接获得文件信息(路径)的方式也有点怪异   1dir=./ 2files=() 3filenum=0 4function getfiles() 5{ 6 for file in `ls $dir`; 7 do 8 if [ -d $file ]; then 9 cd $file 10 getfiles 11 cd .. 12 else 13 files[$filenum]=$(pwd $file)/$(basename $file) 14 # echo file=$(pwd $file)/$(basename $file) 15 let filenum++ 16 fi 17 done 18} 带颜色的输出 使用ANSI escape code\n1Black 0;30 Dark Gray 1;30 2Red 0;31 Light Red 1;31 3Green 0;32 Light Green 1;32 4Brown/Orange 0;33 Yellow 1;33 5Blue 0;34 Light Blue 1;34 6Purple 0;35 Light Purple 1;35 7Cyan 0;36 Light Cyan 1;36 8Light Gray 0;37 White 1;37 Code example:\n1#!/bin/bash 2 3RED=\u0026#39;\\033[0;31m\u0026#39; 4GREEN=\u0026#39;\\033[0;32m\u0026#39; 5YELLOW=\u0026#39;\\033[1;33m\u0026#39; 6BLUE=\u0026#39;\\033[0;34m\u0026#39; 7CYAN=\u0026#39;\\033[0;36m\u0026#39; 8NC=\u0026#39;\\033[0m\u0026#39; # No Color 9 10echo -e \u0026#34;${YELLOW}HELLO, YELLOW${NC}\u0026#34; 11echo -e \u0026#34;${GREEN}HELLO, GREEN${NC}\u0026#34; 12echo -e \u0026#34;${RED}HELLO, RED${NC}\u0026#34; 13echo -e \u0026#34;${BLUE}HELLO, BLUE${NC}\u0026#34; 14echo -e \u0026#34;${CYAN}HELLO, CYAN${NC}\u0026#34; 15 16######################################################### 17# generic functions ##################################### 18 19function ERROR(){ 20 echo -e \u0026#34;${RED}[error] $*${NC}\u0026#34;; 21 exit 1 22} 23 24function INFO { 25 echo -e \u0026#34;${BLUE}[info] $*${NC}\u0026#34;; 26} 27 28function WARN { 29 echo -e \u0026#34;${YELLOW}[warn] $*${NC}\u0026#34;; 30} 31 32function LOG { 33 echo -e \u0026#34;${GREEN}[log] $*${NC}\u0026#34; \u0026gt;\u0026gt; $LOG 34} 35 36INFO \u0026#34;This is an infomation\u0026#34; 37WARN \u0026#34;This is a log\u0026#34; ","date":"2022-07-20T11:54:13+08:00","permalink":"https://wangloo.github.io/posts/shell/shell-script/","section":"posts","tags":["shell","bash"],"title":"武器库: shell scripts"},{"categories":null,"contents":"连续内存取n bit 1#include \u0026lt;stdio.h\u0026gt;2#include \u0026lt;stdint.h\u0026gt;3#include \u0026lt;assert.h\u0026gt;4 5#define bitmask(n) ((1ul \u0026lt;\u0026lt; (n)) - 1) 6 7/* 8* 从ptr指向的内存开始，抽取第start个bit开始的连续n个bit 9* 限制: n \u0026lt; 32 10*/ 11uint32_t extract_bits(uint8_t *ptr, uint32_t start, uint32_t n) 12{ 13 uint32_t start_byte = start / 8; 14 uint32_t start_offset = start % 8; 15 uint32_t *pstart = (uint32_t *)(ptr + start_byte); 16 17 uint32_t end = start + n - 1; 18 uint32_t end_byte = end / 8; 19 uint32_t end_offset = end % 8; 20 uint32_t *pend = (uint32_t *)(ptr + end_byte); 21 22 uint32_t data = *pstart \u0026gt;\u0026gt; start_offset; 23 24 if (n \u0026gt; 32 - start_offset) { 25 /* 由于n \u0026lt; 32, 所以补齐*pend一定就够了， 26* end_offset对齐到最后一位(n-1). 27* 28* 严谨性证明: n 一定\u0026gt; end_offset + 1 29* 因为n \u0026gt; 32-start_offset ==\u0026gt; n \u0026gt; 25, 30* 且end_offset + 1 \u0026lt; 9, 故得证 31*/ 32 data |= *pend \u0026lt;\u0026lt; (n - end_offset - 1); 33 } 34 35 return data \u0026amp; bitmask(n); 36} 37 38void test_val(uint32_t val, uint32_t expect) 39{ 40 if (val != expect) { 41 printf(\u0026#34;error: val: 0x%x, expect: 0x%x\\n\u0026#34;, val, expect); 42 } 43 assert(val == expect); 44} 45 46 47int main(void) 48{ 49 uint32_t vals[] = {0x11223344, 0x11223344}; 50 uint32_t ret; 51 52 ret = extract_bits((uint8_t *)vals, 31, 30); 53 test_val(ret, 0x22446688); 54 55 56 printf(\u0026#34;Test Passed!\\n\u0026#34;); 57 return 0; 58} 一个数取连续n bit 1/* 2* 从一个数中取第start个bit开始的连续n个bit 3*/ 4uint32_t extract_bits (uint32_t val, uint32_t start, uint32_t n) 5{ 6 return (val \u0026gt;\u0026gt; start) \u0026amp; bitmask(n); 7} 判断一个数是否为2的幂 1unsigned int v; 2 3if ((v \u0026amp; (v - 1)) == 0) 4 printf(\u0026#34;v is a power of 2\\n\u0026#34;); 5else 6 printf(\u0026#34;v is not a power of 2\\n\u0026#34;);  统计一个数的二进制中1的数量 依然是利用v \u0026amp; (v -1)的运算结果会将v的最低位的1(如果有的话)置0.\n循环执行此操作就可统计v中1的数量.\n1int numberof1(int v) { 2 int count = 0; 3 4 while(v) { 5 count++; 6 v = v \u0026amp; (v -1); 7 } 8 return count; 9}  将一个数向上取整为2的幂 用一个1一直左移, 直到比这个数大为止.\n1uint32_t roundup_pow_of_two(const uint32_t x) { 2 uint32_t ret = 1; 3 4 while (ret \u0026lt; x) { 5 ret = ret \u0026lt;\u0026lt; 1; 6 } 7 return ret; 8} Linux内核中使用了一种更快的方案, amazing!!!\n1static __inline__ int generic_fls(int x) 2{ 3\tint r = 32; 4 5\tif (!x) 6\treturn 0; 7\tif (!(x \u0026amp; 0xffff0000u)) { 8\tx \u0026lt;\u0026lt;= 16; 9\tr -= 16; 10\t} 11\tif (!(x \u0026amp; 0xff000000u)) { 12\tx \u0026lt;\u0026lt;= 8; 13\tr -= 8; 14\t} 15\tif (!(x \u0026amp; 0xf0000000u)) { 16\tx \u0026lt;\u0026lt;= 4; 17\tr -= 4; 18\t} 19\tif (!(x \u0026amp; 0xc0000000u)) { 20\tx \u0026lt;\u0026lt;= 2; 21\tr -= 2; 22\t} 23\tif (!(x \u0026amp; 0x80000000u)) { 24\tx \u0026lt;\u0026lt;= 1; 25\tr -= 1;1 26\t} 27\treturn r; 28} 29 30static inline unsigned long __attribute_const__ roundup_pow_of_two(unsigned long x) 31{ 32\treturn (1UL \u0026lt;\u0026lt; generic_fls(x - 1)); 33}  向上/向下对齐, 检查是否对齐 1/* uintptr_t 代表指针的位数 2* 加uintptr_t转换的原因是: (void *)不能进行运算 3*/ 4#define IS_ALIGNED(X, align) (((uintptr_t)(const void *)(X)) % (align) == 0) 5#define ALIGN_UP(X, align) (((X) + ((align) - 1)) \u0026amp; ~((align) - 1)) 6#define ALIGN_DOWN(x, align) ((X) \u0026amp; ~((align) - 1)) 7 8#define X (0x12345675) 9#define align (1 \u0026lt;\u0026lt; 2) 10 11int main() 12{ 13 int v = IS_ALIGNED(X, align); 14 15 if (0 == v) { 16 printf(\u0026#34;Given X(0x%x) is not align to 0x%08x\\n\u0026#34;, X, align); 17 printf(\u0026#34;After align up, new X = 0x%x\\n\u0026#34;, ALIGN_UP(X, align)); 18 printf(\u0026#34;After align down, new X = 0x%x\\n\u0026#34;, ALIGN_DOWN(X, align)); 19 } else { 20 printf(\u0026#34;Give X(0x%x) is aligned to 0x%08x\\n\u0026#34;, X, align); 21 printf(\u0026#34;After align up, new X = 0x%x\\n\u0026#34;, ALIGN_UP(X, align)); 22 printf(\u0026#34;After align down, new X = 0x%x\\n\u0026#34;, ALIGN_DOWN(X, align)); 23 } 24 25 return 0; 26}  检查两个有符号数是否异号 1int x,y; 2 3if ((x ^ y) \u0026lt; 0) 4 printf(\u0026#34;They have opposite signs\\n\u0026#34;); 5else 6 printf(\u0026#34;They have same signs\\n\u0026#34;);  大小端转换  对某个位的get/set/clear操作 1#define GET_BIT(x, bit) ( ((x) \u0026amp; (1ULL \u0026lt;\u0026lt; (bit))) \u0026gt;\u0026gt; (bit) ) 2#define SET_BIT(x, bit) ( (x) |= (1ULL \u0026lt;\u0026lt; (bit)) ) 3#define CLEAR_BIT(x, bit) ( (x) \u0026amp;= ~(1ULL \u0026lt;\u0026lt; (bit)) )  Release note:\n 添加对unsigned long long长度的支持    Sign extending from a varaiable bit-width 1 int bits = 2 * 8; // number of bits representing the number in x 2 int x = 0xFFC1; // ready to get sign-extended 3 int rst; // resulting sign-extended number 4 int const mask = 1U \u0026lt;\u0026lt; (bits - 1); // mask can be pre-computed if bits if fixed. 5 6 x = x \u0026amp; ((1U \u0026lt;\u0026lt; bits) - 1); // cut x if it holds more bits 7 rst = (x ^ mask) - mask; // excellent trick! 8 9 printf(\u0026#34;INPUT: 0x%x, RESULT: 0x%x\\n\u0026#34;, x, rst);  字符/字符数组的大小写转换 1#define TO_LOWER(c) (unsigned char)((c \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;Z\u0026#39;) ? (c | 0x20) : c) 2#define TO_UPPER(c) (unsigned char)((c \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;z\u0026#39;) ? (c \u0026amp; ~0x20) : c) 3 4#define TO_LOWER_STR(s, len) { \\ 5for (int i = 0; i \u0026lt; len \u0026amp;\u0026amp; s[i] != \u0026#39;\\0\u0026#39;; i++) { \\ 6s[i] = TO_LOWER(s[i]); \\ 7} \\ 8} 9 10#define TO_UPPER_STR(s, len) {\\ 11for (int i = 0; i \u0026lt; len \u0026amp;\u0026amp; s[i] != \u0026#39;\\0\u0026#39;; i++) { \\ 12s[i] = TO_UPPER(s[i]); \\ 13} \\ 14} ","date":"2022-07-03T09:44:13+08:00","permalink":"https://wangloo.github.io/posts/c/bitops/","section":"posts","tags":["c"],"title":"C 语言位操作技巧"},{"categories":["Operating system"],"contents":" 堆的含义 我们都知道malloc动态申请的变量是存放在堆中. 所以相比栈来说, 堆是动态的.\n堆占据进程虚拟地址空间的大部分, 我们可能通过堆来申请1GB的数组, 但是栈通常不行 , 大多也就几兆的空间.\n 堆空间的管理 进程中堆空间的管理是运行库负责的, 在Linux中是GLIBC.\n运行库在初始化时会像操作系统申请一大块的堆空间, 再为每个进行分别分配需求. 当然, 如果某些程序的需求过大, 运行库也可以使用mmap系统调用直接向操作系统申请, 然后 返回给用户进程.\n GLIBC的malloc函数的处理方式是: 对于小于128KB的申请, 会从运行库\u0026quot;批发的\u0026quot;堆空间 里分出一块来; 但若申请的空间过大, 则使用mmap系统调用来创建匿名空间分配给用户.\n  Linux中虚拟地址块(VMA)的管理使用了红黑树, 可以用于运行库管理自己向操作系统 \u0026ldquo;批发\u0026quot;的堆空间. 使得用户程序动态申请和释放内存性能提高.\n ","date":"2022-06-28T16:41:54+08:00","permalink":"https://wangloo.github.io/posts/os/stack-and-heap/","section":"posts","tags":["Operating system","Virtual memory"],"title":"Stack and Heap"},{"categories":null,"contents":"静态链接带来的问题   像是libc这种几乎每个程序都要用到的库, 如果是静态的, 那么不仅意外着每个程序的 可执行文件很大, 浪费磁盘空间. 并且当程序加载到内存时, 可能许多程序都会用到printf , 使得内存中会存在好多份的printf源码.\n  维护和更新难. 一旦静态链接的其中一个目标文件更新, 所有的可执行程序都要重新链接.\n  不满足局部性原理. 上面提到, 内存中同时存在多份的printf源码会破坏局部性原理的. 显然如果所有的程序共享一份printf源码的想法更好. 即动态加载.\n  可移植性差. 静态链接, 只要有一个依赖目标文件的实现不同, 软件厂商就得专门发布一个 版本. 而动态链接则信赖客户电脑上的动态库, 相当于一个中间层.\n   动态链接的过程 对比静态链接使用ld链接器在编译后即执行链接, 动态链接则是将链接过程推迟到运行时, 即装载到内存时.\n这样, 链接器在链接产生可执行文件时就有两种做法:\n 对于静态符号, 按照静态链接的规则进行地址引用重定位 对于动态符号, 链接器则仅标记其为动态链接中的符号, 不进行处理. 而是等到装载时由 专门的动态链接器来完成动态符号的链接工作.  :interrobang: 链接器如何确定一个符号是静态的or动态的?\n在动态共享对象(.so)中保存了完整的动态符号表*, 表中存在的符号即为动态的, 否则为静态.\n Linux的C语言运行库glib的动态链接版本叫libc.so. 它在外存上只保存一份, 所有的程序 都可以在运行时使用它. 所以千万不要删掉它.\n  动态链接有一定的性能损失, 因为每次运行程序时都要重新链接, 并不像静态链接是一劳永逸的. 也有例如延迟绑定对性能进行优化的方法, 大概仅有5%的损耗, 与带来的便利相比可以忽略不计.\n  地址无关代码 PIC GCC生成动态库时需要添加参数-fPIC, 含义就是生成地址无关码\n地址无关码的含义是代码中不包含任何的绝对地址引用, 全都是相对地址.\n 对于模块内的跳转/数据引用, 使用相对的跳转/加载指令. 例如ARM指令集中的B, ADR, 经过汇编器之后, 目标的地址都会转为相对于该指令(PC)的偏移. 对于模块间的跳转/数据引用, 借用GOT表来间接实现地址无关.  而如果该动态库中全部使用相对地址, 那么加载时也就不需要进行重定位, 即所有的程序都可以 共享这些地址无关代码.\n 上面说PIC的动态库不需要重定位其实是错误的, 只不过它的重定位过程不需要修改代码段, 而是设置了一个放置在数据段的GOT表来实现代码段部分的地址无关特性.\n  现在貌似GCC ARM版本在编译动态库时强制使用-fPIC选项, 否则会报错. 对此我不是 非常确定!\n  一般来说, 不将主程序编译为地址无关码. 因为主程序不需要共享, 而且地址无关码的调用 需要两个指令: 计算地址 + 跳转. 多了一步根据偏移得到绝对地址.\n ","date":"2022-06-26T19:50:45+08:00","permalink":"https://wangloo.github.io/posts/os/dynamic-link/","section":"posts","tags":["Operating System"],"title":"动态链接"},{"categories":null,"contents":"ELF is a file format Files in ELF format includes:\n   Type description 实例     Relocatable File 这些文件包含了代码和data, 可以被用来链接成可执行文件或共享目标文件. .o, .a   Executable File 直接可执行的文件 /bin/ls   Shared Object File Including code and data. 链接器可将其与其他Relocatable File或Shared Object File结合, 生成新的目标文件. 动态链接器可将其与Executable File结合, 作为进程映像的一部分来运行. .so   Core Dump File Restore critical infomation when process is terminated unexpectedly core dump     :pushpin: file command in Linux can output the format of a file.\n  ELF 文件组成的结构 1+---------------------------------+ 2| ELF Header | 包含描述整个ELF的基本信息, 如版本, 入口地址... 3+---------------------------------+ 4| .text | 5+---------------------------------+ 6| .data | 7+---------------------------------+ 紧接着是各个段 8| .bss | 9+---------------------------------+ 10| ... | 11| other sections | 12+---------------------------------+ 13| | 段表: 与段相关最重要的结构 14| Section Header table | 描述了每个段的name, length, authority... 15| | 16+---------------------------------+ 17| String tables | 18| Symbol tables | 19+---------------------------------+    字段 含义     e_machine 目标架构   e_entry 入口地址   e_machine 目标架构   e_phnum number of entries in the program header table   e_shnum number of entries in the section header table   e_shoff offset, in bytes, of the section header table   e_phoff offset, in bytes, of the program header table   e_machine 目标架构   e_machine 目标架构    段表 ELF文件中的各个段的基本属性就是保存在段表中，是分析ELF文件最重要的字段。存放了每个段的信息，例如，段名，段的长度，在文件中的偏移，读写权限以及其他属性。\n编译器、链接器都是依靠段表来定位和访问各个段的属性的。\n如何找到段表？ e_shoff字段\n 使用readelf -S \u0026lt;elfname\u0026gt; 就能查看ELF文件的段表\n 程序头表  分析ELF文件的工具 1. objdump 2. readelf  为什么目标文件中代码和数据要分开放? 一方面, 程序被加载进内存后, 代码段和数据段分别被映射到两个virtual memory region. 通过MMU的支持, 可以将代码段的区域设置为只读, 防止恶意篡改.\n另一方面, 当下CPU Cache多划分为Instruction Cache和Data Cache, 再配合互相独立的 地址区域能够提高局部性原理的效果.\n最后, 代码段可以被多个进程共享(例如都调用同一外部函数), 节省内存空间.\n 针对嵌入式设备, 如果内存空间不够大, 只读的代码段可存放在ROM中\n  关于静态库 一个静态库可以简单的看作是 a set of object file.\n这些 object file 可能包括: 输入输出相关的printf.o, scanf.o, 日期时间相关的time.o, date.o等.\n:question: 为什么不直接提供这些目标文件呢?\n这些零散的文件若直接提供给使用者, 很大程度上造成文件传输, 管理等方面的不便.\n于是人们通常使用ar压缩程序将这些目标文件压缩到一起.\n:question: 如何查看一个静态库是由哪些object file压缩到一起的?\nShell commandar -t libc.a 可以查看libc.a中包含的所有object files.\n ELF文件加载-运行流程  废了半天劲编译生成的ELF文件, 想要最终跑起来则包含的instruction and data必须要在内存中.\n 静态加载与动态加载 我们能想到的最简单的办法是: 把整个ELF的所有指令和数据在运行之前就全部load到内存中. 这就是静态加载.\n更加高效的做法是: 充分利用局部性原理, 将指令和数据划分为模块, 只有当该模块被使用时, 才load进内存, 否则就在外存中老老实实呆着. 这就是动态加载.\n动态加载的步骤 借助虚拟内存技术, 上面提到的模块的概念可以自然的被页(page)代替. 我们将所有的指令和数据按照page为单位划分.\n  运行该ELF的线程被创建时, 其virtual space范围被划定, 但其页表是空的, 没有任何映射.\n  OS读取ELF Header, 建立virtual space与ELF文件的映射关系. 这个映射关系的表达方式是一个特殊的数据结构. 建立该映射关系的原因是: 当程序运行到某个地址发现该页表项是空的(例如 call 0x1234), 那么必然触发page fault. 由OS负责到特定的外存地址将页面加载到physical memory中.\n  1OS要想知道缺失的内容在ELF文件的哪个位置, 就是利用该映射, 即某个数据结构 physical memory中有了所需的指令或数据后, 还需建立visual memory到physical memory的映射, 即在页表项中写入. 随着程序的运行, 会继续触发page fault, 从ELF中不断load page到physical memory, 建立缺页visual addr处的页表映射, 最终填补成一个完整的pagetable.   段地址对齐技术  由前面动态加载的步骤可知, ELF文件中的代码和数据被按page划分. 并只有在用到时才被加载到内存, 并建立虚拟内存-物理内存的映射.\n 假设一个ELF有三个段需要被LOAD, ELF段表如下:\n   Segment Length offset     SEG 0 127 B 34 B   SEG 1 9899 B 164 B   SEG 2 1988 B 0 B    :question: 这三个段在ELF文件中的布局如何? 根据前面ELF文件格式的介绍, 这三个段必然是挨着的(简单考虑, ELF中仅有这三个段).\n:question: 这三个段在物理内存中的布局? 发生page fault之后, OS会为页面分配合适的物理页面, 如利用buddy system等.\n可以保证段内的连续, 不能保证段与段是连续的.\n 未使用段对齐技术之前, SEG0的长度不足一页, 但是也给它分配一页的空间. 同理为SEG1分配两页, SEG2分配一页. 总共占用 1+2+1=5个物理页.\n :question: 这三个段在用户virtual addrspace下的布局如何? todo\n:question: 何为段地址对齐技术? 上面说了, 在为这三个段分配物理内存时, 虽然他们的真实大小远小于5个页面, 但由于简单采用: 每个段的开头必须是page align, 导致实际上产生了巨大的内部碎片.\n段地址对齐实际上就是在为ELF文件中的段分配物理内存时, 不考虑其段的独立性, 强制按照page来划分. 划分的行为如下图所示. 结果就是仅需占用3个物理页面.\n1+---+---------------+ 2| P | SEG0 | 3| A +---------------+ 4| G | | 5| E | | 6+---+ | 7| P | SEG1 | 8| A | | 9| G | | 10| E | | 11+---+ | 12| P +---------------+ 13| A | | 14| G | SEG2 | 15| E | | 16+---+---------------+  目前, gcc(更准确是说是GUN ld)默认启用段对齐技术. 各个段的虚拟地址并不是page align.\n  :four_leaf_clover: 物理页面到虚拟页面的映射阶段, 那些同时包含两个段的页面会被映射两次, 即一个物理页面对应两个 虚拟页.\n原因是: 在一个页面的不同段可能权限不同, 所以不能使用同一映射.\n ","date":"2022-06-20T16:21:27+08:00","permalink":"https://wangloo.github.io/posts/os/elf-format/","section":"posts","tags":["Operating System"],"title":"ELF 文件的链接与加载"},{"categories":null,"contents":"添加更多的编译选项(comiler options)来防止bug 对于我常用的GCC, 推荐开启一下的compiler options:\n  -Wall: enable a lot of common warnings\n  -Wno-format-truncation: warns about the snprintf output buffer not being large enough for a corresponding “%s” in the format string.\n  -Werror: turn warnings into errors.\n   动态申请的空间到底要不要释放 When using a barebones embedded OS, you absolutely need to tightly manage your memory.\n但是, 如果你是写应用业务的代码, 特别是在内存足够的场景下. 最好不要手动释放内存, 因为当线程/进程退出时, 操作系统会自动帮我们释放. 某些情况下, 释放内存的操作会很大程度上增加逻辑的复杂度.\n 如果你是一个内核程序员, 则必须手动的释放. 不用怀疑.\n  尽可能在创建变量时赋初值 放置某些变量创建后是 magic value. 而使用这些变量可能不会立马导致错误, 但是这是一个隐患.\n但这会产生一个问题, 有时我们定义变量之后的不久之后就会对其赋予正确的值, 这时候初值就是 多余的. 而且维护者可能认为这个值是meaningful, 这就要求我们如果要赋初值, 就要说明这个值 仅仅是无意义的初值.\n 使用#define, enum 对于代码在不同地方使用的同一个值, 应使用#define来声明使得代码maintainable.\n如果这些值有多个且能规划为同一类别, 则还可将#define的方式换为enum. 这会使代码更加meaningful\n 使用enum使还要注意其所占内存空间在不同架构中可能不同的问题, see enum的优势和漏洞\n  使用typedef优化function pointer  重定义一套自己的类型 在开发大项目时, 需要考虑可移植性的情况下, 最好利用typedef对类型进行重定义.\n1#if SYSTEM1 2 typedef int INT32; 3 ... 4#else 5 typedef long INT32; 6 ... 7#endif 如上, 对于某些架构int类型可能不是32bit, 此时就要使用long. 这种定义的方式会保证我们的系统 在任何架构中都不会出现类型的bug. 而且也增加了代码的readability.\n 善用~0 在做嵌入式编程时, 有时在设置掩码(mask)或者其他情况会要用到全1的变量值, 你是否经常这样声明?\n1int mask = 0xffff; 暂且不谈int类型到底占多少字节的问题. 就像上面一样, 我们程序员经常忘记某个类型的大小, 而少添加了f. 会导致变量mask的值不是全1(32位情况下).\n这是要变换一下思维, 使用~0的定义方法就可轻松化解, 无需管变量的类型是什么.\n1int mask = ~0;  合理的使用goto语句 在大学课堂中, 我们老师说过禁止使用goto语句, 但却没有给出明确的原因.\n实际上, 合理的使用goto能够极大的减少程序的冗余度.\ngoto语句常用于程序出现错误要退出时, 可能有多个情况会使用重复的代码处理, 例如释放一些allocated memory. 相较于使用flag, 使用goto显然更加clearly and readability.\n所以, 在面对重复的错误处理代码时, 想想能不能用goto进行优化. 当然, 避免过早优化.\n 注意, goto出现的场景其实很受限. Never use a backward goto or jump into control statements.\n  定义合理, 正确的结构体 结构体是C语言编程应用中常用的数据结构, 关于结构体也有许多要注意的点.\n#1 Flexible Array Member C99开始支持Flexible Array Member. 且看我lstring库的结构体定义:\n1struct str { 2 int length; 3 int size; 4 char data[]; // Flexible array member - C99 only 5}; 对于这种不定长的数组元素, 我之前都是定义一个指针, 占用一个sizeof(char *)的空间. 而Flexible Array Member本身不占用空间. 需要在malloc时为他单独声明空间.\n1int n = 100 2struct str *s = malloc(sizeof(struct str) + sizeof(char[n]));  这里也有一个小trick, 使用sizeof(char[n]) 比 sizeof(char) * n 更简洁!\n # 2 Padding and Packed 有关结构体的大小, 和地址对齐的问题. 假设我有一个结构体如下:\n1struct mystruct_A 2{ 3 char a; int b; char c; 4} x; Padding是编译器对结构体默认做的事情. 它会在成员之间插入一些 gap 来保证地址对齐:\n1struct mystruct_A { 2 char a; 3 char gap_0[3]; /* inserted by compiler: for alignment of b */ 4 int b; /* int 在32位上其地址是4字节对齐的 */ 5 char c; 6 char gap_1[3]; /* -\u0026#34;-: for alignment of the whole struct in an array */ 7} x;  除了保证每个成员的地址是对齐的, 整个结构体的地址也是按照其最大的成员类型来对齐, 即对齐到int(4字节).\n 如果你不想要这些 gap, 那么可以对结构体声明使用 __attribute__((__packed__))关键字. 整个结构体大小仅为6个字节.\n1struct __attribute__((__packed__)) mystruct_A { 2 char a; 3 int b; 4 char c; 5};  永远为你的函数设置error return value 一旦你的函数可能被其他人调用, 那么养成设置return value的习惯. 即便你现在的实现 并不会产生任何错误, 也请返回success.\n这样做的原因是, caller可以根据你的定义做错误判断, 即便以后你的实现加上了出错情况, 上层的代码也不需要修改.\n 变量类型的选择  名字, 特定不变的字符串使用const char *, 甚至const char const* 长度使用size_t 表示类型的参数尽可能使用enum 循环变量i使用signed, 避免溢出后出错   Reference How I Improve My (C) Code Quality\nTen Fallacies of Good C Code\n","date":"2022-06-14T17:59:22+08:00","permalink":"https://wangloo.github.io/posts/codestyle/improve_quality/","section":"posts","tags":["c"],"title":"写高质量的C语言工程的技巧"},{"categories":null,"contents":"seL4 Capabilities In seL4, capabilities are stored in C-space. C-space is a hierarchical data structure very similar to page table.\n page table is a mapping from virtual address to physical address. C-space is a mapping from object ID to capability. Kernel object is made up of several C-nodes, just like a page table made up of individual page tables. Each C-nodes is an array of cap slots, which contain capability.  Inaccessible to userland, you can never hold an actual capability\n You can only hold a reference to capability, which pointers into C-space(slot addresses) These C-space addresses are called CPTRs   You don\u0026rsquo;t need to do the transform, because this is typically extracted in some libs.\n Capabilities convey specific privilege (acces rights)\n Read, Write, Execute, GrantReply(call), Grant(cap transfer)  Main operations on capabilities:\n Invokeperform operation on object referred to by cap.  For example, map some frame into memory. You need to have capabilities to both the frame and address space.   Copy|Mint|Grant: create copy of cap with same/lesser privilege. Move|Mutate: transfer to different address with same/lesser privilege.  Between C-space or within C-space.   Delete: invalidate slot(cleans up object if this is the only cap to it) Revoke: delete any derived(eg. copied or minted) caps  Capability Derivation MINT OPERATION The Mint operation creates a new, less powerful cap\n Can add badge Can strip access rights, eg RW-\u0026gt;RO  1mint(dest, src, rights, badge)  The first two arguement are capability pointers(CPTR) to a C-space(represented by C-node), which are references inside C-node. The destination C-node cap must allow modification Then you have the rights and the batch of the new cap.  :pushpin: This is an alternative of sending addressed capabilities by IPC operation. That is what operating system do to set up protection domains for user level process.\nCOPY OPERATION  Copy as a version of Mint.\n  seL4 Kernel Objects In file libsel4\\include\\sel4\\objecttype.h\n1typedef enum api_object { 2 seL4_UntypedObject, 3 seL4_TCBObject, 4 seL4_EndpointObject, 5 seL4_NotificationObject, 6 seL4_CapTableObject, 7#ifdef CONFIG_KERNEL_MCS 8 seL4_SchedContextObject, 9 seL4_ReplyObject, 10#endif 11 seL4_NonArchObjectTypeCount, 12} seL4_ObjectType;  seL4 System Calls seL4 has 11 syscalls:\nYield(): invokes scheduler\n does NOT require a capability!  Send(),Recv() and variants/combinations thereof: IPC operations\n Call(),ReplyRecv(): usually invokes by client/server Send(), NBSend(): send-only and non-blocking version of it. Recv(), NBRecv(), NBSendRecv() Wait(), NBWait(), NBSendWait()   We just use Call() normally, the others are only for bootstrapping protocols and exception handling.\n Call() is atomic Send() + reply-object setup + Wait()\n cannot be simulated with one-way operations!  ReplyRecv() is NBSend() + Recv()\nDifferent object support different operations ENDPOINTS Endpoints support all 10 IPC variants.\nNOTIFICATIONS Notifications support:\n NBSend() - aliased as Signal() Wait() NBWait() - aliased as Poll()  OTHER OBJECTS Other objects only supports Call() operation.\n Appear as (kernel-implemented) servers. If you invoking a method on an object, this is done by treating the object as a kernel-implemented server. And you invoke it with a call() operation just as you do a normal server invocation. Each of these kernel objects has a different kernel-defined protocol  operations encoded in message tag parameters passed in message words   Mostly hidden behind syscall wrappers, user do not need to know this details.   seL4 IPC  IPC in seL4 is a way to realize cross-domain invocation.\n seL4 IPC is not a mechanism for shipping data. Transfering data is axillary but not the primary purpose.\nseL4 IPC is a protected procedure call, a user-controlled context switch(from clients context into server context).\n seL4 Threads Creating a thread  Obtain a TCB object Set attributes: V-space, C-space, fault endpoint, IPC buffer Set Scheduling parameters:  priority, scheduling context, timeout endpoint(maybe MCP)   Set architecture-related registers  Threads and Stacks Stacks are completely user-managed, kernel doesn\u0026rsquo;t care!\n Kernel only preserves SP.. on context switch\n Stack location, allocation, size must be managed by userland.\nKernel beware of stack overflow\n","date":"2022-06-04T11:52:51+08:00","permalink":"https://wangloo.github.io/posts/microkernel/sel4/","section":"posts","tags":null,"title":"MicroKernel Learning: SeL4"},{"categories":["hugo"],"contents":"HuGo 基础学习 本章将解答Hugo是什么, 以及Hugo是如何工作的. 只有了解Hugo的工作机制之后, 才能发挥想象力进行DIY.\n本章内容大多来自官方手册或者搜索引擎提供的结果.\nHugo 项目目录结构 一个hugo 项目通常包含以下内容:\n1. 2├── archetypes 3├── config.toml 4├── content 5├── data 6├── layouts 7├── public 8├── static 9└── themes 这里面有些是必须的, 有些是可选的.\narchetypes\n定义新创建post时, header的格式.\nasserts\n Note: assets directory is not created by default.\n config\nHugo uses the config.toml, config.yaml, or config.json (if found in the site root) as the default site config file.\nThe user can choose to override that default with one or more site config files using the command-line --config switch.\n1hugo --config debugconfig.toml 2hugo --config a.toml,b.toml,c.toml  Note: config directory is not created by default.\n content\n显然, 存储所有的post.\ndata\nThis directory is used to store configuration files that can be used by Hugo when generating your website.\n像是你 website 的一个mini 数据库, 你可以放置 toml, yaml, json格式的文件.\nlayouts\nStores templates in the form of .html files that specify how views of your content will be rendered into a static website. Templates include list pages, your homepage, taxonomy templates, partials, single page templates, and more.\npublic\n保存build生成的站点. 当运行hugo [flag]时生成.\n拷贝该目录下的内容, 可以部署到web 服务器上了.\nstatic\nStores all the static content: images, CSS, JavaScript, etc. 当Hugo构建您的站点时，静态目录中的所有资源都会按原样复制。\n即当构建website时, static/下的所有文件都会复制到 public/下.\nThe static files are served on the site root path (eg. if you have the file static/image.png you can access it using http://{server-url}/image.png, to include it in a document you can use ![Example image](/image.png) ).\nresources\n一些缓存文件\n Note: resources directory is not created by default.\n Hugo CLI 命令 hugo 支持的所有命令可以通过 hugo help 命令来查看. 每一条命令的具体用法, 可以执行 hugo [command] help 来查看\n1Usage: 2 hugo [flags] 3 hugo [command] Hugo completion 用来配置补全 hugo command 和 flag 的. 该命令会输出一段脚本, 将该脚本复制到你的 shell 的配置文件中就可以使用 hugo tab 补全了.\nhugo config 打印hugo的配置文件, 即根目录下的 config.toml.\nhugo env 打印 hugo 的版本和环境信息\nhugo list 打印所有post的info, 包含标题, 发布日志, 链接等.\nhugo new 非常重要的命令, 可以用来新建一个 website, 主题, 或者一篇post(常用). 带有许多 flag可以使用.\nhugo server 执行hugo server之后, 首先构建了你的网站(但是默认并不在本地创建文件, 而是放在内存), 然后启动hugo 自带的 web服务器让我们能看见网站的效果.\n同时, 默认情况下, server 会同步你的本地更改, 然后实时的reload你的页面. 这样你就能同时看到修改的效果.\nhugo server 的常用flag:\n1-D 包含标记为草稿的post. 默认不构建草稿. 2--theme strings 使用[strings]主题进行构建 hugo [flags] hugo 自身就是一个命令, 用于build website, 放到 public/目录下.\n常用 Flag(All supported flags):\n1--gc 在build后会清除一些cache文件. 与 resource/有关 2--minify minify any supported output format (HTML, XML etc.)  hugo 命令不会删除之前的文件. 而是仅新增改动. 所以每次build时需要你手动删除 public/ 目录.\n Hugo 内容管理 hugo build 后的website页面的布局和你源文件的布局相同, 所有源文件都放置在 content/ 目录下.\n1└── content 2 ├── _index.md // \u0026lt;- https://example.com 3 | 4 ├── about 5 | └── index.md // \u0026lt;- https://example.com/about/ 6 ├── posts 7 | ├── _index.md // https://example.com/posts/ 8 | ├── firstpost.md // \u0026lt;- https://example.com/posts/firstpost/ 9 | ├── happy 10 | | └── ness.md // \u0026lt;- https://example.com/posts/happy/ness/ 11 | └── secondpost.md // \u0026lt;- https://example.com/posts/secondpost/ 12 └── quote 13 ├── first.md // \u0026lt;- https://example.com/quote/first/ 14 └── second.md // \u0026lt;- https://example.com/quote/second/  hugo 将content/ 下的那级目录(例如 content/posts)特殊看待, 称为 section.\n 页面资源(Page Resources) 页面资源指每个页面私有的图片, 文档等静态资源. 与static/ 中全局的资源不同.\n页面资源放在content/下的任意位置, 但不是所有页面都能访问. page bundles 中的index.md or _index.md 能够访问该 bundles 下的资源.\n1content 2└── post 3 ├── first-post 4 │ ├── images 5 │ │ ├── a.jpg 6 │ │ ├── b.jpg 7 │ │ └── c.jpg 8 │ ├── index.md (root of page bundle, 能够访问first-post/下的所有资源) 9 │ ├── notice.md 不能访问任何资源, 但其自身作为一个资源可被index.md访问 10 │ ├── office.mp3 11 │ ├── pocket.mp4 12 │ ├── rating.pdf 13 │ └── safety.txt 14 └── second-post 15 └── index.md (root of page bundle, 但不能访问first-post/下的资源) 内容分类(Taxonomy) Taxonomy: How to group the content together. Two default taxonomies are tags and categories.\n代码高亮(Syntax Highlighter) 代码高亮的配置(in config.toml):\n页面分类 从布局上来看, 页面可以分为两类: List page 和 single page.\n显而易见, list page比较特殊, 它负责列出当前目录下的所有post. 所以一个目录地址必然是一个list page.\n在下面的例子中, https://example.com , https://example.com/posts/happy/ 都可以叫做 list page.\n  https://example.com/posts/happy/ 是list page, 目录下的_index.md 不是必须的, hugo 会默认仅显示所有post的title. 详见\n  https://example.com/about/ 不是list page, 因为其目录下有index.md, 强制表明这是一个 single page. 详见\n  1└── content 2 ├── _index.md // \u0026lt;- https://example.com 3 | 4 ├── about 5 | └── index.md // \u0026lt;- https://example.com/about/ 6 └── posts 7 ├── _index.md // https://example.com/posts/ 8 ├── firstpost.md // \u0026lt;- https://example.com/posts/firstpost/ 9 ├── happy 10 | └── ness.md // \u0026lt;- https://example.com/posts/happy/ness/ 11 └── secondpost.md // \u0026lt;- https://example.com/posts/secondpost/  Homepage 和 section page 都属于特殊的 list page.\n homepage 特指 content/_index.md section page 特指 content/[section]/_index.md   shortcodes shortcode 可以理解为 hugo 为了封装了一些代码块, 通过 shortcode 来调用.\n模板(Template) 模板是hugo的一个高级用法, 用来定义你网站的style. 模板不等同与主题(themes), 可以理解为主题是一套模板的集合. 我们可以在使用模板的同时添加DIY的 style. 😎 Hugo 会有优先级的判断.\n不同的页面类型需要定义不同的模板. List page 的模板称为 List template, single page 的模板称为 single template. 同理还有 homepage template, section template.\n存储模板的目录为layout/, 上面介绍hugo的目录结构时已经说过. 如果你使用了一个 theme, 那么themes/[your-theme]/layout/就是该theme的模板.\nhomepage 模板 Base 模板 对应layouts/_default/baseof.html\nbase 模板是整个website的核心. 所有的模板包括 list template, single template, homepage template\u0026hellip; 都是独立的, base template 将其他的模板联系到一起.\npartial 模板 包含网站的许多元素, 增加模块化. 我可以为网站的 header 或者 footer 写一个模板(html), 这些HTML可以嵌入其他的模板.\n模板优先级 既然同一种页面的模板可以定义在多个位置, 如果他们同时存在时, 优先级规则必然存在. 常见的情况比如我们使用了某个模板, 然而, 我们对模板中的一些布局不满意, 直接修改模板中的文件显然不是一个好方法, 那么该怎么做呢?\n一般来说, 如果你只想重写theme中的某个模板, 例如section template. 那么你只需要新建 layout/_default/section.html 即可, hugo 构建你的网站时, 如果检测到本地和theme的layout/_default下都有 section.html, 它会使用我们自己定义的那个.\n 完整的, 多级的优先级规则: Hugo\u0026rsquo;s Lookup Order | Hugo (gohugo.io)\n 变量(Variables) ❗ Hugo 变量仅设计给模板使用, 即在layouts/下的html文件.\nPage Variables 与post相关的变量, 定义在post 的 front matter中.\n1// Define Page variables in front matter of post 2---------------- 3title: \u0026#34;使用 HuGo 搭建个人网站\u0026#34; 4description: 学习正确的 Hugo 食用方式, DIY 属于自己的 website~ 5Myvar: \u0026#34;my value\u0026#34; 6---------------- 7 8// Use Page Variables 9{{.Description}} // Get the description of the post 10{{.Params.Myvar}} // Get the value of Myvar, that is, \u0026#34;my value\u0026#34; Site Variables 站点层面的变量大部分是网站配置相关.\n函数(Functions) 函数是hugo为你封装的一些方法你可以直接调用.\n❗ Hugo 函数仅设计给模板使用, 即在layouts/下的html文件. Same as variables.\nHugo pipes DIY My Own Website 支持 Emoji Adding emoji tutorial\nEmoji chart\nTODO List  深色和浅色模式使用 不同的代码高亮 格式 Post section page 添加简介 Single template 调整 Header\u0026rsquo;s margin  ","date":"2022-05-21T17:39:42+08:00","permalink":"https://wangloo.github.io/posts/hugo/","section":"posts","tags":["hugo"],"title":"使用 HuGo 搭建个人网站"},{"categories":["motivation"],"contents":"Content Fourteen years ago, Steve stood on this stage and told your predecessors \u0026ldquo;Your time is limited. So don\u0026rsquo;t waste is living someone else\u0026rsquo;s life.\u0026rdquo;\nSo what is true then is true now. Don\u0026rsquo;t waste your time living someone else\u0026rsquo;s life. Don\u0026rsquo;t try to emulate the people who came before you to the exclusion of everything else, contorting into a shape that doesn\u0026rsquo;t fit.\nGraduates, the fact is, when your time comes, and it will, you will never be ready. But you\u0026rsquo;re not suppposed to be. Find the hope in the unexpected. Find the hope int the challenge. Find your vision on the solitary road. Don\u0026rsquo;t get distracted. There are too many people who want credit without responsibility. Too many who show up for the ribbon cutting without building anything worth a damn.\nBe different. Leave something worthy. And always remember that you can\u0026rsquo;t take it with you. You\u0026rsquo;re going to have to pass it on.\nThank you very much. And Congratulations to the Class of 2019!\nYouTube vidio\n","date":"2022-05-18T19:32:38+08:00","permalink":"https://wangloo.github.io/posts/motivation/2019-stanford-commencement-timcook/","section":"posts","tags":["tim cook","address"],"title":"2019 Stanford Commencement Timcook"},{"categories":["note"],"contents":"Get start What is HTML\u0026amp;CSS?   HTML is resonsible for the content of the page. That\u0026rsquo;s the text, images, buttons, etc.\n  CSS is resonsible for the presentation of the content. That\u0026rsquo;s the color, layout, etc.\n  Web designers create the overall look and fell of a website.\n  Web developers implement the design using HTML, CSS and JavaScript code.\n  Configure VIM as HTML code-editor  Finally in the arms of vscode :hear_no_evil:\n Add vim plugin:\n emmet: Coding HTML faster.  CSS autocomplete key: \u0026lt;C-x\u0026gt; \u0026lt;C-o\u0026gt;\nHTML and CSS live previes plugin: bracey\n urlopen error solution   HTML Fundamentals Anatomy of an HTML element 1\u0026lt;p\u0026gt; THML is a markup language\u0026lt;/p\u0026gt; The HTML element is composed of opening tag, content, closing tag.\nHTML good styles  \u0026lt;img/\u0026gt; element should add alt attritube at all time, for the convenience of the blind. An important principle in web design is making the HTML elements meaningful. That is semantic HTML.   CSS Fundamentals CSS describes the visual style and presentation of the contend in HTML.\nAnatomy of an HTML element 1h1 { 2 color: blue; 3 text-align: center; 4 font-size: 20px; 5} h1 is Seletor, every style has proporty and value.\nCSS good styles  Class selector is more commonly used than ID selector, as ID is unique in HTML. For scalability, remember always using class selector. We should always specify all the four state of \u0026lt;a\u0026gt; element in order, which including link, visited, hover and active.  Priority conflicts between selectors CSS style priority from high to low:\n Inline style(style attribute in HTML) ID selector class or pseudo-class selector element selector universal element selector   The CSS box model The box model defines how elements are displayed on a webpage and how they are sized.\nIn the box model, every element on a webpage can be seen as a rectangular box.\n Universal element \u0026amp; \u0026lt;body\u0026gt; element Styles in \u0026lt;body\u0026gt; selector take effect because of inheritance. But the text-independent elements do not support inheritance.\nThat is where universal element selector is needed. It\u0026rsquo;s styles take effect on all element.\nWhen we want to set padding and margin of all elements to 0. Must put the code in universal element selector.\n Inline elements \u0026amp; Block elements Inline elements:\n Occupies only the space necessary for its content. Box model applies in different way: heights and widths do no apply. Paddings and margins are applied only horizontally(left and right).  Block elements:\n 100% of parent\u0026rsquo;s width vertivally, one after another  Inline-Block elements:\n Good example is \u0026lt;img\u0026gt;.   The 3 ways of building layouts with CSS Float Layouts: The old way of building layouts, using the float CSS property. Still used, but getting outdated fase.\n Element is removed from the normal flow: out of flow. Like absolutely positioning. Text and inline elements will wrap around the floated elements. Different from absolutely elements. The container will NOT adjust its height to the elements.  FlexBox: Modern way of laying out elements in a 1-dimensional row without using floats. Prefect for component layouts.\n One of its most useful applications is vertical centering. Flex container property:  gap: To create space between items. justify-content: To align items along main axis(horizontally, by default) align-items: To align items along cross axis(vertically, by dedauly) flex-wrap: To allow items to wrap into a new line if they are too large align-content: Only applies when there are multiple lines(flex-wrap: wrap)   Flex Items property:  align-self: To overwrite align-items for individual flex items. flex-grow: To allow an element to grow. flex-shrink: To allow an element to shrink. flex-basis: To define an item\u0026rsquo;s width, instead of the width property. flex: Recommended shorthand for flex-grow, -shrink, -basis.    CSS Grid: For laying out elements in a fully-fledged 2-dimensional grid. Perfect for page layouts and complex components.\n  CSS grid is a set of CSS properties for building 2-dimensional layouts\n  The main idea behind CSS Grid is that we divide a container element into rows and columns that can be filled with its child elements\n  CSS grid is not meant to replace flexbox!. Instead, they work perfectly together. Need a 1D layouts? Use flexbox. Need a 2D layout? Use CSS grid\n  Grid container\n grid-template-rows/grid-template-columns: To establish the grid row and column tracks. One length uniit for each track. Any unit can be used, new fr fills unused space row-gap/colum-gap: To create empty space between tracks justify-items/align-items: To align items inside rows/columns(horizontally/vertically)    Grid items\n grid-column/grid-row: To place a grid item into a specific cell, based on line numbers. span keyword can be used to span an item across more cells justify-self/align-self: To overwrite justify-items/align-items for single items    ","date":"2022-05-17T11:02:04+08:00","permalink":"https://wangloo.github.io/posts/html-css/0/","section":"posts","tags":["html","css"],"title":"Html Css Learning note (0)"},{"categories":["vim"],"contents":"Search a word quickly: put cursor on the word, press / and press \u0026lt;C-R\u0026gt; \u0026lt;C-W\u0026gt;.\n 缩写的含义(Meaning of abbreviations) Operation\n d - delete y - yank(copy, 因为c被占了) c - change r - replace v - visual select  Scope or location\n i - inside a - around f - forward t - to  Object\n w - word s - sentence p - paragraph   书签: Bookmark ma: create bookmark a inside file.\nmA: create global bookmark A.\n`a: jump to bookmark a.\n:marks: display all bookmarks\ntag 目前用的生成tags文件工具是 ctag, 感觉还可以。\n1ta \u0026lt;tag\u0026gt; \u0026#34; 跳转到一个tag，如果有多个应该是随机一个 2CTRL-] \u0026#34; 快捷键跳转到当前光标下的tag 3ts \u0026lt;tag\u0026gt; \u0026#34; 多个tag时，可以选择跳转到哪一个 45help tag \u0026#34; 查看更多帮助 缩进: indent   \u0026gt;: increase indent , \u0026lt;: decrease indent ,=: auto indent\n  \u0026gt;\u0026gt;: 增加当前行的缩进\n  gg=G: 缩进全文, 无论当前光标在哪\n   以上命令都可以配合visual mode使用\n 自动缩进的规则 主要有四种可用缩进的方式, 分别是:\n1\u0026#39;autoindent\u0026#39; 沿用上一行的缩进。 2\u0026#39;smartindent\u0026#39; 类似 \u0026#39;autoindent\u0026#39;，但是可以识别一些 C 语法以能在合适的地方 3 增加 / 减少缩进。 4\u0026#39;cindent\u0026#39; 比上面两个更聪明；可以设置不同的缩进风格。 5\u0026#39;indentexpr\u0026#39; 最灵活的一个: 根据表达式来计算缩进。若此选项非空，则优先于其它 6 选项覆盖。参见 indent-expression 。 自定义的快速命令:\n1command IndentOff setl noai nocin nosi indentexpr=\u0026#34;\u0026#34;2command IndentOn setl ai cin si \u0026#34;indentexpr can\u0026#39;t be re-enabled.3command IndentStatus set ai? si? cin? indentexpr? cindent 不一定对所有的语言都有效果. 只是 C-like 风格, 其中一个要求是顶层函数必须在第一列中含有 {.\n  只有当indentexpr计算不出当前需要缩进几格时(return -1), 才使用上面的三个规则. 它是优先级最高的.\n Find and Tail f(: 从当前cursor处向右查找下一个(, 并将光标移动到(处.\nF(: Like f(, but 向左查找.\nt(: Like f(, but 将cursor移动到(的前一个.\nT(: You can guess.\nTrick vt(c: With visual, 删除当前光标到下一个(前的所有内容.\n;/,: 查找下一个/上一个 f/F/t/T 的内容.\n Substitute and Global  See: :help :s and :help :g\n 这两个都属于vim的命令. vim 的替换和sed 的s命令使用方式基本一致. 就不多介绍了.\n而 vim 的 global 命令和sed有些许差别. 使用Sed删除包含个字符串的行的指令为: sed '/STRING/d' input_file, 而在vim中则多了一个g前缀, :g/STRING/d.\nglobal 可以和 substitute 结合使用, 例如想要在包含某个字符串的行中替换good为excellent\n1:g/STRING/s/good/excellent/  TODO:\n More [cmd] in global. Power of g | Vim Tips Wiki | Fandom vim subtitute使用的正则表达式集包含 \\zs和\\ze, 然而 sed 没有(Sed 为 POSIX Basic Regular Expression).    大小写转换    cmd description     g~ 翻转大小写   gu 转换为小写   gU 转换为大写    以上命令(严格来说叫操作符)需要配合动作命令来使用.\n gUaw: 将光标所在位置的单词转为大写 gUap: 将光标所在位置的段落转为大写   Search and replace case 1: search and convert to uppercase/lowercase 我直觉想到的方式是%s/html/HTML/gc\n这种方式在简单情况下也行, 比较灵活且直观, 但是对于复杂文件不够通用且容易出错\n还有一种方式是先搜索, 然后一步步替换\n 搜索: /\\vhtml\\C 替换: 执行命令gUgn, 然后使用n和.来重复操作下一个选中项.   gn命令进对于sreach的匹配项使用, 类似于n, 但会将下一个匹配项(若光标停在match上, 那则选中当前匹配项) 转为visual模式选中的状态.\n  其实对于简单的文本, n和.也可以简化为.. 唯一的坏处就是如果两个匹配的距离太大, 你不能确认是否search了你想要的内容.\n case 2: search the text seleted in visual mode  vim 本身并未提供这个功能, 需要借助一个脚本来完成\n search the text selected in visual mode\n Visual Block 模式   选中后, 编辑所有行: I(captial i), 编辑完成后按两次ESC\n  重复visual 选中上次的 block: Normal模式下gv即可.\n   单词间跳转 w: Move cursor to begin of next word.\nb: Move cursor to begin of last word.\ne: Move cursor to end of next word.\nTrick w/b配合ce使用可达到在某一行中快速移动到某个单词, 然后删除该单词开始edit.\ndaw: 即 Delete A Word, 可以删除一个完整的单词, 无论当前光标的位置在哪.\n 编辑二进制/十六进制文件 可以使用xxd命令将一个文件中的文本转换为hex格式显示. 在vim中键入:%!xxd 即可. 得到的效果如下:\n10000000: 5468 6973 2069 7320 6120 7465 7374 0a41 This is a test.A 20000010: 6e6f 7468 6572 206c 696e 650a 416e 6420 nother line.And 30000020: 7965 7420 616e 6f74 6865 720a yet another. 后面的对应文本是自动生成的, 仅需要修改十六进制的部分即可. 修改完成后, 要返回原本的模式, 键入:%!xxd -r.\n 可通过设置文本格式对十六进制内存高亮显示 set ft=xxd.\n  删除光标前/后的所有字符  d^ \u0026ndash; delete to first non-whitespace character in the line d0 \u0026ndash; delete to beginning of the line c-u in insert mode. Same as bash command shortkeys, see here   文件恢复/swp文件 正确对待swp文件的姿势:\n vim 打开原文件, 此时会提示Found a swap file the name .xxx.swp, 显然选择(R)ecover 来恢复未保存的内容. 使用:w将恢复的内容保存下来 但是此时原本的swp文件还是存在, 此时我们执行:e刷新一下当前bufffer, 仍然会提示恢复的选项, 但此时文件内容已经恢复, 选择(D)elete 就可将对应的swp文件删除了   删除当前目录中所有swp file的脚本?\n需要确保:\n 所有文件内容已恢复 当前窗口或者其他窗口没有vim正在打开文件(会生成swp file)  1find . -type f -name \u0026#34;.*.sw[klmnop]\u0026#34; -delete  How to handle swapfiles in Vim (longwood.edu)\n Debug VIM key mapping https://vi.stackexchange.com/a/7723/43494\n 如何同步 VIM Dotfiles vim 的 dotfiles 主要包含.vimrc和.vim/中的插件.\n  对于.vimrc, 我选择使用mackup 软件和其他system dotfiles 一起备份. Git repo\n  对于 plugins, 传统的管理插件的方式(使用vim-plug), 也就是放在~/.vim/plugged/目录中的, 可以通过:PlugInstall命令在新机器上重新从网上克隆. 能够保证使用的是新版本.\n  VIM 8.0 之后, 引入 pack system 新的插件管理方式. 对于这类的插件, 我们直接利用submodule加入另一个备份的 Git repo. 使用方法见README.\n   Good plugins  Reference: The Ultimate vimrc\n TODO Installed NERD Commneter - 快速注释\nNERD Tree - 目录树\nOpen File Under Cursor - 打开光标处的文件目录\n 不支持vim-plug安装. 直接clone源码到plugged目录即可. Usage: gf: 在当前window打开文件. \u0026lt;C-w\u0026gt;\u0026lt;C-f\u0026gt;: new vertical windows中打开文件.  Ack.vim - 快速定位内容\nLeaderF - Like Ctrlp but better?\nbarbaric - normal模式切换英文输入法\n Helpful script search text selected in visual mode 1xnoremap * :\u0026lt;C-u\u0026gt;call \u0026lt;SID\u0026gt;VSetSearch(\u0026#39;/\u0026#39;)\u0026lt;CR\u0026gt;/\u0026lt;C-R\u0026gt;=@/\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt;2xnoremap # :\u0026lt;C-u\u0026gt;call \u0026lt;SID\u0026gt;VSetSearch(\u0026#39;?\u0026#39;)\u0026lt;CR\u0026gt;?\u0026lt;C-R\u0026gt;=@/\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt;3function! s:VSetSearch(cmdtype)4let temp = @s5norm! gv\u0026#34;sy6let @/ = \u0026#39;\\V\u0026#39; . substitute(escape(@s, a:cmdtype.\u0026#39;\\\u0026#39;), \u0026#39;\\n\u0026#39;, \u0026#39;\\\\n\u0026#39;, \u0026#39;g\u0026#39;)7let @s = temp8endfunction","date":"2022-05-09T19:28:12+08:00","permalink":"https://wangloo.github.io/posts/vim/basic/","section":"posts","tags":["vim"],"title":"我的 vim 调教随笔"},{"categories":null,"contents":"Change code theme Default use monokai.css. see 官方文档\n修改需要下载新的css放到plugin/highlight/目录下.\n其他可用的css在highlight.js仓库中下载.\nAlign Slide Align 取消center对齐方式:\n1Reveal.initialize({ 2 ... 3 center: false, 4 ... }) 所有slide左对齐: https://github.com/hakimel/reveal.js/issues/1897\n用markdown写的方式下使某一幻灯片左对齐: https://github.com/hakimel/reveal.js/issues/890#issuecomment-129735291\n","date":"2022-05-08T19:34:44+08:00","permalink":"https://wangloo.github.io/posts/revealjs/","section":"posts","tags":null,"title":"reveal.js Tutorial"},{"categories":null,"contents":"Load/Store 指令 寻址模式 Base register - w0=[x1]\n1ldr w0, [x1] Offset addressing mode - w0=[x1+12]\n1ldr w0, [x1, 12] Pre-index addressing mode - x1+=12; w0=[x1]\n1ldr w0, [x1, 12]! Post-index addressing mode - w0=[x1]; x1+=12\n1ldr w0, [x1], 12 更多示例 1// load a byte from x1 2ldrb w0, [x1] 3 4// load a signed byte from x1 5ldrsb w0, [x1] 6 7// store a 32-bit word to address in x1 8str w0, [x1] 9 10// load two 32-bit words from stack, then add 8-byte to sp 11ldp w0, w1, [sp], 8 12 13// store two 64-bit words at [sp-96] and subtract 96-byte from sp. 14stp x1, x2, [sp, -96]! 15 16// LDR伪指令. load 32-bit immediate from literal pool(addr: 0x12345678) 17ldr w0, =0x12345678 数据处理指令 Bitfield 操作指令 Bitfield 指令常用于设置/提取寄存器的某个字段.\n1;BFI(Bit Field Insert) 2BFI w0, w0, #9, #6 ;w0[0, 5] = w0[9, 14] 3 4;BFC(Bit Field Clear) 5BFC w0, #4, #2 ;w0[4, 5] = 0 6 7;UBFX(Unsigned Bit Field Extract) 8UBFX w1, w0, #18, #7 ;w1=w0[18, 24]  与 UBFX 相对的是 SBFX, 若提取后的字段高位为 1, 会进行符号扩展\n 分支/控制指令 获得地址的相关指令 写汇编中，常常会获取一个变量或者函数(label)的地址，A64 中一共有几种获取地址的指令， 包括adr, adrp, adrl, ldr等，下面我就对这些指令进行介绍。\nADR 首先是 adr，它的作用是加载 PC 相对地址，adr 指令的格式是:\n1adr reg, offset 输入一个 offset，输出 PC+offset 的值，但我们常用的是 offset 填某一个 label，例如函数 或者变量，此时 reg 中存的就是此函数的地址了。例如，\n1adr x0, a_func # x0 = addr(a_func) adr 指令中留给 offset 的位数是 21，所以最大的寻址范围为+-1MB。\nADRP adrp 的指令格式与 adr 相同，不同点是会将计算的结果向下对齐到 4k，但这样直接计算的 地址结果往往是不正确的，因为少了页内的偏移。需要一个额外的 add 指令进行纠正，一般来说 是组合起来用的：\n1adrp x0, a_func 2add x0, x0, :lo12:a_func 显然 adrp 这样做是为了更大的寻址空间，能到+-4GB。\nLDR 伪指令 如果 ldr 指令的参数是=\u0026lt;label\u0026gt;，那就代表伪指令，作用是加载 label 的绝对地址，即 VMA。好处是可以获取到一个位于任意 label 的地址，不受寻址空间的约束。\n 注意label是一个 offset, =label是一个绝对地址。\n  当目前指令执行地址不等于它们的虚拟地址时，比如当 MMU 未开始时通过 uboot 加载到内存 中直接运行的那段程序，此时用adr/adrp这些加载 pc 相对地址的指令就会正确的返回 label 的实际运行地址；而ldr则是永远返回其编译链接后绑定的虚拟地址。这种情况下 如果寻址范围允许，用adr*指令更方便。\n 有趣特性/常见误区 \u0026lsquo;#\u0026rsquo; before the immediate value  A64 assembly language does not require the # to introduce constant immediate value. But the assembler can also indentify the #. In armv7, there must be a # or $ before other than using .syntax unified. About syntax unified.   Agreed Recommendation\nUse .syntax unified in v7 code, and never use # on any literal on either v7 or v8. Unified syntax is newer and better, and those # and $ signs are just more code noise.\n ","date":"2022-05-07T21:19:01+08:00","permalink":"https://wangloo.github.io/posts/armv8/a64/","section":"posts","tags":["arm64"],"title":"ARM64: A64指令集"},{"categories":null,"contents":"寄存器分类 通用寄存器  x0-x7 参数寄存器: Restore function parameters and return vaule. x9-x15 caller-saved 临时寄存器: callee 默认可以直接使用来保存临时变量, 不需要保存和恢复. 如果 caller 在里面存储了非临时信息, 那么在函数调用之前应当由 caller 负责保存. x19-x28 callee-saved 寄存器: callee 应该避免使用. 如果必须要使用，那么在返回前必须恢复. special registers:  x8 restore indirect result. Commonly used when returning a struct. x18 platform reserved register. x29 frame pointer register(FP). x30 link register(LR).     All general-purpose register xN is 64-bit width. They all have corresponding wN register using the lower 32-bit of xN. And write to wN will clear the upper 32bit of xN.\n  💫 The different between Caller-saved and callee-saved registers\n Caller-saved 寄存器又称为临时寄存器, 常用来存放临时变量. 例如A() 调用 B(), 那么 B() 可以直接使用 caller-saved 寄存器, 也就是说 A() 在调用 B() 之前不会在这些寄存器里保存重要信息(编译器实现), 不能保证调用 B() 前后其值不变. 如果必须要保证, 那么保存和恢复(利用栈)这件事是 A() 来做. Callee-saved 寄存器则相反, 通常持续使用的值会保存到这些寄存器中. 还是拿 A() call B() 来举例. 如果 A() 中的一个变量需要在调用 B() 前后持续有效, 那么它应当保存到 callee-saved 寄存器中. 而且 B() 正常来说不应该动这些寄存器, 如果非得动(例如寄存器不够用), 那么 B() 需要在使用他们的前后进行保存和恢复(利用栈).   每个EL的特殊寄存器  sp_el0/1/2/3 stack pointer register of each EL. elr_el1/2/3 exception link register of each EL except EL0. spsr_el1/2/3 save program status register of each EL except EL0.   sp is an alias of sp_el0. Do NOT treat sp as general-purpose register.\n ","date":"2022-05-07T20:19:44+08:00","permalink":"https://wangloo.github.io/posts/armv8/register/","section":"posts","tags":["armv8"],"title":"ARMv8-A 寄存器"},{"categories":null,"contents":"考试大纲 :dart: To Reader:\nThis blog is JUST FOR EXAMINATION! If you are interested in numberical analysis, please quit this web. I try to sort out the knowledge points of the course, just to pass the exam.\nBased on the course of Professor Zhong Erjie of UESTC.\n:anger: I hate mathematics!\n 第二章 非线性方程/方程组的求解 1. 二分法及迭代  二分法误差估计定理  2. 不动点迭代  不动点及不动点迭代的概念 迭代格式的选择? 是否收敛? 迭代的初值是否合适?  3. 牛顿法解非线性方程  背景: 如果函数f(x)是线性的, 那么它的求根问题就会简化. 牛顿法实质上是一种线性化方法, 将非线性方程逐步归结为某种线性方程来求解.\n 牛顿法的迭代格式: $$ x^{k+1} = x^k - \\frac{f(x^k)}{f^\u0026rsquo;(x^k)} $$\n4. 弦截法  背景: 弦截法是牛顿法的一个改进. 牛顿法求根时需要计算f'(x), 而导数的计算往往困难. 弦截法使用差商来回避导数的计算.\n 5. 收敛阶 6. 非线性方程组的牛顿迭代格式  雅可比矩阵是什么?   第三章 直接法解线性方程组 1. Gauss消元法 求解过程的算法复杂度为O(n^2), 消元过程的算法复杂度为O(n^3).\n2. 直接三角分解法(Doolittle分解法)  背景: 直接意味着可以由A的元素直接计算L和U, 不需要任何的中间步骤.\n 一旦L和U得到, 求解Ax=b就可以等价表示为求解两个三角形方程组:\n Ly=b, 求y Ux=y. 求x   第四章 迭代法解线性方程组  背景: 对于线性方程组Ax=b, 当A为低阶稠密矩阵时, [选主元消去法]是求解的有效方法.\n但是实际情况中A大都是巨型的稀疏矩阵, 这是采用迭代法来求解是合适的. 迭代法可以利用A中有大量零元素的特点.\n  迭代法不一定最终能够逼近方程组的解, 认识误差向量的概念.  1. Jacobi迭代 雅可比迭代格式和收敛性的判别\n快速计算Bj的特征值\nJacobi迭代由A直接看出Bj\n2. Seidel迭代 Seidel迭代收敛格式和收敛性的判别\nSeidel迭代独有的判断收敛性的方式: 若A为对称阵, 且A正定, 那么迭代收敛.\n 第五章 插值法 1. 插值方法与插值问题  背景: 仅已知某些点和该点的函数值的情况下, 如何模拟一个插值函数P(x), 使得误差最小.\n  什么是插值函数P(x)? 被插函数? 插值节点? 插值余项?  2. 多项式插值  可证明多项式P(x)存在唯一. 多项式插值通过解方程组就能得到解(a0, a1,..., an).  3. 拉格朗日插值公式  背景: 虽然上面的多项式插值能否解决n+1个点的光滑函数, 且解是唯一的. 但是解方程组是很麻烦的.\n 拉格朗日插值公式: $$ L_n(x) = l_0(x)y_0 + l_1(x)y_1 + \\dots + l_n(x)y_n $$ 插值基函数:\n插值条件(插值系数): $$ y_0 = f(x_0), y_1 = f(x_1), \\dots,y_n = f(x_n) $$\n误差余项Rn(x)\n4. 牛顿插值公式  背景: 给定5个插值节点及其函数值, 可以得到L4(x); 由于某种原因, 需要加入一个新的插值节点. Lagrange插值法之前的计算结果(l)均失效, 需要重新计算. 非常的不方便.\n  牛顿法是基于差商的概念. 导数是差商的极限. 差商的差商是高阶差商.  牛顿插值法的插值函数(以二次插值举例): $$ P(x) = a_0 + a_1(x-x_0) + a_2(x-x_0)(x-x_1) $$ 需要做的就是解出系数a0,a1,....\n所以引入差商的符号: $$ a_1=f[x_0,x_1]=\\frac{f(x_1)-f(x_0)}{x_1-x_0} $$ $$ a_2=f[x_0,x_1,x_2]=\\frac{f[x_1,x_2]-f[x_0,x_1]}{x_2-x_0} $$\n5. Hermite插值  背景: 有时我们已知的条件不都是函数值, 也有导数值. 例如已知两个点的函数值和两个点的导数值, 可以应用Heimite插值法得到三次多项式.\n 求Hermite插值函数的方法: 构造差商表, 重复节点特殊处理.\nHermite插值方法的余项证明与Langrange插值法相同.\n6. 分段低次插值  背景: 次数太高的多项式插值的效果不好. 比如龙格现象.\n  分段: 把被插值函数所在的大区间分成一个个的小区间. 低次: 每个小区间上用次数不超过3的函数来逼近  6.1 分段线性插值 就是分段折线\n分段线性插值的优点:\n 简单 当二阶导数趋近0时, 一定收敛  分段线性插值的缺点:\n 分段折线不光滑, 分段点处不能求导.  6.2 分段Hermite插值  背景: 为了解决分段线性插值的缺点(存在尖点).\n 已知函数在(n+1)个点的函数值值以及其导数值, 去构造一阶连续可导函数.\n分段Hermite插值根据(n+1)个已知点划分为(n+1)个区间. 这样在每个小区间上都已知4个条件, 可以使用3次Hermite插值.\n结论: 已知(2n+2)个条件的情况下, 居然只得到一阶连续可微函数. 结论太差!\n 第六章 拟合 :mag: 插值, 拟合, 逼近的区别\n1. 最佳平方逼近 2. 最小二乘法  背景: 已知不共线的三点, 如何确定一条可信的直线.\n 三个点可以用插值来模拟二次多项式, 但题目要求了用一次多项式, 这是插值无法做到的.\n不共线的三点不可能同时经过一条直线, 所以要用逼近的思想. 找一条近似的直线, 使得误差最小.\n 与插值的区别: 插值是明确给出n+1个插值条件, 得到n次多项式. 如何定义误差最小?: 函数间的距离.  1. 线性拟合 拟合的函数是n次多项式, 可转化为超定方程GX.\n 其中规定G为系数矩阵, X为变量的列向量. 同时定义列向量F为给出的函数值. GX=F是超定方程组, 没有准确解. 得到残差最小的解的方法即最小二乘法.  所以线性拟合的残差r = |GX - F|, 而找到目标函数的宗旨就是使r最小. 使用初等变分原理将这个问题转化为正规方程组求解的问题.\n 第七章 数值积分  背景: 定积分的计算中可能无法找到原函数的情况. 考虑定积分的本质是一句具体的数, 我们的目标就是找到这个数的近似值, 越接近越好.\n 解决的两种思路: 积分中值定理 和 插值型求积公式(近似被积函数).\n1. 积分中值定理 基本的积分中值定理: $$ \\int_{a}^{b}f(x)dx = f(\\xi)(b-a) $$\n将一个区域的面积转化为矩形的面积. 如何确定矩形的高呢? 左矩阵, 右矩阵, 中间矩阵, 梯形公式.\n更常用的积分公式是 在乘积函数积分中, 如果g(x)不变号, 则有: $$ \\int_{a}^{b}g(x)f(x)dx =f(\\xi)\\int_{a}^{b}g(x)dx $$\n2. 插值型求积公式 在被积函数很复杂的情况下, 可以对其进行近似处理, 例如使用Lagrange插值法.\n二次插值: Simpson公式 取二次插值的步长h=(b-a)/2, 即增加一个插值节点(b-a)/2, Simpson公式化简的结果为: $$ \\int_{a}^{b}f(x)dx = \\frac{b-a}{6}[f(a)+4f(\\frac{a+b}{2})+f(b)]+R[f] $$\n:pushpin: Simpson公式满足3阶代数精度. 虽然它只是二次插值得到的.\n3. 余项  插值型求积公式的余项, 即对应的插值方法(如Lagrange, Newton)的余项在区间上的积分. 梯形公式方法的余项可以用积分中值定理来优化. Simpson公式的余项不能使用积分中值定理来优化, 因为不满足保号的条件.  4. 衡量求积公式的好坏 代数精度: 不是一种误差, 而是对误差的描述.\n如何得知某个公式的代数精度: 只要带入一个m次多项式验证余项是否为0即可.\n5.复合求积公式 为了提高精度通常把积分区间分为若干个子区间, 再在每个子区间上应用低阶求积公式.\n 复合梯形公式: 将区间等分. 复合simpson公式: 将区间偶数等分.   第八章 常微分方程初值问题数值解法 将研究的内容进一步限定为: 一阶初值问题, 单步法.\n 背景: 在无法给出解析表达式时如果利用数值方法求出y的近似解?\n 1. 简单的数值方法 1.1 Euler公式 使用一阶向前差商近似替代y'. 得到递推的数列表达式: $$ y_{n+1} = y_{n} + hf(x_n,y_n), n=0,1,2,\u0026hellip; $$\n误差: Euler法使用的近似代替只有一阶精度, 所以误差很大. 此时有两种解决方案:\n 加细步长h, 若不行再加细. 总是能得到正确的, 如果你不嫌弃带来的计算变得缓慢的问题. 换方法.  1.2 梯形公式  背景:为得到比Euler法精度更高的计算公式. 梯形公式具有二阶精度.\n 对y' = f(x,y)的两端进行局部的积分, 然后用梯形公式近似计算右边.\n1.3 改进Euler公式 先用欧拉公式求得一个近似的yn+1, 带入梯形公式, 得到矫正的yn+1.\n","date":"2022-05-07T18:04:58+08:00","permalink":"https://wangloo.github.io/posts/numberical-analysis/","section":"posts","tags":["Math","Examination"],"title":"Numberical Analysis Exam"},{"categories":["vim"],"contents":"Use plugin vimtex Vim build-in support of LaTeX files is just OK. When we need more excellent exprience, good plugins is very recommended.\nvimtex is a nice and modern vim plugin for LaTeX files.\nUseful Futures of vimtex IMO\n \u0026lt;leader\u0026gt;ll Complier. By default, it will auto-complier when you type :w. \u0026lt;leader\u0026gt;lt Open content tree as a sidebar. \u0026lt;leader\u0026gt;lv View PDF with configured PDF viewer. \u0026lt;leader\u0026gt;li File information. cse Change surrounding \\begin \\end environment. tse Exchange between \\begin{env} and \\begin{env*}. tsc Exchange between \\command{} and \\command*{}.   Add Support of Simplified Chinese Install xetex I use xetex to add supports for Chinese fonts in LaTex files. Actually the magician is amacro package of xetex named xeCJK.\nAnd xetex is included intexlive. so we install it from source:\n1sudo apt install texlive-xetex Install Chinese Font If there is no Chinese font in your system, you must install one. I choose WinQingYuan microhei as a instance.\n1sudo apt install ttf-wqy Excute fc-list to check if install successfully, here is excepted output:\n1fc-list | grep wqy 1/usr/share/fonts/truetype/wqy/wqy-microhei.ttc: WenQuanYi Micro Hei,文泉驛微米黑,文泉驿微米黑:style=Regular 2/usr/share/fonts/truetype/wqy/wqy-microhei.ttc: WenQuanYi Micro Hei Mono,文泉驛等寬微米黑,文泉驿等宽微米黑:style=Regular Configure your tex file 1\\documentclass {article} 2\\usepackage{xeCJK} 3\\setCJKmainfont{WenQuanYi Micro Hei} 4 5\\begin{document} 6Hello, LaTeX! 7 8你好, LaTex! 9 10\\end{document} Complier it and see, the Chinese font is displayed!\n Confusing Tools Difference between {pdf,lua,xe}Tex and {pdf,lua,xe}LaTeX If a .texfile starts with \\documentclass, it\u0026rsquo;s a LaTex format file rather than the Plain Tex format file.\nThe LaTeX format file has some specific macro like \\documentclass that cannot be compliered by [pdf]Tex, so that\u0026rsquo;s the job of [pdf]LaTeX. Same goes for other engines.\nWhat is xetex/xelatex? xetex/xelatex is one of the TeX/LaTeX engines. Others are pdfTex, LuaTex, etc. Wiki\nxetex/xelatex add fonts and character sets support for TeX/LaTeX file.\n Treat input as Unicode Allow us to use many system fonts in LaTeX file easily  What is latexmk? LaTeXmk 是一个集成化的命令行工具, it must work with one LaTeX engine.\nThe fundamental issue that latexmk solves is that the number of runs of [pdf]latex is highly dynamically dependent on the document and the class file used. latex just need to be run once a time.\nDifferent between CTeX/MiKTeX/TeXlive ? They are all 包含与.tex文件关联的各种编辑、查看工具、常用宏包及文档.\nCTex packages add complete Chinese support based on MiKTeX.\n CTex is only avilable in windows.  ","date":"2022-05-04T17:07:51+08:00","permalink":"https://wangloo.github.io/posts/latex-vim-tutorial/","section":"posts","tags":["LaTeX","vim","Tutorial"],"title":"LaTeX Vim Tutorial"},{"categories":null,"contents":"When reading C standard documents, we usually see phrases like \u0026ldquo;Implementation-defined\u0026rdquo;, \u0026ldquo;Unspecified\u0026rdquo;,.etc.\nSo, what do they really mean?\n术语 我们将这些难以直接理解的词汇称为术语，在ANSI C中，术语可以分为描述不可移植代码(unportable), 坏代码(bad), 可移植的代码(portable)三类.\nunportable code Implementation-defined\n需要由编译器设计者决定采取何种行为，他们可能不同，但都不能说是错误的.\n例如：当整型数右移时，是否需要扩展符号位. 右移代替除法可能导致的灾难.\nunspecified\n在某些正确情况下的做法，标准并未明确规定应该怎样做.\n例如：参数求值的顺序.\nbad code undefined\n在某些不正确情况下的做法，但标准并未规定应该怎样做。意味着你可以采取任何行动，可以什么都不做，也可以发出一条警告信息, 或者终止CPU重启等等. 你甚至可以发射核导弹(只要你安装了能发射核导弹的硬件系统).\n例如：当一个有符号整数溢出时该采取什么行动.\nconstraint\n这是一个必须遵守的限制或要求. 如果你不遵守, 那么你的程序的行为就会变成如上所说的undefined. 这出现了一种很有意思的情况: 分辨某种东西是否是一个constaint是很容易的, 因为每个标准的主题都附有一个constraint小节, 列出了所有的约束条件。\n例如: %操作符的操作数必须为整型. 所以,在非整型数据上使用%操作符肯定会导致undefined.\nportable code strictly conforming\n严格遵守标准的. 符合该条件的程序应当是:\n 只使用已确定的特性 不突破任何由编译器实现(Implementation-defined)的限制. 不使用unspecified和undefined特性  这样规定的目的是最大程序保证代码的可移植性. 但符合该术语的代码并不常见, 例如INT_MAX的值在不同架构的机器上结果可能不同.\ncomforming\n遵循标准的; 一个遵循标准的程序可以依赖一些对于某种编译器特有的不可移植的特性. 这样一个程序对于某个编译器可能是遵循标准的, 但对于另外一个编译器又是不遵循标准的.\n","date":"2022-05-01T16:41:35+08:00","permalink":"https://wangloo.github.io/posts/reading-notes/expert_c_programming/portability_issues/","section":"posts","tags":null,"title":"Portability Issues"},{"categories":null,"contents":"","date":"2022-05-01T16:41:35+08:00","permalink":"https://wangloo.github.io/posts/third-blog/","section":"posts","tags":null,"title":"Third Blog"},{"categories":null,"contents":"As we all know, there are huge number of parameters for GCC. With them, we can make many things possible. Now we talk about -M and related ones. After reading this article, you will know the meaning of there magic parameters. And I will put some little demos follows. Finally, we will see what can they do in really project. Let\u0026rsquo;s go ahead.\n实例规则 以下的分析都是基于这样一个生成目标文件的规则, 应该来说具有一定的通用性。\n1build/obj/main.o: src/main.c 2 $(CC) $(CFLAGS) $(INCLUDES) -c $\u0026lt; -o $@ main.c中的内容：\n1/* File: main.c */ 2#include \u0026lt;stdio.h\u0026gt; // system header file3#include \u0026#34;header.h\u0026#34; // user defined header file4int main() { 5 return 0; 6} -M Output the dependencies of the input source file. Incluing the names of itself and all included files.\n-M(and 下面的-MM)和-o 不能同时使用，因为都隐含-E。 假设我们只想输出依赖文件，我们可以将示例中的规则如此改造：\n1build/obj/main.o: src/main.c 2 $(CC) $(CFLAGS) $(INCLUDES) -c $\u0026lt; -M We will get messy output like following. Notice that the first two words is object filename and a colon.\n1main.o: src/main.c /usr/include/stdc-predef.h /usr/include/stdio.h \\ 2 /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \\ 3 /usr/include/features.h /usr/include/x86_64-linux-gnu/sys/cdefs.h \\ 4 /usr/include/x86_64-linux-gnu/bits/wordsize.h \\ 5 /usr/include/x86_64-linux-gnu/bits/long-double.h \\ 6 /usr/include/x86_64-linux-gnu/gnu/stubs.h \\ 7 /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \\ 8 /usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h \\ 9 /usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h \\ 10 /usr/include/x86_64-linux-gnu/bits/types.h \\ 11 /usr/include/x86_64-linux-gnu/bits/timesize.h \\ 12 /usr/include/x86_64-linux-gnu/bits/typesizes.h \\ 13 /usr/include/x86_64-linux-gnu/bits/time64.h \\ 14 /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \\ 15 /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \\ 16 /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \\ 17 /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \\ 18 /usr/include/x86_64-linux-gnu/bits/types/FILE.h \\ 19 /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \\ 20 /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \\ 21 /usr/include/x86_64-linux-gnu/bits/sys_errlist.h 22 src/header.h -MM Like -M but do NOT output system header files.\n1main.o: src/main.c src/header.h -MF \u0026lt;file\u0026gt; Use with -M or -MM. Specify output dependencies to file instead of STDOUT.\n注意，只要使用追加上-MF，就可以和-o选项并存了，可以写在一条语句中\n-MD -MD is same as -M -MF \u0026lt;file\u0026gt;. But the filename is basd on the object file but replacing .o with .d.\n如果将示例中的代码换成：\n1build/obj/main.o: src/main.c FORCE 2 $(CC) $(CFLAGS) $(INCLUDES) -c $\u0026lt; -o $@ -MD 1$ ll build/obj/ 2 3total 16 4drwxrwxr-x 2 soben soben 4096 3月 23 20:45 ./ 5drwxrwxr-x 3 soben soben 4096 3月 23 20:35 ../ 6-rw-rw-r-- 1 soben soben 1144 3月 23 20:45 main.d 7-rw-rw-r-- 1 soben soben 1368 3月 23 20:45 main.o  Note: -MD and -MMD 因为有-MT，也不隐含 -E.\n -MMD -MMD is same as -MM -MF \u0026lt;file\u0026gt;. Also named on object file but replacing .o with .d.\n-MT \u0026lt;target\u0026gt; MT 是一个单独的选项，不与上面的冲突。作用是改变生成依赖规则的目标格式。在此之前，默认的格式是文件名.o，去除任何前缀目录。\n而使用-MT之后可以自定义规则中目标的格式， 由\u0026lt;target\u0026gt;指定。\n例如，对于前面的选项，依赖规则目前总是main.o，很多使用，我们需要的是其编译规则中目标的形式，包含路径，并不仅仅是文件名本身。这时我们就需要使用-MT，可以将示例中的规则做如下修改:\n1build/obj/main.o: src/main.c FORCE 2 $(CC) $(CFLAGS) $(INCLUDES) -c $\u0026lt; -o $@ -MMD -MT $@ 依赖文件的内容就变为:\n1build/obj/main.o: src/main.c src/header.h  实际上，从我的开发经验来看，大项目中编译规则的目标并不直接是目标文件，总有一个路径前缀，例如：$(objdir)/%.o: $(srcdir)/%c, 这时如果 include 的依赖文件的目标只是一个文件名，其实没什么意义。 所以 -MT 应该是在开发大型项目中很常见的。\n -MQ \u0026lt;target\u0026gt; 与MT类似，而且我没有验证成功官网说出的和 MT 的区别. 所以，这是一个 TODO。\nApplication Here is an important question you may ask me: Why do we struggle to get the dependencies formats? What can they do?\nIf you are familiar with make and Makefile, aha, that\u0026rsquo;s it! With the help of M-related parameters, you can easily handle the problem of tracing header files.\nGive you a little demo about my point.\n1-include *.d 2%.o:%.c 3 $(CC) $(CFLAGS) $(INCLUDES) $\u0026lt; -c -MMD -o $@ Actually, we do two things in order:\n When complieing source files, we generate dependency files xxx.d at the same time. After geting xxx.d, we include them in makefile. As its format is exactly the dependency format required by makefile.  Summary Hope this article can give you a clear understanding of M-related parameters in GCC. We can sometimes find them in large projects\u0026rsquo; makefile. It\u0026rsquo;s very useful to automatic build dependency for header files. So try to use them in your current or next project.\nReference  GNU GCC options GCC -M, -MM, -MMD, -MF, -MT  ","date":"2022-04-26T19:08:22+08:00","permalink":"https://wangloo.github.io/posts/c/gcc_-m_related/","section":"posts","tags":["c","makefile"],"title":"GCC '-M' and Related Parameters"},{"categories":null,"contents":"This is my second blog.\n Wish you have a good life.\n  happy smile   sunset   ","date":"2022-04-26T15:32:11+08:00","permalink":"https://wangloo.github.io/posts/second-blog/second-blog/","section":"posts","tags":null,"title":"Second Blog"},{"categories":null,"contents":"This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog.\n1#include \u0026lt;stdio.h\u0026gt;2 3int main(void) { 4 printf(\u0026#34;hello, hugo\\n\u0026#34;); 5 return 0; 6} ","date":"2022-04-26T15:13:07+08:00","permalink":"https://wangloo.github.io/posts/first-blog/first-blog/","section":"posts","tags":null,"title":"First Blog"},{"categories":null,"contents":"编译Linux 源码 上海交通大学镜像站\n1# get linux source code 2wget http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/ 3# extract 4tar xvf linux-4.12.1.tar.gz 5# enter dir 6cd linux-4.12.1/ 7 8# generate .config 9make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- defconfig 10make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- menuconfig 11# compile  12make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- Image -j16 构建根文件系统 使用 Busybox 构建, 下载源码时可能比较慢, 暂时没有发现国内镜像站\n1# Download busybox source code 2wget https://busybox.net/downloads/busybox-1.35.0.tar.bz2 3 4# menuconfig - generate .config 5make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- menuconfig 6# compile 7make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- -j16 8 9make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- install 10 11# create rootfs 12cd ../ 13qemu-img create -f raw qemu_rootfs.img 128M 14# set ext4 filesystem 15mkfs.ext4 qemu_rootfs.img 16# mount on host 17mkdir mnt-tmp 18sudo mount -o loop qemu_rootfs.img ./mnt-tmp 19# copy file 20sudo cp busybox-1.35.0/_install/* mnt-tmp/ -r 21cd mnt-tmp 22# create other path 23sudo mkdir proc sys dev etc etc/init.d 在etc/init.d/rcS中写入启动脚本\n1#!/bin/sh 2mount -t proc none /proc 3mount -t sysfs none /sys 4/sbin/mdev -s 赋予rcS可执行权限\n1sudo chmod +x rcS 改为mount -a 之后启动脚本会自动挂在/etc/fstab文件中声明的所有分区\nfstab 在 Linux 开机以后自动配置哪些需要自动挂载的分区\n1#device mount-point type options dump fsck order 2proc /proc proc defaults 0 0 3tmpfs /tmp tmpfs defaults 0 0 4sysfs /sys sysfs defaults 0 0 5tmpfs /dev tmpfs defaults 0 0 6debugfs /sys/kernel/debug debugfs defaults 0 0 7tracefs /sys/kernel/tracing tracefs defaults 0 0 添加软件 perf perf已经集成到了Linux 主分支中，源码的位置在tools/perf\n编译命令:\nstrace 下载源码：Releases · strace/strace (github.com)\n编译\u0026amp;\u0026amp;安装:\n1# 确定编译的参数 2./configure \\ 3--host=aarch64-linux \\ 4--prefix=/home/soben/linux-qemu/strace-6.0/_install \\ 5--enable-mpers=no \\ 6CC=aarch64-none-linux-gnu-gcc \\ 7LD=aarch64-none-linux-gnu-ld \\ 8RANLIB=aarch64-none-linux-gnu-ranlib 9 10# 编译为静态链接方式 11make LDFLAGS+=\u0026#39;-static -pthread\u0026#39; -j16 12 13# 拷贝到 _install 目录 14make install 启动 QEMU 运行 Linux ","date":"0001-01-01T00:00:00Z","permalink":"https://wangloo.github.io/posts/os/arm64-linux-qemu/","section":"posts","tags":null,"title":""},{"categories":null,"contents":"名词解释 probe 一个probe是一个位置或者活动, 动态追踪工具可以在probe上绑定一些action. 例如记录栈帧位置, 查看参数等.\nprobe就像是一个可编程的传感器, 你可以为他设定触发的事件或者指令. 当probe 触发时, 可以执行你提前绑定的函数, 了解此时系统的状态\n","date":"0001-01-01T00:00:00Z","permalink":"https://wangloo.github.io/posts/os/trace/","section":"posts","tags":null,"title":""}]