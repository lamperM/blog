[{"categories":["Hugo"],"contents":"写博文时避免不了插入一些图片，总结了几种方式。\n图床 最早在其他平台写博客时，因为 Markdown 格式编辑，不方便内嵌图片（好像听说支持 Base64 编码， 没试过）， 此时想要维护单个 md 文件，最好的方式就是用网络图片， 本地引用必须同时维护图片和文件在同一个目录，而且一些博客平台上传图片太麻烦。\nMarkdown 插入图像的语法本就支持网络图片，这里防一张图片作为演示：\n以前用的 Gitee（码云）搭建图床，后面码云官方禁止这种行为，考虑过换成其他收费的平台， 例如各家云公司的对象存储 OSS。但是仔细想想如果要迁移平台意味着所有的博客都要改动， 未免太麻烦了。\nHugo 使用 Hugo 搭建静态博客页面之后，其实对于远程链接的引用方式的依赖性就消失了。 反正都是用一个 Hugo 工程管理所有笔记，那么也统一管理所有图片也没太大所谓。 以前觉得本地管理很麻烦，需要传图片之类的，但最近用 Latex 写论文发现也还好。 工程放在 Windows 上，传图片直接另存为改下目录就行了，用虚拟机上确实不太方面。 还好 Hugo 对 Windows 的支持还不错。综上，目前就在尝试使用本地的方法管理图片。\nHugo 引用图片有两种方式：\n 建立一个 Page bundle，图片作为 Page source。通过![](sunset.jpg) 即可访问，Hugo 官方描述。 属于各自 blog 的图片放到各自的目录下，这样的好处是看起啦比较清晰。 但是麻烦的地方就在于需要引用图片的博文都需要建立一个 Page bundle， 而且我不喜欢 index.md 这种文件名，难以搜索。 1content/ 2└── posts/ 3 └── post-1/ \u0026lt;-- page bundle 4 ├── index.md 5 └── sunset.jpg \u0026lt;-- page resource  所有博文的图片都放到的/static目录下，统一管理。 /static可能不是必须存在，可以手动创建。此时的图片通过 ![](/sunset) 的方式来访问，多了一条斜杠。 Latex论文里的图片就是这样管理的，以前担心混乱， 实际上因为图片不多，命名规范也还好。  Shortcode Md支持的原生图片引用方式调整大小、对齐等操作比较麻烦， Hugo在这方面引入了默认的Shortcode: figure 帮助实现引用本地图片。\n1{{\u0026lt; figure src=\u0026#34;/test.jpg\u0026#34; width=\u0026#34;100%\u0026#34; \u0026gt;}} 另外，我自己根据网上的资料写了引用外部图片的shortcode: insertFigure。\n","date":"2024-01-03T13:39:42+08:00","permalink":"https://wangloo.github.io/posts/hugo/hugo_image/","section":"posts","tags":["Hugo"],"title":"Hugo 引用图片"},{"categories":["C"],"contents":"const 修饰成员函数 C++允许将成员函数添加const修饰符，代表此成员函数不会对成员变量进行修改， 否则会发生编译错误。在下面的示例中，set函数用const修饰就会出错， 而get函数用const修饰就能清楚的告诉别人这个函数不会修改类的成员。\n对于一个声明为const的类实例，C++规定它只能调用const修饰的成员函数， 也就是说明这个类的成员是不允许被修改的。\n1class A { 2 int num; 3public: 4 void set_num(int x) { num = x; } 5 int get_num(void) const { return num; } 6}; 7 8const A a; 9a.set_num(10); // Compile error 10a.get_num(); // Success 说起a为什么不允许调用set函数，我这里尝试从C的角度去进行解释， 毕竟C和C++本是同根生。C++定义的成员函数会有一个隐形的参数叫this指针， this总是指向这个类的示例，所以实际上我理解调用成员函数的时候会将成员地址作为参数也传递给成员函数，毕竟这样才能用this指针嘛。然后就说为什么不能调用set函数呢？ 我猜测对于一般的成员函数，规定接受的隐形参数this的类型是 A*， 而const修饰的成员函数接受的this类型为 const A*， 这样做就能限制用const修饰的类实例在将其自身地址传递给普通成员函数的时候出错， 即const A * 不能传递给参数类型为 A* 的函数哦，导致编译错误。\n1// 猜测C实现C++类 2struct A { 3 int num; 4 void (*set_num)(struct A *a, int x){...} 5 void (*get_num)(const struct A *a) {...} 6}; 7 8const struct A a; 9a.set_num(\u0026amp;a, 10); // Compile error 10a.get_num(\u0026amp;a); // Ok 查看编译后的结果能够证实上述的猜想，确实需要将类变量的地址传递给成员函数作为隐式参数。https://godbolt.org/z/dT9rnsvKz\n ","date":"2023-12-22T18:51:49+08:00","permalink":"https://wangloo.github.io/posts/c/cpp/","section":"posts","tags":["C"],"title":"C++ 特性的底层原理"},{"categories":["Thinking"],"contents":"在我刚上初中的时候，我姐毕业在青岛差不多稳定了下来，于是我放假便经常去青岛找她玩。 不久，我姐姐与我姐夫相识，姐夫对我不错，除了请我吃喝玩乐以外， 我现在想起仍然感慨万分的是：他帮助我建立厚脸皮、外向的性格。\n其实在此之前我是一个非常内向的人，也是大家口中的乖孩子， 跟圆滑、变通这些词毫无关系，而每当我在青岛的时候，我姐夫便以身作则， 给我展示一个小老板是如何圆滑处事，偶尔也让我开口去和外人交流。 我始终觉得就是这一段段时间，一件件事的影响和磨练，使我现在变得不那么自卑和内向。 面向陌生人也能大大方方的交流，起码不使人尴尬吧。\n这个点我的父母，甚至我的姐姐应该很难观察到，他们估计觉得姐夫就是带我玩而已， 而我自己将永远铭记在心。\n","date":"2023-12-17T17:19:44+08:00","permalink":"https://wangloo.github.io/posts/thinking/growth/","section":"posts","tags":["Thinking"],"title":"Thinking: 感谢姐夫"},{"categories":["DevTools"],"contents":"Task.json Vscode中，可以为编译、打包等过程创建自动化任务，避免每次手动敲一些命令。 在我看来，Vscode Task就像是一个强大的、与Vscode联动的Shell脚本。\n创建一个Task 创建一个Task很简答，Terminal-Configure Tasks， 然后根据引导就可以创建一个默认的task，对他进行配置的文件是workspace/.vscode/task.json。\n展示一下我刚刚创建的一个编译并执行单元测试的任务，关键的参数是label也就是任务的名字， type除了shell不知道还有啥，command就是该任务会执行的shell命令。 更多的参数下面会介绍。\n1{ 2 // See https://go.microsoft.com/fwlink/?LinkId=733558 3 // for the documentation about the tasks.json format 4 \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, 5 \u0026#34;tasks\u0026#34;: [ 6 { 7 \u0026#34;label\u0026#34;: \u0026#34;build-ut\u0026#34;, 8 \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, 9 \u0026#34;command\u0026#34;: \u0026#34;bash tools/vscode_build_ut.sh\u0026#34;, 10 \u0026#34;presentation\u0026#34;: { 11 \u0026#34;echo\u0026#34;: true, 12 \u0026#34;reveal\u0026#34;: \u0026#34;always\u0026#34;, 13 \u0026#34;focus\u0026#34;: true, 14 \u0026#34;panel\u0026#34;: \u0026#34;shared\u0026#34;, 15 \u0026#34;showReuseMessage\u0026#34;: true, 16 \u0026#34;clear\u0026#34;: false 17 }, 18 \u0026#34;problemMatcher\u0026#34;: [], 19 } 20 ] 21} 支持的参数 支持的参数很多，我主要介绍几个，Vscode的官方文档说的非常通俗易懂，修改参数时最好参考一下。\n label: 此任务的名字 type：类型  shell：作为shell命令执行 process：创建一个新进程执行   command：任务实际执行的命令 group：任务的分组 presentation：定义如何处理Task的输出  reveal：终端是否显示 echo：任务输出是否到终端中 focus：任务执行时是否聚焦到终端 showReuseMessage：是否显示最后的提示信息 clear：任务运行前是否清理终端输出   options：定义当前目录和一些环境变量 runOptions：定义任务何时运行以及如何运行 problemMatcher: 自定义错误匹配机制，这个应该很强大，我这里单纯是为了运行时不需要再选一次所以用了一个默认值。具体怎么用可以参考: https://code.visualstudio.com/docs/editor/tasks#_defining-a-problem-matcher  Launch.json 早就看Vscode左边的\u0026quot;Run and Debug\u0026quot;栏不爽了，呆在那也没啥用。 其实在实习的时候看过他用Vscode调试Qemu guest， 抽时间把这个给研究了一下，感觉比直接执行gdb方便一些。\nLaunch.json就是定义一些运行与Debug的动作，结合Vscode的界面， 比Gdb Tui还是好看了一些。这里列出我当前项目所使用的配置项。\n 注意：如果同时在项目根目录有.gitinit文件，可能会导致错误， 详细: QEMU: Terminated via GDBstub error\n 1{ 2 // Use IntelliSense to learn about possible attributes. 3 // Hover to view descriptions of existing attributes. 4 // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 5 \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, 6 \u0026#34;configurations\u0026#34;: [ 7 { 8 \u0026#34;name\u0026#34;: \u0026#34;qemu-kernel\u0026#34;, 9 \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, 10 \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, 11 \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;/usr/bin/gdb-multiarch\u0026#34;, 12 \u0026#34;miDebuggerServerAddress\u0026#34;: \u0026#34;localhost:1234\u0026#34;, 13 \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/your/exec/file\u0026#34;, 14 \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, 15 \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, 16 \u0026#34;stopAtConnect\u0026#34;: true, 17 } 18 19 ] 20} ","date":"2023-12-17T15:25:12+08:00","permalink":"https://wangloo.github.io/posts/tools/vscode/task_launch/","section":"posts","tags":["tools"],"title":"Vscode task.json \u0026 launch.json"},{"categories":["Binary"],"contents":"前言 栈回溯是调试代码常用的功能之一，Gdb 中对应的命令是bt,info frame等。 这篇文件将介绍利用 Dwarf 生成的调试信息实现栈回溯的方法。\n原理 Dwarf v2 开始提供一种叫做 Call Frame Information（简称 CFI）的信息， 它存储在.debug_frame中，调试器可以通过解析这个 Section 完成栈回溯。 .debug_frame里的内容可以看做是一张二维表格，一列是 pc， 另一列是对于此 Pc 如何查找上一个 Frame。\nDemo 例如，对于以下的 C 代码和对应的汇编（通过object -S生成)， 汇编代码有一点长，但没关系我们不需要关注每一条汇编指令。 这段代码共有两个函数，main()和fibonacci()， 由 main 函数调用 fibonacci 来计算第 10 个 bibonacci 数。 目前暂时不需要看汇编。\n选择 fibonacci()作为例子的原因是模拟一个非叶子函数， 因为 Arm64 下对叶子函数可能不会生成正确的 CFI 信息， 因为这种情况不常见，所以我们先讨论普通的情况。 另外，我知道这个计算 fibonacci 数的算法不是最优的， 但是我们毕竟不是算法优化的主题，所以能够说明问题即可。\n1int fiboncci(int n) 2{ 3 if (n \u0026lt;= 2) 4 return 1; 5 else 6 return fiboncci(n-1) + fiboncci(n-2); 7} 8 9int main(void) 10{ 11 int result; 12 13 result = fiboncci(10); 14 return 0; 15} 1int fiboncci(int n) 2{ 3 400594: a9bd7bfd stp x29, x30, [sp, #-48]! 4 400598: 910003fd mov x29, sp 5 40059c: f9000bf3 str x19, [sp, #16] 6 4005a0: b9002fe0 str w0, [sp, #44] 7 if (n \u0026lt;= 2) 8 4005a4: b9402fe0 ldr w0, [sp, #44] 9 4005a8: 7100081f cmp w0, #0x2 10 4005ac: 5400006c b.gt 4005b8 \u0026lt;fiboncci+0x24\u0026gt; 11 return 1; 12 4005b0: 52800020 mov w0, #0x1 // #1 13 4005b4: 14000009 b 4005d8 \u0026lt;fiboncci+0x44\u0026gt; 14 else 15 return fiboncci(n-1) + fiboncci(n-2); 16 4005b8: b9402fe0 ldr w0, [sp, #44] 17 4005bc: 51000400 sub w0, w0, #0x1 18 4005c0: 97fffff5 bl 400594 \u0026lt;fiboncci\u0026gt; 19 4005c4: 2a0003f3 mov w19, w0 20 4005c8: b9402fe0 ldr w0, [sp, #44] 21 4005cc: 51000800 sub w0, w0, #0x2 22 4005d0: 97fffff1 bl 400594 \u0026lt;fiboncci\u0026gt; 23 4005d4: 0b000260 add w0, w19, w0 24} 25 4005d8: f9400bf3 ldr x19, [sp, #16] 26 4005dc: a8c37bfd ldp x29, x30, [sp], #48 27 4005e0: d65f03c0 ret 28 2900000000004005e4 \u0026lt;main\u0026gt;: 30 31int main(void) 32{ 33 4005e4: a9be7bfd stp x29, x30, [sp, #-32]! 34 4005e8: 910003fd mov x29, sp 35 int result; 36 37 result = fiboncci(10); 38 4005ec: 52800140 mov w0, #0xa // #10 39 4005f0: 97ffffe9 bl 400594 \u0026lt;fiboncci\u0026gt; 40 4005f4: b9001fe0 str w0, [sp, #28] 41 return 0; 42 4005f8: 52800000 mov w0, #0x0 // #0 43} 44 4005fc: a8c27bfd ldp x29, x30, [sp], #32 45 400600: d65f03c0 ret 46 400604: d503201f nop 47 400608: d503201f nop 48 40060c: d503201f nop 因为在编译时添加了-g选项，所以 Gcc 默认会生成.debug_frame， 让我们来看看里面的内容是什么。\n1aarch64-none-linux-gnu-objdump --dwarf=frames-interp frame 100000088 0000000000000020 0000008c FDE cie=00000000 pc=0000000000400594..00000000004005e4 2 LOC CFA x19 x29 ra 30000000000400594 sp+0 u u u 40000000000400598 sp+48 u c-48 c-40 500000000004005a0 sp+48 c-32 c-48 c-40 600000000004005e0 sp+0 u u u 7 8000000ac 0000000000000020 000000b0 FDE cie=00000000 pc=00000000004005e4..0000000000400604 9 LOC CFA x29 ra 1000000000004005e4 sp+0 u u 1100000000004005e8 sp+32 c-32 c-24 120000000000400600 sp+0 u u 这是经过解释之后的.debug_frame，在实际存储的时候可能通过压缩。 解释之后就明显展示出二维表格的样貌。上述代码里共有两段表， 第一段对应我们在fibonacci()中如何查找上一个 Frame， 第二段则是main()函数中的计算规则。\n暂时到这里其实就 Ok 了，你只需要知道它起码看起来像是一个二维表格的结构， 我们下面再说它到底是怎么帮助实现栈回溯的。\n解剖 .debug_frmae CIE \u0026amp; FDE 上面不是说表格中存的是栈回溯的规则吗，这张大表可以按照函数的界限来划分， FDE 就是对应某个函数的计算规则。一些函数共同的部分提取成一个 CIE。\n栈回溯的过程 还是以上面的代码为例，假设我们位于 Fibonacci()中的4005a4地址上， 此时我们要进行栈回溯，找到 main()中的调用点。\n首先，在第一个 FDE 里找到当前地址4005a4的计算规则， 因为连续的一段地址可能计算规则不变，可以将他们存成一条，节约空间。\n100000088 0000000000000020 0000008c FDE cie=00000000 pc=0000000000400594..00000000004005e4 2 LOC CFA x19 x29 ra 30000000000400594 sp+0 u u u 40000000000400598 sp+48 u c-48 c-40 500000000004005a0 sp+48 c-32 c-48 c-40 600000000004005e0 sp+0 u u u 第一列 LOC 是每个规则相同的连续地址块的起始地址，由此得到4005a4需要参考第三行规则。\n再看到第二列，CFA 的含义是 caller 的 sp， 第三列ra 的含义是返回地址(Returen address)， 表格中的值 u 代表不变，c 代表 CFA。\n所以说，由表格中的数据可知，caller'sp=sp+48，而返回地址就存储在cfa-40的地址上， 这是一个栈的地址，由于函数调用不会破坏之前栈的内容，所以可以放心取出 ra，也就是返回地址。 这就找到了 main 函数中的调用点，如果 main 之上还有 caller 的话，可以继续查 main 的 FDE 来寻找。\n原理 其实，这种方法就是利用了每次进入函数时时会在栈上保存返回地址 x30， 基于 Fp 的栈回溯方法也是这样做，Fp 是通过记录每个栈的栈底， 而每次保存 x30 的位置相对于栈底都是固定的，所以知道栈底也就能取出 x30。\n.debug_frame可以看作将每次函数调用的栈底存在本地成为一张表， 这就省了一个通用寄存器。\n关于 Caller-saved Regs 注意  上面说到，用.debug_frame实现栈回溯时，起点不能是叶子函数。 叶子函数不会调用任何函数，所以 Arm64 会优化而不保存 Lr 在栈上（反正你也不调用其他函数，x30 不会被破坏）。 我们的方法就不奏效，可以验证叶子函数的 FDE 是空的。  ","date":"2023-12-16T15:51:49+08:00","permalink":"https://wangloo.github.io/posts/binary/dwarf/frame/","section":"posts","tags":["Dwarf","Binary"],"title":"Dwarf: Stack Unwinding"},{"categories":["Binary"],"contents":"1# 输出 section header table 2readelf -S xxx.elf 3 4# 输出 program header table 5readelf -l xxx.elf 6 7# 输出 ELF header 8readelf -h xxx.elf 9 10# 输出 elf header，section header table，program header table(常用） 11readelf -e xxx.elf 12 13# 查看符号 14nm xxx.elf 15readelf -s xxx.elf # detailed 16 17# 打印某个section的内容 18readelf -p .strtab xxx.elf ","date":"2023-12-14T13:21:27+08:00","permalink":"https://wangloo.github.io/posts/binary/gnu_binutils/","section":"posts","tags":["Binary"],"title":"Weapon: GNU Binutils"},{"categories":["C"],"contents":"背景 今天在写 C 代码时，遇到一个问题，我忘记 include 头文件而调用某个函数， 一般情况下在编译时会报警告 ⚠，然后也会链接成功，所以我这次就没管它因为只是暂时测试一下。 然而令我费解的是函数的执行结果异常，检查汇编后发现，我声明的函数返回 u64 类型， 而编译后的代码在返回前裁切成了 32 位，就是这里导致的错误！\n这与我之前的理解不同，我以为要么就链接找不到符号，要不就成功链接， 为什么会有这种返回类型识别错误呢？\n思考 我忽然想起，会不会是因为编译器将返回值识别为了默认的 int 类型， 进而，我的猜想是：\n 链接时能用符号名找到符号的地址，所以能成功调用 但因为没有参数和返回类型的说明（没有 include），所以导致类型出错  简单验证之后，确实我的猜想是正确的，我调用时多传入一个参数， 还是能够成功编译，汇编只是把参数寄存器赋值，内部用不用得到无法判定。 返回类型则统一认定为默认的int类型。\n由此，我又产生了一个想法，既然C语言只使用符号名作为匹配的标准， 那么必然不支持同名函数（参数、返回类型不同）。然而C++明确是支持的， 那么C与C++的符号管理有什么不同吗？\n进一步验证 我写了内容相同的C和C++两个文件来尝试解答问题：\n1// Same code in demo.c/demo.cpp 2void func(int a, int b) 3{ 4 func(b, a); 5} 对他们进行编译，查看大小仅相差8字节，猜测是符号的管理有所不同。\n1$ ls -al 2total 8 3drwxr-xr-x 1 loo loo 512 Dec 14 14:09 . 4drwxr-xr-x 1 loo loo 512 Dec 14 12:03 .. 5-rw-r--r-- 1 loo loo 42 Dec 14 14:09 demo.c 6-rw-r--r-- 1 loo loo 1480 Dec 14 12:04 demo.c.o 7-rw-r--r-- 1 loo loo 42 Dec 14 12:04 demo.cpp 8-rw-r--r-- 1 loo loo 1488 Dec 14 12:04 demo.cpp.o 进一步查看section的差别，忽略地址的差异，其实差异就在.shstrtab的大小， C++编译处的目标文件多了几个字节，而.shstrtab我们给的样例中也就是存符号func。\n1$ diff \u0026lt;(readelf -S demo.c.o) \u0026lt;(readelf -S demo.cpp.o) 21c1 3\u0026lt; There are 13 section headers, starting at offset 0x288: 4--- 5\u0026gt; There are 13 section headers, starting at offset 0x290: 610c10 7\u0026lt; [ 2] .rela.text RELA 0000000000000000 000001e8 8--- 9\u0026gt; [ 2] .rela.text RELA 0000000000000000 000001f0 1024c24 11\u0026lt; [ 9] .rela.eh_frame RELA 0000000000000000 00000200 12--- 13\u0026gt; [ 9] .rela.eh_frame RELA 0000000000000000 00000208 1429,30c29,30 15\u0026lt; 000000000000000d 0000000000000000 0 0 1 16\u0026lt; [12] .shstrtab STRTAB 0000000000000000 00000218 17--- 18\u0026gt; 0000000000000014 0000000000000000 0 0 1 19\u0026gt; [12] .shstrtab STRTAB 0000000000000000 00000220 继续查看.shstrtab的内容，就能得到最终的结果，确实C语言只存储符号名， 而C++则既有符号名，也有参数和返回值类型。\n1$ readelf -p .strtab demo.c.o 2 3String dump of section \u0026#39;.strtab\u0026#39;: 4 [ 1] demo.c 5 [ 8] func 6 7$ readelf -p .strtab demo.cpp.o 8 9String dump of section \u0026#39;.strtab\u0026#39;: 10 [ 1] demo.cpp 11 [ a] _Z4funcii  通过nm命令也一样能够查看\n1$ nm demo.cpp.o 20000000000000000 T _Z4funcii  总结 确实C语言只存储符号名，而C++则既有符号名，也有参数和返回值类型。 这是C++能够支持重载的本质。 有时我们在写C++时，如果找不到函数会报一个乱码的函数名， 其实也就是这种经过压缩存储的符号。\n","date":"2023-12-14T12:21:27+08:00","permalink":"https://wangloo.github.io/posts/c/linker_symbol/","section":"posts","tags":["C"],"title":"C/C++ 符号管理的区别"},{"categories":["Thinking"],"contents":"起因：今天与一位同学一起尝试去配置Linux静态IP，这中间有不少坎坷，想简单把思考的过程写下来， 复盘一下是不是应该有可以更快的定位到问题并解决的方案。\n提出问题 Cl同学想要达到启动Linux后自动设置某个静态Ip的效果， 在我的理解里这并不是一件很复杂的事。\n他给我的想法是在Kernel Command Line参数中指定Ip， 我之前没有看到过这种方式配网，但是网上搜了一下确实有这样的例子。 所以他目前已经完成的是:\n Linux是通过Uboot起的，要增加Linux Command Line， 可能是在Uboot的bootargs中添加。 但是他在修改完bootargs并重启的时候，发现变量没有成功赋值， 即使已经成功saveenv。所以就邀请我和他一起讨论。\n 动手实践 了解到问题之后，我先说出了我的想法：\n 配置静态Ip这个事其实我第一时间想到的是以前修改/etc/network/interfaces文件的方式 但是我愿意陪他先看下为什么命令行参数没有配置上去  这是两条路，因为他的系统里没有真正的文件系统，而是initrd， 所以我提出的方案需要去解包inird的压缩文件，还是尽量先去研究为什么命令行参数没有配置上去。\n为什么CMDLINE没有配置上去呢? 首先它说bootargs没有保存成功，这个我也不知道为啥， 可以先不管，即便在每次启动之前在Uboot里设置了Bootargs， 他说在启动之后Kernel的打印也没有输出配置的项目。\nUboot中Bootargs设置的值是和Kernel Command Line配套吗？ 这个我反正是不太确定。\n好，那能不能通过别的方式来设置CmdLine呢？ 我们搜索找到了两种方式：\n Dts中 Menuconfig中修改  没有尝试Menuconfig是因为他说“目前Menuconfig配置的CmdLine为空， 但是实际Kernel启动后又是有值输出的，那么说明肯定是其他的地方有添加。” 对于这句话我也表示认同，Menuconfig里给的说明是：“默认配置”， 所以即便添加了也无法保证会不会被其他的给冲刷掉。所以，一个根本问题就是： CmdLine配置的顺序，或者说优先级是什么？\n先去Dts里改改试试吧，找到了一个chosen结点有关于bootargs的配置， 不管怎么样改了一下，发现并没有生效，和最终Kernel输出的对不上。\n所以，看起来修改CmdLine这条路要失败了，只能去修改initrd试试。\n修改Initrd达到目的 initrd是打包好的，用的是cpio+lz4的方式。要修改首先要把他解开， 解开到还好说，网上能搜得到命令。 但是重新压缩回去问题很多，前期我就想到了我在华为实习时期遇到的类似的问题， 压缩的算法不对、打包的版本差异都会导致Kernel无法解析重新打包的initrd而panic。\n实际也遇到了这个问题，但是这有个小插曲：即便是换回原来的initrd也还是panic。 最终破案是因为需要make clean之后重新make，猜测可能是用了什么中间文件。 不得不感慨Linux Kernel的构建还是相当复杂的。\n问题来了：修改/etc/network/interfaces并没有改变静态Ip， 这就使我产生了疑惑，想着可以先在系统启动之后修改试试嘛， 执行ip down和ipup发现确实没有成功修改，这不禁让我想问为什么？\n此时，我们突然想到一个问题，既然shell命令能成功修改Ip， 那么就在启动时增加一个脚本去执行设置Ip的行动，不就行了吗？\n确实是可以的，所以暂时先不管为什么interfaces不生效。 那就修改有关于/etc/init.d和/etc/inittab相关的知识了， 这一部分我就没参与了，网上的资料的非常全，最终是成功达到目的。\n感慨 虽然成功达到了目的，但是消耗了4个小时左右的时间，我觉得这件事并不应该这么复杂。 主要原因是Linux可以配置网络的方式太多了，以至于像我们这种不是非常熟悉的人一时间不知道如何下手。\n另外，其实这中间还有一些问题没有去解决，可能以后有时间再搞一个完整的qemu-liunx环境去测试一下吧💭。\n","date":"2023-12-08T17:19:44+08:00","permalink":"https://wangloo.github.io/posts/thinking/cfg_linux_ip/","section":"posts","tags":["Thinking"],"title":"Thinking: Config Linux Network"},{"categories":["C"],"contents":"在设计一个消息传递类似的子系统时，消息经常需要各种参数， 通常消息的个数和类型是根据消息自身的类型决定的。\n1void 2handle_open(..., int flags, int mode); 3void 4handle_read(..., size_t len, int offset); 5// ... 有的消息/命令参数比较多，不想写这么长的参数那就把这些参数封装到struct里\n1struct arg_open { 2 int flag; 3 int mode; 4}; 5struct arg_read { 6 size_t len; 7 int offset; 8}; 9 10// 这里用结构体还是结构体指针都可以，不是重点! 11void 12handle_open(..., struct arg_open *arg); 13void 14handle_read(..., struct arg_read *arg); 这种方法有什么缺点呢?\n 不具有通用性；无法用函数指针来实现进一步抽象，即跳表。 \u0026hellip;（暂时没想到）  所以说，一个更好的抽象方式来了，将所有的参数利用union放到一个结构体中。\n1struct proto_open { 2 int flag; 3 int mode; 4}; 5struct proto_read { 6 size_t len; 7 int offset; 8}; 9 10// GOOD DESIGN 11struct proto { 12 // ... 可能有公共的参数, 例如ID 13 union { 14 struct proto_open open; 15 struct proto_read read; 16 // ... 17 }; 18}; 19 20// 因为每个类型的消息/命令都有自己的处理函数 21// 所以各个函数知道自己应该从那个union成员里取 22void 23handle_open(..., struct proto *proto) 24{ 25 int flag, mode; 26 flag = proto-\u0026gt;open.flags; 27 mode = proto-\u0026gt;open.mode; 28} 29void 30handle_read(..., struct proto *proto) {...} 这样做的最大好处就是可以用跳表来设计了，减少了代码量，增加了易读性！！\n","date":"2023-11-26T16:21:27+08:00","permalink":"https://wangloo.github.io/posts/c/good_design_proto/","section":"posts","tags":["C"],"title":"Good Design: 抽象消息参数"},{"categories":["C"],"contents":"字节序与比特序 字节序又称大小段，网络中传输的是大端，在CPU上处理的一般是小端。\n字节序与比特序转换 字节序转换 比特序转换 两种方法，一种直接法，另外有一种优化的技巧。\n（1）\n1// Bit reverse 2unsigned char 3bit_reverse(unsigned char x) 4{ 5 unsigned char newx = 0; 6 for (int i = 0; i \u0026lt; 8; i++) { 7 newx |= (((x \u0026gt;\u0026gt; i) \u0026amp; 1) \u0026lt;\u0026lt; (7-i)); 8 } 9 return newx; 10} (2) https://mp.weixin.qq.com/s/KNUH_RmIhUHhuSZLSmN4LQ\n1// Bit reverse(faster) 2// 碟式交换法 3unsigned char 4bit_reverse_faster(unsigned char x) 5{ 6 x = (x\u0026lt;\u0026lt;4) | (x\u0026gt;\u0026gt;4); // [ 5678 1234 ] 7 x = ((x\u0026lt;\u0026lt;2)\u0026amp;0xcc) | ((x\u0026gt;\u0026gt;2)\u0026amp;0x33); // [ 78 56 34 12 ] 8 x = ((x\u0026lt;\u0026lt;1)\u0026amp;0xaa) | ((x\u0026gt;\u0026gt;1)\u0026amp;0x55); // [ 8 7 6 5 4 3 2 1 ] 9 return x; 10} 测试工具函数:\n1int 2to_binary_str(unsigned long val, char *bin_str, int *len) 3{ 4 char *p, *q; 5 int cnt = 0; 6 7 while (val) { 8 char tmp = val \u0026amp; 1; 9 bin_str[cnt++] = tmp+\u0026#39;0\u0026#39;; 10 val = val \u0026gt;\u0026gt; 1; 11 } 12 13 p = bin_str, q = bin_str+cnt-1; 14 while (p \u0026lt; q) { 15 char tmp = *p; 16 *p = *q; 17 *q = tmp; 18 p++, q--; 19 } 20 21 bin_str[cnt] = 0; 22 *len = cnt; 23 return 0; 24} 25 26int main(void) 27{ 28 char bin[65]; 29 int len; 30 unsigned char x = 0b11110000; 31 unsigned char y = 0b10101010; 32 to_binary_str(bit_reverse(x), bin, \u0026amp;len); 33 printf(\u0026#34;bin: %s\\n\u0026#34;, bin); 34 to_binary_str(bit_reverse(y), bin, \u0026amp;len); 35 printf(\u0026#34;bin: %s\\n\u0026#34;, bin); 36 37 assert(bit_reverse(x) == bit_reverse_faster(x)); 38 assert(bit_reverse(y) == bit_reverse_faster(y)); 39 40 return 0; 41} ","date":"2023-11-25T16:21:27+08:00","permalink":"https://wangloo.github.io/posts/c/byte_bit_order/","section":"posts","tags":["C"],"title":"Byte/Bit Order"},{"categories":["Binary"],"contents":"分析Elf文件 映射 Segments 对栈进行预处理  1int main(int argc, char **argv, char **envp) {...} 见到一个main函数的定义，你是否考虑过:\n main函数使用这些参数的作用分别是什么? Elf运行前，他们是如何被正确放置的? 我们又如何正确的访问?   内核中的Elf加载器还需要将辅助向量和其他信息(argc,argv,envp)一起放在栈上。 初始化后，进程的堆栈如下所示(64位架构下):\n1position content size (bytes) + comment 2 ------------------------------------------------------------------------ 3 [ free used for process ] 4 stack pointer -\u0026gt; [ argc = number of args ] 8 5 [ argv[0] (pointer) ] 8 (program name) 6 [ argv[1] (pointer) ] 8 7 [ argv[..] (pointer) ] 8 * x 8 [ argv[n - 1] (pointer) ] 8 9 [ argv[n] (pointer) ] 8 (= NULL) 10 11 [ envp[0] (pointer) ] 8 12 [ envp[1] (pointer) ] 8 13 [ envp[..] (pointer) ] 8 14 [ envp[term] (pointer) ] 8 (= NULL) 15 16 [ auxv[0] (Elf64_auxv_t) ] 16 17 [ auxv[1] (Elf64_auxv_t) ] 16 18 [ auxv[..] (Elf64_auxv_t) ] 16 19 [ auxv[term] (Elf64_auxv_t) ] 16 (= AT_NULL vector) 20 21 [ padding ] 0 - 16 22 23 [ argument ASCIIZ strings ] \u0026gt;= 0 24 [ environment ASCIIZ str. ] \u0026gt;= 0 25 26 (0xbffffffc) [ end marker ] 8 (= NULL) 27 28 (0xc0000000) \u0026lt; bottom of stack \u0026gt; 0 (virtual) 29 ------------------------------------------------------------------------ 在这之上，我们最常用的是argc和argv，所以还是需要介绍一下envp和auxv。\nEnvironment 环境变量的结构和argv相同，都是一些字符串指针的方式去访问。 只不过没有用于表示数量的\u0026quot;envc\u0026quot;，而是以NULL表示结尾。\nAuxiliary Vectors Auxiliary Vectors 简称Auxv, OS内核在加载Elf时, 可以将一些键值对类型的数值传递给用户态程序， 即进程启动时内核向用户态传递信息的一种方式。\nAuxv的存储结构不是argv和envp那样的间接形式，而是顺序存一些Elf64_auxv_t结构体，在Linux上，结构体的定义在/usr/include/elf.h中。\n1typedef struct 2{ 3\tuint64_t a_type; /* Entry type */ 4\tuint64_t a_val; 5} Elf64_auxv_t; 可以看到就是一个类型和数值，直接就能存下，不支持字符串的形式。\n我们可以在Linux上测试Auxv，在启动一个用户程序之前加上LD_SHOW_AUXV=1, 可以打印出所有的Auxv。\n1~ $ LD_SHOW_AUXV=1 /bin/ls 2AT_SYSINFO_EHDR: 0x7ffc3b3de000 3AT_HWCAP: 1f8bfbff 4AT_PAGESZ: 4096 5AT_CLKTCK: 100 6AT_PHDR: 0x55a318711040 7AT_PHENT: 56 8AT_PHNUM: 13 9AT_BASE: 0x7f0f5ac91000 10AT_FLAGS: 0x0 11AT_ENTRY: 0x55a3187177d0 12AT_UID: 1000 13AT_EUID: 1000 14AT_GID: 1000 15AT_EGID: 1000 16AT_SECURE: 0 17AT_RANDOM: 0x7ffc3b272ab9 18AT_HWCAP2: 0x2 19AT_EXECFN: /bin/ls 20AT_PLATFORM: x86_64 一般来说，普通的用户程序不需要获取内核的信息，但对于一些位于用户态和内核态之间的、 交互非常紧密的用户态程序而言则比较有用。比如说解释器、init进程、微内核OS中的root-service等等。\n测试你的Elf Loader 在Elf中输出这些辅助信息，看是否能顺利读到。这里分别给出（1）只打印Auxv（2）打印所有\n1#include \u0026lt;stdio.h\u0026gt;2#include \u0026lt;elf.h\u0026gt;3 4main(int argc, char* argv[], char* envp[]) 5{ 6 Elf32_auxv_t *auxv; 7 while (*envp++ != NULL); /* from stack diagram above: *envp = NULL marks end of envp */ 8 9 /* auxv-\u0026gt;a_type = AT_NULL marks the end of auxv */ 10 for (auxv = (Elf32_auxv_t *)envp; auxv-\u0026gt;a_type != AT_NULL; auxv++) { 11 if (auxv-\u0026gt;a_type == AT_SYSINFO) 12 printf(\u0026#34;AT_SYSINFO is: 0x%x\\n\u0026#34;, auxv-\u0026gt;a_un.a_val); 13 } 14} 1int main(int argc, char *argv[], char *envp[]) 2{ 3 int i; 4 5 // Print all arguements 6 printf(\u0026#34;argc: %d\\n\u0026#34;, argc); 7 for (i = 0; i \u0026lt; argc; i++) { 8 printf(\u0026#34;argv[%d]: %s\\n\u0026#34;, i, argv[i]); 9 } 10 11 // Print all enviroment variables 12 for (i = 0; envp[i]; i++) { 13 printf(\u0026#34;env[%d]: %s\\n\u0026#34;, i, envp[i]); 14 } 15 16 // Print all auxv 17 Elf64_auxv_t *auxv = (Elf64_auxv_t *)(envp+i+1); 18 for (; auxv-\u0026gt;a_type != AT_NULL; auxv++) { 19 if (auxv-\u0026gt;a_type == AT_PAGESZ) { 20 printf(\u0026#34;AT_PAGESZ: 0x%lx\\n\u0026#34;, auxv-\u0026gt;a_un.a_val); 21 } 22 } 23} 设置User Context Reference  About ELF Auxiliary Vectors  ","date":"2023-11-24T16:21:27+08:00","permalink":"https://wangloo.github.io/posts/binary/elf_load/","section":"posts","tags":["Binary"],"title":"Design a Elf Loader"},{"categories":["DevTools"],"contents":"Vim插件YouCompleteMe国内安装  Update 2023/11/23: vim下现在我不用YCM了，换成Coc.nvim来进行代码补全。 不过在我看来其实没有特别明显的优势，所以YCM的配置注意事项还是留在这吧。\n YCM 插件对 python, vim 的版本均有要求。\n下载 可以使用 vim-plug 等工具下载, 也可以下载源码然后拷贝到.vim目录下\n编译 编译用到 python3, 这里是问题最多的一步\n1# 编译并添加对C的提示支持 2python3 install.py --clangd-completer --verbose 3 4Searching Python 3.8 libraries... 5... 6Downloading Clangd from https://github.com/ycm-core/llvm/releases/download/13.0.0/clangd-13.0.0-x86_64-unknown-linux-gnu.tar.bz2... 使用--clangd-completer参数时, 脚本会去下载 clangd-14.0.0-x86_64-unknown-linux-gnu.tar.bz2 文件, 比较慢. 也可以提前根据提示的网站自己手动下载压缩包.\n下载完成后, 放到本地目录下:\n1:~/.vim/plugged/YouCompleteMe/third_party/ycmd/third_party/clangd/cache$ ls 2clangd-14.0.0-x86_64-unknown-linux-gnu.tar.bz2 还需对脚本YouCompleteMe/third_party/ycmd/build.py进行修改, 防止重新下载.\n1def DownloadClangd( printer ): 2 ... 3 MakeCleanDirectory( CLANGD_OUTPUT_DIR ) 4 5 if not p.exists( CLANGD_CACHE_DIR ): 6 os.makedirs( CLANGD_CACHE_DIR ) 7 # 注释下面的语句 8 # elif p.exists( file_name ) and not CheckFileIntegrity( file_name, check_sum ): 9 # printer( \u0026#39;Cached Clangd archive does not match checksum. Removing...\u0026#39; ) 10 # os.remove( file_name ) 11 12 if p.exists( file_name ): 13 printer( f\u0026#39;Using cached Clangd: { file_name }\u0026#39; ) 配置 YCM 配合一个配置文件.ycm_c_c++_conf.py, YCM 搜索的位置在 vimrc 中指定:\n1Plug \u0026#39;rdnetto/YCM-Generator\u0026#39;, { \u0026#39;branch\u0026#39;: \u0026#39;stable\u0026#39; } 2let g:ycm_global_ycm_extra_conf = \u0026#34;~/.ycm_c_c++_conf.py\u0026#34; 其内容的 example:\n1import os 2import ycm_core 3 4flags = [ 5 \u0026#39;-Wall\u0026#39;, 6 \u0026#39;-Wextra\u0026#39;, 7# \u0026#39;-Werror\u0026#39;, 8 \u0026#39;-Wno-long-long\u0026#39;, 9# \u0026#39;-Wno-variadic-macros\u0026#39;, 10 \u0026#39;-fexceptions\u0026#39;, 11 \u0026#39;-ferror-limit=10000\u0026#39;, 12 \u0026#39;-DNDEBUG\u0026#39;, 13 \u0026#39;-std=c99\u0026#39;, 14 \u0026#39;-xc\u0026#39;, 15 \u0026#39;-isystem/usr/include/\u0026#39;, 16 ] 17 18SOURCE_EXTENSIONS = [ \u0026#39;.cpp\u0026#39;, \u0026#39;.cxx\u0026#39;, \u0026#39;.cc\u0026#39;, \u0026#39;.c\u0026#39;, ] 19 20def FlagsForFile( filename, **kwargs ): 21 return { 22 \u0026#39;flags\u0026#39;: flags, 23 \u0026#39;do_cache\u0026#39;: True 24 } 使用方式 🔻 对于C/C++来说, YCM的使用最好配合compilation database 来使用, 例如compiledb. 否则, 可能头文件的path识别出问题(stackoverflow).\n2022年2月13日我使用的compilation database生成工具从compiledb换成了bear, 因为bear更好的支持递归, 即有make -C的情况.\n需要的compilation database生成工具介绍: Compilation database — Sarcasm notebook\n","date":"2023-11-17T19:28:12+08:00","permalink":"https://wangloo.github.io/posts/tools/vim/ycm/","section":"posts","tags":["tools"],"title":"Vim-YouCompleteMe插件国内安装"},{"categories":["Operating System"],"contents":"伙伴系统的优势 作为一个页分配器，伙伴系统主要解决外部碎片过多的问题， 保证系统中尽可能有大的连续空间可以使用。\n这也正是伙伴系统要设计成相邻内存块合并的原因。\n","date":"2023-09-18T17:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/mem/buddy/","section":"posts","tags":["linux","Operating System"],"title":"Linux Buddy 内存分配器"},{"categories":["Architecture"],"contents":"为什么要关心内存模型 内存模型是一个约定或者规则, 是体系结构决定的，定义了内存的某些属性和行为。 一般各个架构之间有所不同，比如 ARM 会做合并访存、乱序执行这类优化方法。\n所以，某些情况下，指令的执行顺序可能不与你程序设计的一模一样，只是为你呈现的结果相同罢了。 当然这里边还有编译器来优化（捣乱 hh）。\n一般程序无需关心内存模型带来的差异，除非你从事底层软件开发（嵌入式开发）这种需要和寄存器打交道， 涉及系统底层机制的实现时，你必须按照内存模型来合理的规划你的程序。\n各种内存模型 不同的处理器架构有不同的内存模型.\n 例如, ARM 架构可能优化内存读写指令的顺序, 但是 X86/64 架构通常不会这样做. X86 架构的每次内存加载指令都带有 acquire 语义, 每次写内存都带有 release 语义. ARM 架构就不一定, 拿 ARMv8 来说, 仅有LDRA/STRL指令带有此含义.   我们称类似 ARM 架构行为的内存模型为 Relaxed Memory Model\n  将 X86/64 上稳定运行的 Lock-free 的代码搬到 ARM 上, 就不一定是可行的.\n 顺序一致性模型 Sequential Consistency Model 指令的执行顺序总是和可执行文件一致.不论是否存在内存访问指令重排等优化操作.\n举个例子,\n 先写后读内存的模型中, 总是能实现读内存时值是新的(不会被优化成先读后写). 多条ldr指令的执行顺序也是严格按照程序所写   多处理器环境下, 每个核的执行顺序都是可执行文件中的指令顺序. 多核之间的同步需要程序员来保证.\n 宽松一致性模型 Relaxed Consistency Model 各种优化 buff 叠满，一般加载/存储指令的执行顺序不能保证，需要程序员自行维护。\n这种宽泛的规则，给了处理器很大自主决定空间，它可以根据当前的情况决定是不是如何处理你的访存指令。\n宽松内存模型下几种保证正确性措施 \u0026ldquo;volatile\u0026rdquo; 关键字  这里对volatile的描述都是基于 C 语言的.\nvolatile(JAVA) != volatile(C/C++)\nvolatile(JAVA) == atomic(C/C++)\n volatile解决的是编译器的过度优化问题， 添加了volatile关键字表示该变量可能随时被改变, 即便当前的程序中没有体现, 也可能被其他的线程修改，或者对于寄存器来说自身就会发生变化。\n对于添加volatile关键字的变量, 编译器会严格按照你所写的来编译:\n 不会删除内存分配 不会在寄存器中缓存变量, 每次访问都会重新读内存. 不会改变赋值的顺序  看一个未添加volatile关键字可能导致的问题: 下面是一个简单的函数, 作用是为在等到设备完成当前任务后关闭设备.\n1void poweroff(dev_t ID, reg_addr_t *busy) { 2 while(*busy) 3 ; 4 poweroff(); 5} 看上去似乎是正确的, 但\u0026quot;过于聪明\u0026quot;的编译器可能让这段程序失效. 编译器总认为我们的程序是单线程的, 即没有人会来修改busy. 这种过分的优化导致汇编的结果仅仅读busy一次, 然后陷入死循环. 显然不是我们想要的.\n1void poweroff(dev_t ID, reg_addr_t *busy) { 2 if (busy) do_endless_while(); 3 poweroff(); 4} 对关键的busy变量添加volatile关键字将拯救我们!\n1void poweroff(dev_t ID, reg_addr_t volatile *busy) { 2 while(busy) 3 ; 4 poweroff(); 5}  延申阅读材料: 为什么大部分情况下使用volatile关键字都是错误的. 只要锁正确实现, 那么被锁锁住的变量就完全不需要volatile来声明, 因为获得锁时其他的 core 不能修改它. 这是锁来保证的, 不应该添加多次一举的 volatile!\nWhy the “volatile” type class should not be used — The Linux Kernel documentation\n  内敛汇编中的 volatile\n  1asm volatile(\u0026#34;\u0026#34;:::\u0026#34;memory\u0026#34;);  volatile 向编译器说明禁止内敛的语句与其他语句 reorder。但不能保证内部 reorder， 那是下面内存屏障的任务 \u0026quot;memory\u0026quot; 向编译器说明对于所有内存访问操作，不能使用 asm 之前预加载到寄存器中的值 ，而必须在 asm 内部重新加载。保证其内部访问内存值具有可见性和正确性。   内存屏障 Memory Barrier 对于可执行文件中的指令顺序, CPU并不会严格的依次执行, 而是进行更底层的\u0026quot;优化\u0026quot;来保证高效率, 即CPU乱序执行(Out of order)。 内存屏障指令能够保证乱序执行不会跨过该指令。\n正如下面的例子, 两条指令之间没有数据相关, 所以指令执行的顺序是不确定的.\n1ldr [x1], x2 # load x2 -\u0026gt; *x1 2str x3, [x4] # store *x4 -\u0026gt; x3 而在指令中间插入一条内存屏障指令, 就能强制保证内存屏障指令后面的指令不能先于其前面的指令执行.\n1ldr [x1], x2 # load x2 -\u0026gt; *x1 2# An Memory Barrier Instruction 3str x3, [x4] # store *x4 -\u0026gt; x3 AArch64 内存屏障指令 AArch64 提供了三种类型的屏障指令, 其中DMB和DSB属于内存屏障指令:\n ISB(指令同步屏障) DMB(数据内存屏障) DSB(数据同步屏障)  ISB 字面翻译为指令同步, 执行后指令流水线被刷新, 后续的指令需要再次fetch. 实际上可以理解为上下文同步. ARMv8将上下文定义为系统寄存器的状态, 并将上下文更改操作定义为: Cache, TLB和分支预测器的维护操作, 或对系统寄存器的修改.\n这些上下文更改操作对其后的指令来说并不是立即可见的. 只有在发生上上下文同步事件之后才可见. 所有的上下文同步事件包括:\n 发生异常 异常返回 执行ISB指令  所以ISB的作用可以表示为: 同步ISB前面的上下文更改操作, 并刷新指令流水线, 确保后面的指令可见新的上下文.\n所有的上下文更改后都需要添加ISB指令来保证后续指令执行时, 更改操作已经完成. The following example shows how to enable the floating-point unit and SIMD, which you can do in AArch64 by writing to bit [20] of the CPACR_EL1 register. The ISB is a context synchronization event that guarantees that the enable is complete before any subsequent FPU or NEON instructions are executed.\n1 MRS X1, CPACR_EL1 // Copy contents of CPACR to X1 2 ORR X1, X1, #(0x3 \u0026lt;\u0026lt; 20) // Write to bit 20 of X1. (Enable FPU and SIMD) 3 MSR CPACR_EL1, X1 // Write contents of X1 to CPACR 4 ISB  This does not mean that an ISB is required after each instruction that modifies a processor register. For example, reads or writes to PSTATE fields, ELRs, SPs, and SPSRs always occur in program order relative to other instructions.\n DMB 内存屏障指令ARM的实现, 上面已经介绍过. 这里再给出一个例子:\n1 LDR X0, [X1] // Must be seen by the memory system before the 2 // STR below. 3 DMB ISHLD 4 ADD X2, #1 // May be executed before or after the memory 5 // system sees LDR. 6 STR X3, [X4] // Must be seen by the memory system after the 7 // LDR above. DSB 在DMB的基础上进一步阻止除了内存读/写外的其他指令. 如下示例保证DC的执行结果为ADD操作可见。\n其后可以跟SEV指令, 它将等待此处理器发出的所有Cache、TLB和分支预测器维护操作完成.\n1 DC ISW, X5 // operation must have completed before DSB can 2 // complete STR 3 STR X0, [X1] // Access must have completed before DSB can complete 4 DSB ISH 5 ADD X2, X2, #3 // Cannot be executed until DSB completes  从上面的例子中可以看到，DMB和DSB指令接受一个参数, 用来指定生效的地址区域.\nLearn the architecture - ARMv8-A memory systems\n 单向屏障指令 LDAR/STLR 上面介绍的屏障指令能够保证,: 程序中所有在屏障前面的内存访问在执行屏障指令之前那一刻对于所有的master都是可见的(visible). 说中国话就是指定内存域(通过屏障指令的参数指定)的访存指令不能够跨过屏障指令而乱序执行.\n1+----------+ 2| LOAD +\u0026lt;--+ 3+----------+ | valid reorder 4| STORE +\u0026lt;--+ 5+----------+ 6| DMB | 7+----------+ 8| LOAD +\u0026lt;--+ 9+----------+ | valid reorder 10| LOAD +\u0026lt;--+ 11+----------+ 12 13+----------+ 14| LOAD +\u0026lt;--+ 15+----------+ | 16| STORE | | 17+----------+ | invalid reorder 18| DMB | | 19+----------+ | 20| LOAD | | 21+----------+ | 22| LOAD +\u0026lt;--+ 23+----------+ 然而, 这种双向的barrier太过于严格, 以致于导致不少性能的损失. 所以, ARMv8提供给我们单向的内存屏障指令, LDAR/STLR\nLoad-Acquire (LDAR)\n限制程序中所有在LDAR指令之后的内存访问必须在执行完该LDAR指令后才对其他master可见.\n用中国话说就是程序中所有在LDAR之后指令的内存访问都不能被execution-reorder到LDAR之前.\n再通俗点, 就是仅仅设定了一个reorder的上限.\nStore-Release(STLR)\n可以对比LDAR, 限制程序中所有在STLR之前的访存操作必须在执行STLR之前就对其他master可见, 不能再往后延迟了, 通俗点说就是设置了reorder的下限.\n用一张ARM用户编程手册中的图来解释, 黑色箭头代表每条指令最远能够reorder的路径.\n   独占访问指令?? ","date":"2023-09-10T18:02:04+08:00","permalink":"https://wangloo.github.io/posts/armv8/memory_model_and_barrier/","section":"posts","tags":["armv8"],"title":"ARMv8 内存模型"},{"categories":["Operating System"],"contents":"SystemV IPC Linux 引入了 SystemV 中 IPC 的集中实现方式，包括：信号量、共享内存、消息队列。\n共享内存 共享内存基于文件实现，用操作文件的方式来操作共享内存区。\n原理是对一块物理内存做多个映射，用引用计数来维护，只有引用计数为0时，才能释放。\n共享内存的特点是：\n 速度快，但自身没有同步功能，需要配合外部的同步机制。  信号量  为什么说信号量也是一种通信机制?\n其实通信并不一定就是要发送数据，只要能够相互感知，通知到对方，就算是一种通信。 类比抛媚眼也算是通信的一种。\n 消息队列  并非基于文件，由自己的一套API，使用起来不方便。 消息队列是面向消息的（并非字节流），消息由类型。 消息队列有自己的同步机制，无需外部添加。  信号 常用于父子之间通信，只要你知道了对方的PID，就可以给对方发信号。\n用kill(pid, signal)来发送信号。\n","date":"2023-09-08T16:21:27+08:00","permalink":"https://wangloo.github.io/posts/os/linux/ipc/linux-ipc/","section":"posts","tags":["Operating System","linux"],"title":"Linux 进程间通信概述"},{"categories":["Qemu"],"contents":"Qemu 的工作方式 Qemu有两种工作方式：全系统模拟（Full-system emulation）和用户模拟（User-mode emulation）。\n用户模拟仅仅对目标格式的Elf文件进行指令翻译并执行， 在遇到需要使用系统资源的命令（通过系统调用）时， 就转换成实际host的系统调用来完成，将执行完的结果返回。 Elf就是一个用户态的应用，不能直接操作硬件。 总之，用户模式下Qemu仅仅实现了讲Guest指令翻译为Host指令并执行， 不模拟资源。\n全系统模拟的方式下，Qemu在用户态模拟了完整的一套Guest硬件资源， 包括Cpu、内存、外设等，此时Qemu更像是一个虚拟机管理器。 Guest Elf可以直接对硬件进行操作。\n指令翻译 在 host 上运行 guest 架构代码的能力由 QEMU TCG 模块提供。\nTCG 做指令翻译的思路是 “边翻译边执行”， 并且将翻译工作分为前后端，中间会有一层中间指令， 这样能够方便添加对新指令的支持。这个有点类似于现代编译器，也是由类似间结果的流程，称为 IR。\nTCG 执行一次翻译的单位是 Translation Block，以分支跳转、页边界为划分条件。\nQemu 全系统模拟启动内核 \u0026ndash;kernel选项后面接一个Elf格式的系统镜像，Qemu内部用seaBios来实现引导Elf， 所以我们可以不关心如何引导Elf的问题。\n","date":"2023-09-08T16:21:27+08:00","permalink":"https://wangloo.github.io/posts/qemu/1/","section":"posts","tags":["Qemu"],"title":"QEMU 工作原理"},{"categories":["Operating System"],"contents":"   名词 含义解释     Unix 起源于BELL实验室的一个操作系统家族, 指代一类OS。\n这些OS共同遵守Unix特性，但各个分支在实现上有所不同。\n包括SystemV、BSD等分支   SystemV 是Unix的特殊版本，由AT\u0026amp;T公司开发   GNU 目标是开发一个完全自由、开源的OS，借鉴Unix   Linux OS内核，借鉴了Linux。后与GNU工具集结合，称为GNU/Linux                        ","date":"2023-09-08T16:21:27+08:00","permalink":"https://wangloo.github.io/posts/os/abbreviation/","section":"posts","tags":["Operating System"],"title":"操作系统：相关名词汇总"},{"categories":["Architecture"],"contents":"关于PMU PMU是一个独立的单元，不和体系结构绑定。而是每个SOC都可以不同。比如说Cortex-A53实现了PMUv3架构，但别的基于ARMv8架构的Soc可能实现PMUv4或者其他版本。\nPMU内部有六个计数器，所以可以记录六个事件的发生次数。计数器的数值不一定绝对的正确，因为管道的存在，所以一般来说还是通过长时间计数来减弱影响。\nPMU和ETM的区别 1. 记录的事件不同  PMU：Cache Miss、分支预测失败、TLB Miss等 ETM：记录分支指令、内存屏障指令等所有指令的执行，包括地址、结果等。 另外还可以记录数据读写的地址、结果（可选）。  2. 记录的粒度不同  PMU：仅用计数器来记录事件发生的次数 ETM：指令的类型、地址、执行结果等。数据访问也类似。  所以说，ETM的信息量大，需要专门的缓存机制。而PMU只需在定时器结束时记录发生的次数就行， 不需要什么缓存，没有实际的数据流。\n","date":"2023-09-02T22:02:04+08:00","permalink":"https://wangloo.github.io/posts/armv8/pmu/","section":"posts","tags":["armv8"],"title":"Cortex-A53 PMU介绍"},{"categories":["Hugo"],"contents":"footer属于 partial模板之一, 创建一个新文件footer.html, 然后在baseof模板中, 指定footer内容显示的位置.\n1\u0026lt;body\u0026gt; 2 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 3 {{- partial \u0026#34;sidebar.html\u0026#34; . -}} 4 \u0026lt;main class=\u0026#34;container\u0026#34;\u0026gt; 5 {{- block \u0026#34;main\u0026#34; . }} 6 {{- end }} 7 {{- partial \u0026#34;footer.html\u0026#34; . -}} 8 \u0026lt;/main\u0026gt; 9 {{- partial \u0026#34;script.html\u0026#34; . -}} 10 \u0026lt;/div\u0026gt; 11 12\u0026lt;/body\u0026gt; 下面将按照功能划分, 添加各种内容到footer模板中.\n文件创建和lastmode时间  commit: https://github.com/wangloo/hugo-theme-puer/commit/d263d9af65808ff03b2307abfb4db397ae1bcc2a\n 文件创建时间是获取的footer中的变量, lastmod其实也可以通过这种方式获取, 但是这样每次修改都要手动更新太复杂, 我们可以借助git追踪的文件的修改时间来作为lastmod, 默认不是这样的, 需要在config.toml中指定.\n1[frontmatter] 2 lastmod = [\u0026#39;lastmod\u0026#39;, \u0026#39;:git\u0026#39;, \u0026#39;:fileModTime\u0026#39;, \u0026#39;date\u0026#39;, \u0026#39;publishDate\u0026#39;] 然后就是在footer.html中引用这两个变量即可:\n1\u0026lt;HR width=\u0026#34;100%\u0026#34; id=\u0026#34;EOF\u0026#34;\u0026gt; 2 3{{- if not .Lastmod.IsZero -}} 4 \u0026lt;p style=\u0026#34;color:#777;\u0026#34;\u0026gt;创建于: {{ .Date.Format \u0026#34;2006-01-02T15:04:05\u0026#34;}}, Lastmod: {{ .Lastmod.Format \u0026#34;2006-01-02T15:04:05\u0026#34;}}\u0026lt;/p\u0026gt; 5{{- end -}} ","date":"2023-09-02T18:39:42+08:00","permalink":"https://wangloo.github.io/posts/hugo/new_theme_7/","section":"posts","tags":["hugo"],"title":"Hugo 主题创建(7): footer"},{"categories":["Thinking"],"contents":"富士的价格为什么被炒的越来越高？如果单说是外观，那尼康的zfc、索尼、佳能的一些微单并不输给他很多， 我觉得其中有一个很重要的原因就是富士的胶片模拟风格。\n作为一个程序员，我当然知道这些都是软件层面的东西， 其他厂家如果想做是完全可以做的，可能他们对这块也没什么兴趣。不得不承认富士可能在这方面做了一些 功夫，很可能并不单单只是颜色调整而已，它对于高光部分有更加细致的处理。\n今天主要想说的是为什么这种古老的风格会再次风靡？，如今数码时代的进步使得一张照片的清晰度、还原真实诚程度飙升， 为何还要去追求这种模糊与做旧呢？这是审美的倒退吗？\n我觉得，我们对美的认识或者说定义并不是随着科技的进步而进步的，有一些东西是不需要创新或者说无法进行创新的， 老的、旧的并不一定就差于现代的，衡量美的标准可能就是如此。\n那么我就想，其他东西是否也会这样呢？是否在过了几十年几百年的发展之后，我们回过头来再看，还不如原来固有的。 我想中华文化就在这之列，我们盲目的学习西方追求自由、绝对的平等，我相信时间会证明这不是适合中国人的社会风气。\n","date":"2023-08-20T20:30:35+08:00","permalink":"https://wangloo.github.io/posts/thinking/film/","section":"posts","tags":["Thinking"],"title":"Thinking: 胶片风格爆火"},{"categories":["Algorithm"],"contents":"实际上我做过的二分搜索的题目并不少，但是一直以来没有静下心去研究它的 【循环条件】【边界调整】【返回值】的细节，通过这个题目希望自己能完整、 清晰的了解二分搜索。\n题目 https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array\n 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。\n如果数组中不存在目标值 target，返回 [-1, -1]。\n你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。\n 示例 1：\n输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4]\n  解答(python): 1def searchRange(self, nums: List[int], target: int) -\u0026gt; List[int]: 2 3 if nums == []: 4 return [-1, -1] 5 6 # 第一次二分，确定右边界 7 left, right = 0, len(nums)-1 8 while left \u0026lt;= right: 9 mid = (left + right) // 2 10 if nums[mid] \u0026lt;= target: 11 left = mid+1 12 else: 13 right = mid-1 14 end = right 15 16 # 第二次二分，确定左边界 17 left, right = 0, len(nums)-1 18 while left \u0026lt;= right: 19 mid = (left + right) // 2 20 if nums[mid] \u0026lt; target: 21 left = mid+1 22 else: 23 right = mid-1 24 sta = left 25 26 print(sta, end) 27 if end \u0026lt; 0 or sta \u0026gt; len(nums)-1 or nums[sta] != target or nums[end] != target: 28 return [-1, -1] 29 else: 30 return [sta, end] 细节 写好一个二分搜索就是需要确定三件事:\n 循环边界条件 调整边界 返回值  这三件事是环环相扣的，先说确定的，调整边界的操作一定是left=mid+1 or right=mid-1, 整数的二分不存在left=mid这种操作，仅限于浮点数中。\n再说边界条件，我个人喜欢使用带等号的判断，即while left \u0026lt;= right, 这纯粹是个人习惯.\n问题转化 以求右侧下标为例, 可以等价为: 搜索\u0026lt;=target的最大值. 这其实是问题的关键, 只是另外加一个判断说如果求得数 不是target, 返回特殊值就行了. 如果你还是不理解这两个问题为什么是等价的, 那么看完下面的解释应该也能清楚.\n先说搜索\u0026lt;=target的最大值的计算方法, 一般的二分搜索, 搜索完成之后, 如果没有找到target, right=left-1, 且 right 指向比 target 首个小的元素,left 指向首个比 target 大的元素.\n那么代码是不是可以这么写:\n1left, right = 0, n-1 2while left \u0026lt;= right: 3 mid = (left + right) // 2 4 if nums[mid] == target: 5 return mid 6 elif nums[mid] \u0026lt; target: 7 left += 1 8 else: 9 right += 1 10 11return right 更进一步的说, 如果\u0026quot;把target也看作是小于target\u0026quot;, 也就是让循环不停下, 最后平衡的条件也一定是满足 right 指向比 target 首个小的元素,left 指向首个比 target 大的元素., 只不过此时=target 也被算作是小于target, 走小于target的处理流程. 最终的结果就是right指向的就是target(如果存在), 要不就是比target小的那个数.\n于是代码就可以被优化为:\n1left, right = 0, n-1 2while left \u0026lt;= right: 3 mid = (left + right) // 2 4 if nums[mid] \u0026lt;= target: 5 left += 1 6 else: 7 right += 1 8 9return right 再审原题 上述这种进一步思考的思想是不是与原题中的要求类似? 我可以有一连串的target, 我要求的是最右边的target在哪, 如果把=target也看作是小于target, 让循环继续跑, 最后right指向的就是最右边的那个target.\n","date":"2023-08-20T20:30:35+08:00","permalink":"https://wangloo.github.io/posts/algorithm/bsearch/","section":"posts","tags":["Algorithm"],"title":"一道题搞定二分法的细节"},{"categories":["Hugo"],"contents":"shortcode 可以当成是一些对 html 代码块封装的函数，在写 markdown 的时候就会方便一些， 举个例子来说，我有时需要往 post 中插入图片，并调整它的大小，这时候每次都手动写一些 html 简直是太麻烦了，使用 shortcode 就像是调用函数一样，告诉它函数名和必要的参数， 它会在生成网页时自动转换为对应的 html 语法。\nshortcode 分为两种：Hugo 默认和自定义的。Hugo 默认支持的 shortcode 有这些 https://gohugo.io/content-management/shortcodes/ ，这里面同时包含了告诉我们如果使用 shortcode 的基本语法。\n figure 插入图片 ref/relref 引用本地文档  当然hugo支持创建自定义 shortcode，详细的使用方法可以看这里， https://gohugo.io/templates/shortcode-templates/ ，我会大概说一下。\n 定义一个新的shortcode，即在layouts/shortcodes/下创建一个新的xxx.html文件，文件名就是你的函数名 这个shortcode会做什么事，就是在这个html中进行实现  插入链接图片 remoteFigure，参考的是diary主题的实现支持调整图片大小、填充样式、对齐、添加图片描述等。\n puer 主题的 Github commit\n Reference  中文介绍Shortcode  ","date":"2023-08-20T18:39:42+08:00","permalink":"https://wangloo.github.io/posts/hugo/new_theme_6/","section":"posts","tags":["hugo"],"title":"Hugo 主题创建(6): shortcode"},{"categories":["C Language"],"contents":"C 中的qsort, python 中的sorted()很多时间需要自己构造比较的规则，也就是告诉排序函数怎么衡量两个值的大小关系？\nTL;DR 升序的写法(C-qsort):\n1int cmp(const void *a, const void *b) 2{ 3 return *(int *)a - *(int *)b; 4} 5 6int main(void) 7{ 8 int nums[] = {2, 1, 3, 5, 4}; 9 10 qsort(nums, 5, sizeof(int), cmp); 11 return 0; 12} 升序的写法(python-sorted()):\n1from functools import cmp_to_key 2nums = [2, 3, 1, 4, 5] 3 4nums = sorted(nums, key=cmp_to_key(lambda x,y: x-y)) 5print(nums)  python3 丢弃了sorted()中的cmp选项， 全部用 key 选项进行指定， 所以需要cmp_to_key进行转换\n 升序的写法(C++-sort()):\n1// sort()原型 2void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp); 3 4bool cmp(int a, int b){ 5 return a \u0026lt; b; 6} 7 8int main(){ 9 int a[10]={8 ,3 ,10 ,9 ,5}; 10 sort(a,a+10,cmp); 11 return 0; 12} 详解 正如上面所说，cmp 函数的作用是给排序函数一个比较的依据。\n  c 和 python 的 cmp 函数属于同一种，返回的是 int 类型的值，代表的含义是：a 相对于 b 的位置。 返回正数代表 a 在 b 之后，负数则反之。所以用a-b算式就能表达升序排序\n  而 C++返回的则是布尔值，代表的含义是：a 排在 b 的前面吗?，所以用a\u0026lt;b， 也能表达升序排序\n  这样看起来，貌似 c++的写法更好理解一些。\n 有时我们会看到 python 中这样表示升序:\n1lambda x,y: -(x \u0026lt; y) 这其实是和x-y的效果是相同的, 只是有的时候一些类型不能够相减，比如说字符串， 但是可以使用\u0026lt;\u0026gt;比较，所以执行这样一个转换的小 trick。\n ","date":"2023-08-20T17:59:22+08:00","permalink":"https://wangloo.github.io/posts/c/cmp-func/","section":"posts","tags":["c","python"],"title":"C/python: cmp函数应该怎么写"},{"categories":null,"contents":"排序 使用sorted()来做, 不修改原来的变量, 而是返回一个新的。 自定义cmp函数的例子\n 被排序的类型必须是iterable的。\n 字符串 无重复字符的最长子串 1def lengthOfLongestSubstring(self, s: str) -\u0026gt; int: 2 mp = {} 3 left, right = 0, 0 4 max_len = 0 5 6 while right \u0026lt; len(s): 7 if s[right] not in mp: 8 mp[s[right]] = 1 9 else : 10 mp[s[right]] += 1 11 12 while mp[s[right]] \u0026gt; 1: 13 mp[s[left]] -= 1 14 left += 1 15 max_len = max(max_len, right-left+1) 16 right += 1 17 return max_len 牛客网处理输入 https://blog.nowcoder.net/n/0632a788b94b4923976b7c82c45eca95\n写递归 遇到需要用递归的题目中, 常常需要传值出来. 比如写一个求 sum(1..n)的函数\n这样写是错误的, 因为每次对 Sum 的更新都是局部的, 并不会影响到 parent frame 的值. 所以最后传出的值一定是 0\n1def func(n, Sum): 2 if n == 0: 3 return 4 else: 5 Sum+= n 6 func(n-1, Sum) 7 8result = 0 9func(3, result) 有两个方案解决:\n 使用全局变量来保存结果, 见全局变量章节 将传出的参数用可修改的类型来保存, 比如说 List. 以上代码可以修改为:  1def func(n, Sum): 2 if n == 0: 3 return 4 else: 5 Sum[0] += n 6 func(n-1, Sum) 7 8result = [0] 9func(3, result) 全局变量的使用 在写机试题时, 一般不会出现函数嵌套, 所以用不到nonlocal关键字.\n反而需要使用global关键字, 使用的方法为:\n1max_len = 0 2 3def dfs(..): 4 global max_len 5 # 在dfs()中修改或者访问的max_len就是全局的了 6 ... 进制以及 ascii 码转换 ascii 和字符相互转换, ord()和chr()互为逆函数:\n1c = \u0026#39;a\u0026#39; 2ac = ord(c) # 65 3c = chr(ac) # \u0026#39;a\u0026#39; 进制转换\n 如果要生成整型数据, 不管什么进制, 统一使用int()在最外层 如果要生成字符串, 统一使用format()在最外层, 当然它和bin(), hex()这类是等价的  下面给出几个常用的例子:\n1# \u0026#39;1010\u0026#39; -\u0026gt; 10 2int(\u0026#39;1010\u0026#39;, 2) # 10 3# 10 -\u0026gt; \u0026#39;1010\u0026#39; 二进制字符串 4format(10, \u0026#39;b\u0026#39;) # \u0026#39;1010\u0026#39; 5format(10, \u0026#39;#b\u0026#39;) # \u0026#39;0b1010\u0026#39; , 等价于bin(10)的结果 6# 10 -\u0026gt; \u0026#39;12\u0026#39; 八进制的字符串 7format(10, \u0026#39;o\u0026#39;) # \u0026#39;12\u0026#39; 8format(10, \u0026#39;#o\u0026#39;) # \u0026#39;0o12\u0026#39; , 等价于 oct(10)的结果 浮点数的处理 浮点数打印精度(四舍五入)\n1x = 1.23 2print(\u0026#34;{:.1f}\u0026#34;.format(x)) 3print(format(x, \u0026#39;.1f\u0026#39;)) # 我自己习惯统一使用此方法 字符串/字符的常用处理  字符串中含有非字母转小写/大写: 可直接调用.lower(), .upper() 非字符会默认保持不变  string 和 list 相互转换\n1# list to str 2a = [\u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;] 3s = \u0026#39;\u0026#39;.join(a) 4 5# str ot list 6s = \u0026#39;hello\u0026#39; 7a = list(s) 字符串是多个数字字段的组合, 如何分割每个字段转成int并存入 list:\n1s = \u0026#34;10 20 30\u0026#34; 2s = s.split() 3l = [int(x) for x in s] 字符和整数之间的转换\n1# c = \u0026#39;b\u0026#39; 2c = chr(ord(\u0026#39;a\u0026#39;)+1) 3 4# c = \u0026#39;2\u0026#39; 5c = chr(ord(\u0026#39;1\u0026#39;)+1) 字符串回文判断\n1s == s[::-1] 统计字符出现的次数: 不一定要借用字典\nstring 和元组一样, 有.count(x)方法统计 x 的出现次数\n1s = input() 2 3for i in s: 4 if s.count(i) == 1: 5 print(i) 6 break 7else: 8 print(\u0026#39;-1\u0026#39;) 搜索一个字符串中是否包含另一字符串, 不要再使用.find() != -1了 直接使用in关键字即可\n1if s1 in s2: 2 print(\u0026#34;s1 is included in s2\u0026#34;) 字符串删除指定字符:\n1s = \u0026#34;hello\u0026#34; 2#删除所有 l 3s = s.replace(\u0026#39;l\u0026#39;, \u0026#39;\u0026#39;) 4#删除前一个 l 5s = s.replace(\u0026#39;l\u0026#39;, \u0026#39;\u0026#39;, 1) 字典的常用处理 字典按照 value 排序:\n1# 返回降序的value list 2d = {} 3l = list(sorted(d.values(), reverse=True)) 4# 返回按value升序排序的的字典 5d_sorted = dict(sorted(d.items(),key=lambda x: x[1])) 6# 返回value降序的字典 7d_sorted = dict(sorted(d.items(), key=lambda x: -x[1])) 8# 返回按value降序,如果value相同时按key升序排序的字典 9d_sorted = dict(sorted(d.items(), key=lambda x: (-x[1], x[0]))) 集合 1# 创建一个空集合 2s = set() 3# 集合中添加元素 4s.add(123) 列表的常用处理 建立非重复的列表, C++中的集合(set)\n1s = \u0026#34;abcdabcd\u0026#34; # 想要得到[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;] 2set_list = [] 3for c in s: 4 if c not in set_list: 5 set_list.append(c) 列表删除元素\n1l = [1, 2, 3, 3] 2 3l.remove(3) # 删除第一个3 4 5# 删除所有3 6for c in l: 7 if c == 3: 8 l.remove(c) 工具模块 lru_cache 装饰器优化递归\n注意, 用此装饰器的函数参数必须为hashable的, 例如 list 就是 unhashable 的, 需要转为元组: func(tuple(lst))\n1import functools 2 3@functools.lru_cache(2**20) 4def fibonacci(n): 5 ... 典型问题整理 称砝码 以小见大, 假设我们有三个砝码, 要统计可能出现的所有重要, 我们的方法是:\n 先放 A, 统计所有可能 [0, A] 再放 B, 与之前统计的所有可能相加, 去重后加入所有可能 [0, A, B, A+B] 再放 C, 与之前统计的所有可能相加, 去重后加入所有可能 [0, A, B, A+B, C, A+C, B+C, A+B+C]  ","date":"2023-08-19T10:30:35+08:00","permalink":"https://wangloo.github.io/posts/python/algo/","section":"posts","tags":["Python"],"title":"Python 做机试题目技巧"},{"categories":["Hugo"],"contents":"通过 tag 可以实现对post进行分类，用到的支持是 HUGO Taxonomy Template（分类模板）\n原理 实现tag的功能需要完成两类页面的设计： /tags/ 和 /tags/\u0026lt;one-tag\u0026gt;\n前者属于 Taxonomy Terms（分类术语）页面，用分类术语模板实现， 后者属于 Taxonomy List （分类列表）页面，用分类列表模板实现，他们都属于 Taxonomy 模板。\n不难推测出，分类术语模板规定了如何展现某个分类方式，比如说用云图来展示tag分类方法。 而分类list模板的作用是展示选中某一类之后的页面，比如说在云图中选中了某个tag。\n更加详细的描述可以看官方文档: https://gohugobrasil.netlify.app/templates/taxonomy-templates/\n设计 正与文档中所说，分类terms模板可以有多个查找的优先级：\n  /layouts/taxonomy/.terms.html /layouts/_default/terms.html /themes//layouts/taxonomy/.terms.html /themes//layouts/_default/terms.html   这样的好处是，比如说我有两种terms，tag和categories，我想在分类术语页面对这两种分类展示不用的页面， 就可以定义tags.terms.html和categories.terms.html, 而我目前就用terms.html，简单。\n分类list模板也是，使用最通用的list.html, 和其他的list公用，并没有对分类list做单独的页面。\n 对应的 commit: https://github.com/wangloo/hugo-theme-puer/commit/63d8bb762b16a3d4657ba3523d6b6fb38cf5f9ca\n上面的commit不小心提交了menu.html, 实际不属于taxonomy的目的，所以在这纠正: https://github.com/wangloo/hugo-theme-puer/commit/0af07f66807b540fd9d3be84e8d7faca7f962c4b\n References  中文博客介绍Taxonomy(1): https://hugo-in-action.foofun.cn/zh/docs/part1/chapter4/4/ 中文博客介绍Taxonomy(2): https://note.qidong.name/2017/10/hugo-taxonomy/  ","date":"2023-08-15T18:39:42+08:00","permalink":"https://wangloo.github.io/posts/hugo/new_theme_5/","section":"posts","tags":["hugo"],"title":"Hugo 主题创建(5): Tag 分类支持"},{"categories":["Architecture"],"contents":"之前在特斯拉面试的时候被问到了 cache 的 maintain 操作有哪些, 一时间竟想不起一个准确的词来, 这里就再学习一下, 把这个坑填上吧。\n可能不会说的很细，目的只是把一些概念复习，做到心中大致有数。\ncache 是个硬件 cache 的本质是一种 SRAM, 容量很小, 速度很快(ns 级)。\n拿 Cortex-A53 来说，共有三级 Cache：\n L1 cache 是 Core 单独的，分为数据 cache 和指令 cache，容量是 KB 级 L2 cache 一般是 cluster 内共享，容量是 MB 级 L3 cache 是所有 core 共享，容量是 MB 级  cache 控制器 单独的 cache 就是一个存储设备，得有一个控制器告诉它存什么以及什么时候存。\ncache 控制器的任务举个例子说：比如 cache miss 的时候，需要从主存向 cache 回填数据，然而此时 CPU 那边记着要数据，我们都知道 cache 操作的单位 是 cache line 嘛，但这是 cache 控制器会有限填充一个 cache line 中 CPU 要的那一条（或几条），最后在后台默默填充完剩下的。\ncache 控制器的行为是不可配置的，软件不可见，不可编程。\ncache policy（策略） cache policy 就说了两件事：\n cache 分配：执行 load 操作时需要分配入 cache 吗？ cache 更新：执行 str 修改数据时需不需要与主存同步？  cache 的更新方式有两种：\n Write back，写回；即仅修改 cache 中数据，然后设置一个 dirty 标志位 ，当且仅当此 cache line 被 clean 时才对 dirty 数据回写主存 Write through，写直通；即每次修改 cache 都同步修改主存，也就不需要 dirty 标志了  cache 相关的内存属性 一段内存可被设置为 cacheable 或者 uncacheable，uncacheable 的内存直接访问主存。\ncacheable 又可划分为 inner 和 outer 两种：\n inner: 可入L1 cache，或者L2 cache，实现定义 outer: 可入外部板级的 cache(L3 cache)  cache maintain（维护） 为什么需要维护cache？\n 主存中的内容更新了 此部分内存的权限改了或者映射改了  cache的三种维护操作（软件可见）：\n [invalidation]: 设置cache line对应的invalid位。常见于reset时，cache里的内容不可信， 所以需要将所有的cache invalid [clean]: clean的含义是清理，将原有的标记为dirty的line都与主存进行同步。当然， 仅更新策略为 write back的时候才需要 [zero]: 什么也不管，直接将cache line置0，数据丢了我也不关心   以上的三种操作都是有粒度的，包括整个 cache、指定va范围、某一路等。\n  软件只能通过体系结构提供的维护指令来控制 cache。\n ARMv8获取Cache信息 想要管理好整个cache系统, 首先要了解的信息是:\n 系统实现了几级cache? Cache line 是多大? 对于每一级的Cache, 它的 set/way 分别是多少?  这些信息都可以通过ARMv8的系统控制寄存器来读取.\nCLIDR_EL1 标识每一级Cache的类型以及系统最多支持几级Cache.\nCtype\u0026lt;n\u0026gt;字段用来描述缓存的类型. 系统最多支持7级缓存, 软件需要遍历Ctype\u0026lt;n\u0026gt;字段, 当读到的值为000时, 说明该级及以上都没有实现.\n 具体每种类型对应的值, 和其他字段的含义, RTFM\n CTR_EL0 记录了Cache line的大小, 以及Cache的策略.\nIminLine: 表示所有指令cache中最小的cache line, 单位是 word.\nDminLine: 表示所有数据cache中最小的cache line, 单位是 word.\nL1IP: 表示 L1 指令cache的策略. RTFM\nCSSELR_EL1 与CSSIDR配合工作. CSSELR用于选定查看某级的Cache, 再去读CSSIDR就是该级Cache的信息.\nCSSIDR_EL1 LineSize: 该级cache的cache line.\nAssociativity: 该级Cache的way\nNumSets: 该级Cache的set\n 该寄存器的字段分布与是否实现FEAT_CCIDX有关, RTFM## 获取Cache信息\n ","date":"2023-08-14T22:02:04+08:00","permalink":"https://wangloo.github.io/posts/armv8/cache/","section":"posts","tags":["armv8"],"title":"ARMv8: cache相关知识"},{"categories":["HTML/CSS"],"contents":"display 是规定元素排列方式的属性，总的来说，元素的排列方式可分两种：block 和 inline。\n block 的含义是，该元素默认情况下的 width 表现为充满整个父元素，height 表现为根据内容决定。 inline 的含义是，该元素的 width 和 height 都是必须根据内容决定，不能使用显示的width和height来改变。  即便 block 可以去设置 width, 比如为 50%, 但是它永远必须独占一行，下面的元素也不会排到它的空白处， 这就是 block 称之为 block 的原因。\n细分来说，其实 display 这个属性共有五种取值： block, inline, inline-block, flex, grid。 我们将依次介绍。\nblock 默认 display 方式为 block 的标签有: p, h1-h6, div, li 等\ninline 默认 display 方式为 inline 的标签有: span, a, strong\ninline-block inline-block 是结合了 block 和 inline 的优势：既不必独占一行，又可以调整 width 和 height。\n一些 button 经常使用的 display 就是 inline-block。\nflex grid 不同 display 文字居中的方法 文字居中是开发中常见的需求，然而根据 display 的不同，决定了实现居中的方式也不同。\n居中大概分为水平居中和垂直居中\n水平居中 对于 inline、inline-block 来说，直接设置text-align=center即可实现。\n对于 block，设置text-align=center的效果是将 block 内部的文字相对与 block 居中，并不是 相对于 block 的父元素。\n但是很多情况下，我们是想让整个 block 同时再相对于父元素居中（因为block的width不一定是100%） 此时需要对 block 元素额外添加margin-left=auto和margin-right=auto属性。\n垂直居中 用 flex 比较方便实现。\n","date":"2023-08-11T22:02:04+08:00","permalink":"https://wangloo.github.io/posts/html-css/display/","section":"posts","tags":["css"],"title":"前端学习: display"},{"categories":["HTML/CSS"],"contents":"position 属性决定了一个元素在页面中的排放方式, 通过与 top、bottom、left、right 结合可以决定任一元素在页面中应该在什么位置上。\nposition 的取值可以是: static/absolute/relative/fixed/sticky ，下面我将依次对他们的使用方法和场景进行介绍。\nstatic static 是元素默认的 position，它使得元素按照顺序排列（什么样的顺序取决于display)。\n它不能与 top、bottom 等属性结合，就是最简单的依次排布。\nrelative relative 与 static 相比，支持了 tom、bottom 这些属性，使得元素在依次排布的同时 能调整相对于上一个元素的位置变化。\n据我所知，relative 并不常见。\nabsolute absolute 也就是我们常称的\u0026quot;绝对定位\u0026quot;， 产生的效果相对于父元素做了一些偏移，而不是上面所说的上一个元素，只有父元素的位置改变，它才按照偏移数值进行改变。 偏移数值的指定通过 top、bottom 来实现。\nabsolute 可以与 fixed 进行对比，两者相差很小。\n absolute 无视 static。上面说 absolute 是基于父元素进行调整，仅当父元素是 static 时例外，absolute 会跳过这一层，找它的爷爷元素。\n fixed fixed的含义是使元素的排列始终固定在页面的某个位置，换句话也可以说它总是基于body做relative的 排列。当然，偏移是通过top、bottom给出的。\n一些页面的小广告用的排列就是fixed。\nsticky sticky像默认的static，但它也有top、bottom等属性值，这些值有特殊含义： 当元素随着页面滚动变化，而使元素的页面绝对位置（相对于body）达到top、bottom值时， 便固定在那不会再移动，使元素永远不会被移动出页面。\n看起来就好像是用页面的外框对sticky元素画了一个笼子，它永远跑不出页面之外。\nsticky目前被广泛应用与导航栏，只要设置top=0\n sticky是新增的属性，某些浏览器支持的可能不是很好\n ","date":"2023-08-11T21:02:04+08:00","permalink":"https://wangloo.github.io/posts/html-css/position/","section":"posts","tags":["css"],"title":"前端学习: position"},{"categories":["Hugo"],"contents":"字体替换  commit: https://github.com/wangloo/hugo-theme-puer/commit/861ca01617c06c83b701506c9a574cc2726d36d8\n 修改的参考：\n 一般文字用最近很火的【霞鹜文楷】 代码使用一些比较通用的代码字体，注意用!important提高优先级  ","date":"2023-08-11T18:39:42+08:00","permalink":"https://wangloo.github.io/posts/hugo/new_theme_4/","section":"posts","tags":["hugo"],"title":"Hugo 主题创建(4): 样式打磨"},{"categories":["Hugo"],"contents":" commit:\n 为什么选择fast search? hugo本身是不支持站内搜索功能的, 如果你写的文章较多就只能按照tag去检索分类. 这样至少也需要三次点击操作, 如果每个页面的边栏或者顶栏有一个搜索框, 能够 搜索文章的内容或者标题、Tag这些，对我来说效率就能得到显著提升。\nfast search 是我检索到的目前比较简单、成熟的方案，它的亮点：\n 最小外部依赖（无需jQuery） 支持实现键盘唤出 无需NPM, grunt等外部工具 无需额外的编译步骤，你只需要像往常一样执行hugo 可以方便地切换到任意可使用json索引的客户端搜索工具  集成 集成的步骤我是参照的这篇文章 , fast search官方也有说明类似的步骤，过程不难，大概可分为：\n  Add index.json file to layouts/_default Add JSON as additional output format in config.toml Add search.js and fuse.js (downloaded from fusejs.io) to static/js Add searchbox html 到你想布局的位置 对searchbox添加样式文件   具体的步骤看博文或者官方文档就行，这里不赘述。\n改动 做了一些让自己舒服的改动：\n 让搜索框常驻，只是搜索结果可以隐藏(ESC) /聚焦搜索框，和vim相同 简化样式，贴合我的主题 搜索结果只显示title就够  这样以后不论在哪，想要切换到一篇文章只需要两次鼠标（或者两次键盘）就能精准定位并打开，不必使用鼠标的方式可能更有作用哈哈。\nTODO  只能搜索标题，不能搜索内容、tag？  ","date":"2023-08-11T16:39:42+08:00","permalink":"https://wangloo.github.io/posts/hugo/new_theme_3/","section":"posts","tags":["hugo"],"title":"Hugo 主题创建(3): 站内搜索"},{"categories":["Hugo"],"contents":" commit: https://github.com/wangloo/hugo-theme-puer/commit/32abfccc6bafd3763e07b751f0315a5403c6eaff\n 与顶栏相比，我更喜欢侧边栏，现在的屏幕纵向空间很宝贵。\n本文创建了侧边栏模板的框架，预留了未来实现各种功能的布局，这个过程也是第一次接触partials/ 下的文件的作用——页面的某个组成部分。而_default/下的模板则是描述不同类型的页面。\n布局 基于hugo模板的分类思想，侧边栏属于页表的一个部分，所以侧边栏的模板需要放在partials/下， 同理的还有footer、toc、comment等。我们给侧边栏模板起一个名字sidebar.html。\n因为想在站点所有的页面（section、single、list）都显示侧边栏， 所以在baseof.html中需要引入sidebar模板：\n1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html\u0026gt; 3 4\u0026lt;head\u0026gt; 5 6 {{- partial \u0026#34;head.html\u0026#34; . -}} 7 \u0026lt;title\u0026gt; 8 {{ block \u0026#34;title\u0026#34; . }} 9 {{ .Site.Title }} 10 {{ end }} 11 \u0026lt;/title\u0026gt; 12\u0026lt;/head\u0026gt; 13 14\u0026lt;body\u0026gt; 15 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 16 {{- partial \u0026#34;sidebar.html\u0026#34; . -}} 17 \u0026lt;main class=\u0026#34;container\u0026#34;\u0026gt; 18 {{- block \u0026#34;main\u0026#34; . }} 19 {{- end }} 20 \u0026lt;/main\u0026gt; 21 \u0026lt;/div\u0026gt; 22\u0026lt;/body\u0026gt; 23 24\u0026lt;/html\u0026gt; sidebar.html的内容就比较简单了，目前的计划是添加首页、TAG和一个搜索框， 不着急，先展位，以后再实现这些功能，本次先实现框架。\n1\u0026lt;div id=\u0026#34;sideContainer\u0026#34; class=\u0026#34;side-container\u0026#34;\u0026gt; 2 \u0026lt;div class=\u0026#34;nav-link-list\u0026#34;\u0026gt; 3 {{/* TODO: 回到首页 */}} 4 \u0026lt;div class=\u0026#34;a-block nav-link-item \u0026#34; href=\u0026#34;\u0026#34;\u0026gt; 5 BACK 6 \u0026lt;/div\u0026gt; 7 8 {{/* TODO: articles... */}} 9 \u0026lt;div class=\u0026#34;a-block nav-link-item \u0026#34; href=\u0026#34;\u0026#34;\u0026gt; 10 POSTS 11 \u0026lt;/div\u0026gt; 12 13 {{/* TODO: tags */}} 14 \u0026lt;div class=\u0026#34;a-block nav-link-item \u0026#34; href=\u0026#34;\u0026#34;\u0026gt; 15 TAGS 16 \u0026lt;/div\u0026gt; 17 \u0026lt;/div\u0026gt; 18\u0026lt;/div\u0026gt; 样式 这是首次接触样式的修改，也就是用到css语言。顺便说下，我非常敬佩视频网站上那些对CSS玩的很溜 的人，我觉得CSS中的细节远比我的工作中的多，可能你糊弄一下能得到一个相同的效果，但是一个优秀的 前端工程师是要清楚每个属性的作用，他们之间是如何搭配的，绝对不是凑出结果。\n主题中如何添加css文件呢？创建模板时会自动创建目录 static/css/，其中可以放置一些css文件， 比如我为sidebar.html创建的叫style.css, 在样式不多的情况下其他部分的样式也都可以放在这。\n不在一个目录下，如何联系html和css呢？这就不得不提到partials/下的另一个重要模板head.html, 通过baseof.html中它的位置就能大概知道它的作用：\u0026lt;head/\u0026gt;标签的模板，基本上就是描述样式的css语法嘛。 这就是html和css连接的桥梁。\n以下是style.css文件内容：\n1.container { 2 padding-left: 25%; 3 width: 75%; 4 min-height: 100vh; 5 white-space: normal; 6 7} 8 9.side-container { 10 position: fixed; 11 top: 0; 12 height: 100vh; 13 width: 25%; 14 text-align: left; 15 padding: 20px 0 50px 0; 16 display: flex; 17 flex-direction: column; 18 justify-content: space-between; 19} 20 21.nav-link-list { 22 flex-grow: 1; 23 .nav-link-item { 24 margin-bottom: 10px; 25 border-right: 2px solid transparent; 26 /* padding: 8px 28px 8px 30px; */ 27 cursor: hand; 28 transition: all 0.2s linear; 29 } 30 } 有了侧边栏后，我们需要启用内容的wrap line，且目前暂时用padding-left+width=100%的方式 来避免当文字过长出现滚动条时滑动会破坏布局。 本质还是由于侧边栏的实现是通过padding方式，sidebar和内容互相不能感知对方。\n","date":"2023-08-11T15:39:42+08:00","permalink":"https://wangloo.github.io/posts/hugo/new_theme_2/","section":"posts","tags":["hugo"],"title":"Hugo 主题创建(2): 添加侧边栏"},{"categories":["Hugo"],"contents":" 本次对应的commit，应该属于站点的仓库，因为仅修改 config.toml\n 代码高亮 hugo 内置一套highlight引擎, 参见官网的描述 , 所以我们只需要对站点的配置文件(注意不是模板的配置文件)进行修改, 就能最简单的实现代码高亮.\n如果你需要对其进行自定义, 且将其固化到你的主题中, 那么就可能需要使用highlight.js来完成, 遵循\u0026quot;提前优化是万恶之源\u0026quot;的理论, 暂时使用hugo提供的高亮支持就能符合我们的目标.\n这是我的配置文件config.toml中关于代码高亮的启用:\n1[markup] 2 [markup.highlight] 3 anchorLineNos = false # 行号格式化为\u0026lt;span\u0026gt; 4 codeFences = true # 代码围栏, 不启用高亮无效 5 guessSyntax = true # 自动推断高亮语言 6 hl_Lines = \u0026#39;\u0026#39; # 突出显示某些特定的行 7 hl_inline = false # 高亮 inline code, ver\u0026gt;=0.101.0 8 lineAnchors = \u0026#39;\u0026#39; #　与 anchorLineNos 配合 9 lineNoStart = 1 # 行号开始 10 lineNos = true # 是否显示行号 11 lineNumbersInTable = true # 生成html中分开行号和代码 12 noClasses = true 13 noHl = false 14 style = \u0026#39;vs\u0026#39; 15 tabWidth = 4 参考  hugo代码高亮引擎描述引导页: https://gohugo.io/content-management/syntax-highlighting/ 参数的详细描述: https://gohugo.io/functions/highlight/  ","date":"2023-08-11T07:39:42+08:00","permalink":"https://wangloo.github.io/posts/hugo/new_theme_1/","section":"posts","tags":["hugo"],"title":"Hugo 主题创建(1): 内置样式"},{"categories":["Hugo"],"contents":" commit: https://github.com/wangloo/hugo-theme-puer/commit/c014d1fae09eea1fcc44e03c69b6dd4d185f91fd\n 背景交代 到现在为止我使用hugo也一年多了, 记了几十条的博客，对于使用频率如此高的工具来说， 有一个顺眼的外观、方便的功能布局简直是梦寐以求。\n然而，试过了这么多的现有主题，始终没有一个让我觉得满意，可能我的要求过于苛刻：\n 搜索；我经常需要翻阅之前的博客/笔记，期望可以检索Tag，且不需要二次点击（ 上方直接是一个搜索框而不是一个按钮）。 TOC；要求可是展开显示三级的目录，且布局好看些。 外观；简洁，不花里胡哨，代码高亮看起来舒服。 xxx  所以，既然Hugo是一个开源的、社区环境较好的工具，那么为什么不尝试打造一款属于自己主题呢。\n我是一名嵌入式开发工程师，对于前端的知识生疏，希望在良好的社区环境下能帮助我早日完成满足我个人需求的主题。\n计划  搭建框架 制作模板，熟悉模板的概念，各个模板负责的区域 在上面的了解过程中逐渐加入对布局的调整，这一块可能需要学习css的知识 观摩学习前人的代码，结合百家之长，磨合出适合自己的布局和功能  开始动手：搭建脚手架 创建的过程可以参考这个博客 , 我主要想按照我的理解对整个框架进行详细的介绍。\n目录结构 1. 2├── layouts 3│ ├── 404.html 4│ ├── _default \u0026lt;--- 此次重点研究 5│ │ ├── baseof.html 6│ │ ├── section.html 7│ │ ├── single.html 8│ │ └── list.html 9│ ├── index.html \u0026lt;--- 此次重点研究 10│ └── partials 11│ ├── footer.html 12│ ├── header.html 13│ ├── head.html 14│ └── script.html 15├── LICENSE 16├── static \u0026lt;--- 目前是空的, 后续再研究 17│ ├── css 18│ └── js 19└── theme.toml \u0026lt;--- 干什么用的不清楚,后续研究 此次重点探讨index.html和_default目录下的文件.\nindex.html 是整个网站的首页, 打开你的站点最先看到的就是它的内容.\n1{{ define \u0026#34;title\u0026#34; }} 2 首页 3{{ end }} 4 5{{ define \u0026#34;main\u0026#34; }} 6 \u0026lt;p\u0026gt; 这里是个人站的首页, 仅展示用, 请DIY自己的首页覆盖它 :] \u0026lt;/p\u0026gt; 7{{ end }} 你可能看不懂这段代码, 这不是正常的html, 但马上你就能明白了.\n_dafult下的文件被hugo称之为模板, 顾名思义他们的存在是为了减少代码的重复度. 不同名称的模板代表了hugo将页面划分为不同的类, 这个在官方文档中应该有介绍, 后续可以插入个链接(TODO).\n single.html: 普通页面的模板, 我们写的博客中的内容页面就算是single page list.html: 列表页面的模板, 好几个博客分布在同一个子目录下, 访问这个目录的 地址就是 list page section.html: content/是hugo工程放置内容的目录, 其下需要建立子目录, 比如posts/代表这是一些博客  baseof.html需要着重介绍, 它相当于模板的模板, 目的是为了消除模板代码中的重复, 其中使用hugo提供的block语法, 建立基础模板, 目前我们baseof.html的内容如下:\n1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html\u0026gt; 3 4\u0026lt;head\u0026gt; 5 {{- partial \u0026#34;head.html\u0026#34; . -}} 6 \u0026lt;title\u0026gt; 7 {{ block \u0026#34;title\u0026#34; . }} 8 {{ .Site.Title }} 9 {{ end }} 10 \u0026lt;/title\u0026gt; 11\u0026lt;/head\u0026gt; 12 13\u0026lt;body\u0026gt; 14 {{- partial \u0026#34;header.html\u0026#34; . -}} 15 \u0026lt;main class=\u0026#34;container\u0026#34;\u0026gt; 16 {{- block \u0026#34;main\u0026#34; . }} 17 {{- end }} 18 \u0026lt;/main\u0026gt; 19 {{- partial \u0026#34;footer.html\u0026#34; . -}} 20 {{- partial \u0026#34;script.html\u0026#34; . -}} 21\u0026lt;/body\u0026gt; 22 23\u0026lt;/html\u0026gt; 这还稍微像一点html, 能看出是一个html的框架, 其中用block声明了title和main变量.\n其他的模板文件中(包括index.html), 只要实现这两个变量, 就相当于把整段的代码都拷过来, 并且将{{ block \u0026quot;xx\u0026quot; }} 和 {{ end }} 之间的内容替换为你define的内容.\n在baseof.html中对{{ block \u0026quot;xx\u0026quot; }} 和 {{ end }} 之间提前填充就实现了, 对网页的title设置了一个默认值, 如果重定义了, 那么覆盖原先的默认值. 看index.html就能明白, 它将网站的title替换成了\u0026quot;首页\u0026quot;, 内容也改变了, 其他的都是相当于和 baseof.html相同.\n 这里不介绍hugo的更多详细语法使用, 官方文档中都有\n  这里先不介绍优先级的概念, 假设这些模板文件在全局中只有一个\n 参考  https://gohugo.io/templates/base/  ","date":"2023-08-10T17:39:42+08:00","permalink":"https://wangloo.github.io/posts/hugo/new_theme_0/","section":"posts","tags":["hugo"],"title":"Hugo 主题创建(0): 脚手架"},{"categories":["Openwrt"],"contents":"构建 openWRT  我在此步骤失败了，后面项目没有依赖完整的编译过程， 所以可能对你不构成参考\n 过程可参考官方教程, 编译过程非常长，使用到的工具非常多，这里提供两个优化的思路:\n提前安装本地依赖，忘了./scripts/feeds update -a还是./scripts/feeds install -a时需要检查系统的各种依赖, 可以提前统一安装一波.\n1sudo apt install g++ 2sudo apt install libncurses5-dev 3sudo apt install zlib1g-dev 4sudo apt install bison 5sudo apt install flex 6sudo apt install unzip 7sudo apt install autoconf 8sudo apt install gawk 9sudo apt install make 10sudo apt install gettext 11sudo apt install gcc 12sudo apt install binutils 13sudo apt install patch 14sudo apt install bzip2 15sudo apt install libz-dev 16sudo apt install asciidoc 17sudo apt install subversion 18sudo apt install python 19sudo apt install git 提前下载dl, dl是默认在编译时下载的一些工具源码, 你可以将他们提前下载好 放到dl/下, 即可省去下载的时间, 特别当你不能翻墙时.\n就像这个仓库这样, 但是它里面 的软件版本可能比较老了而且有的软件是缺失的, 以后如果真的要自己编译, 需要查makefile去替换真正依赖的软件和其对应的版本.\n最终还是因为编译某个模块失败, 且编译时间太长(连交叉编译工具链都需要现场编译) , 导致排查困难, 没有编译成功。好在后面也没有直接依赖编译的结果。\n编译的tips  make V=99 build with verbose  ptgen 正如上面所言, 我最终没有完整的编译成功。但其中的一个小工具ptgen是我 需要用的到，它在过程中被编译出来了，相对独立些。\nptgen是OpenWRT开发的一个用来生成gpt分区表的工具，创建的sdcard镜像， 只有配合分区表才能正确的被bootrom加载起来。\n使用方法及参数 ptgen使用的参数说明:\n1 2ptgen [-v] -h \u0026lt;heads\u0026gt; -s \u0026lt;sectors\u0026gt; -o \u0026lt;outputfile\u0026gt; [-a 0..4] [-l \u0026lt;align kB\u0026gt;] [[-t \u0026lt;type\u0026gt;] -p \u0026lt;size\u0026gt;...] 3 4-v: 指定是否打印调试信息,可选 5-h: 指定起始磁头号 6-s: 指定起始扇区号 7-o: 指定输出文件名 8-a: 指定激活分区为哪个, 可选 9-l: 指定多少KiB对齐,可选，这个参数会决定每个分区的偏移扇区号，非常重要 10-t: 指定文件系统分区标志类型值,是0x83指linux,0x0b指Win95 FAT32,可选 11-p 指定分区大小,可选 ptgen使用案例 这里贴出我使用ptgen创建一个BananaPi M2 Ultra可以识别的sd卡镜像文件， 对bootfs进行挂载可放入一些文件，在uboot下能访问。\n1#!/bin/bash 2 3if [ -f \u0026#34;sd.img\u0026#34; ]; then 4 echo \u0026#34;warning: sd.img already exist, do nothing\u0026#34; 5 exit 6fi 7 8if [ -f \u0026#34;bootfs.ext4\u0026#34; ]; then 9 echo \u0026#34;warning: bootfs.ext4 already exist, do nothing\u0026#34; 10 exit 11fi 12 13BOOTFS_SIZE=16M 14# make ext4 fs which including kernel.bin 15dd bs=\u0026#34;$BOOTFS_SIZE\u0026#34; if=/dev/zero of=bootfs.ext4 count=1 16sudo mkfs.ext4 bootfs.ext4 17[ -d \u0026#34;./mnt\u0026#34; ] || mkdir ./mnt 18sudo mount -o loop bootfs.ext4 ./mnt 19sudo cp kernel.bin ./mnt 20sudo umount ./mnt 21 22 23# create empty image 24dd bs=32M if=/dev/zero of=sd.img count=1 25 26 27# generate parition table 28# -t 0xc: FAT32 29# -t 0x83: ext4 30set $(./ptgen -o sd.img -h 4 -s 63 -l 1024 -t 0x83 -p \u0026#34;$BOOTFS_SIZE\u0026#34;) 31 32 33BOOTFS_OFFSET=\u0026#34;$(($1 / 512))\u0026#34; 34# write in uboot and bootfs 35dd bs=1024 if=u-boot-sunxi-with-spl.bin of=sd.img seek=8 conv=notrunc 36dd bs=512 if=bootfs.ext4 of=sd.img seek=\u0026#34;$BOOTFS_OFFSET\u0026#34; conv=notrunc 37 38 39echo -e \u0026#34;\\n\\nsd.img is ok\u0026#34; 我正是依赖这个工具生成了最终的镜像而已，其他的模块其实并不是特别需要。 本来u-boot也是必须的，但是后面发现我用的硬件(BananaPi M2 Ultra) 在uboot中有直接的defconfig，所以也就不依赖openWRT的编译结果了。\n","date":"2023-08-05T19:28:12+08:00","permalink":"https://wangloo.github.io/posts/embedded/openwrt/","section":"posts","tags":["tools"],"title":"openwrt 开发日记"},{"categories":["DevTools"],"contents":"博客站 向优秀的前辈们学习~\n  hitzhangjie\n 腾讯 一本有关Dwarf的gitbook: https://www.hitzhangjie.pro/debugger101.io/ Blog也是基于Hugo构建，风格很好，移动端体验不错。https://www.hitzhangjie.pro/blog/    stdcc\n 上海交大 IPADS Blog风格很好，https://stdrc.cc/ Slides一定得学习，https://stdrc.cc/slides/write-os-in-rust-2.0/slides.html 用notion整理表格 https://stdrc.notion.site/c93719166f094ac187dfba6fc199b566 \u0026hellip;    工具站  Armv8 寄存器、指令速查：http://hehezhou.cn/a64/ Emoji cheat sheet https://www.webfx.com/tools/emoji-cheat-sheet/ Windows10搭建局域网FTP服务器 跟我一起写Makefile https://seisman.github.io/how-to-write-makefile/Makefile.pdf 网络调试工具 http://free.cmsoft.cn/download/cmsoft/assistant/netassist5.0.3.zip Gnu gcc 内联汇编官方手册: https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C  交叉编译工具   Linaro: 经常用来编译armv7架构的一些项目。 https://releases.linaro.org/components/toolchain/binaries/\n  Gnu: https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads\n   目前我组织的ARM64项目都使用 aarch64-none-linux-gnu- 作为交叉编译工具集, 直达链接: https://armkeil.blob.core.windows.net/developer/Files/downloads/gnu-a/10.3-2021.07/binrel/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu.tar.xz\n ","date":"2023-08-05T19:28:12+08:00","permalink":"https://wangloo.github.io/posts/tools/useful_sites/","section":"posts","tags":["tools"],"title":"工具\u0026\u0026博客站点集合"},{"categories":["DevTools"],"contents":"前言 写这篇博客的背景是我实在忍受不了每次换新的开发机器都得费好大的劲来完全恢复以前的环境， 而且，我平常喜欢搜集各种有用的工具、好看的主题，字体这些，如果零零散散的记录，大概率会忘记或者记不得某些细节。\n所以，最后期望达到的是能够使我每次在新机器上搭建环境只需要看这一篇文章就可以了。因此这里会记录：\n 帮助提升开发效率的小工具 好看的字体、主题 配置某些环境的要点及注意事项   🥀 到目前为止，我还未发现一种方式能够完全达到“一键式布置”，这也不是本文的目的。 付出至少半天的时间的一定的，希望未来能发现一种好的方法。\n 字体 Fira Code 这款字体适合做编程字体，蛮好看的。我在 vscode 和 terminal 下都使用了这款字体。\n详情及安装参考github\n霞鹜文楷 开源的中文字体，做博客、PPT 不错。\n详情及安装参考github\nvscode vscode的所有配置通过其内置的sync功能实现, 目前用的是Github账号同步。\nUbuntu2004源 新版本的Clangd  Clangd用15+才能用vscode的inlay hint功能。\n 获取签名\n1wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add - 添加源地址到/etc/apt/sources.list, 修改完后别忘了sudo apt update\n1# 15, 后缀可以改成你需要的版本号 2deb http://apt.llvm.org/focal/ llvm-toolchain-focal-15 main 3deb-src http://apt.llvm.org/focal/ llvm-toolchain-focal-15 main 新版本的Vim  Vim 8+才有pack插件管理\n 1sudo add-apt-repository ppa:jonathonf/vim 终端软件安装 源替换 apt 1sudo apt install python3-pip 2sudo apt install tmux 3sudo apt install fzf 4sudo apt install zsh 5sudo apt install cmake pip3 1# CLI 代码高亮 2sudo pip3 install pygments shell zsh oh-my-zsh oh-my-zsh可以看作对zsh的配置文件做一层抽象，使配置更方便。 带来的缺点就是速度变慢。\n 进入git目录下太卡\nTODO： 是主题的原因，可以配置\n 配置文件  .bashrc .zshrc .bash_aliase .bash_path  terminal ubuntu自带的终端我觉得还不错，有些人说Terminitor不错，分屏功能还是挺常用的！\nssh 密钥 1ssh-keygen -t rsa -C \u0026#34;cnwanglu@icloud.com\u0026#34; tmux tmux 在远程开发时比较有用。我们在用ssh连到服务器时经常需要有多窗口的需求， 比起现有terminal软件自带的多窗口功能(Xshell,mobaxterm等)，使用tmux 会更加方便。\n 窗口创建、切换等方式可以做到统一，不用追随终端软件 可以保存现场，即便因为网络问题ssh断开，也能随便恢复到之前的状态。因为 tmux是C/S架构，只要服务器上的server不死，永远可以恢复之前状态！ 甚至，tmux提供了将现场保存到本地文件中的功能。  reference  Tmux使用手册  科学上网 Clash for Linux 目前clash的作者已经删除跑路，但是已经发布的版本还是可以正常使用的。这一章节介绍如何在Linux上用命令行配置Clash。\n首先需要准备好一些文件：\n clash在linux中的命令行可执行文件，目前这里还可以下载 https://github.com/Kuingsmile/clash-core/releases， 去下载clash-linux-amd64-v1.18.0.gz Country.mmdb为全球IP库，可以实现各个国家的IP信息解析和地理定位，没有这个文件clash是无法运行的。 但目前版本的clash有点问题，不会自动生成MMDB文件，所以需要使用命令行下载。去这个地方或者这个地方看看 config.yaml为clash的代理规则和clash的一些其他设置。代理规则不需要我们自己编写，通过订阅地址直接下载即可。 此处将订阅链接粘贴进双引号中间。注意不要删除双引号，不要删除空格。 wget -O ~/.config/clash/config.yaml \u0026quot;订阅链接\u0026quot;。或者，如果你有clash的其他客户端，可以由已有的配置导出。  下载上面的文件，就可以准备好安装了：\n 创建~/.config/clash/，并将config.yaml和Country.mmdb放进去，如果已经存在请忽略 1mkdir ~/.config/clash/ 2mv Country.mmbd ~/.config/clash/ 3mv config.yaml ~/.config/clash/  解压clash-linux-amd64-v1.18.0.gz，并将可执行文件放到一个合适的位置 1gunzip clash-linux-amd64-v1.18.0.gz 2chmod +x clash-linux-amd64-v1.18.0.gz 3mv clash-linux-amd64-v1.18.0 ~/tools/clash-v1.18.0 4cd ~/tools/  运行clash可执行文件，如果成功运行应该可以看到以下LOG 1 $ ./clash-linux-amd64-v1.18.0 2 INFO[0000] Start initial compatible provider 故障转移 3 INFO[0000] Start initial compatible provider 自动选择 4 INFO[0000] Start initial compatible provider 大机场 Big Airport 5 INFO[0000] inbound mixed://:7890 create success. 6 INFO[0000] RESTful API listening at: 127.0.0.1:9090   到此，clash就可以正常运行了，由于我的订阅地址有3条规则，所以会有3条Start initial compatible provider xxxx。\ninbound mixed://:7890 则代表已经开启了http(含https)和socks代理，只要服务器内有软件流量通过7890这个端口，流量都将进入clash从而被代理。（但有些不支持设置，后面会说如何使用全局代理）\nRESTful API listening at: [::]:9090代表clash已经开启了ui控制面板，是的，Linux的clash有可视化控制面板。\n验证科学上网 根据我们之前前台运行可得知，默认是监控了自己的7890端口，验证方式可以通过curl向google发送一个请求看是否能正常返回。\n1curl --proxy 127.0.0.1:7890 www.google.com 返回正常 Google成功返回数据，代表7890端口代理正常，clash运行正常。注意目前必须手动指定代理的地址和端口，后面会介绍启用全局代理。\nClash全局代理 可以添加这个配置到你的.bashrc/.zshrc中，使得终端的所有请求都走代理。\n1export http_proxy=127.0.0.1:7890 2export https_proxy=127.0.0.1:7890 这里只设置了http和https，初次之外，还可代理其他协议。\n可以做成一个sh命令，当想临时关闭科学上网的时候执行unproxy。\n1function proxy() { 2 export http_proxy=http://127.0.0.1:7890 3 export https_proxy=$http_proxy 4 echo -e \u0026#34;proxy on!\u0026#34; 5} 6function unproxy(){ 7 unset http_proxy https_proxy 8 echo -e \u0026#34;proxy off\u0026#34; 9} 验证全局代理配置成功只需要再执行一次curl即可，这次无需手动指定代理。\n1curl www.google.com 将Clash作为一个服务 使clash一直运行在前台会占用一个终端，而且总感觉不是很优雅，更好的方法是将clash作为一个服务来操作。\n 在/etc/systemd/system/目录新建一个clash.service文件 1[Unit] 2Description=Clash service 3After=network.target 4 5[Service] 6Type=simple 7User=root 8ExecStart=这里写你的clash运行的绝对路径（本文中的路径是`~/tools/clash-v1.18.0`） 9Restart=on-failure RestartPreventExitStatus=23 10 11[Install] 12WantedBy=multi-user.target  之后就可以用systemctl系列命令来确认是否启用成功： 1systemctl status clash 查看clash服务 2systemctl start clash 启动clash服务 3systemctl stop clash 停止clash服务 4systemctl restart clash 重启clash服务 5systemctl enable clash 设置开机自启clash服务 6systemctl daemon-reload 如果修改了clash.service文件，需要此命令来重载被修改的服务文件   Reference  Linux中安装Clash并且实现全局代理（纯命令行） https://github.com/Kuingsmile/clash-core/releases clash-for-linux Ubuntu配置 命令行Clash 教程 Clash can\u0026rsquo;t initial MMDB of Country.mmdb  Windows下迁移WSL WSL2目前已经相当好用了，在对性能要求不极致的场景下用WSL开发非常舒服。\n迁移WSL到别的位置/别的机器还是比较方便的，也有人写了脚本来做这些，它是针对迁移到其他硬盘位置的，所以我这次还是自己手动做一遍，原理都是相同的。\n步骤 1. 关闭WSL 1# 检查WSL是否在运行 2wsl -l -v 3 NAME STATE VERSION 4* Ubuntu2004 Running 1 5# 关闭 6wsl --shutdown 2. 导出WSL镜像 1wsl --export Ubuntu2004 D:\\Ubuntu2004_202311.tar 3. 注销原系统(可选) 1wsl --unregister Ubuntu2004 4. 将镜像压缩文件复制到新机器/新位置 如果是新机器，还需要重新配置好WSL，开启一些选项:\n1控制面板-\u0026gt;程序-\u0026gt;启用或关闭 windows 功能，开启 Windows 虚拟化和 Linux 子系统（WSL2)以及Hyper-V。 2 3勾选完成后，Windows11 会自己下载些东西，并提示你重启。等电脑彻底重启完以后，进行后续操作。 5. 在新机器上导入镜像文件 1wsl --import Ubuntu2004 D:\\wsl\\Ubuntu2004\\ D:\\Ubuntu2004_202311.tar 执行的时间比较长, 执行完后至此WSL就迁移完毕了，剩下的是一下配置的修正。\n6. 配置 设置默认用户 这样移过来现在登陆就是root，我们需要进行一些配置:\nSet your default user inside your distro by adding the following configuration to your /etc/wsl.conf.\n1[user] 2default=loo If the file doesn\u0026rsquo;t exist create it manually. Then exit your distro, terminate it (wsl -t Ubuntu2004) and start it again.\n设置默认distro 1wsl -s Ubuntu2004 这样完成后，所有的一切就OK了。\nReference  https://zhuanlan.zhihu.com/p/622706723  Linux组织Dotfiles Linux开发环境中的许多软件都由配置文件，重新捣鼓一台新环境时去重新设置这些配置文件是非常复杂的一件事情，所以我想着用一种统一的方式进行管理。\n vimrcs 用单独的子仓库管理 vim 插件使用单独的子仓库管理 其他的配置文件暂时都使用mackup管理   不将vim插件也归于mackup管理的原因是: 我的.vim/pack/xx/下的所有插件都是通过submodule的方式管理,这样有利于维护和更新。但是在mackup的管理方式中是将整个pack/的内容拷贝过来，这就与submodule的理念冲突了。此时去改mackup的实现不如将vim的插件系统单独进行维护更容易。\n 新环境恢复Dotfile  vimrcs的恢复方法: wangloo/myvimrcs vim插件的恢复方法: wangloo/myvimpack 其他配置文件，教程参考：wangloo/dotfiles  Reference  Installing Vim(8) plugins with the native pack system  ","date":"2023-07-17T19:28:12+08:00","permalink":"https://wangloo.github.io/posts/tools/dev_env/","section":"posts","tags":["tools"],"title":"开发环境构建指南"},{"categories":["Operating System"],"contents":"slub 和 slob 是基于 slab 思想针对某些场景下的优化实现。\nSLUB  当 slab 分配器面对过多的申请需求时，cache 中就会有多个 slab (struct slab), 在以前的 slab 分配器设计中， slab 描述符是放在物理页中的，即物理页的结构为： （slab 描述符+freelist+对象 s）,管理数据结构的开销就比较大。后期 SLUB 首先将 slab 描述符与struct page共用（通过 union 实现）。后面该思想被 SLAB 采纳。 SLAB 中每个 cache node 有三个 list: free, partial, full， 管理起来很麻烦， SLUB 中只有一个 partial 链表。 放弃着色，效果不明显  SLOB SLOB 的设计更加简洁，只有 600 行左右代码（SLAB，SLUB 都是 4000+），适合小内存的嵌入式设备。\nSLOB 中没有对象的概念，每个 slab 中分配的小块内存大小可以是不同的， 通过长度+偏移来记录下一个小块内存的位置。\n另外，SLOB 基本上放弃了 cache 的思想，系统中通过创建三个全局的链表: small, medium, large, 分别应对\u0026lt;256b, \u0026lt;1k, \u0026lt;PAGESIZE 的请求， slab 直接挂在这三个链表上，因为 slab 中的内存分配大小可以不同， 用三个链表可以加速查找。\n 从思想上，SLOB 仅仅保留 slab 中分配小块内存的思想，舍弃了 cache 的设计方案，所以实现上非常简单。\n ","date":"2023-05-26T18:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/mem/slab3/","section":"posts","tags":["linux","Operating System"],"title":"Linux SLAB 内存分配器(3): SLUB/SLOB"},{"categories":["Operating System"],"contents":"上一篇介绍了数据结构，这一篇主要介绍 slab 分配器的分配和释放算法。\n最外层接口: kmalloc()/kfree() 最上层的接口是kmalloc(size, flag)。\nslab 分配器维护了多个不同大小的 kmem_cache，放在数组kmem_caches[]中, 其对应的 object 大小和该 kmem_cache 的 name 在另一个数组kmalloc_info[] 中，它们的下标是对应的。使得我们能根据请求分配的大小来找到对应的struct kmem_cache结构。 【代码】\n专用的\u0026quot;cache\u0026quot; 上面的结构，会遍历系统初始化创建的一些内存池，来寻找一个大小满足要求的 object， 但是通常不能找到大小相等的，如果系统中存在的固定 cache 中 object 的大小太稀疏， 就容易发生空间浪费的问题。\n因此，我们可以为某个特定大小的内存请求再创建一个单独的 cache，仅仅用于满足这一类 结构体的申请，也是符合 slab 分配器关于面向对象的设计思想。\nslab 分配器提供的相关接口是:\n kmem_cache_create(): 创建一个专用 cache kmem_cache_alloc()： 从指定的 cache 里分配 object kmem_cache_free(): 释放对象到指定的 cache kmem_cache_destory(): 销毁某个 cache  Reference https://blog.csdn.net/u010923083/article/details/116518646?spm=1001.2014.3001.5502\n","date":"2023-05-20T18:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/mem/slab2/","section":"posts","tags":["linux","Operating System"],"title":"Linux SLAB 内存分配器(2): 算法"},{"categories":["Operating System"],"contents":" 参考的 linux kernel 代码版本 4.12\n slab 是什么 slab 属于 linux 内核内存分配器的一种，满足细粒度的小块内存的请求。 内核中还有其他的内存分配器例如伙伴系统，它是满足页为单位的分配请求。 因为内核中大部分的分配请求都用不到一个页那么大，所以 slab 的出现能够减小 内存碎片的出现。\n另外，非常重要的是，除了基本的小块内存分配， slab 的最初设计开始就基于 对象缓存的思想，加速分配和初始化的过程，下面将详细介绍缓存的设计思想。\n slab 分配器的实现在 linux 中是基于伙伴系统的，slab 管理的内存来源 就是伙伴系统，只是进行“二次管理”， 。\n slab 的设计思想 对象缓存特性 经常会在 slab 接口中看到kmem_cache这个前缀，我最初也有疑问说 slab 不就是一个内存分配算法，和 cache 扯上什么关系呢？\nslab 一般用于分配一些结构的内存，拿struct task来举例，我们通常会为 struct task创建一个内存池，里面包含了若干大小为sizeof(struct task) 的内存块，用的时候从里面取，释放之后回归池子里即可。这是 slab 分配小块内存的 基本思想。\n内核中的很多数据结构，我们在申请完空间之后立马做的一件事，就是初始化对象的成员 为某些特定的值，可以称这个过程为结构体(类)的构造函数，意为所有对象都会 做的那些相同的事。比如说，多核环境下很多结构中会有锁，或者链表，那么申请完空间 之后都会做锁或链表做初始化，这是固定的。实际上这些操作消耗的时间甚至大于申请 一块内存。\n基于以上事实，slab 分配器做的缓存优化是：为每个类别的内存池都绑定一个构造函数 和析构函数，当用完的对象空间被释放时，调用析构函数将某些成员的值恢复为默认状态 ，这样下次申请的时候，直接拿就行了，省略了重复的初始化流程。而构造函数被调用的 情况仅仅是当该小块内存第一次被申请时。\n由于这个思想，整个内存池也就被声明结构 struct kmem_cache, 它是整个 slab 算法的顶层数据结构，其中包含了许多相同大小的小内存块，slab 通过一些算法对其进行 管理。\n整体数据结构的规划 上面说了整个系统的顶层结构是struct kmem_cache, 其中可以再划分为多个\u0026quot;slab\u0026quot;, 这个 slab 就能代表一个或多个连续的物理页嘛，从 buddy 申请来的。\n表示一个 slab 的描述符可以与struct page，即物理页描述符共用，只是有一些 特定的成员不同，但毕竟 slab 描述符含义上来说也是表示一个或多个联系的物理页。 只是这些物理页中可以再此进行划分为小的内存块。\nslab 算法称这些小的内存块为object, 对象, 每个kmem_cache中的所有 slab 中的所有 object 的大小都是一致的。\nslab所指向的连续物理页中的内容=（一大堆 object +辅助快速定位 object 的结构）。 [图]\n这个结构就差不多了，另外，如果让kmem_cache下的所有 slab 都放在一起，不好判断那些 slab 中的 object 已经全部分配了，哪些 slab 是空的？为了方便管理和查找，slab 算法还 封装了一个struct kmem_cache_node结构，组织了三条链表: free, partial, full。 特定状态的 slab 挂在特定的链表上，方便查找。【图】\nReference https://blog.csdn.net/u010923083/article/details/116518248\n","date":"2023-05-20T17:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/mem/slab1/","section":"posts","tags":["linux","Operating System"],"title":"Linux SLAB 内存分配器(1): 概述"},{"categories":["Operating System"],"contents":"软中断、tasklet、工作队列都是中断上下部分离的具体实现方案。\n软中断 我们可以将某些中断配置为软中断，相当于建立一张 INTID 到软中断的映射表，这样在 中断到来时就能判断是否为软中断。\n这张“表”的建立是静态的，即编译时确定的。key 为 INTID，value 为描述一个软中断 的数据结构，在下面会介绍。\n 软中断的服务函数必须是可重入的，即多个 CPU 可以同时执行同一个 softirq 的处理函数，涉及到的全局结构可以用 spinlock 钳制。\n 表示 softirq 的数据结构 struct softirq_action代表一个软中断，系统中所有支持的软中断组成一个数据 softirq_vec[], 所有的软中断按照优先级来分配下标。\n1struct softirq_action { 2 // 指向softirq的处理函数 3 void (*action)(struct softirq_action *); 4}; softirq 的中断流程 在中断的上部，如果识别到当前中断是一个 softirq， 那么系统会标记一个软中断发生， 即raise_softirq()函数。其做的事情包括:\n 标记某个软中断发生，记录的结构是irq_cpustate_t.__softirq_pending (这个字段使loca_softirq_pending()访问) 唤醒ksoftirqd内核线程，之后介绍  光标记不行，那么什么时候执行它们的服务函数呢？\n几个可能的检查点:(1) 中断退出前 (2)ksoftirq被唤醒时\n如果在检查点发现有标记挂起的 softirq(local_softirq_pending() != 0), 内核调用do_softirq()处理它们：\n 如何in_interrupt()返回非 0， 直接返回。此时代表要么禁用了 softirq，要么当前是 在中断嵌套的环境下，也可能正在执行do_softirq()时中断嵌套的，而do_softirq() 函数是不能嵌套执行的。 调用__dosoft_irq(), 对于local_softirq_pending()的每一位都调用其 softirq_vec[nr]-\u0026gt;action()  这里有个重要的问题，此时处于中断下部，即开中断的情况，所以在处理 softirq 时会有新的 softirq 到来，这里就有两种策略：\n 不断的获取最新的local_softirq_pending(), 直到不再有新的 softirq 产生才返回 忽略新来的 softirq，使其在下次检查点再被处理  这两种方案其实各有利弊，首先第一种方案，提高了 softirq 的响应速度，但如何 softirq 过多或者处理时间太长就会导致用户态线程已知得不到运行；而第二种方案则会增加 softirq 的响应延迟。\n实际上，softirq 的处理函数do_softirq()是采用折中的方案，它会在内部循环检查 10 次 （是可配置的），检查有无新的 softirq 到来。对于那些在循环之后到来的 softirq，那么 唤醒 ksoftirqd 线程来处理剩下的，不延迟用户态的运行。\nksoftirqd 内核线程 ksoftirqd 是一个内核线程，每个 CPU 都有，它的任务是不断检查是否存在挂起的 softirq， 并 执行其处理函数。\n1for (;;) { 2 set_current_state(TASK_INTERRUPTABLE); 3 schedule(); 4 while (local_softirq_pending()) { 5 preempt_disable(); 6 do_softirq(); 7 preempt_enable(); 8 } 9} ksoftirqd 的优先级较低，这样当do_softirq()循环 10 次还有新的 softirq 时， 唤醒 ksoftirqd 线程不会耽误用户态的执行，但当系统空闲时间，挂起的 softirq 又 会很快得到处理。\ntasklet tasklet 是基于其中一个软中断(TASKLET_SOFTIRQ)构建，其关系有点像线程与用户态 线程之间那种嵌套关系。\ntasklet 的分配可以是运行时确定的(例如使用 insmod)增加新的 tasklet。\n 内核对 tasklet 的服务函数进行了更加严格的控制：不能在多个 CPU 上同时运行同一个类型的 tasklet 函数(不同类型的 tasklet 可以)。，这样就使得 tasklet 服务函数不必非得 实现为可重入的， 简化驱动开发者的工作。\n 表示 tasklet 的数据结构 描述一个 tasklet 的数据结构为tasklet_struct, 成员包括:\n1struct tasklet_struct { 2 // 指向下一个tasklet，所有tasklet链表串联 3 struct tasklet_struct *next; 4 unsigned long state; 5 // tasklet 对应的处理函数 6 void (*func)(unsigned long); 7 // func 中可以使用的数据 8 unsigned long data; 9}; tasklet 的中断流程 TASKLET_SOFTIRQ的 action 指向遍历所有tasklet_struct的方法，该方法中 执行每个 tasklet 的func()。\n工作队列 工作队列创建了一个内核线程kworker, 原理与ksoftirqd差不多。\n主要的区别是ksoftirqd运行在中断的上下文，因为其调用了do_softirq(), 而中断上下文中是禁用用户抢占的，也就是说不能发生调度(不影响嵌套中断)。\n 中断上下文中禁止抢占的原因是开启了中断嵌套，代价是必须禁止抢占。 如果同时允许中断嵌套和抢占，那么“嵌套的”中断返回时如果发生了调度， 返回别的高优先级的进程去了，此时初级的中断还未结束。如此时在新进程里 又发生了初级类型同样的中断，就很有可能发生数据不一定或者死锁。\n 工作队列是运行在进程的上下文中的，也就是一般情况下。此时当然可以发生 抢占，所以工作队列适用于那种需要中断服务函数需要发生调度的情况， 比如说调用了sleep().\n工作队列 ","date":"2023-05-13T20:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/interrupt/softirq/","section":"posts","tags":["Operating System"],"title":"Linux 中断管理: 软中断/tasklet/工作队列"},{"categories":["Operating System","C Language"],"contents":"linux 内核为创建【用单链表解决冲突的哈希表】设计了专门的数据结构 hlist。\nhlist 整体来说是带头结点的双向链表，头结点的类型为hlist_head, 普通节点 的类型为hlist_node. 为什么要区别两种类型？节约空间， 因为哈希表的 表项类型可以是hlist_head, 它其实不需要prev指针, 比起一般的结点，一个 哈希表能节约一半的空间。\n所以一个哈希表和头结点的结构可表示为:\n1struct hlist_head { 2 struct hlist_node *first; 3}; 4struct hlist_head table[TALBE_SZ]; 二象性 任何事物都具有二象性，区分两种类型节约空间的空间，也带了一个问题： 首个hlist_node结点的prev指向哪呢？\n正常情况下肯定毫不犹豫的指向头结点，即hlist_head，但注意此时类型是 不同的，prev不能同时是struct hlist_head*和struct hlist_node *。\n解决方案有两个，首先可以使首个结点的prev=NULL, 这样虽然避免了类型引发的 问题，也能保证功能正确，但是却破坏了一致性，使得操作的复杂度上升，增加了许多 判断分支。\n1// delelt a node 2void del_node(struct hlist_head *head, struct hlist_node *node) 3{ 4 // 这个if 本来是不需要的，甚至参数的head 也不需要传， 5 // 更好的处理方式见解决方案2 6 if (node == head-\u0026gt;first) { 7 head-\u0026gt;first = node-\u0026gt;next; 8 } 9 else { 10 node-\u0026gt;prev-\u0026gt;next = node-\u0026gt;next; 11 } 12 13 if (node-\u0026gt;next) { 14 node-\u0026gt;next-\u0026gt;prev = node-\u0026gt;prev; 15 } 16} 17// insert a node 18void add_node_before(struct hlist_head *head, struct hlist_node *new 19 struct hlist_node *next) 20{ 21 // 这个if 本来是不需要的，参数head也是不需要传递的 22 if (next == head-\u0026gt;first) { 23 new-\u0026gt;prev = NULL; 24 head-\u0026gt;first = new; 25 } 26 else { 27 new-\u0026gt;prev = next-\u0026gt;prev; 28 new-\u0026gt;prev-\u0026gt;next = new; 29 } 30 new-\u0026gt;next = next; 31 next-\u0026gt;prev = new; 更好的解决方案: **prev 改变struct hlist_node的构成，使用二级指针:\n1struct hlist_node { 2 struct hlist_node *next; 3 struct hlist_node **pprev; 4}; 使得每个结点的pprev = \u0026amp;(prev_node-\u0026gt;next), 首先类型是统一的，其次删除和添加 都无需额外的分支了。\n1void del_node(struct hlist_node *node) 2{ 3 *(node-\u0026gt;pprev) = node-\u0026gt;next; 4 if (node-\u0026gt;next) 5 node-\u0026gt;next-\u0026gt;pprev = node-\u0026gt;pprev; 6} 7void add_node(struct hlist_node *new, struct hlist_node *next) 8{ 9 new-\u0026gt;pprev = next-\u0026gt;pprev; 10 *(new-\u0026gt;pprev) = new; 11 new-\u0026gt;next = next; 12 next-\u0026gt;pprev = \u0026amp;(new-\u0026gt;next); 13} Ref:\n **prev 可以提高删除的效率 stackoverflow  ","date":"2023-05-11T20:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/data_struct/hlist/","section":"posts","tags":["c","linux"],"title":"Linux 内核数据结构 hlist"},{"categories":["Operating System"],"contents":"管道属于实现进程间通信的一种方式，正如其名，一个进程在一头读，另一个进程在一头写。\n管道被看做是打开的文件，但在已安装的文件系统中没有相应的实体，即并不是一个 真正的文件。\n管道的创建和使用 可以使用pipe()系统调用来创建一个管道(后面会介绍另一个方式)，其返回一对文件 描述符，一个用来写一个用来读。必须返回两个描述符的原因是： POSIX 只定义了半双工 的管道，所以读写需要两个端口。\n POSIX 另外要求使用一个描述符前需要关闭另一个描述符。 但 Linux 中则可以不关闭， 可以实现全双工，但为了可移植性， 一般还是将另一个先关闭。\n 用ls | more组合命令来解释如何使用pipe()实现通信:\n shell 调用pipe(), 返回 fd3(对应读通道),fd4(对应写通道) 两次调用 fork() 创建两个子进程，由于属于不同的地址空间， 所以操作自己的文件描述符不会影响其他进程，但都指向同一个管道 父进程调用close()关闭这两个文件描述符  第一个子进程执行ls程序，其操作如下，\n 调用dup2(fd4, stdout), 执行文件描述符的拷贝，从此stdout 就代表管道的写通道 由于stdout代表写通道，所以可将 fd3 和 fd4 均关闭 exec()执行ls程序，默认情况下，其输出结果到 stdout， 当下即管道的写通道，即向管道中写了数据  第二个子进程执行more程序，其操作如下：\n 调用dup2(fd3, stdin), 从此stdin代表管道的读通道 同样可以将 fd3 和 fd4 关闭 exec()执行more程序，由于现在stdin就是管道的读通道, 上面的子进程向管道中写了数据，所以stdin现在有数据，more 可以正常输出  popen(): 更简单的 API 当管道的使用是单向的，即某个进程仅仅想知道另一个进程的执行输出，或者 某个进程想把数据灌入到另一个进程的输入。\n此时 Linux C 库中的popen()和pclose()简化使用pipe()中 调用dup2(), close()这些繁琐的步骤。\npopen()接受两个参数: 可执行文件的路径和使用方式 type, 返回 一个指向 FILE 的指针。\npopen()做的事包含:\n pipe()创建一个管道 创建一个新进程，执行:  如果使用方式是 r, 绑定管道的写通道到stdout, 否则绑定读通道 到stdin. 关闭pipe()返回的两个描述符 exec()执行指定的可执行文件   回到父进程，如果使用方式是 r, ·关闭管道的写通道。否则关闭读通道 返回管道剩下的文件描述符地址  这样父子进程就能单向通信了，如何使用方式是 r, 父进程可用popen() 返回的 FILE 来读取可执行文件的输出；相反，父进程可向 FILE 中写数据 到可执行文件的输入。\n因为返回的是 FILE 指针，所以通常配合fprintf(), fscanf(), fgets() 这类函数使用。\npclose()等待popen()创建的子进程结束。\npopen()样例 父进程读\n1#include \u0026lt;stdio.h\u0026gt;2#include \u0026lt;unistd.h\u0026gt;3 4int main(void) 5{ 6 FILE *fp = NULL; 7 char s1[32], s2[32]; 8 9 fp = popen(\u0026#34;ls\u0026#34;, \u0026#34;r\u0026#34;); 10 11 // read the first two files and print their name 12 fscanf(fp, \u0026#34;%s %s \u0026#34;, s1, s2); 13 printf(\u0026#34;s1 = %s, s2 = %s\\n\u0026#34;, s1, s2); 14 15 // close the read side of pipe 16 pclose(fp); 17 return 0; 18} 父进程写\n1#include \u0026lt;stdio.h\u0026gt;2#include \u0026lt;unistd.h\u0026gt;3 4int main(void) 5{ 6 FILE *fp = NULL; 7 char s1[32], s2[32]; 8 9 fp = popen(\u0026#34;wc -l\u0026#34;, \u0026#34;w\u0026#34;); 10 fprintf(fp, \u0026#34;one\\ntwo\\nthree\\n\u0026#34;); 11 pclose(fp); 12 13 return 0; 14} ","date":"2023-05-11T20:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/ipc/pipe/","section":"posts","tags":["Operating System"],"title":"Linux 进程间通信(1): 管道"},{"categories":["Operating System"],"contents":"Linux 中其实并不区别进程和线程，都用task_struct来描述，可以说 它们之间的联系大于区别。\n创建进程的接口是fork()， 创建线程的接口是pthread_create()， 但是它们最终都是调用的clone()系统调用， 只是参数不同而已。\n当一个进程/线程发起创建线程的请求时，不像创建进程那样重新申请mm_struct 和打开的文件等结构， 而是直接将指针赋值为父进程的值，所以它和父进程共享同一个 地址空间这些。\n 上面说的父进程，因为没有父线程的概念，如果创建线程的task_struct也是一个 线程，那么它的地址空间也是最终指向某个进程的，所以父亲和新的线程就是同等 地位了。\n 再说说 PID，PID 能够唯一的标识一个进程，一个进程下所有的线程的 PID 都与父进程 相同，那么问题来了，如何标识线程的从属关系呢？\ntask_struct.tgid标识自己所归属的进程 ID，或者叫主线程 ID，反正就是地址空间 的真正来源。 而进程如何知道自己创建了哪些线程呢？， 通过task_struct.children 链表来查找，但这里面即有子进程又有线程，需要过滤。\n 有的地方会使用一个名词 管理线程， 其实就是线程共享的地址空间这些的原主。\n 内核线程 内核线程是一种特殊的进程，当然也是用task_struct来描述，内核线程的特殊点：\n mm成员=NULL，没有用户空间的数据，不能访问用户空间 每个内核线程有私有数据，用set_child_tid成员指向， 是一个struct kthread结构，用to_kthread()来访问私有数据  内核线程也像普通线程一样参与调度，其创建的地方在内核，使用kthread_create() 创建，不能由用户态创建。\n内核线程一般负责执行一些内核任务，比如软中断 就有一个内核线程，来专门执行到来中断的服务函数中不着急的部分。\n","date":"2023-05-10T20:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/process/thread/","section":"posts","tags":["Operating System"],"title":"Linux 进程与线程的关系"},{"categories":null,"contents":"与 ARMv7 相比的改动  指令集： 新增 A64 指令集， 但也兼容原来的 A32 指令集 权限等级： AArch64 下新增 EL0-EL3 异常等级，对应 V7 的特权等级 通用寄存器：31 个通用寄存器，V7 15 个 虚拟地址长度：64 位的地址长度，理论支持 256TB 的寻址范围  ","date":"2023-05-09T21:19:01+08:00","permalink":"https://wangloo.github.io/posts/armv8/introduce/","section":"posts","tags":["armv8"],"title":"ARMv8 基础概念"},{"categories":["C Language"],"contents":"C++几乎是 C 的超集，只有很少的 C 的特性在 C++中不支持\nC++增加了需要方便实现面向对象特性的语法和封装，当然这些用 C 应该也能实现， 只不过 C++使其实现起来更简单。\n C++ 改进了一些 C 中的缺点，比如 new 自动计算大小避免出错 C++ 增加一些语法糖，比如迭代器等 C++ 原生支持一些方便的库文件，比如 STL 库  ","date":"2023-05-09T20:51:49+08:00","permalink":"https://wangloo.github.io/posts/c/c_and_cpp/","section":"posts","tags":["c"],"title":"C 和 C++ 的区别与联系"},{"categories":["Binary"],"contents":"想要描述一个变量，必须知道它类型信息，才能知道变量的大小、输出的格式等。\nDwarf 为 C 语言定义了一些描述数据类型的 DIE，包括 basetype, array,pointer, structure\u0026hellip;\nbasetype 今天我们先介绍最简单的 basetype。\nbasetype 是指那些 C 语言自身定义的基础类型，像int, double这些。\nbasetype 类型的 DIE 通常有属性:\n DW_AT_name: basetype 的名称 DW_AT_byte_size: 该 basetype 占空间大小  下面给出描述int和double的 DIE 展示(还是通过objdump工具输出）：\n1 \u0026lt;1\u0026gt;\u0026lt;43\u0026gt;: Abbrev Number: 3 (DW_TAG_base_type) 2 \u0026lt;44\u0026gt; DW_AT_byte_size : 4 3 \u0026lt;45\u0026gt; DW_AT_encoding : 5\t(signed) 4 \u0026lt;46\u0026gt; DW_AT_name : int 5 6 \u0026lt;1\u0026gt;\u0026lt;60\u0026gt;: Abbrev Number: 4 (DW_TAG_base_type) 7 \u0026lt;61\u0026gt; DW_AT_byte_size : 8 8 \u0026lt;62\u0026gt; DW_AT_encoding : 4\t(float) 9 \u0026lt;63\u0026gt; DW_AT_name : (indirect string, offset: 0x9): double Array 数组表示为 DW_TAG_array 的 DIE，通常含有属性:\n DW_AT_type： 指向数组元素的 DIE  数组的长度信息如何表示呢？每个 array DIE 的每个 child 都代表一个维度信息，最左边的 child 描述第一个维度信息。\n描述维度信息的 DIE 为 DW_TAG_subrange_type, 其包含两个属性:\n DW_AT_type: 指向所属 array 的 DIE DW_AT_upper_bound: 表示数据在该维度下的长度, 数值是-1 的  所以要得到一个数组的总长度，需要遍历其 DIE 的所有 child。\n下面给出一个二维数组int var_array[3][5]的相关 DIE 信息:\n1 \u0026lt;1\u0026gt;\u0026lt;43\u0026gt;: Abbrev Number: 3 (DW_TAG_base_type) 2 \u0026lt;44\u0026gt; DW_AT_byte_size : 4 3 \u0026lt;45\u0026gt; DW_AT_encoding : 5\t(signed) 4 \u0026lt;46\u0026gt; DW_AT_name : int 5 \u0026lt;1\u0026gt;\u0026lt;4a\u0026gt;: Abbrev Number: 4 (DW_TAG_array_type) 6 \u0026lt;4b\u0026gt; DW_AT_type : \u0026lt;0x43\u0026gt; 7 \u0026lt;4f\u0026gt; DW_AT_sibling : \u0026lt;0x60\u0026gt; 8 \u0026lt;2\u0026gt;\u0026lt;53\u0026gt;: Abbrev Number: 5 (DW_TAG_subrange_type) 9 \u0026lt;54\u0026gt; DW_AT_type : \u0026lt;0x60\u0026gt; 10 \u0026lt;58\u0026gt; DW_AT_upper_bound : 2 11 \u0026lt;2\u0026gt;\u0026lt;59\u0026gt;: Abbrev Number: 5 (DW_TAG_subrange_type) 12 \u0026lt;5a\u0026gt; DW_AT_type : \u0026lt;0x60\u0026gt; 13 \u0026lt;5e\u0026gt; DW_AT_upper_bound : 4 14 \u0026lt;2\u0026gt;\u0026lt;5f\u0026gt;: Abbrev Number: 0 ","date":"2023-05-09T16:51:49+08:00","permalink":"https://wangloo.github.io/posts/binary/dwarf/1_basetype/","section":"posts","tags":["Binary","ELF"],"title":"DWARF(2): basetype类型"},{"categories":["Binary"],"contents":"Dwarf 把源文件中每个可描述的模块（例如函数，变量，结构体的声明等）描述为一个 DIE (Debugging Information Entry)，所以每个源文件可以描述为若干 DIE 的组合。\n每个 DIE 由一个 tag 和若干 attribute-val 键值对构成:\n tag: 描述此 DIE 的类型 attribute-val: 描述此 DIE 的一些细节属性，项目根据 DIE 的类型不同而有差别  各个 DIE 之间会相互联系，一个 DIE 可能含有 parent，若干的 child 和 sibling， 它们之间组成树的结构。\n查看一个 ELF 的所有 DIE ELF 文件中的所有 DIE 存储在.debug_info section 中，通过 GNU utils 中的objdump工具 可以解析为可阅读的结构:\n1objdump --dwarf=info \u0026lt;file\u0026gt; 若我们有一个 demo.c 如下:\n1void func(void) { 2 int var_local; 3} 编译为可执行文件后， 执行上述的objdump命令， 可以得到如下的输出（节选）：\n1 \u0026lt;1\u0026gt;\u0026lt;68\u0026gt;: Abbrev Number: 5 (DW_TAG_subprogram) 2 \u0026lt;69\u0026gt; DW_AT_external : 1 3 \u0026lt;69\u0026gt; DW_AT_name : (indirect string, offset: 0x32): func 4 \u0026lt;6d\u0026gt; DW_AT_decl_file : 1 5 \u0026lt;6e\u0026gt; DW_AT_decl_line : 3 6 \u0026lt;6f\u0026gt; DW_AT_decl_column : 6 7 \u0026lt;70\u0026gt; DW_AT_prototyped : 1 8 \u0026lt;70\u0026gt; DW_AT_low_pc : 0x1129 9 \u0026lt;78\u0026gt; DW_AT_high_pc : 0xb 10 \u0026lt;80\u0026gt; DW_AT_frame_base : 1 byte block: 9c (DW_OP_call_frame_cfa) 11 \u0026lt;82\u0026gt; DW_AT_GNU_all_call_sites: 1 12 \u0026lt;2\u0026gt;\u0026lt;82\u0026gt;: Abbrev Number: 6 (DW_TAG_variable) 13 \u0026lt;83\u0026gt; DW_AT_name : (indirect string, offset: 0x28): var_local 14 \u0026lt;87\u0026gt; DW_AT_decl_file : 1 15 \u0026lt;88\u0026gt; DW_AT_decl_line : 4 16 \u0026lt;89\u0026gt; DW_AT_decl_column : 9 17 \u0026lt;8a\u0026gt; DW_AT_type : \u0026lt;0x43\u0026gt; 上述例子中节选了两个 DIE，分别是函数func()和局部变量var_local, 可以看到它们的 tag 是不同的，且都具有一系列属性。\n并且，值得注意的是，这两个 DIE 的关系可以从首列\u0026lt;\u0026gt;中的数字得知，数字代表 DIE 构成树的 深度，此例子中\u0026lt;1\u0026gt;下面紧靠的\u0026lt;2\u0026gt;就表示\u0026lt;2\u0026gt;是\u0026lt;1\u0026gt;的 child。理论上也是如此，因为局部变量 是属于对应的函数体的。\n小结 之后的章节打算介绍 Dwarf 是如何描述源文件中的不同对象的(函数,变量,数据类型等)\n","date":"2023-05-09T15:51:49+08:00","permalink":"https://wangloo.github.io/posts/binary/dwarf/0_basic/","section":"posts","tags":["Binary","ELF"],"title":"DWARF(1): 基础"},{"categories":["C Language"],"contents":"内存对齐为何被需要 架构规定了数据类型大小的同时，也规定了对这些类型的变量合法访问的对齐要求。 也就是说，变量不能随便的放在内存的任意位置，起始地址必须满足特定的对齐要求， 对不满足要求的变量强行访问就叫做非对齐访问， 非对齐访问通常会触发异常。\n一般数据类型的对齐要求 对于一般的数据类型，比如 int, long, char 这些，要求其变量地址对齐到自身大小， 比如 ARM64 中，int 变量的地址必须对齐到 4 字节，long 变量地址必须对齐到 8 字节等等。\n那么对于*(int *)0x1001 = 1234;, 这类的内存访问就叫非对齐的内存访问。\n 即 （变量 addr % 变量 size) ！= 0, 就称为非对齐内存访问。\n 结构体的对齐要求 上面说的还都是一般的数据类型，对于结构体这种复杂的类型，对齐的要求也复杂些。\n 首先是结构体成员，每个成员都必须满足其自身的对齐要求 然后是结构体变量自身的起始地址的对齐要求是其所有成员的最大对齐要求。  然而两个要求均满足有时候根本不可能，比如一个结构体声明为:\n1struct foo { 2 char mem1; 3 int mem2; 4 short mem3; 5}; 不可能同时做到 foo 变量和其成员 mem2 同时满足对齐到 4 字节，所以编译器会依据 上面的两条要求在成员之间添加 padding。\n除了变量中间添加 padding 外，在末尾也会添加，使得结构体数组容易满足对齐需求。\n最后 foo 变量在内存中的样子可能是:\n1struct foo { 2 char mem1; 3 char _pad1[3]; // 保证结构体和成员均对齐正确 4 int mem2; 5 short mem3; 6 char _pad2[2]; // 保证【结构体数组】对齐正确 7};  若结构体的成员还是一个结构体，嵌套操作就可以了，编译器可以 handle。\n  对于结构体的定义来说，若不想添加 padding，可以使用__attribute((packed)) 来声明。 常用于一些数据包的声明，除非你清楚自己为什么要这么做，要不别用。\n 如何做到内存对齐 上面一节说明了各个类型的变量对于内存对齐的需求，只要是各个类型变量的地址满足要求了， 对所有变量的访问也就 OK 了。那么如何保证每个变量地址都满足需求呢？\n对于静态分配的变量，即在编译链接时期就能确定地址，由编译器完成这项工作。编译器保证 分配给这些变量的地址是满足对齐要求的，这个完全不用担心。\n对于运行时动态分配的变量，例如malloc()接口返回的，其实 malloc 本身不知道要申请 空间的对齐规则，因为它只接受一个 size 作为参数。 所以一般来说，为了保证满足所有的 对齐要求，malloc() 返回的地址总是满足最大的对齐请求，即指针的大小 8 字节。\n malloc() 的实际效果与运行库的实现有关，并不是规定死的。不过我还没有见过不是 按照最大对齐要求分配的实现方法:)\n AArch64 对非对齐访问的支持 非对齐访问的结果是架构定义的， 不同的架构可能造成的结果不同：\n 架构可能支持非对齐访问，成功读取数据 架构不支持非对齐访问，产生异常  AArch64 架构支持 16、32、64 和 128 位的非对齐访问，但是有几个前提条件:\n 关闭系统的对齐检查: SCTLR_ELx.A bit 来控制 exclusive load/store 和 load-acuqire/store-release 两类指令必须是对齐访问的 。这就表示构建信号量和其他锁机制时必须是对齐访问的 非对齐访问仅“普通内存”可用，\u0026quot;Device memory\u0026ldquo;必须是对齐访问的   AArch64 非对齐访问的原理是分解为多次的访存，所以不能保证原子性，且性能是较差的。\n  虽然 AArch64 支持非对齐访问， 但编译器默认还是会生成满足对齐要求的代码。\n ","date":"2023-05-08T17:19:44+08:00","permalink":"https://wangloo.github.io/posts/c/alignment/","section":"posts","tags":["arm64","c","Operating System"],"title":"C 语言的内存对齐要求"},{"categories":["TODO"],"contents":"当进程被创建时，就预留了一块特殊的线性区，其开始地址和结束地址单独保存在 mm_struct.start_brk和mm_strcut.brk成员中，并不由vm_area_struct 链接，这块特殊的线性区就叫堆。\n进程使用的malloc()和free()等相关 API 都是操纵的堆空间。\n修改堆空间的接口 对用户态进程来说，提供brk()系统调用来修改自身的堆空间。\nbrk(): 参数addr, 效果是修改mm_struct.brk到 addr，即修改一个堆的结束地址。\nbrk() 系统调用的实现，在内核态是调用do_mmap()扩充堆，或者do_unmap()缩小堆。 并且移动mm_struct.brk的值而已，这是 brk()的实现。\n 用户态进程还有一个接口: sbrk(), 参数是字节，代表扩充的字节数。 其下层还是调用的 brk()。\n malloc()的实现 进程刚创建时，堆空间的大小为 0， 即bkr==start_brk。\n调用malloc()，即对堆空间扩充，上面介绍了修改堆空间的接口， 所以我们可以使用brk()来实现malloc().\n对于进程本身来说，只能通过brk()简单的增加/减少堆的总大小，这样做的效率是比较低的。 比如连续执行了三次malloc(), 如果要将中间的地址 free 掉，其实是无法实现的。\n而且这种最简单的情况下，每次malloc()都要使用brk()系统调用，效率也是很低的。\n所以，通常在 C 库则一层，即malloc()和brk()之间，会有一层对堆内存的管理， 包含碎片回收，内存池等算法来避免频繁的使用系统调用。\n","date":"2023-05-08T10:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/addrspace/heap/","section":"posts","tags":["Operating System"],"title":"Linux 进程地址空间 堆的管理"},{"categories":["Operating System"],"contents":"当前存在的问题 未启用写时复制时，fork()创建子进程地址空间的流程如下:\n 动态申请子进程的页表 动态申请子进程的物理页面，大小和父进程的相同 创建父进程虚拟地址-新物理页的映射到子进程页表 memcpy()将父进程所有页面拷贝到子进程地址空间下  这样做有什么问题呢？ 在fork()的常规调用环境下，fork()之后 接的一般是exec()类函数，即载入一个新的可执行文件，继续用父进程 的情况不多。\n这样的话，上述过程中memcpy()父进程的页面就是多余的，而且如果 父进程比较大，会非常耗时。\n写时复制的优化 执行 fork() 时，不给子进程分配新的物理页，而是将父进程的页表项 完全的拷贝到子进程中，结果就是父子进程的虚拟地址指向同一个物理地址。\n换句话说，这样做就不需要memcpy()父进程所有的页面，仅仅是memcpy()一份 父进程的页表，给子进程用。\n 那么是否连新页表都不申请，直接用父进程的页表？\n显然是不行的，因为本质上父子进程拥有不同的地址空间， 最后都要分隔开（无论是否执行exec()），所以没必要 推迟页表的申请，本身不怎么耗时。\n但是创建线程时，确实使用同一张页表。\n 当然，仅设计到这步是不行的，因为按理来说父子进程是独立的，对子进程的 修改不应该影响父进程的地址空间。\n所有，在 copy 完页表后，会将父子进程的所有地址空间（实际是页表项）设置 为只读属性，当父/子进程尝试修改地址空间时，触发异常，配合特定的 异常处理机制，为其创建一个新的屋里也，拷贝原来的+执行修改。\n下图是对上述情况的描述，仅给出一个页面的示例，可以推广到整个地址空间：\n1 VMA VMA 2 ┌───────┐ │ ┌───────┐ 3Parent │ │ │ Parent │ │ 4 │ │ │ │ │ 5 ├───────┤ │ ├───────┤ 6 │ ├────┐ │ │ ├────┐ 7 ├───────┤ │ PMA Write │ ├───────┤ │ PMA 8 │ │ │ ┌───────┐ ────┼───► │ │ │ ┌───────┐ 9 │ │ │ │ │ │ │ │ │ │ │ 10 │ │ │ │ │ │ │ │ │ │ │ 11 └───────┘ │ ├───────┤ │ └───────┘ │ ├───────┤ 12 ├────►│ │ Read │ └────►│ │ RW 13 ┌───────┐ │ ├───────┤ only │ ┌───────┐ ├───────┤ 14Child │ │ │ │ │ │ Child │ │ │ │ 15 │ │ │ │ │ │ │ │ ├───────┤ 16 ├───────┤ │ │ │ │ ├───────┤ ┌─►│ │ RW 17 │ ├────┘ └───────┘ │ │ ├───────┘ ├───────┤ 18 ├───────┤ │ ├───────┤ │ │ 19 │ │ │ │ │ └───────┘ 20 │ │ │ │ │ 21 │ │ │ │ │ 22 └───────┘ │ └───────┘ 23 │ 这样就完美了吗 实际上不是的，拷贝父进程的页表和vm_area_struct就不占内存了吗？\n当页表是稀疏的，vm_area_struct的数量过多时，其本身的数据结构 就会占用很大的空间。\n就 AArch64 来说，针对页表过大的问题，提供了 2M 和 1G 的巨型页(Huge Page) 可供选择，能在申请大而稀疏的页面时显著的减少页表的大小，同时也增加了 TLB 的 命中率，因为同样大小的内存大页只需要一个 TLB 表项即可。\n然而，还有一种情况更加严重，若fork()后父进程写了地址空间的内容， 如上所说就要拷贝这些物理页面，此时如果写的页面过多可能发生fork()到exec() 那一段间隔时间里的物理内存占用极高。虽然这种情况极少发生，前提必须是内存 分配稀疏+父进程修改的内存也是稀疏的，但是并不能完全忽略这种情况。\n当然，这个问题不能归根于 COW，而是fork()带来的，fork()应该提供参数 给那些子进程立马调用exec()的场景，就不用拷贝父进程的这些数据结构了。\n","date":"2023-05-08T09:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/addrspace/cow/","section":"posts","tags":["Operating System"],"title":"Linux 进程地址空间 写时复制"},{"categories":["TODO"],"contents":"何为进程地址空间? 进程地址空间由允许进程使用的若干线性地址区域(也称\u0026quot;虚拟内存区域\u0026quot;)构成。\n每个线性区域由起始地址、长度和属性来描述。\n在进程刚创建时，其地址空间仅包含 3 个线性区，分别是：代码段、数据段和堆区，其中 堆区的初始大小为 0。\n 栈区虽然也属于进程使用的内存区域，但这个区域对用户是透明的，所以我们一般将其 归于内核管理，并非进程本身。\n 线性区增加的典型情况:\n 使用mmap()为一个文件映射内存空间 创建一个 IPC 共享线性区与其他进程协作 调用malloc()扩张自己的堆区  Linux 描述地址空间的数据结构 在进程的 tcb 中，描述地址空间相关的结构都保存在成员mm中，其类型为struct mm_struct, 其中重要的成员有：\n mmap(struct vm_area_struct*): 指向所有线性区的链表头 mm_rb(struct rb_root): 指向所有线性区对象红黑树的根 pgd(pgd_t *): 指向进程的页表 mmlist(struct list_head): 指向下一个地址空间描述符(所有进程的地址空间描述符 被链接起来)  Linux 描述线性区的数据结构 用struct vm_area_struct描述一个线性去，其中重要的成员有:\n vm_mm(struct mm_struct *): 指向所属的地址空间描述符 vm_start(unsigned long): 此线性区的开始 vm_end(unsigned long): 下一个线性区的开始(此线性区结束地址+1） vm_next(struct vm_area_struct *): 指向进程线性区的 next vm_rb(struct rb_node): 此线性区对应红黑树中的节点  此线性区的大小就可以表示为: vm_end - vm_start.\n进程地址空间所有线性区的组织 进程拥有的所有线性区通过单链表串联（按地址排序），第一个区在mm_struct-\u0026gt;mmap, 下一次 通过vm_area_struct-\u0026gt;vm_next找到，依次类推。并且，mmstruct-\u0026gt;map_count成员 记录了进程所有线性区的数量。\n红黑树优化查找 正常来说，想要查找某个地址是否存在于进程的地址空间，遍历上述链表的效率是 O(n).\n因此，Linux2.6 引入红黑树来优化查找速度， 所有线性区同时组织成一个红黑树， 首部通过mm_struct.mm_rb指向。 然后每个线性区的vm_area_struct.vm_rb 存储节点的颜色和双亲信息。\n现在，当需要插入/删除一个线性区描述符时，用红黑树查找前后元素，再操作链表进行插入。\n分配一个线性区 接口是do_mmap(), 参数为:\n file, offset; 如果有文件映射 addr, len prot; 该线性区的权限  步骤大致包含:\n 用红黑树确定新线性区的前后， 对应find_vma_prepare() slab 分配一个struct vma_area_struct，并初始化 操作链表插入，对应vma_link()  释放一个线性区 接口是do_munmap()\n步骤大致包含:\n 红黑树确定要删除线性区的位置，以及做分割（必要时） 调用detach_vmas_to_unmapped()将其从链表中删除 unmap_region()删除页表项 释放 vma_area_struct 的空间  ","date":"2023-05-07T14:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/addrspace/addrspace/","section":"posts","tags":["Operating System"],"title":"Linux 进程地址空间 概述"},{"categories":["Operating System"],"contents":"Linux 为什么要引入信号? 信号是用户进程感知外部事件的一种方式。内核可以发送信号给用户程序，当然用户程序之间也可以互相发送信号，进程通过对某个信号绑定Handler实现对信号的响应。\n所以说信号也属于进程通信的一种方式，但是这种通信比较简单直接，目标进程只能知道信号来源的PID，无法直接附带其他数据。\n信号传递的原理 每个进程的TCB里都有一条链表存该进程等待的所有信号，给某个进程发送信号就表示为挂一个节点到目标进程的此链表上，内核发送信号当然可以直接操作，进程之间的话会转换成系统调用间接完成。当目标进程被调度时会检查并处理等待的所有信号。\n 目标进程只能同时有一个同种类型的信号处于挂起状态，也就是说，如果上一个同种信号没有被处理，那么之后到来的同类信号会被忽略。\n 更详细的说，这个信号的队列（链表）不止一条，分为进程组共享和进程私有的挂起队列。 才能实现某些信号是发送给整个进程组的，比如kill()，而一些是指定某个进程的， 比如tkill().\n信号被处理 对目标进程来说，它可以提前设置自定义的handler，所以在其TCB中还需要记录对于每个信号的处理方式。可能有三种：ignore, default handler, user-defined handler。\n当进程被调度获得CPU时，在返回用户态执行代码之前会检查是否有挂起的信号。如果有则执行对应的handler。\n 这个过程对应内核函数do_signal()。\n 有一个问题是，自定义的信号处理函数是在用户态的, 而do_signal()是发生在 内核态，所以内核要做一些特殊的操作：\n 创建一个临时的用户栈，不能破坏保存的原来用户态环境 ELR(返回地址) = 自定义处理程序，和其他的用户态环境构建 返回用户态，CPU 会执行处理函数 执行完毕后，通过之前对用户栈的特殊构建，使得程序接下来会运行一个 syscall (sys_sigreturn), 返回内核态 如上述操作检查完所有挂起的信号 当所有信号都被处理完成后，则恢复用户进程的原有环境，继续执行  ","date":"2023-05-05T20:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/signal/","section":"posts","tags":["Operating System"],"title":"操作系统：信号的由来和实现原理"},{"categories":["Operating System"],"contents":"为何需要同步互斥机制 同步互斥存在的意义只针对多个任务都会修改同一块内存的场景。这块内存也叫临界区， 要求是必须各个任务独占访问的。比如说许多线程都会往 ringbuffer 中填数据， 必须使用同步互斥机制才能保证数据的正确性。\n所以说，在以下的场景中，无需考虑同步互斥：\n 如果你只有1个CPU，该CPU上只运行1一个线程 如果会存在多个线程（可能是多个core或者一个core上的多线程环境），但是他们不会涉及同一块内存 即便是多个线程访问了同一块内存，但是都是读操作   需要同步互斥的场景在OS内核和用户态程序中都很常见：\n 内核中常见的临界资源包括：对内存区域的引用计数操作，或者对调度队列的修改操作等。 用户态那就更不用说了，同步互斥的场景很多，比如典型的读者写者问题(Buffer)  因为OS内核和用户态程序的权限不同，所以实现同步互斥的方案也不太相同。\n 同步互斥的常见方案 per-cpu 变量 OS 内核里有些数据结构如果不需要CPU之间共享，可以定义成per-cpu形式。\n 比如说调度队列，每个CPU只关心自己核上队列的情况，如果想要访问其他CPU的， 比如进程迁移请通过核间通信IPI来做，并不能直接访问。\n  per-cpu 变量通常被安排在不同的 cache line，避免 cache 的频繁刷新\n  优点：多 CPU 之间互不干扰 缺点：  要求逻辑独立， 极少数临界资源可以实现为 per-CPU 形式 需要考虑内核抢占的影响，如果OS内核修改percpu变量时被调度，新的进程也可能修改这个变量。 如果在中断服务函数中可能修改，还需要另外关闭内核中断。    原子操作 如果临界资源只是一个基础类型变量，比如说一个Flag或者引用计数。那么实现同步互斥的逻辑就比较简单。\n我们知道，如果多个CPU同时对一个变量做修改(flag++)，结果是不可知的。这是因为一次修改其实在处理器来看分为三步:\n load mem =\u0026gt; register update register store register =\u0026gt; mem  ISA 会提供一些原子操作的指令，将这三步绑定在一起，一旦有一个core执行了写动作，会对该内存总线独占， 只有此次写入完成后，其他core才能发起写入请求。\n 这就行了？并不是\n原子操作只能排除上面描述的问题出现，但是多CPU情况下的同步互斥还很复杂。比如说，一个Core修改了 这个变量，至于其他core能不能看到这次写操作，就和 memory consistency 和 cache coherence 相关， 实际应用中还需要考虑这些来保证逻辑的正确性。\n 原子操作指令的特权级别是用户级的，也就是说OS内核和用户态程序都可以用，比如说C++就提供了相应的原子操作库函数。\n 缺点：仅适用于临界资源是简单的基础数据类型的情况。当然，复杂操作的同步互斥实现底层也是在原子操作上做封装  锁和信号量 锁的实现底层就是利用了原子操作，锁应用的场景包含OS内核和用户态:\n OS内核:  自旋锁 Spinlock 互斥锁 Mutex 读写锁以及其改进版 RCU   用户态:  Futex（Fast Userspace mutex)     关于信号量\n信号量和锁的本质是相同的，书籍会写信号量是解决同步问题，锁是解决互斥问题。二值信号量就是互斥锁。\n 选择合适的同步互斥机制 (1) 内核中避免使用自旋锁: 获取不到锁的 CPU 会一直死等，浪费 CPU 资源\n(2) 若临界区仅仅是一个共享的整数变量操作，那么用原子操作即可完成，不需要复杂的锁。 例如各类数据结构的引用计数通常声明为 atomic_t。\nReferences  Let\u0026rsquo;s Talk Locks!  ","date":"2023-05-04T20:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/sync/","section":"posts","tags":["Operating System"],"title":"操作系统：同步互斥机制"},{"categories":["Operating System"],"contents":"tracepoint 是 Linux trace system 中 data source 之一， 其 trace 的对象是 kernel，属于一种静态的插桩方法。\n 添加和删除需要手动修改内核源码 可以向上提供接口，可以通过 frontend 来开启或者关闭，也可以自定义数据处理方式 在 disable 时， 仅有一次 if 判断的损耗，所以效率还算高。但缺点是不够灵活。  tracepoint 的组成 看其源码struct tracepoint就能知道它的组成结构：\n1struct tracepoint { 2 const char *name; 3#define TP_STATE_DISABLE 0 4#define TP_STATE_ENABLE 1 5 int state; 6 7 // 并非用于注册hook的函数，而是注册hook时的hook 8 int (*reghook)(void); 9 void (*unreghook)(void); 10 11 // 在tracepoint触发时将调用的hook 12 struct tracepoint_hook *hooks; 13};  name: 是该 tracepoint 的名称 state: 用于控制其开关状态 hooks: 是一系列的函数指针，当 tracepoint hit 时，这些函数会被依次调用 reghook/unreghook: 在注册/注销 hook 时将被调用，可以用来输出一些提示信息  为了提供对 tracepoint 操作的接口，定义一个 tracepoint 时，会同时定义一系列功能函数, 包括：\n 放在内核代码之中的插桩函数；其被调用说明 tracepoint hit， 如果 enable 状态， 则依次执行其 hook 用于注册 hook 的接口；为该 tracepoint 添加新的 hook 注销某个 hook 的接口；  tracepoint 工作原理 类似于一般的日志记录函数， 在合适的位置放置trace_##event()作为“插桩”，运行到 此处代表该做一些事了，至于做什么事不是 tracepoint 该管的。它只能负责提供给你一些接口 ，让你能把“做事”的函数与 tracepoint 联系起来，到时候触发时调用它们。\n这就是上面说的，tracepoint 仅负责 data source 这一部分。\n小结 下一节将介绍如何 Linux trace system 中的数据记录组件，毕竟每次触发都输出到控制台还是 太乱了，而且不是 trace 这个系统的工作内容（log 系统应该是干这个的）。\n","date":"2023-04-23T23:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/trace/tracepoint/","section":"posts","tags":["linux","Operating System","trace"],"title":"Linux Trace(1): Tracepoint"},{"categories":["Architecture"],"contents":"从进入 IRQ/FIQ 中断向量开始，中断处理的完整流程:\n 保存上下文 切换中断栈，为进入“真正的”中断服务程序做准备 执行真正的中断服务程序 恢复之前的上下文  “真正的”中断服务程序 “真正的”意为不算那些对于所有异常、中断来说都相同的“套话” ，只讨论对于中断特有的行为。\n承认一个中断 真正的中断服务程序从接受 CPU Interface 传来的中断 开始算起，这一步的实现通过读取ICC_IAR1_EL1, 返回当前 中断的 INTID。\n拿到 INTID 后，就根据不同的 ID 调用各自对应场景下的服务函数， 比如若 INTID 是对应与时钟中断，那么此步需要清楚状态寄存器、 重新开启时钟定时器。\n标记中断处理完毕 做完相干的事情后，需要将该中断标记为已完成，方便后面的中断进来， 也就是上一节说的优先级下降和中断失效过程。\nGICv3 支持将这两步合为一次操作，实际我们也是这样做的，通过写入 ICC_EOI1_EL1寄存器来完成标记处理完成。此中断的状态也就从 active-\u0026gt;inactive.\n 中断服务程序中，承认中断和标记完成两步操作应该是用 while 循环 包裹起来的。\n反复的读取 IAR、标记中断已完成\u0026hellip; 如果此时该 CPU 上已经没有 中断待处理了，读取 IAR 会返回特殊 INTID: 1023\n 中断的上下部机制 中断服务函数的停留时间应该越短越好，否则影响其他任务占用 CPU，这是老生常谈的。\n以上观点存在的原因是：中断服务函数中是关闭中断的，CPU 只有串行的处理完当前 中断后， 才能继续做下一件事情，即便是高优先级任务也得等待，因为时钟中断被关闭！\n所以 Linux 在 2.6 引入了中断的上下部机制，将整个中断服务函数拆分为上部和下部:\n 上部：那些不能被打断的步骤，比如保存上下文，承认和标记中断完成等 下部：宽松的管理方式，执行过程就算被打断也没关系，指的就是上面说的对应各自中断 应用场景下的服务函数，比如一个按键触发代表的实际行为  ARMv8 如何支持中断上下部 ARMv8 中，进入异常向量是自动关中断的，可执行msr DAIFClr, #imm来手动开启。\n所以说，直到手动开中断之前的所有操作都属于中断的上部。\n那么，应该在何时开启中断呢？我认为分割后的正确中断处理流程应该是：\n 承认一个中断 根据 INTID 标记其应该做的行为，注意只是标记 标记该中断完成 待该 CPU 上的所有中断都完成后，开中断 遍历检查所有标记，如果有待完成的任务在此时执行  上面说的标记和执行过程可以用许多方式实现，包括 softirq, tasklet, workqueue 等， 都属于实现中断上下部机制的实现。\nsoftIRQ softirq 定义了一些中断事件和处理函数，在中断的上半部中，如果 INTID 属于定义的软中断 之一， 则添加标志其处理函数需要被执行，只是标志，并不实际执行。\n当中断服务程序退出之前，会遍历软中断列表中的状态，如果有需要处理的，则调用注册的处理函数。\n注意，软中断处理函数的执行是在中断上下文中，用户进程只能等待中断完成才能有机会被调用， 所以软中断的一个问题是， 如果需要执行的处理函数过多，会导致一般线程长时间不能被调度。\n同样地，因为处理函数的执行在中断上下文，所以也不能执行可能导致进程睡眠的操作， 例如申请锁，可能导致优先级反转。\ntasklet workqueue ","date":"2023-04-13T23:51:49+08:00","permalink":"https://wangloo.github.io/posts/armv8/gicv3/3/","section":"posts","tags":["armv8"],"title":"ARMv8 中断管理(3): 中断服务程序"},{"categories":["Operating System"],"contents":"抢占的含义 抢占指的是强制使一个任务让出 CPU 给其他任务。\n抢占是调度器做的，每次执行schedule()就可能发生一次抢占，所以 抢占发生的地点是内核，也就是schedule()的执行环境。\n用户抢占 与内核抢占相对应的是用户抢占，用户抢占不是指抢占发生的地点，因为 上面说了抢占发生的地点一定是内核。\n所以用户抢占的含义是：抢占的时机是用户态，换句话说就是抢占发生之前， 系统正处于用户态。\n用户抢占的经典场景是时钟中断，用户进程 1 执行的好好地，被时钟中断打断 然后中断返回时执行重调度，选择了新的用户进程 2。其他的可能用户抢占的场景 还有系统调用返回时， 总之是内核返回用户态时都会发生用户抢占。\n内核抢占 启用内核抢占增加了系统中发生抢占的点，即抢占前系统正处于内核。\n当一个进程正处于内核态执行任务时，比如执行mmap()系统调用的任务，在 未开启内核抢占的情况下，中断返回时只可能继续执行当前进程的任务，不会 发生调度。\n当启用内核抢占时，上述情况下若发生中断，系统在退出中断后，即使此时不是 返回用户态，也可以执行schedule()，即可以发生抢占。此之谓内核抢占。\n抢占发生的条件 启用内核抢占之后，其实抢占的过程也不区分用户态和内核态，只要满足条件都会 执行schedule()。\n执行重调度的条件有两个:\n 是否需要重调度? 是否可以重调度?  是否需要重调度也就是何时执行schedule()的问题，大概包含以下的场景:\n 时钟中断 新进程创建 修改进程的 nice 值 中断返回内核态 内核恢复为可抢占(下面会介绍)  然而有一些情况不可以重新调度，比如内核中一些关键的步骤，那些不能被打断的 原子操作。\n在关键步骤之前，需要调用preempt_disable()，此时 linux 会在 tcb 中会改变 preempt_count的值，这个操作不是关闭中断，而是在中断返回时即使有更高优先级的其他进程， 只要该值不符合要求，重调度也不会发生。\n关键步骤执行完，调用preempt_enable()，此时为了去满足关键区域内可能 有新加入的高优先级进程，会调用一次重调度，这也正是上面所说需要重调度的场景之一。\n","date":"2023-04-13T23:51:49+08:00","permalink":"https://wangloo.github.io/posts/os/linux/schedule/kernel_preempt/","section":"posts","tags":["linux","Operating System"],"title":"Linux 内核抢占"},{"categories":["Architecture"],"contents":"一个中断完整的生命周期大概包括:\n 产生中断 中断分发: by Distributor or Redistributor 中断传递: deliver to CPU Interface 中断激活: pending-\u0026gt;active 优先级下降: priority drop 中断失效: active-\u0026gt;inactive  中断的产生 外设传来中断信号，或者处理器触发 SGI， GIC 此时将该中断标记为pending状态。\n中断的分发 中断生命周期中的重要部分，根据中断的类型不同可能由 Distributor 和 Redistributor 负责分发工作。\n分发器查配置得到此中断的优先级，目的 CPU 等信息。此时可能有多个中断想要发往同一 CPU， 优先级决定先分发哪个中断。将其顺利分发目的 CPU 的 CPU Interface\n中断传递 CPU Interface 做最后一步检查，是否满足优先级屏蔽? 是否符合抢占条件?\n如果条件都满足，给 CPU 一个信号，CPU 准备激活中断\nTODO: 关于running priority 和 highest pending priority的解释\n中断激活 CPU 此时将触发 IRQ/FIQ，执行对应的中断服务程序。\n中断服务程序中需要显式的执行一些操作将中断状态由 pending 置为 active。\n 异常向量（中断处理函数）的详细步骤见下一节\n 优先级下降和中断失效  优先级下降和中断的失效可以配置为同时发生，实际中我们也是这么使用的。\nTODO: 何种情况下需要将其分开？\n 中断服务函数结束后，需要执行一些额外的步骤来使中断失效，便于在该 CPU 上 pending 的其他中断能够进来。\n优先级下降意味着降低抢占的优先级限制，允许 CPU 上等待的其他中断进来。\n然后执行中断失效过程，将其状态由 active-\u0026gt;inactive， 至此中断的整个生命周期结束。\n小结 中断激活到中断失效的整个过程都属于中断服务程序的部分，由开发者显式控制， 将在下一节进行介绍。\n","date":"2023-04-12T23:51:49+08:00","permalink":"https://wangloo.github.io/posts/armv8/gicv3/2/","section":"posts","tags":["armv8"],"title":"ARMv8 中断管理(2): 中断的生命周期"},{"categories":["Architecture"],"contents":"ARMv8 中断系统的架构 GIC 的输入为许多的中断线，但输出到 CPU 的只有 IRQ 和 FIQ 两种， 所以就要由 GIC 做中断的分发和过滤工作。\n总体来说，整个中断系统架构从底向上可分为三部分:\n 硬件接口；外设的引脚 中断控制器；桥梁，向下提供引脚连接外设，向上连接 CPU 在合适的时间 触发中断信号，充当中断系统的主管 中断处理函数；GIC 将中断信号传递到 CPU 后，CPU 执行中断处理函数  1+-----------+ +-----------+ 2| Process | | Process | 3+---------+-+ ++----------+ 4 | | 5 +-+--------+----+ 6 | | 7 | GIC | 8 | | 9 +-------+-------+ 10 | 11 +-------------+----------+ 12 | Peripheral Device | 13 +------------------------+ 中断控制器 GICv3  GIC 的有许多版本，本文皆以 GIC version3 为例介绍, 简称为 GICv3\n 如上所述，GIC 在中断系统中充当“管家”的作用。如果将 CPU 比作老板， 到来的中断比作约见老板的员工，那么 GIC 就是秘书，统筹安排何人何时 与老板谈话。\nGICv3 的组成大概可分为 3 部分:\n Distributor Redistributor CPU Interface  如果将上面架构图中的 GIC 拆开，大概的结构如下图所示。能够注意到除了 GIC 被细分外，外设中断源也划分为两部分，在下面中断分类中会详细 介绍。\n1+----------------+ +----------------+ 2| Process | | Process | 3+--+----------+--+ +--+----------+--+ 4 | CPU | | CPU | 5 | Interface| | Interface| 6 +----+-----+ +----+-----+ 7 | | 8 +------+-------+ +------+-------+ 9 | Reditributor | | Reditributor +-----+ 10 +----------+---+ +--+-----------+ | 11 | | | 12 +---+-------------+-----+ | 13 | | | 14 | Distributor | | 15 | | | 16 +-----------+-----------+ | 17 | | 18 +---------+--------+ +-------+---------+ 19 |Peripheral Device | |Peripheral Device| 20 | (SPI) | | (PPI) | 21 +------------------+ +-----------------+ Distributor 负责全局中断的分发\nRedistributor Redistributor 是 GICv3 相较于 v2 新引入的部件，在我看来，引入 Redistributor 的 主要原因是: 提高中断相应的效率。 在以前，无论是全局中断还是私有中断都是通过一个 Distributor 分发，如果中断到来的比较频繁，则可能产生延迟。\nRedistributor 就主要负责私有中断的分发，减轻了 Distributor 的负担。\nCPU Interface 物理结构上依附与 CPU，而不是 GIC。主要负责控制中断被 CPU 接收的过程， 即中断状态 pengding , active, inactive 的切换。\n同时， CPU Interface 还负责优先级的过滤，只有符合优先级条件的中断才会被 CPU 响应。 相关的寄存器有ICC_PMR_EL1，ICC_RPR_EL1等\n中断抢占的配置也是由其完成，详见ICC_BPRx_EL1寄存器。\nGICv3 Affinity Rounting GICv3 以前都是用 target-list, 来设置中断到达的目的 CPU，这种方式类似于位图， 以前只有 8bit 来做这个，所以采用 GICv2 的系统最多支持 8 个 CPU。\n而 GICv3 引入了 Affinity value 来支持更多的 CPU，类似于 IP 地址的方法，用 4 个 8bit 来标识。可以写作a.b.c.d\n c: 一般是指某个 cluster d: 转发时会填入 target-list，指定多个 CPU，最多 8 个(下图的形式还没有将d转为targetlist)      所以用 Affinity value 虽然能指定大于 8 个 CPU，但是一次只能发往一个 cluster 内的最多 8CPU。\n GICv3 中断的分类与标识 在使用 GICv3 的系统上，中断被划分为 4 种类型:\n spi: 全局的中断，可以被路由到任意的一个或多个 CPU。一般对应所有 CPU 共用 的外设，例如串口中断。 ppi: 每个 CPU 私有的中断，只能被路由到该 CPU。对应与 CPU 私有的外设中断， 例如 CPU 内部定时器中断。 sgi: CPU 触发的中断，可以被路由到任意 CPU。一般用于核间通信使用。 lpi: message-based interrupts 这里不做介绍.  中断标识: INTID CPU 如何区分当前来的中断是来自哪个外设的中断信号? 答案是通过 INTID，它是 GIC 定义的中断标识符，CPU 通过读取寄存器ICC_IAR1_EL1就能得知当前处理中断的 INTID。\nINTID 按照中断类型分类的, 对照表如下:\n   INTID 中断类型 Note     0-15 SGI 本地的, 不同 CPU 可使用同一中断号代表不同中断   16-31 PPI 本地的   32-1019 SPI 全局的   1020-1023 特殊中断    1056-1119 扩展的 PPI 本地的   4096 – 5119 扩展的 SPI 全局的     扩展中断号的最大值是实现定义的, 可以在GICD_TYPER.IDbits中读取。\n 特殊中断号  特殊中断不需要 end of interrupt or deactivation 过程.\n   1020:\n  1021:\n  1022:\n  1023: 读ICC_IAR1_EL1 返回该值表明当前的 CPU 上没有待处理的中断， 编程时可当做while退出的标志\n  小结 这节主要总结 ARMv8 中断系统的总体架构和 GICv3 的组成结构，下一节将介绍 一个中断的生命周期，即中断的状态转换，以及在此过程中各个组件的作用。\n","date":"2023-04-12T21:51:49+08:00","permalink":"https://wangloo.github.io/posts/armv8/gicv3/1/","section":"posts","tags":["armv8"],"title":"ARMv8 中断管理(1): 架构与GICv3"},{"categories":["Architecture"],"contents":"有了虚拟内存系统之后，MMU 可以抽象出一些可配置的内存属性。\n例如，配置某个虚拟内存区域为不可执行、不被 cache 等，不可执行的属性 有助于防范攻击，不进入 cache 经常划分给外设 Memory-mapped 区域。\n内存属性和内存类型 首先，我们没法直接设置内存类型，我们能设置的是一些细粒度的内存属性字段， 比如说权限(WRX)、cacheable、shareable 等。\n我们说的内存类型也就是某些有意义的属性字段相互组合，ARM 给出了两种内存类型: 普通内存和设备内存。\n  普通内存会启用架构提供的所有优化技术，例如合并访存、乱序执行等。所以 普通内存有最高的性能，但同时不是那么的“安全”，需要底层人员手动使用 内存屏障等手段保证某些情况下的顺序性要求。\n  设备内存，顾名思义，常映射到外设的 Memory-mapped 区域。对于设备来说， 那些提高性能的技术会造成一些问题，例如某些寄存器的配置必须按照顺序， 这时就不能使用乱序执行。设备内存就牺牲了性能，优先保证正确性。\n  配置内存类型也是通过页表项中的其中一个属性字段: AttrIndx[2:0], 它与系统寄存器MAIR_EL1配合实现。\n具体表现为: mair_el1寄存器被划分为 8 个字段，我们为每个字段写入 不同的值可代表不同的内存类型和一些配套属性，具体的真值表可以参见 mair_el1寄存器的描述。\n mair_el1中内存类型配套属性只是属性的一部分，是和设备类型绑定的那部分。\n cacheable\u0026amp;shareable 傻傻分不清 先说 cacheable，一段内存被设置为 non-cacheable 属性说明不会进入 cache， inner-cacheable 是实现定义的，可能指进 L1 cache/L2 cache， outer-cacheable 说明会进入 L3 cache。\n要注意，只有普通内存才支持配置是否进入 cache，所有的设备内存需要 non-cacheable。\n 内存支持配置为是否被 cacheable，这在mair_el1的字段中配置。\n shareable 说的是一块内存的外部可见性，外部不可见并不是真的看不到，只是说不保证值的正确性。\nshareable 属性和 cacheable 其实是有关联的，他们俩比如配合使用，不能随便设置:\n 如果一块内存是 cacheable 的，则需要硬件提供 cache 的一致性维护机制。 如果不能保证 cache 的一致性，想要启用 shareable 就必须是 non-cacheable 对于 non-cacheable 的内存，一定是 shareable 的， 不需要配置。因为此时对数据的修改直接操作内存，读取操作亦是如此，一定 是外部可见的  如何设置内存属性  相关内容可以在 ARMv8 arm 手册 D5.3.3 Attuibute fields in stage 1 VMSAv8-64 Block and Page descriptors 中找到参考\n 对于每一个表示内存块(block)的页表项，都有两个属性字段: lower attr 和 upper attr.\n以下任何类型或者属性的设置都是通过这两个字段完成的。\n","date":"2023-04-12T08:01:33+08:00","permalink":"https://wangloo.github.io/posts/armv8/memory_attr/","section":"posts","tags":["armv8"],"title":"AArch64 内存属性与内存类型"},{"categories":null,"contents":"为什么写 因为平常的工作中很少用到python, 但是不得不承认 python是一门优秀的语言, 对于我目前要准备秋招的情况来看, 有的公司做题如果支持python那会简单很多, 同样的代码,用C写要100行, 换到python最多30搞定.\n有人说C++也可以啊,而且对于常用C的人来说学习门槛更低, 但是我实在是受不了 C++的语法, 包括但不限于模板、迭代器，STL操作，感觉有点四不像的味道。 当然，这只是我的个人习惯，使用C++的人也是很多的，还是根据自己的习惯 选择一套趁手的工具比较好。\n因为我其他时间基本都在用C，所以在本篇文章中我会更多拿C来进行比较，这样更好记忆。\n我学习 Python 的知识点来源:\n 《Python 学习手册 第 4 版》李军等 UCB CS61A  列表 list 列表支持下标索引，所以它就像C语言中的“数组”，列表支持大小动态增长，所以更像“数组plus”，类似C++中的vector吧（不太确定）。\n列表支持定长声明或变长声明，像创建一些flag列表，用下标进行查找时，定长创建就是必要的。\n相关操作 创建一个列表 以下的创建操作都是支持的:\n1# 创建一个空列表 2lst = [] 3# 创建一个带有初值的列表 4lst = [1, 2] 5# 创建二维空列表 6# 应用的场景是: 按照索引来修改list, 此时如果单纯的初始化list=[], 7# 那么对list[1].append()会提示超出范围. 所以我们要提前规定list的长度, 8# 即将list声明为目标长度的二维list. 9lst = [[] for _ in range(5)] 10# 创建定长列表并附初值 11lst = [0 for _ in range(5)] 12# 创建二维定长列表并附处置0 13lst = [[0 for _ in range(5)] for _ in range(5)] 以下的方式是错误的! 因为每个子列表都指向同一个对象, 修改一个会同步其他的\n1lst = [[]] * 5 List 的高级构建方法，充分利用python的灵活性:\n1\u0026gt;\u0026gt;\u0026gt; odds = [1, 3, 5, 7, 9] 2\u0026gt;\u0026gt;\u0026gt; [x+1 for x in odds] 3[2, 4, 6, 8, 10] 4\u0026gt;\u0026gt;\u0026gt; [x for x in odds if 25 % x == 0] 5[1, 5] 其他操作  直接使用 +, *运算符实现多个列表的组合, 与字符串类似 append: 为列表增加一个对象(末尾) pop(pos): 删除列表中的某个元素(按位置)，并返回其值 insert(pos, val): 在列表的任意位置插入对象 remove: 删除列表中的某个元素(按内容) 多级列表是被支持的，像二维数组一样，但是操作比较复杂，一般不使用内置的列表来实现。 \u0026hellip;  Python 内置类型 实例的类型可以通过内置函数type()来查看。\n字符串 定义一个 python 字符串\n1S = \u0026#39;Spam\u0026#39; 支持索引其中元素，也支持反向索引（即从右边开始计算），一般来说负的索引号会简单地与字符串的长度相加。\n1\u0026gt;\u0026gt;\u0026gt; S[0] 2\u0026#39;S\u0026#39; 3\u0026gt;\u0026gt;\u0026gt; S[-1] 4\u0026#39;m\u0026#39; 5\u0026gt;\u0026gt;\u0026gt; S[len(S)-1] 6\u0026#39;m\u0026#39; python 也支持字符串分片操作，左边界的默认值为 0，右边界的默认值为字符串的长度。\n1\u0026gt;\u0026gt;\u0026gt; S[1:] 2\u0026#39;pam\u0026#39; 3\u0026gt;\u0026gt;\u0026gt; S[0:3] 4\u0026#39;Spa\u0026#39; 5\u0026gt;\u0026gt;\u0026gt; S[:-1] 6\u0026#39;Spa\u0026#39; 字符串对于+操作符的表现是字符串的连接，这体现了 python 的多态性。 字符串创建后无法直接通过索引改变其元素，可以转而通过同名对象覆盖来实现：\n1\u0026gt;\u0026gt;\u0026gt; S[0] = \u0026#39;z\u0026#39; 2Traceback (most recent call last): 3 File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; 4TypeError: \u0026#39;str\u0026#39; object does not support item assignment 5\u0026gt;\u0026gt;\u0026gt; S = \u0026#39;z\u0026#39; + S[1:] 6\u0026gt;\u0026gt;\u0026gt; S 7\u0026#39;zpam\u0026#39; 字符串支持的属性，例如.find()可以通过内置命令 dir(S)来查看。\n dir 函数仅仅给出了方法的名称，如果想查询其具体使用方法，可以利用内置函数help(S.find)。\n string 的三种形式 Python 允许字符串被包括在单引号或者双引号中(它们的含义相同），它也允许在三个引号（单或双均可）中包含多行字符串常量，当 Python 脚本中嵌入像 HTML 这样的内容时，这是很方便的。\n1\u0026gt;\u0026gt;\u0026gt; msg = \u0026#34;\u0026#34;\u0026#34; 2... aaaaa 3... bbbbb 4... ccccc 5... \u0026#34;\u0026#34;\u0026#34; 6\u0026gt;\u0026gt;\u0026gt; msg 7\u0026#39;\\naaaaa\\nbbbbb\\nccccc\\n\u0026#39; 字典 键值对\n支持通过 key 索引来修改， 所以与字符串和列表不同。\n1\u0026gt;\u0026gt;\u0026gt; D = {} 2\u0026gt;\u0026gt;\u0026gt; D[\u0026#39;name\u0026#39;] = \u0026#39;Bob\u0026#39; 3\u0026gt;\u0026gt;\u0026gt; D[\u0026#39;age\u0026#39;] = 40 4\u0026gt;\u0026gt;\u0026gt; D 5{\u0026#39;name\u0026#39;: \u0026#39;Bob\u0026#39;, \u0026#39;age\u0026#39;: 40} 字典也支持嵌套操作，在 json 中常用\n字典的操作  keys() 返回 key 的列表 value() 返回 value 的列表 item(): 返回(key,value)构成的元组列表  字典的限制  在python3.6之前字典是 unordered, 即存储的顺序不按照加入时间; 而在python3.6+, 字典改为 ordered. key 是唯一的, 如果你想让一个 key 对应多个值, 将其 value 设置为 list 是一种方案! list 只能是 value, 不能是 key  元组 元祖像一个不可改变的列表\n1\u0026gt;\u0026gt;\u0026gt; T = (1, 2, 3, 4) 2\u0026gt;\u0026gt;\u0026gt; T 3(1, 2, 3, 4) 其专有的方法：\n index(x) 返回 x 所在元组中的下标 count(x) 计算 x 在元组中出现的次数   为什么要使用元组？ 一般来说，元组不如列表那样常用，因为它的不可被改变的特性。但是，这也赋予了元组天然的完整性约束，可应用在期望不会被改变的场景中\n 基础语法 iterator 1l = [1, 2, 3] 2k = iter(l) # 得到一个可以遍历的iterator 3next(k) # get 1 4next(k) # get 2 iterator 任何情况下都可以等价于一个 for 循环!\nlist 的 iterator 像是一个 list, 不同的是它存在一个\u0026quot;监视者\u0026quot;会记录你当前所在的位置, 使得你可以调用一些方法(next()) 来得到当前位置的元素, 并监视下一个位置的元素.\n当然, 不仅仅 list 有对应的 iterator, 对于其他数据结构来说亦是如此.\n 如果在遍历k的途中改变了遍历对象的结构(例如lst.append(4)), 该 iterator 将不可再用!\n所以以下代码的行为是错误的:\n1lst = [1, 2, 3] 2for item in lst: 3 if item == 1: 4 lst.remove(1) 可以专门创建一个 lst 的副本用于循环:\n1for item in list(lst): 2 ... 但修改其中的值不影响(例如lst[0] = 0)\n 另一个有趣的事情是: 如果使用list()方法创建一个 iterator 的 list, python 实际的行为是 调用next()直到结尾来得到元素并插入新的 list. 所以下面的代码行为就容易理解了:\n1t = iter([1, 2, 3]) 2list(t) # [1, 2, 3] 3list(t) # [] Python 内置功能函数 聚合可索引的类型 一些内置的功能函数可以将可索引的参数转换为有意义的数值. 例如 range, list 等.\nsum(iterable[, start]) 返回可索引的参数元素之和(不能是字符串), 加上 start(默认是 0). 当 iterable 为空时, 返回 start\n 为什么要有一个start? 使得如果输入字符串组成的列表(可以是其他可索引的数据结构), 会抛出异常. 详见下面实例\n 1\u0026gt;\u0026gt;\u0026gt; sum([2, 3, 4]) 29 3\u0026gt;\u0026gt;\u0026gt; sum([\u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;]) 4Traceback (most recent call last): 5 File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; 6TypeError: unsupported operand type(s) for +: \u0026#39;int\u0026#39; and \u0026#39;str\u0026#39; 其实现的原理是: 保证前面iterable中元素求和的结果与start的类型相同. 例如:\n1\u0026gt;\u0026gt;\u0026gt; sum([2, 3, 4], 5) 214 3\u0026gt;\u0026gt;\u0026gt; sum([[2, 3], [4]], []) 4[2, 3, 4] 5\u0026gt;\u0026gt;\u0026gt; sum([[2, 3], [4]]) 6Traceback (most recent call last): 7 File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; 8TypeError: unsupported operand type(s) for +: \u0026#39;int\u0026#39; and \u0026#39;list\u0026#39; max 1max(iterable[, key=func]) -\u0026gt; value 2max(a, b, c, ...[,key=func]) -\u0026gt; value key是用来预处理数据的, 默认为 lambda x: x\n其他特性 nonlocal声明 使用方法:\n1nonlocal \u0026lt;name\u0026gt; 效果: 在声明某个变量为nonlocal之后, 对其所有赋值语句, 都不会建立一个局部的绑定, 而是将该变量重新绑定到当前 frame 向上能找到的第一个非局部 frame中对该变量的绑定.\n简单来说, 就是对该变量的所有赋值操作都改为操作能找到的第一个全局(这个全局是相对的)同名变量. 当然, 如果找不到一个同名全局变量, 就抛出异常.\n下面的例子中, 如果在withdrew()中不将balance声明为 nonlocal:\n if 语句是可以通过的, 因为访问balance会找到当前 frame 的 parent, 即make_withdraw()中声明的balance. 而 python 处理赋值操作就不一样了. 他会默认将balance绑定到局部, 而 这就与 if 语句产生了冲突, 会抛出异常.  所以就需要nonlocal的声明, 告诉 python: 赋值语句也得去上面 frame 中找一个全局的.\n1# make_withdraw 建立一个银行账户, 并给出初始金额, 2# 其返回一个函数withdrew(), 调用该函数的行为是从 3# 银行账户里扣款 4def make_withdraw(balance): 5 def withdraw(amount): 6 nonlocal balance 7 if amount \u0026gt; balance: 8 return \u0026#39;Insufficient funds\u0026#39; 9 balance = balance - amount 10 return balance 11 return withdraw 12 13wd = make_withdraw(20) 14wd(8) Python 动态类型 对象的垃圾回收 在 Python 中，每当一个变量被赋予了一个新的对象，之前对象占用的空间就会被回收。\n1\u0026gt;\u0026gt;\u0026gt; x = 42 2\u0026gt;\u0026gt;\u0026gt; x = 3.14 3\u0026gt;\u0026gt;\u0026gt; x = \u0026#34;hello\u0026#34; 对象的引用值在此过程中被逐个回收，每次 x 指向一个新的对象，Python 将自动回收原来对象的内存空间。\nPython 使用引用计数来实现该功能。为每个对象维护了一个引用计数器，记录了当前引用该对象的变量数目，一旦计数值变成 0，则其空间被回收。\n深拷贝和浅拷贝 1L1 = [2, 3, 4] 2L2 = L1 产生的结果是， L1 是一个包含了对象 2、3、4 的列表，当然列表自身也是个对象。L1 是一个变量，引用了该列表的对象。运行 L2 的赋值操作后，L1 和 L2 引用了相同的对象。\n此时如果使用索引对 L1 列表的某个元素进行修改，由于 L1 和 L2 引用的是同一个对象，相当于 L2 也做了修改。这就是浅拷贝\n浅拷贝是默认的，如果你希望使用深拷贝，即拷贝对象，而不是创建索引。对于列表来说，可以使用分片来实现\n1L1 = [2, 3, 4] 2L2 = L1[:] 对于其他的内置类型，有的也可以用 X.copy()方法；而且标准库的copy模块有一个通用的赋值任意对象类型的方法，也有一个用于嵌套深拷贝的特殊方法。\n1import copy 2X = copy.copy(Y) # 只深拷贝top-level 3X = copy.deepcopy(Y) # 嵌套进行深拷贝 判断相等 基于上述深拷贝和浅拷贝的理论，就有关于 Python 中变量判断相等的方法。 Python 中有两种不同的方法检查变量是否相等：\n == 操作符：测试两个变量引用的对象是否具有相同的值 is操作符：检查对象的同一性，即是否指向同一个对象，是一种更加严格的相等性判断  字符串 特殊字符的转义 字符串中的\\n会被识别为换行符，与 C 语言类似，但 Python 不识别结束符(\\0)\n在字符串第一个引号之前输入r，会关闭转义机制，将反斜杠当做普通字符来保持。常用与 Windows 环境中打开文件\n1file = open(r\u0026#39;C:\\my\\path\\file.txt\u0026#39;, \u0026#39;w\u0026#39;) 索引和分片 分片的常见作用\n处理参数 在系统命令行中启动 python 程序时，获取附加的参数，需要使用内置的 sys 模块中的 argv 属性：\n1# file echo.py 2import sys 3print(sys.argv) 4 5% python echo.py -a -b -c 6[\u0026#39;echo.py\u0026#39;, \u0026#39;-a\u0026#39;, \u0026#39;-b\u0026#39;, \u0026#39;-c\u0026#39;] 通常你只对跟随在程序名后边的参数感兴趣，这就是分片的典型应用，sys.argv[1:]就能满足你\n处理文件 分片也常常用作清理输入文件的内容。如果知道一行会以换行符结尾，就可以使用line[:-1]，把这行去除最后一个字符之外的内容提取出来。\n 值得注意的是，去除换行符常常推荐采用line.rstrip方法，因为这个方法将会正确的处理最后一行的情况。\n 字符串和其他类型转换 字符串和整数\n1\u0026gt;\u0026gt;\u0026gt; int(\u0026#34;42\u0026#34;), str(42) 2(42, \u0026#39;42\u0026#39;) 字符和 ASCII 码\n1\u0026gt;\u0026gt;\u0026gt; ord(\u0026#39;s\u0026#39;) 2115 3\u0026gt;\u0026gt;\u0026gt; chr(115) 4\u0026#39;s\u0026#39; 修改字符串 字符串是不可变序列，即不能通过索引来修改。\n若想改变一个字符串，需要利用合并、分片这样的工具来建立一个新的字符串，并将结果赋值给原始字符串变量\n1S = S[:4] + \u0026#39;Bureger\u0026#39; 如果不得不对一个超长字符串进行多处的修改，为了优化脚本的性能和代码，可能需要将字符串转换为一个支持原处修改的对象，如 List\n1\u0026gt;\u0026gt;\u0026gt; S = \u0026#39;spammy\u0026#39; 2\u0026gt;\u0026gt;\u0026gt; L = list(S) 3\u0026gt;\u0026gt;\u0026gt; L 4[\u0026#39;s\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;y\u0026#39;] 对于 L 可以使用索引来修改，完成后需要将其转换回字符串，可以使用字符串的join方法来实现:\n1\u0026gt;\u0026gt;\u0026gt; S = \u0026#39;\u0026#39;.join(L) Python 中的 sprintf 1\u0026gt;\u0026gt;\u0026gt; \u0026#39;That is %d%sbird!\u0026#39; % (1, \u0026#39;dead\u0026#39;) 2That is 1 dead bird 字符串的方法 see Python standard manual\n列表 列表与字典都是其他对象的集合。\n列表能够完成 C 中结构体的工作，不需要手动实现。\nPython 中的列表是：\n 任意对象的有序集合 通过偏移读取 可变长度、异构以及任意嵌套 对象引用的数组。类似与 C 语言中的指针数组  列表实现 LIFO 在某些应用中，会使用列表的pop和append方法，实现快速的 LIFO 对战结构。\n字典 字典可以称作 Python 中最灵活的内置数据结构。字典当中的元素是通过 key 来存取，而不是通过偏移，类似 C++的 map。\n作为内置类型，字典可以取代许多搜索算法和数据结构。有时也能执行其他语言中的记录、符号表的功能，可以表示稀疏（多数为空）的数据结构等。\n字典的主要属性如下：\n 任意对象的无序集合 可变长、异构、任意嵌套 对象引用的散列表。字典的底层实现是散列表，一开始很小，根据要求增长。   列表和字典，不会经常用常量来创建，常使用动态方法\n 用字典模拟灵活的列表 列表对在其末尾外的元素赋值是非法的：\n1\u0026gt;\u0026gt;\u0026gt; L = [] 2\u0026gt;\u0026gt;\u0026gt; L[99] = 1 3Traceback (most recent call last): 4 File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; 5IndexError: list assignment index out of range 虽然你可以预先分配足够的大空间，但这种情况用字典更为方便。字典的 key 为整数时，可以效仿列表在偏移赋值时增长：\n1\u0026gt;\u0026gt;\u0026gt; D = {} 2\u0026gt;\u0026gt;\u0026gt; D[99] = \u0026#39;spam\u0026#39; 3\u0026gt;\u0026gt;\u0026gt; D[99] 4\u0026#39;spam\u0026#39; 5\u0026gt;\u0026gt;\u0026gt; D 6{99: \u0026#39;spam\u0026#39;} 好处是， 此时的 D 仅有一个元素，看上去好像是有 100 个元素。\n字典描述稀疏数据结构 字典创建的方法 共有四种不同的方案：\n1{\u0026#39;name\u0026#39;: \u0026#39;mel\u0026#39;, \u0026#39;age\u0026#39;: 45} 2 3D = {} 4D[\u0026#39;name\u0026#39;] = \u0026#39;mel\u0026#39; 5D[\u0026#39;age\u0026#39;] = 45 6 7dict(name=\u0026#39;mel\u0026#39;, age=45) 8dict([(\u0026#39;name\u0026#39;, \u0026#39;mel\u0026#39;), (\u0026#39;age\u0026#39;, 45)]) 上面四种方案建立的字典是相同的，它们分别应用与不同的条件：\n 如果你可以事先拼出整个字典，那么第一种是很方便的 如果你需要一次动态地建立字典的一个字段，第二种比较合适 第三种关键字形式所需代码量比较少，但是 key 必须都是字符串才行 如果你需要在程序运行时把 key 和 value 逐步构建成序列，那么用第四种  如今的 Python 代码中，第三种方式比较流行。\n","date":"2023-04-01T10:30:35+08:00","permalink":"https://wangloo.github.io/posts/python/basic/","section":"posts","tags":["Python"],"title":"Python 基础知识"},{"categories":["Operating System"],"contents":"Kconfig 介绍 Kconfig 是一个通用的配置系统，最初由 Linux 开发，提供了一种简单的可扩展的配置语言， 实现工程的模块化和可定制需求。\n在简单的工程中，或许我们使用简单的 C 语言宏就能解决问题，不必用到 Kconfig。 但对于大型项目，并不只是一个选项的开启和关闭，并不只是影响到源代码，还有基于 Makefile 的编译工作。并且，当可配置的选项增加时，开发者手动管理这些配置选项就显得不那么智能了。\nKconfig 的出现使得上述工作变得轻松：\n 在 build 前，我们可以使用图形化界面来选择此次构建启用了哪些编译选项, (menuconfig) 对于不同的厂商驱动，可以有不同的配置文件，厂商可以为我们提供一个默认的 config 文件，我们可以方便的应用这些默认选项进行编译, 或者基于这些默认选项进行改动，保存为自己的配置项文件(defconfig) 选项之间可以建立依赖关系，例如，只有 A 启用时，BCD 选项才有意义。对此 Kconfig 提供了一套简单上手的编辑语言  Kconfig 的使用必须配合 Makefile 进行，应该说，Kconfig 与 Makefile 结合是简化了 Kconfig 的使用步骤。\nKconfig 的使用方法 我们常用的功能大概包括：\n 使用一些默认配置文件来构建项目 自定义配置构建项目 将某套配置选项保存下来，方便下次使用  在分别介绍这些功能的使用方法之前，先得说明这些 Kconfig 中各种配置文件的用途了，还是比较容易混淆的。\n Kconfig: Kconfig 不仅在根目录，还可能存在于各级子目录下。里面的内容是整个 Kconfig 系统的所有配置项，以及每个配置项的默认值、描述等。如果想要添加、删除配置项，需要改动这个文件 xxxdefconfig: xxx 可以替换为任意字符，这些都是默认的配置项，通常由开发人员提供给使用者 .config: 这个文件存在于根目录下，我们可以叫他当前配置。可以把他当为服务与一次构建的“临时文件”，每次构建都是基于当前配置进行的 autoconfig.h: 由 Kconfig 系统根据当前构建使用的配置自动生成的头文件，C 源代码可以通过它来知道当前的配置情况  其实它们之间的关系不是那么复杂，到底是谁根据谁生成的谁，下面将要说明。\n使用默认配置(xxxdefconfig) 一般我们拿到一个 SDK，厂商会提供一些默认的配置项供我们使用。我们的使用方法一般是执行make xxxdefconfig，make 会调用 Kconfig 程序来读取这个 defcofig 文件，然后生成当前配置（即.config）\nxxxdefconfig中的配置项是需要和Kconfig文件配合的，其中的属性和值都是 Kconfig 中支持的配置项。并且，xxxdefconfig 不会记录 Kconfig 每个项目的值，只是记录那些非默认值的变化，这样大大减少了文件大小。\n 以上行为可以通过执行make xxxdefconfig后，查看.config和xxxdefconfig的文件差异来验证\n 改变当前配置 总是使用默认配置可不行，那么怎么修改当前配置呢? 一种显而易见的方法是修改defconfig或者.config，取决于你想你这次更改永远有效，还是只是这次编译有效，其实，最好不要改动厂商给的默认配置，你可以复制一份，然后进行修改。\n这里要介绍与 Kconfig 配合使用的工具——menuconfig，它为我们提供交互式的配置菜单，比面对 Kconfig 的语言来修改配置更加方便。可以把 menuconfig 理解为 Kconfig 的一个前端。\nmenuconfig 的使用方式是执行make menuconfig, 它会加载当前配置的内容（或者是 Kconfig 中定义的默认值），生成一个图形化的菜单，修改后还是保存为.config。每次构建都是使用最新的当前配置，就达到了临时修改配置的效果了。这不比直接修改.config方便多了？\n保存当前配置 有时，我们发现当前这个配置很好，想要将其保存为新的defconfig文件，这样不用每次都修改当前配置了。Kconfig 当然也支持这个功能，叫做savedefconfig。\n使用的方法是:make savedefconfig， 会将当前配置(.config)中的内容提取为一个 defconfig 的文件，保存的位置取决于 Kconfig 的配置（一般是conf.c的源码中），我们对他改个名字就成为自己的配置了。下次执行make xxxdefconfig 即可套用这一套配置\n其他的功能\u0026hellip; Kconfig 提供的功能很多，包括：一键启用所有的配置选项、最小的构建选项等等，但是不常用就不介绍了。\nKconfig 系统的工作原理 上面说道，Kconfig 的使用是需要配合修改 Makefile 的，在 Makefile 会增加几个目标: %defconfig, savedefconfig, menuconfig。 它们向上给用户提供选项，向下调用 Kconfig 系统的功能接口。\nKconfig 系统主要任务是由conf程序完成，它是一个 host 程序，负责解析 Kconfig，defconfig 等文件的内容，完成功能的实现。还有一个重要的程序是mconf，它负责实现 menuconfig 的功能。\n","date":"2023-03-28T16:15:03+08:00","permalink":"https://wangloo.github.io/posts/os/linux/kconfig/","section":"posts","tags":null,"title":"Linux Kconfig 概述"},{"categories":["C Language"],"contents":"枚举类型的优势 枚举类型完全可被宏定义替代，类如\n1enum Furniture { 2\tDOOR = 1, 3\tDESK, 4\tLOCK, 5} 与下面的代码等效\n1#define DOOR 1 2#define DESK 2 3#define LOCK 3 那么我们如何在两种设计方法中选择呢？在我看来某些情况下使用 enum 会有以下优势：\n 提高代码键入效率；仅适用于所需变量的值是连续的整数，就像上面的情况，可以只给第一个 DOOR 赋值，其余的值累加。如果首个变量的值要求是 0，甚至每一个都无需显式赋值 提高代码的可维护性；可以划定范围，编译器也会检查类型是否正确，偶尔会有用 提高代码的可读性；例如 DOOR, DESK, LOCK\u0026hellip; 都属于家具，均定义在 Furniture 中  枚举类型所占的大小 枚举类型所占内存的大小，即枚举变量的大小。\n由于枚举变量的赋值，一次只能存放枚举结构中的某个常数。所以 枚举变量的大小，实质是常数所占内存空间的大小（常数为 int 类型，当前主流的编译器中一般是 32 位机器和 64 位机器中 int 型都是 4 个字节），枚举类型所占内存大小也是这样。\n所以默认情况下，无论枚举变量的值是多少，都是占用 4 个字节。即执行：\n1printf(\u0026#34;sizeof(enum Furniture) = %d\\n\u0026#34;, sizeof(enum Furniture)); 输入的结果是 4。\n编译选项：-fshort-enums GCC 下关于这个编译选项的介绍：\n -fshort-enums Allocate to an enum type only as many bytes as it needs for the declared range of possible values. Specifically, the enum type is equivalent to the smallest integer type that has enough room. Warning: the -fshort-enums switch causes GCC to generate code that is not binary compatible with code generated without that switch. Use it to conform to a non-default application binary interface.\n 意思是说使用-fshort-enums 后，对改枚举类型所占空间的分配就会按照实际变量的占用空间，而非总是 4 字节。\n启用该选项之后，再打印它的 size 就会是 1，因为用 1 个字节就能表示所有枚举变量的值（DOOR=1，DESK=2，LOCK=3）.\n这个“1”不再是固定的，根据其中枚举变量值的不同，动态调整enum Furniture的大小。\n1enum Furniture { 2\tDOOR = 256, 3\tDESK, 4\tLOCK, 5} 再打印它的 size，结果为 2。因为值 256 无法用 1 个字节存下。\nenum 潜在的可移植性问题 看似好像启用该选项会节约一定的内存空间，是的。但它也有一定的缺点，其一就是可移植性问题。\n例如你编写的应用在编译时没有启用了该“优化”选项，默认采用 4 字节存储枚举变量。而链接的库文件在编译时却使用了“优化”选项，则库内部此枚举类型的大小可能为 1 字节。若此时恰好你有调用某个库 API，将 enum 变量作为参数进行传递，那么就会发生错误。\n为避免不同库和应用程序使用“优化”选项的差异造成潜在的危险，常用的解决方案是强制使 enum 变量占用 4 个字节，无论其是否开启“优化”。实现方式是在 enum 变量末尾添加一个成员 XXXX_END = 0xFFFFF，例如：\n1enum Furniture { 2 DOOR = 1, 3 DESK, 4 LOCK, 5 END = 0xFFFFF, 6} ","date":"2023-03-09T17:18:57+08:00","permalink":"https://wangloo.github.io/posts/c/enum/","section":"posts","tags":["c"],"title":"C 语言enum的使用"},{"categories":["C Language"],"contents":"函数指针 指针的数组 or 指向数组的指针? 1\u0026gt;\u0026gt; int (*p)[10] p是指针, 指向长度为10的数组. 加括号是为了强调p是一个指针, 区别包含10个指针的array. 2\u0026gt;\u0026gt; int *(p[10]) p是数组, 它的元素类型是int *, 加括号是为了强调p是数组. 3\u0026gt;\u0026gt; int *p[10] 等效于int *(p[10]) 程序的内存分布 我们写的高级语言代码最终会被编译成可执行文件被操作系统加载、执行。 ELF文件是由一个个section组成的，那么程序里的变量、指令都是如何排布的呢？\n   地址空间各部分 内容 是否与可执行文件相对应     代码段 所有的可执行代码, 属性一般为只读 是, 加载时直接映射   数据段 初始化非0的全局变量和局部static变量 是, 加载时直接映射   bss段 未初始化或初始化0的全局变量和局部static变量 是, 加载时需要清空   栈 局部变量, 参数传递等 无, OS分配空间, 编译器维护   堆 动态申请的空间 无, OS分配空间   常量区 定义的常量字符串等 是, 有时和代码段合并到一起     有的人喜欢说“静态区”这个概念，我也一直被忽悠不理解什么叫静态区。实际上就是表示 存储函数内部static变量的区域，本质上属于数据段的一部分。\n  static声明的全局变量，对于编译器来说有什么区别对待?\n除了预编译时不会建立符号外没有区别。\n  全局变量和局部变量可以重名吗？\n可以重名。因为局部变量用栈来相对索引就可以，不需要符号，也就不会产生冲突。 而全局变量都是用符号来索引的。默认访问的是局部变量，如果希望访问全局变量， 需要使用::val += 1;的语法。\n 灵活数组成员 Flexiable Array Member  C99支持的特性，目的是为了节约空间（灵活数组成员本身不占空间，见下输出） 使用灵活成员可以用于实现string结构，长度动态分配 灵活成员必须是结构的最后一个成员，且此结构体不能只包含一个灵活成员（最少俩） 使用了灵活成员后，就不能用结构体之间直接\u0026quot;=\u0026ldquo;赋值了，改用memcpy() 含有灵活成员的结构体不能嵌入其他结构体中  1#include \u0026lt;stdio.h\u0026gt;2#include \u0026lt;stdlib.h\u0026gt;3 4struct st { 5 int memb1; 6 int memb2; 7 int memb3[]; // flexiable array member 8}; 9 10int main(void) 11{ 12 13 printf(\u0026#34;sizeof struct st: %ld\\n\u0026#34;, sizeof(struct st)); 14 15 /* instantiate */ 16 struct st *st1; // 只能动态分配 17 int memb3_len = 10; 18 19 st1 = malloc(sizeof(struct st) + memb3_len*sizeof(int)); 20 21 /* use */ 22 for (int i = 0; i \u0026lt; memb3_len; i++) 23 st1-\u0026gt;memb3[i] = i; 24 25 for (int i = 0; i \u0026lt; memb3_len; i++) 26 printf(\u0026#34;st1-\u0026gt;mem3[%d] = %d\\n\u0026#34;, i, st1-\u0026gt;memb3[i]); 27 28 29 free(st1); 30 return 0; 31} 输出结果:\n1sizeof struct st: 8 2st1-\u0026gt;mem3[0] = 0 3st1-\u0026gt;mem3[1] = 1 4st1-\u0026gt;mem3[2] = 2 5st1-\u0026gt;mem3[3] = 3 6st1-\u0026gt;mem3[4] = 4 7st1-\u0026gt;mem3[5] = 5 8st1-\u0026gt;mem3[6] = 6 9st1-\u0026gt;mem3[7] = 7 10st1-\u0026gt;mem3[8] = 8 11st1-\u0026gt;mem3[9] = 9 基础架构 1// 函数指针 2\u0026gt;\u0026gt; int (*f)(int) 说明f是一个指向函数的指针, 加括号为了区别返回值为int*的函数 3\u0026gt;\u0026gt; f = function; 函数指针的赋值 4\u0026gt;\u0026gt; (*f)(x) 函数指针指向函数的调用, 可简化为f(x). 但是容易将f误认为是函数. 5 6// 函数指针的数组 7\u0026gt;\u0026gt; int (*(f[10])) (int) f是数组,元素为10个函数指针. 内层括号说明f是数组,外层括号说明元素类型是函数指针 8\u0026gt;\u0026gt; int (*f[10]) (int) 与上面等效. 但外层括号不能省略 9\u0026gt;\u0026gt; f[0] = function() 赋值 10\u0026gt;\u0026gt; (*f[0])() 指向函数的调用, 可简化为f[0]() 11 12// 返回函数指针的函数 13\u0026gt;\u0026gt; void (*signal(int sig, ...))(int); signal是一个函数, 参数有sig.... 它的返回值是一个函数指针, 指向任意返回值为void, 参数为int的函数. typedef帮助理解函数指针 signal()是一个系统调用, 用于告诉系统, 当某种特定\u0026quot;软件中断\u0026quot;发生时调用特定的程序. 它的真正名称应当是: Call that routine when the interrupt comes in.\n看signal()的原型, 非常复杂. 根据上面基础架构的铺垫, 可以看出signal()的返回值是函数指针, 同时它的参数也是一个函数指针. 且这两个函数指针所指向函数的返回值和参数相同.\n1void (*signal(int sig, void(*func)(int)))(int); 可以借用typedef表示通用部分.\n1typedef void (*sighandler_t)(int); 而后signal的声明就是人能看懂的了:\n1sighandler_t signal(int signum, sighandler_t handler); C语言标准 我们在使用C语言编程时很少有人告诉我们C语言各个标准的情况，于是我们在看见一些函数标定支持的C标准（例如仅支持C99及以后），内心不会有什么波澜。\n我们常见这些C标准：K\u0026amp;R C、ANSI C、ISO C、C89、C99、C11、C18。让我们补充点可能很少使用的知识吧。\n什么是K\u0026amp;R C？ 1978年，丹尼斯•里奇（Dennis Ritchie）和布莱恩•柯林汉（Brian ernighan）合作出版了《C程序设计语言》的第一版。书中介绍的C语言标准也被称作“K\u0026amp;R C”。\n最初的C标准与我们现在用的有较大差别，例如它竟然还不支持void类型！\n什么是ANSI C、ISO C、C89、C90标准？ 随着C语言使用得越来越广泛，出现了许多新问题，人们日益强烈地要求对C语言进行标准化。1983年，美国国家标准协会（ANSI）组成了一个委员会，X3J11，为了创立 C 的一套标准。经过漫长而艰苦的过程，该标准于1989年完成，这个版本的语言经常被称作ANSI C，或有时称为C89（为了区别C99）。在1990年，ANSI C标准（带有一些小改动）被美国国家标准协会（ANSI）采纳为ISO/IEC 9899:1990。这个版本有时候称为C90或者ISO C。综上，ANSI C、ISO C、C89、C90其实是同一种标准。\n这一版本的C就更接近我们平常使用的C了，大部分特性都引入了。\n什么是C99标准？ 2000年3月，ANSI 采纳了 ISO/IEC 9899:1999 标准。这个标准通常指C99。\nC99我们最常使用的新特性是：在源代码的中间位置声明变量。\n什么是C11标准？ C11标准是C语言标准的第三版（2011年由ISO/IEC发布），前一个标准版本是C99标准。与C99相比，C11有哪些变化呢？\n11、 对齐处理：alignof(T)返回T的对齐方式，aligned_alloc()以指定字节和对齐方式分配内存，头文件\u0026lt;stdalign.h\u0026gt;定义了这些内容。 22、 _Noreturn：_Noreturn 是个函数修饰符，位置在函数返回类型的前面，声明函数无返回值，有点类似于gcc的__attribute__((noreturn))，后者在声明语句尾部。 33、 _Generic：_Generic支持轻量级范型编程，可以把一组具有不同类型而却有相同功能的函数抽象为一个接口。 44、 _Static_assert()：_Static_assert()，静态断言，在编译时刻进行，断言表达式必须是在编译时期可以计算的表达式，而普通的assert()在运行时刻断言。 55、安全版本的几个函数：gets_s()取代了gets()，原因是后者这个I/O函数的实际缓冲区大小不确定，以至于发生常见的缓冲区溢出攻击，类似的函数还有其它的。 66、 fopen()新模式：fopen()增加了新的创建、打开模式“x”，在文件锁中比较常用。 77、 匿名结构体、联合体。 88、 多线程：头文件\u0026lt;threads.h\u0026gt;定义了创建和管理线程的函数，新的存储类修饰符_Thread_local限定了变量不能在多线程之间共享。 99、 _Atomic类型修饰符和头文件\u0026lt;stdatomic.h\u0026gt;。 1010、改进的Unicode支持和头文件\u0026lt;uchar.h\u0026gt;。 1111、quick_exit()：又一种终止程序的方式，当exit()失败时用以终止程序。 1212、复数宏，浮点数宏。 1313、time.h新增timespec结构体，时间单位为纳秒，原来的timeval结构体时间单位为毫秒。 什么是C18标准？ C18也称C17是于2018年6月发布的 ISO/IEC 9899:2018 的非正式名称，也是目前（截止到2020年6月）为止最新的 C语言编程标准，被用来替代 C11 标准。\nC17 没有引入新的语言特性，只对 C11 进行了补充和修正。\n​\n如何查看自己程序的C标准版本？ 使用宏__STDC_VERSION__可以输出当前使用的C标准版本，是一个长整型：\n1printf(\u0026#34;C std version:%ld\\n\u0026#34;, __STDC_VERSION__); 值与标准的对应关系：\n   标准 宏     C94 _STDC_VERSION_= 199409L   C99 _STDC_VERSION_= 199901L   C11 _STDC_VERSION_= 201112L   C18 _STDC_VERSION_= 201710L    ​\n如何指定按照某个标准执行编译？ 以下的介绍只针对GCC，我没有用过别的编译器。\nGCC中可以添加--std=xxx来指定C标准版本，常用的情况如下：\n1-std=c11 Conform to the ISO 2011 C standard 2-std=c89 Conform to the ISO 1990 C standard 3-std=c90 Conform to the ISO 1990 C standard 4-std=c99 Conform to the ISO 1999 C stand 5 6 7-std=gnu11 Conform to the ISO 2011 C standard with GNU extensions 8-std=gnu89 Conform to the ISO 1990 C standard with GNU extensions 9-std=gnu90 Conform to the ISO 1990 C standard with GNU extensions 10-std=gnu99 Conform to the ISO 1999 C standard with GNU extensions  默认情况下，我电脑上的gcc 5.4.0使用-std-gnu11\n 参考目录 https://blog.csdn.net/zhengnianli/article/details/87387268\nC Dialect Options (Using the GNU Compiler Collection (GCC))\n含糊不清的符号扩展 问题出在哪？ 下面一段代码会输出什么呢？\n1char c = 0xff; 2 3if (c == 0xff) 4 printf(\u0026#34;successful\\n\u0026#34;); 5else 6 printf(\u0026#34;failed\\n\u0026#34;); 答案是取决于不同的编译器设定：\n 当编译器将char识别为signed char时，该判断会失败。因为常数0xff被识别为int类型，所以编译器首先要对c进行符号扩展，判断语句c == 0xff此时等价于(int)c == 0xff。而对于signed char类型是扩展其最高位，即(int)c=0xffffffff，if判断失败。 当编译器将char识别为unsigned char时，判断成功。对于unsigned char类型总是扩展0。   注：gcc可通过添加编译参数 -fsigned-char/ -funsigned-char来指定编译器如何识别char\n 同样的问题也存在与位域(bitfiled)中，详见-fsigned-bitfields/-funsigned-bitfields参数。\n如何避免？ 在使用char类型时，根据情况写清楚unsigned/signed char就ok\n1unsigned char c = 0xff 2 3if (c == 0xff) 4 printf(\u0026#34;successful\\n\u0026#34;); 5else 6 printf(\u0026#34;failed\\n\u0026#34;); 右移和除法 你是否有听说过有符号数不能使用右移操作(\u0026gt;\u0026gt;)来代替除法？ 这篇短文会向你证明它，并尝试向你解释为什么。\nLogical Shift .vs. Arithmetic Shift 若你现在有二进制数x=1110B，对其施加右移操作，请问高位填0还是填1？\n逻辑移位不管造成的影响，总是用0来填充移位操作产生的空缺。但是这样简单的想法在一些情况总会出错。例如若上述x是有符号数，那么简单的填0就会造成错误，起码正负号出错了。\n算数移位支持有符号数的移位操作，在移位后使用符号位进行填充，结合补码的表示方法，就能实现正确的负数移位操作。\n总结来说：在有符号的场景下，使用算数位移；如果你能保证移位操作是无符号的，那么用逻辑位移也无妨.\nx86汇编代码中，shr代表逻辑右移指令，sar代表算数右移指令，我们可以通过以下C代码及其反汇编的结果来更好的理解逻辑移位和算数移位：\n1#include \u0026lt;stdlib.h\u0026gt;2#include \u0026lt;stdio.h\u0026gt;3 4signed int x = -3; 5unsigned int y = 3; 6 7int main() 8{ 9 x \u0026gt;\u0026gt;= 1; 10 y \u0026gt;\u0026gt;= 1; 11 return 0; 12} 1x: 2 .long -3 3y: 4 .long 3 5main: 6 push rbp 7 mov rbp, rsp 8 mov eax, DWORD PTR x[rip] 9 sar eax 10 mov DWORD PTR x[rip], eax 11 mov eax, DWORD PTR y[rip] 12 shr eax 13 mov DWORD PTR y[rip], eax 14 mov eax, 0 15 pop rbp 16 ret https://godbolt.org/z/K4M4Ko4c7\n实践出真知 在我作为一个初级程序员的认知中，/2和\u0026gt;\u0026gt;1是等价的，甚至一起还听说过后者能够优化代码的效率。但是今天我要告诉你， Definitely wrong!\n或许在遥远的古代，我们使用位移操作真的能够对代码进行加速，但是当下编译器已经足够聪明，如果你真的动手反汇编\u0026rdquo;/2\u0026ldquo;的代码，那么你就会知道编译器已经替你优化为了位移操作。\n更糟糕的是，我们要避免使用移位操作来实现除法或者乘法，不仅仅是因为这两者等价，实际上，他们并不是等价的！并且会造成错误！\n考虑如下的C语言代码：\n1#include \u0026lt;stdlib.h\u0026gt;2#include \u0026lt;stdio.h\u0026gt;3 4signed int x = -3; 5signed int y = -3; 6 7int main() 8{ 9 x \u0026gt;\u0026gt;= 1; 10 y /= 2; 11 return 0; 12} 他们的汇编代码是相同的吗？这里还是拿X86汇编举例：\n1; Following is ‘x \u0026gt;\u0026gt;= 1’ 2mov eax, #-3 ;x 3sar eax 4mov x, eax 5; Following is ‘y/= 2’ 6mov eax, #-3 ;y 7mov edx, eax 8shr edx, 31 9add eax, edx 10sar eax 11mov y, eax 注意：以上的汇编代码省去了一些我认为无关紧要的操作，并不是完全正确的，但是足够表达他们的差别了。\n可以看出，除法比移位多了一步shr edx, 31过程，下面会探讨这个。\n还有一件使你震惊的事件，x, y的值最终是不同的！是的，正是因为那条看似“多余”的shr指令。\n为什么结果不同 首先，我们可以确定的一件事是：编译器真的帮我们将除法操作优化为移位。所以，再也不要说你的代码中使用\u0026gt;\u0026gt;来替代除法是为了增加执行效率了。\n让我们来解释下为什么两者的结果是不同的。\n首先，sar指令在x86指令集中表示算数右移，这个是我们熟悉的，那么-3进行算数右移后的结果就是-2. 意味着\u0026gt;\u0026gt;是向负无穷舍入的.\n那么除法操作又是在干什么呢? 它是将原值加上其符号位.Demo中使用的数据类型是32位int.\n1shr edx, 31 2add eax, edx 这样做必然改变了原值啊，动手算一下就会知道，-3/2的结果为-1. 并且只有负奇数会受影响，对于正数，其符号为0；对于负偶数，其补码的最低位必为0，刚加上的1会被下一步的算数右移丢弃，不对高位产生影响。\nAha, 差别就是向负无穷舍弃还是向0舍弃，一时间竟然不知道哪个是正确的了。\n我们应该如何做 根据最新的[C语言标准草案](ISO/IEC 9899:201x (open-std.org)) 6.5.7章节，负数的右移操作是implementation-defined，即取决于具体的实现：\n The result of E1 \u0026raquo; E2 is E1 right-shifted E2 bit positions. If E1 has an unsigned type or if E1 has a signed type and a nonnegative value, the value of the result is the integral part of the quotient of E1 / 2E2. If E1 has a signed type and a negative value, the resulting value is implementation-defined.\n 因此，理论上它依赖于实现。所以我们在实际应用中为了程序的可移植性，应当避免对有符号数使用移位操作。除非你能确定它的值一定是非负数，在此情况下，请将它用无符号类型来声明。\n对于除法操作，标准中的6.5.5章节规定了，除法操作总是向0舍入. 非常好！\n When integers are divided, the result of the / operator is the algebraic quotient with any fractional part discarded.\n 检查你的代码，恢复所有的“优化”乘除法的行为吧！\n","date":"2023-03-09T17:18:57+08:00","permalink":"https://wangloo.github.io/posts/c/feature/","section":"posts","tags":["c"],"title":"C 语言的特点与难点"},{"categories":["C Language"],"contents":"头文件的引用形式 C 中引用一个头文件有两种形式 #include \u0026lt;\u0026gt;和#include \u0026quot;\u0026quot;，在应用开发中，需要引用一些系统库文件，我们通常使用\u0026lt;\u0026gt;，对于自己定义的头文件，我们会使用\u0026quot;\u0026quot;。\n然而对于底层软件的开发，比如说操作系统，用到的库都是自己工程中的文件，那么此时用\u0026quot;\u0026quot;和\u0026lt;\u0026gt;有时都能 work，那么它们的区别是什么呢？\n搜索相关关键词得到的结论是: 两种方式的区别是搜索文件的优先级， \u0026quot;\u0026quot;优先搜索的当前目录，而\u0026lt;\u0026gt;优先搜索系统库文件目录。对于这个系统库，即那些使用gcc -I\u0026lt;dir\u0026gt;参数指定的路径。 当然，如果第一优先级位置没有被找到，也会到另一个目录中搜索。这么两种方式均可，实际工程中也有部分人混合使用，毫不在意规则。但是有时会导致一些细节问题，比如说我们经常会用到-MMD或者类似选项生成目标文件的依赖，方便实现增量编译。此时就可能会产生一些问题。\n假设你有一个头文件inc/father.h, 它里面会引用inc/child.h, 对于根目录下的源文件main.c，其引用语句该如何写呢？以下列出的几种形式都可以，任意的排列组合\n1// 编译参数: -I. -MMD 2// main.c 3#include \u0026#34;inc/father.h\u0026#34;4#include \u0026lt;inc/father.h\u0026gt;5 6// father.h 7#include \u0026#34;inc/child.h\u0026#34;8#include \u0026lt;inc/child.h\u0026gt;9#include \u0026#34;child.h\u0026#34;10#include \u0026lt;child.h\u0026gt; 如果 main.c 是使用系统库路径(-I.)来找到的 father.h, 即上面 main.c 的第 2 种情况，那么其生成依赖文件的形式内容都是绝对路径，包括 father.h 中的引用（因为即便 child.h 是相对路径找到的，相对的也是 father.h，其基准就是绝对路径）。例如:main.o: main.c /home/xx/father.h /home/xx/child.h 否则即以相对路径找到 father.h,即上说 main.c 的第 1 种，那么生成 father.h 依赖的方式一定是相对路径，但 child.h 的形式却取决于其本身.  也就是说，如果 child.h 的寻找方式是绝对的（上面的第 1,2,4 种），那么依赖文件的形式就是main.o: main.c inc/father.h /home/xx/child.h. 如果 child.h 的寻找方式是相对的(上面的第 3 种)，那么依赖文件的形式是main.o: main.c inc/father.h inc/child.h    依赖文件的形式很重要，最简单的方式是均使用绝对路径，此时不需要考虑依赖文件在 makefile 中 include 的位置，也就是不需要考虑 make 的“当前路径”。如果非得使用相对路径，那么已经要确定能够 makefile 中 include 时的 make 当前路径就是生成依赖文件的路径，否则不能建立正确的依赖关系。\n实际上，在“基础架构”优秀的项目中，不可能出现或者尽量避免出来两种形式都能找到头文件的情况。比如说，我们会将源文件统一放在子目录src/下与头文件隔离，这样就从根本上避免了相对依赖的生成，只能通过系统库的形式来找头文件。拿上面的例子来说，正确的方式是：main.c 放入 src/中，然后不管是源文件还是头文件，都统一使用#include \u0026quot;inc/xxx\u0026quot;。这样做即统一，也能保证所有的依赖都是绝对路径形式\n 另外说一点，其实依赖文件(.d)中源文件的依赖项形式也是需要考虑的，这不能通过系统架构来解决，只能用 Makefile 的技巧来实现。比如说，我们的 make 当前目录总是根目录，而在建立 OBJS 变量时为其加上绝对路径的前缀， 从而 make 不需要进入各级子目录，生成的依赖文件也都是相对于根目录的，include 依赖文件的行为也是在根目录进行的，保证统一。\n 外部库的使用方式 最近我在开发项目是, 需要使用到 libelf 库, 我在 Github 上找到了其源代码.\n我之前使用一个 lib 都是以链接的形式使用动态库/静态库, 但是既然它提供了源码, 那么我可以直接将源码拷贝到我的项目中吗? 答案肯定是可以, 那么这两种方案该如何抉择呢?\n在查阅了一些资料后, 我总结了以下几个判断依据:\n 库的大小/对编译时间的敏感度; 如果使用源代码, 每次编译项目时需要额外对库文件进行编译(起码是第一次), 而库文件的定义是不常修改的, 如果库文件比较大, 则会延长整个项目的编译时间. 是否需要版本控制; 要使用的库如果需要区分版本, 或者分配给其他的团队成员使用, 那么用库的形式似乎更为方便 发挥 git submodule 的优势;   Ref: c++ - Should I add the source of libraries instead of linking to them? - Software Engineering Stack Exchange\n const 修饰符的妙用 有些时候, 我们设计的结构体中会有name字段, 类型是char *. 在使用时为它分配空间, 不使用时需要回收.\n其实还有另一种情况, 就是name要指向预先定义好的\u0026quot;static name list\u0026quot;, 适用于 name 的取值是确定的范围. 例如, libdwarf 库中的描述 section name 的dss_name 成员.\n这时, 为了防止使用者调用free()来释放它, 我们可以将其声明为const char *, 此时如果调用free(.dss_name), 编译器会给出警告:\n1const.c:16:10: warning: passing argument 1 of ‘free’ discards ‘const’ qualifier from pointer target type [-Wdiscarded-qualifiers] 2 16 | free(dss_name); 3 | ^~~~~~~~  实际上，不管是用const修饰什么变量或者形参， 都不会改变它的存储原理，该存在哪还是存在哪， const提供的仅仅是在编译时提供警示。\n ","date":"2023-02-27T19:20:20+08:00","permalink":"https://wangloo.github.io/posts/c/experience/","section":"posts","tags":["c"],"title":"C 语言程序设计的一些经验"},{"categories":["Operating System"],"contents":"使用VIM 打开一个文件时, 有时会看到例如 ^M 这类字符出现. 下面我会挖一下其出现的原因.\nEOL 字符 EOL 或者说 end-of-line 表示一个新行的开始.\nEOL 字符在不同的操作系统中是不同的. 本文中仅以 Linux 和 Windows 为例说明.\n Windows中是以读到回车\u0026lt;CR\u0026gt;和换行\u0026lt;LF\u0026gt; 表示 EOL. Linux 中仅以换行作为EOL    回车\u0026lt;CR\u0026gt; : Carriage return. 将光标回到行首, 对应C语言中的 \\r 换行\u0026lt;LF\u0026gt; : Line feed. 将光标下移一行, 对应C语言中的 \\n   在 Linux 中打开 Windows 下的文件将多余的回车通常显示成 ^M 或者 Control-M\nRef End Of Line Characters\n","date":"2022-12-24T01:35:24+08:00","permalink":"https://wangloo.github.io/posts/os/linux/end-of-line/","section":"posts","tags":["other"],"title":"行结束符在windows和linux的区别"},{"categories":["Operating System"],"contents":"我始终以为，C库中常用的 errno 仅是一个全局变量，使用了全局变量就无法保证线程安全了，因为全局变量在所有线程中都是共享的。\n要实现线程安全的errno 就必须将其设置为线程私有的变量，下面就来看看GCC是如何巧妙的实现的。\n正文 现在的errno定义并非一个全局变量, 而是一个宏定义, 以下是在usr/include/errno中的声明:\n1extern int *__errno_location (void); 2# define errno (*__errno_location ()) 这种方式下其实现原理大概是: __errno_location 函数返回一个int指针, 而这个函数的实现中, 返回的就恰好是实际的errno 变量(与宏同名)的地址, 所以对其解引用就相当于对其值进行操作. 所以, 这种定义规则下, 左值和右值表达式均成立.\n1errno = 10; // *__errno_location () = 10 2int x = errno; // x = *__errno_location (); __errno_location 的实现就至关重要, 因为如果其返回的变量地址不包含任何技巧的话, 就和原先直接定义全局变量的方式没差了, 说到底能否实现线程安全, 还得看实际保存errno的变量是否为线程独有的. 目前还没有发掘到其精髓, 只是套壳而已.\n以下给出/csu/errno-loc.c中__errno_location 的实现, 与我们预期一致, 返回变量的地址. 而同名变量errno则定义在/csu/errno.c中, 决定了能够实现errno的线程安全.\n1int * 2__errno_location (void) 3{ 4 return \u0026amp;errno; 5} 1__thread int errno; \u0026ldquo;__thread\u0026rdquo; 是GCC提供的扩展前缀, 表示该变量将被库处理为线程私有的, 注意这一步是C库完成的, 对程序员透明. 相关的理论叫 Thread-local Storage, AArch64 架构实现的原理是利用TPIDR_EL0 寄存器, 其他架构可以参考此PDF\n ❓ 以上源文件中有注释为 non-threaded版本的实现, 是代表什么含义呢?\n ​\n虽然我暂时没有查阅到errno的其他线程安全的实现原理, 但起码GCC下该方式这是可行的. 依靠的是\u0026quot;__thread\u0026ldquo;的支持, 与换成宏定义的方式无关, 不排除可能为了考虑兼容其他实现方式的可能性.\n参考 c - How is thread-safe errno initialized if #define substitutes errno symbol? - Stack Overflow\n","date":"2022-12-21T19:08:22+08:00","permalink":"https://wangloo.github.io/posts/os/errno_thread_safe/","section":"posts","tags":["Operating System"],"title":"操作系统：浅谈 errno 的线程安全问题"},{"categories":["Git"],"contents":"合并操作: git merge merge 有两种方式:\n fast-forward three-way merger  Fast-forward Merge 假设合并的双方为main为dev, 如果其中一个是另一个的祖先, 此时直接移动 HEAD 到前方即可, 称为 fast-forward.\n例如, 当前在 main, 执行git merge dev的过程如下:\n1 main main 2 | | 3M1 --- M2 ===\u0026gt; M1 --- M2 -- F1 4 \\ | 5 \\--- F1 dev 6 | 7 dev three-way Merge 合并的两者不构成直接的祖先-孩子关系, 产生了分叉. 此时进行合并就需要有个基准(参考), 对于两边相较于基准的每个 diff 来说:\n 合并的两者都在基准上进行了改动, 且改动不一致, 标记为冲突 如果该 diff仅在其中一方有改动, 那么就保留此次改动  合并时使用的参考就是两个合并 commit 的最近公共祖先, 这种借助三个 commit(main, dev, 公共祖先)才能完成的合并操作就叫做 three-way merge.\n例如, 当前在 main, 执行git merge dev的过程如下:\n1 main main 2 | | 3M1 --- M2 --- M3 ===\u0026gt; M1 --- M2 --- M3 --- M4 4 \\ \\ / 5 \\--- F1 \\--- F1 --- 6 | | 7 dev dev  three-way 的合并方式如果发生了冲突, 会产生一次额外的 merge commit, 下面介绍它\n 什么情况下 merge commit 没有任何 diff? 按照上面的例子, three-way merge 发生冲突后会产生一次额外的 merge commit, 即 M4. 如果这是去查看 M4 相较前一次 commit 的 diff, 有时是没有的, 有时又会产生 diff.\n如果在解决冲突的过程中, 我们仅仅是接收了 M2,M3 或者 F1 的修改, 那么此时 merge commit 就不会有 diff.\n然而, 在解决冲突时, 我们也可以不采用来自两条路径的修改, 做一次新的修改(可以说, 同时接收两条 diff 就是这种情况), 此时查看 merge commit 的 diff 就是有内容的.\n变基: rebase rebase 命令需要指定一个基准分支，git rebase \u0026lt;base-branch\u0026gt;， rebase 会将当前所处分支整体移动到base-branch之后，即改变了当前分支的历史。\n1// before rebase 2[A]---[B]---[C]---[D]\u0026lt;-dev 3 \\ 4 \\--[E]\u0026lt;-master 5 6// after rebase 7[A]---[E]---[B]---[C]---[D]\u0026lt;-dev 8 | 9 master 交互式 rebase 交互式 rebase 是一种更高级的用法。基础的 rebase 上面说了是将当前分支的所有提交移动到 base-branch 之后。而交互式 rebase 提供一个方法，在移动之前\u0026quot;挑选\u0026quot;当前分支的 commit。\n实际工程中，通常来说，我们将开发分支移动到 master 之前，可以经过交互 rebase 来整理开发分支中混乱的 commit 记录。\n具体的使用方法是，为git rebase指令提供-i参数:\n1git checkout dev 2git rebase -i master 这个命令会打开一个文本编辑器，列出当前 feature 分支的所有提交:\n1pick 33d5b7a Message for commit #1 2pick 9480b3d Message for commit #2 3pick 5c67e61 Message for commit #3 列出的内容就能完整的表示 dev 分支的所有提交，按照顺序。而我们不仅可以任意的重排这些 commit，而且修改pick关键字就能对这些 commit 做改动。举个例子，我们可能发现 commit2 只是对于 commit1 做了一个很小的改动，它们完全可以合并为一个 commit，那么直接 commit2 的pick修改为fixup，整个内容变为:\n1pick 33d5b7a Message for commit #1 2fixup 9480b3d Message for commit #2 3pick 5c67e61 Message for commit #3 当你保存并退出这个文件时，改动就会生效，不仅将 dev 整体移动到了 master 后，并且合并了前两个 commit。\n1// after rebase interactive 2[A]---[E]---[B]---[D]\u0026lt;-dev 3 | 4 master rebase 整理多个 commit 如上面交互式 rebase 所述，当你开发完 dev 分支，需要merge到 main 分支时，可以先利用交互式 rebase\u0026quot;整理\u0026quot;一下 dev 分支的 commit。\n这里其实要用到一个小 trick，上面说过 rebase 命令需要指定一个 base-branch，实际上是一个 base-commit，这种场景下我们不是要合并其他分支，所以base-branch可以选择当前 dev 分支的前面某一次 commit。\n1git checkout dev 2git rebase -i HEAD~3 以上指令实现的功能就是给你整理最后 3 次提交的机会，但不会合并其他分支的东西。\n那如果我想整理整个 dev 分支呢？是向上找到 dev 的第一次 commit 吗？ Git 提供了一个方便找到 dev 分叉出来的那次 commit，将其输出传递给git rebase -i即可实现整理整个 dev 的所有 commit。\n1git merger-base dev main git merege vs git rebase 准则   如果分支已经被提交到远程仓库，就不能再改变他的历史了，即不能使用 rebase。 git 也会阻止你这么做，因为分支的历史已经被修改，除非 force-push。\n  你能进行 rebase 的分支是本地的”私人分支”，私人表示为: 只有你自己在使用，别人不会基于你的分支做东西。\n  dev 同步主分支的改动: rebase 假设我们正在本地的 dev 分支开发一个特性，此时你的同事在 main(也可以是其他的远程分支)上提交了一个重要的 commit，以至于你需要它来继续你的开发任务。\n这种情况我们使用 rebase 和 merge 都能完成目标，但是 rebase 是更好的选择。\n 首先满足 rebase 的使用条件，我们仅仅是破坏了本地 dev 分支的历史，并没有动到其他的远程分支，所以就不存在干涉别人 其次，在 dev 上 merge 其他分支会产生一次不必要的merge commit，其不代表任何实际意义，没必要存在的  合并 dev 到主分支: merge 很简单的逻辑，主分支或者其他合作开发的分支并不是你一个人在用，并且需要最后同步到远程仓库，不符合使用 rebase 的准则\ngit log 参数:    Parameter Description     non-param 列出所有历史提交的 SHA、作者、提交日期和 commit   -p 按补丁显示每次更新，比\u0026ndash;stat 更全   \u0026ndash;stat 显示每次更新修改文件的名称及添加（删除）的行数。比\u0026ndash;name-only 更全   \u0026ndash;name-only 显示文件清单   \u0026ndash;name-status 显示文件清单及改动方式(新增、删除、修改)   \u0026ndash;oneline 只显示前 6 位 SHA 值和 commit   -n 显示前 n 条 log   \u0026lt;branch\u0026gt; 查看某个分支的历史提交。该参数只能 log 命令之后   \u0026lt;branch1\u0026gt;..\u0026lt;branch2\u0026gt;             参考网站：https://www.cnblogs.com/bellkosmos/p/5923439.html\nExample 1: 彩色显示重要信息 1git log --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit Example 2: 查看本地分支和对应远程分支的 commit 差异 1git log --oneline main..origin/main 子模块: submodule 新增一个子模块 (1) 将子模块上传到远端仓库上，或者使用已有的第三方项目\n(2) 执行\n1git submodule add [url] [path] (3) 此时看git status 会有两个changes，分别是：\n .gitmodules中会增加一条项目, 记录子模块的名称和地址 1[submodule \u0026#34;SubmoduleTestRepo\u0026#34;] 2 path = SubmoduleTestRepo 3 url = https://github.com/jzaccone/SubmoduleTestRepo.git  [子模块同名的文件]: 记录主项目追踪的是子模块的哪个commit   .gitmodule和子模块同名文件的作用\n  先说比较简单的.gitmodule，记录主项目中用到的所有子模块。 一般来说仅仅记录子模块的路径和url，但有时还会有指定的分支名。 这个我们在下面会介绍。\n  然后是和子模块同名的文件，我们想一下，上面的.gitmodules仅仅告诉了从哪来， 但是一个仓库是有多个分支，对应多个commit的，那么需要有一种方式去指定使用绑定哪个commit， 这就是同名文件的作用。在同名文件中会记录一下commitid，表明主项目依赖这个commitid下的子模块， 他们之间具有绑定关系。\n   (4) git add这两处改动，git commit -m \u0026quot;add submodule xxx\u0026quot;\nSubmodule Command Execute git submodule --help to get more info.\ngit submodule init 此命令clone新项目的时候会用到, 完整的命令是\n1git submodule init [path]  在详细介绍前需要说明两个文件的差别: .gitmodule和.git/config:\n .gitmoudles在上面已经介绍过一些，这里主要想说它是跟随主项目一起提交的， 而.git/config是后面生成的本地文件。 .gitmodules会给出列出所有子模块，但是不一定每次都全部使用。 **具体会启用哪些由.git/config文件规定。   git submodule init指令会指定生成.git/config文件的内容。 选择某几个子模块启用即写入.git/config。\n 在缺省参数下的含义是添加所有在.gitmodules中的子模块。 未来update指令只会更新.git/config中的项目。  git submodule update 刚才说了，因为.gitmodules中的所有子模块并不一定都使用， 所以新clone下来的项目并不会同时下载所有的子模块。 在上面的init阶段生成了.git/config来指定需要哪些之后， update命令就是用于下载指定的子模块。\n\u0026ndash;init 由于此命令配合init命令使用，两者通常连续操作，所以可以合并为:\n1git submodule update --init \u0026ndash;remote 一般情况下，下载子模块都是checkout到.git/config指定的commit。 --remote则会checkout到追踪分支的最新commit，下面会说到如何设置追踪分支， 默认是master。\n如果最新的commit不等于.git/config指定的，那么执行完该指令后会产生一次同名文件的改动。\ngit submoudle set-x 修改的是哪个文件？\n\u0026ldquo;x\u0026quot;可以是url，修改子模块的地址。\n这里我主要想着重介绍set-branch命令，将原来追踪自模块的方式由commit更改为(branch+commit)。 想要修改追踪子模块的commit到某个分支的最新，有两种方法:\n 传统方案 1cd lib1/ 2git checkout \u0026lt;branch\u0026gt; 3cd .. 4git add lib1 5git commit -m \u0026#34;change lib1\u0026#39;s tracked commit\u0026#34;  使用set-branch参数 1git submodule set-branch -b \u0026lt;branch\u0026gt; lib1/ 2# 改变设置之后，子模块不会立即变化 3# 必须指定带remote参数的update命令，才会用更新到显式指定的分支最新， 4# 而不是同名文件中规定的commitid 5git submodule update --remote 6git add lib1 .gitmodules 7git commit -m \u0026#34;change lib1\u0026#39;s tracked commit\u0026#34;    set-branch修改了.gitmodules, 也同步到了.git/config中。如果你想手动修改.gitmodules来设置分支，不要忘了submodule init来同步到.git/config\n 使用Submodule注意事项 1.Submodule到底是追踪分支还是commit 事实证明子模块默认追踪的不是分支，容易验证。 我们将子模块基于当前分支（假设master）新建一个子分支，并做一些修改， 可以看到主项目中的子模块同名文件也发生了改动。 所以说，它默认并不是跟踪分支。\n我感觉可以证明它默认跟踪的是HEAD。还是用上面的例子， 此时主项目中同名文件发生了改动。但是如果将子模块的分支切换回原来的master， 子模块同名文件的改动就消失了。以我目前的见解我暂且这么认为。\n2. 同名文件发生了修改，应不应该stage？ 分两种场景: (1)如果子项目的这些更新有意义同步到主项目中，那么就add并commit这个同名文件的改动， message为\u0026quot;更新submodule\u0026rdquo;。 (2)如若只是更新子项目而已，或许是为了其他依赖的项目所改的，并不 想涉及到本主项目，那么就restore此次更新，或者重新执行submodule update即可(前提是对子模块 的修改已经push)。\n所以说，同意主项目中的这次change的人必须是更新这次子模块的人，由他决定是否同步到主项目。 其他人甚至在使用期间都不需要cd进入子模块做git pull的，这样也就不会有决策产生，即便 子项目在远端更新了，你要做的就是关注那个同名文件就行，当同名文件更新了，在主项目中 submodule update即可，\n子模块的优缺点 TODO\n","date":"2022-12-13T17:39:42+08:00","permalink":"https://wangloo.github.io/posts/tools/git/git/","section":"posts","tags":["git","tools"],"title":"git 宝典"},{"categories":null,"contents":"..\nnm - 列出符号 nm (GNU Binary Utilities) (sourceware.org)\n","date":"2022-12-03T19:08:22+08:00","permalink":"https://wangloo.github.io/posts/os/gnu_tools/","section":"posts","tags":["Operating System"],"title":"GNU 二进制工具集"},{"categories":["Makefile"],"contents":"伪目标的依赖关系 Makefile 中的依赖关系指的是目标和依赖之间建立的关系，目标对应规则中的语句是否执行取决于依赖的状态。\n最简单的依赖关系可以拿两个文件来举例:\n1# gcc语句执行当前仅当 main.c 新于 main.elf 2main.elf: main.c 3 gcc main.c -o main.elf make 在执行main.elf的规则时，会先判断依赖关系。拿上面的例子来说， gcc 语句是否执行取决于main.c 和 main.elf的修改时间，只有当 依赖新与目标时，规则语句才会执行。\n然而许多情况下，目标或者依赖并不是一个文件，而是虚拟目标。虚拟目标 并不是一个文件，即它没有修改时间这个属性，此时 make 就不能作比较，结果就是 如果目标是伪目标，那么不管依赖如何都执行规则语句；如果依赖是伪目标， 那么目标的规则语句也永远被执行。下面是两个例子：\n1# 伪目标作为目标文件出现 2# build finish总是输出， 而gcc语句仅当main.c比main.elf新时才执行 3.PHONY : all 4all: main.elf 5\t@echo \u0026#39;build finish\u0026#39; 6main.elf: main.c 7\tgcc $\u0026lt; -o $@ 1# 伪目标作为依赖文件中出现 2# 不管main.c是否比main.elf更新，因为pre-work是伪目标 3# 所以gcc语句总是执行 4.PHONY : pre-work 5main.elf: main.c pre-work 6\tgcc $\u0026lt; -o $@ 上面的代码的效果是：两条规则中的语句都会执行，即使你并没有对 main.c 做任何修改！\n恐怖的空格 Makefile 中的变量结合很常见，例如$(FIXDEP)=$(FIXDEP_PATH)/build/fixdep.\n特别是当我们这些语句是从某些地方粘贴过来，要特别注意变量中是否有空格，Makefile 非常重视这个。假如$(FIXDEP_PATH)中有一个空格，那么$(FIXDEP)就变成两个宏了（不知道叫宏合不合适）。而且 Make 的执行过程很难检查出来。\n规则的执行顺序 如果不从命令行传入目标, Makefile 中定义的规则其实是以从上而下的顺序执行的, 但是我习惯把 all 这种默认规则放在最下面, 所以一般我们可以看到很多 Makefile 会在开头写一句规则all:, 作用就是告诉 make 默认(不显式指定)的目标是all.\n Busybox 根目录 Makefile 中的做法示例\n1# That\u0026#39;s our default target when \u0026gt;none is given on the command line 2.PHONY: _all 3_all:  函数的魔法 patsubst 1$(patsubst \u0026lt;pattern\u0026gt;,\u0026lt;replacement\u0026gt;,\u0026lt;text\u0026gt;) 功能：查找\u0026lt;text\u0026gt;中的单词（以空格，tab，回车，换行分割），看其是否符合\u0026lt;pattern\u0026gt;, 如果符合，将其使用\u0026lt;replacement\u0026gt;替换。可以使用通配符%。\n以下两对是等效的, 明显还是直接使用变量的替换语法操作简单:\n1$(patsubst \u0026lt;pattern\u0026gt;,\u0026lt;replacement\u0026gt;,$(var)) 2$(var:\u0026lt;pattern\u0026gt;=\u0026lt;replacement\u0026gt;;) 3 4$(patsubst %\u0026lt;suffix\u0026gt;,%\u0026lt;replacement\u0026gt;,$(var)) 5$(var:\u0026lt;suffix\u0026gt;=\u0026lt;replacement\u0026gt;) 使用 shell 变量 Make 将 $$var 转义为$var, 供 shell 处理.\ndemo(源自 6.828 根目录GNUmakefile):\n1handin-check: 2 @if test -n \u0026#34;`git status -s`\u0026#34;; then \\ 3 git status -s; \\ 4 read -p \u0026#34;Untracked files will not be handed in. Continue? [y/N] \u0026#34; r; \\ 5 test \u0026#34;$$r\u0026#34; = y; \\ 6 fi  以上 demo 还使用了 test 命令来终止 make 的执行, 如果用户没有输入y, make 将会终止执行\n 使用另一个 Makefile 常见的有三种方式， make -C, make -f 和 include\nmake -C \u0026lt;dir\u0026gt; 的作用等价与 cd \u0026lt;dir\u0026gt;+make, 常见于在一个工程 的主目录下，依次编译生成其他子目录的目标文件。有cd命令的效果，会切换 当前目录。\nmake -f \u0026lt;file\u0026gt; 更像临时使用某个 Makefile 来执行一些操作，在指定的 Makefile 中如果想使用之前的变量，需要export. 目前还没有发现有必要的 应用场景，大部分用include方式替代。\ninclude \u0026lt;file\u0026gt; 一般用于引入一些通用规则，就像 C 语言的 include 头文件 一样，变量无需export.\n","date":"2022-12-03T19:08:22+08:00","permalink":"https://wangloo.github.io/posts/c/make/makefile_tricks/","section":"posts","tags":["makefile"],"title":"Makefile 一些技巧"},{"categories":null,"contents":" ..\n环境变量相关 内存操作 网络操作 EMMC和SD卡 BOOT操作指令 bootm go 其他命令 启动相关\nmd\nmmcinfo\ncp\n","date":"2022-11-27T22:03:48+08:00","permalink":"https://wangloo.github.io/posts/os/uboot/commands/","section":"posts","tags":null,"title":"Uboot: 常用命令"},{"categories":["Shell"],"contents":"开发 mkfs.ext4 格式化文件为ext4分区\n1mkfs.ext4 \u0026lt;file\u0026gt; # 将file格式化为ext4 dd https://www.runoob.com/linux/linux-comm-dd.html\nmount 1sudo mount [file] [dir] # 挂载file到dir 2sudo umount [dir] 3sudo mount # 输出当前已经挂载的分区 通用 where and which which 查看可执行文件的位置\n1$ which python3 2/usr/bin/python3 whereis 除了可执行文件还能搜索其他类型的文件, 不常用, 详见 man whereis\n- 的妙用 一些命令支持使用 - 代替文件名, 输入输出都可以:\n 代替标准输出; 一些命令会将-o/-O 后面的-判定为输出到STDOUT, 详见下面示例. 代替标准输入;  下面给出两个同时代替输入输出的例子:\n1# 将标准输入(STDIN)的内容作为gcc的输入, 编译后的结果输出到标准输出(STDOUT) 2echo \u0026#39;void foo() {}\u0026#39; | gcc -x c -o - - 3# 将下载的文件输出到标准输出, 同时作为tar命令的输入文件, 进行解压 4wget -O - \u0026#34;https://www.dropbox.com/download?plat=lnx.x86_64\u0026#34; | tar xzf -  - 如何被解析是取决于命令的实现, 非标准. 比如 cd - 就有特殊的含义\n ","date":"2022-11-27T14:45:58+08:00","permalink":"https://wangloo.github.io/posts/shell/shell-commands/","section":"posts","tags":["shell","bash"],"title":"常用的 shell 命令"},{"categories":["C Language"],"contents":"计算数组元素的个数 1#define nelem(array) sizeof(array)/sizeof(array[0]) ","date":"2022-11-24T01:35:24+08:00","permalink":"https://wangloo.github.io/posts/c/c-macros/","section":"posts","tags":["c"],"title":"C 语言工具宏"},{"categories":["C Language"],"contents":"TODO: inline 的发展历程: Myth and reality about inline in C99 – Jens Gustedt\u0026rsquo;s Blog (wordpress.com)\nGNU89: 函数的实现之前添加不同的关键字:\n  inline: 表明这个函数可能被优化. 如果没有被优化, 编译器就会视为一个常规函数的定义.\n  extern inline: 表明这个函数可能被优化. 如果没有被优化, 编译器就将这个函数的定义转换为该函数的声明, 即 extern inline func(); 因此当此函数被调用时, 可以调用一个外部的函数来替代. 如果没有函数调用它, 那么也可以没有外部的替代函数实现.\n  static inline: 表明这个函数可能被优化. 如果没有被优化, 编译器就会视为一个常规静态函数.\n  C99: 函数的实现之前添加不同的关键字:\n inline: 等效于gnu89中的extern inline extern inline: 等效于gnu89中的inline static inline: 与gnu89相同含义.  C++: 只有inline一个关键字, 如果不能优化就定义为普通函数\n Ref:\nc++ - What does extern inline do? - Stack Overflow\nMyth and reality about inline in C99 – Jens Gustedt\u0026rsquo;s Blog (wordpress.com)\n  C demo 关于以上的各种情况\n ","date":"2022-11-24T01:35:24+08:00","permalink":"https://wangloo.github.io/posts/c/inline/","section":"posts","tags":["c"],"title":"C语言 \"inline\" 关键字"},{"categories":["Architecture"],"contents":"符合调用约定使得调用函数能够正常获取参数, callee结束之后能够回到原来位置继续执行.\nX86 调用约定 函数调用 x86架构中, 函数调用以一条call指令为分界.\n在call指令执行之前, 所有的参数必须都躺在栈中, 参数入栈的规则是: 第一个参数最后入栈.\n另外, 执行call指令之前, 必须确保栈指针esp是16-byte对齐. 这项工作是编译器完成的, 如果它判断参数入栈之后的esp 不满足对齐条件, 则会手动调整esp使之对齐. 实现方式见下面例子.\ncall 指令的语义是:\n1push pc+1 ;push next insttuction 2mov pc, func ;set pc = new function call 指令之后的下一条指令就是callee的内容了, 至此就算是进入新函数的地盘.\n但是在执行新的任务之前, callee还需要完成栈的转换, 因为此时使用的栈还是caller的.\n1push ebp ;preserve location of caller\u0026#39;s stack 2mov ebp, esp ;new ebp is old esp 此时esp也就是栈指针等于ebp, 这是callee栈的初始条件. 万事俱备, 可以开始执行callee的实际任务了.\n ebp在整个函数执行过程中是固定的, 好处是: 能够快速的或者函数参数, 返回地址.\n 函数返回 callee执行完毕后, 需要返回到caller继续执行. 刚才说过, callee的返回地址在栈中, 所以我们要做的是找到返回地址所在的位置, 然后使pc = 返回地址. 当然, 还有另一个重要的任务就是恢复caller的栈.\n上述任务的实现使用两条汇编语句就可完成: leave 和 ret.\nleave 负责搞定栈, 其语义为:\n1mov esp, ebp ;回滚栈空间 2pop ebp ;恢复caller的ebp ret 负责搞定pc, 其语义为:\n1pop ebx ;取出返回地址 2mov pc, ebx ;jmp to 返回地址 ret 之后, 就算是返回caller的地盘了. 还有一件小事别忘了做: 用于保存参数的栈空间还没有回收, 回到caller之后需要先将esp的位置进行调整.\nExample: 函数的调用和返回 一个关于函数调用和返回实现的完整例子.\n1void caller() 2{ 3 Func(1, 2, 3); 4} 5void Func(int a, int b, int c) 6{ 7 /* Do something */ 8} (以下汇编是AT\u0026amp;T格式的, 请见谅).\n1; Caller 2sub $0x4,%esp ;make 16-bytes align before call. 0x4 是由编译器计算的 3push $0x3 ;push 参数, 顺序是从右到左 4push $0x2 5push $0x1 6call f01000ad \u0026lt;Func\u0026gt; ;Func()\u0026#39;addr is f01000ad 7;===========\u0026gt;\u0026gt; Turn to callee 8 9 ;Func() 10 push %ebp ;preserve old ebp 11 mov %esp,%ebp ;set new ebp, ebp=esp now 12 /* Do something */ 13 leave ;restore stack 14 ret ;restore instruction point 15 16;\u0026lt;\u0026lt;=========== Back to caller 17add $0x10,%esp ;recycle stack(12 bytes parameters plus 4 bytes alignment) AArch64 调用约定 大体的思想与x86相似, 只是细节有些许不同\nCall A Function ARMv8的函数调用以bl指令为分界，在bl执行之前，caller需要将参数准备好。少于8个参数的函数在传参时, 参数是放在x0-x7中, 最左边的参数先使用x0, 以此类推. 参数超过8个的情况下才使用栈, 这与x86的方式不同.\nbl指令保存返回地址, 并跳转到callee执行, 其语义是:\n1mov lr, pc+1 ;preserve return address 2 ;lr specially used for preservering return addr 3mov pc, new_func ;set pc = new function 至此到了callee的职责范围。进入函数时, 需要完成三个前置动作:\n1; 为callee()的执行留出足够的栈空间 2; 0x10不是固定的, 编译器计算得到 3sub sp, sp, #0x10 4 5; 保存lr和fp, 因为callee可能调用 6; 其他的函数, 会破坏当前的 7stp x29, x30, [sp] 8 9; 保存sp的值, 所以x29也称为帧指针 10; 原因是sp在callee的执行过程中可能 11; 会变化. 与退出时配合理解较好 12mov x29, sp 上述动作完成后, sp是自由的了, callee()的函数体开始执行.\nFunction Return callee()执行完后, 也需要执行一些后置动作, 以便恢复调用前caller()的环境.\n1; 经过callee的指令执行过后, sp 2; 可能早就不是以前的sp了, 但是帧指针 3; fp总是保存着callee初始的sp 4mov sp, x29 5 6; callee如果调用了其他函数, lr和fp 7; 也会被破坏, 所以从栈中恢复callee 8; 正确的lr和fp, 才能正确回到caller 9ldp x29, x30, [sp] 10 11; 收回为callee分配的栈空间, 此时sp 12; 是调用callee之前的值. 13add sp, sp, #0x10 后置动作完成后, 环境已经大致恢复到调用callee()之前的状态了, 通用寄存器中的值, 其实不必担心, 因为ARMv8规定了哪些寄存器是caller-saved或者callee-saved, 再说到lr和sp, caller也会保存到栈中, 就像callee调用其他的函数时的情况相同.\n所以, 完成后置动作后, 执行ret来返回到lr的位置即可.\n为什么编译出的汇编文件没有mov sp, x29? 如果查看实际C函数编译后的汇编结果, 大部分情况下会发现前置和后置行为不是严格的按照A64PCS中规定的样子, 常见的是后置动作缺少恢复sp的执行, 即mov sp, x29.\n原因其实不难发现, callee中使用的寻址方式都是相对于sp寻址, 即不修改sp. 既然sp从始至终都没被改过, 自然也不需要恢复了. 这样不需要每次都需要sp, 更加高效.\n但是, 前置动作中的保存sp到fp的行为通常是不会被省略的, 我猜是因为调试行为(例如backtrace)的实现需要用到fp.\n不是每次都这样, 也有时会修改sp, 此时就必须恢复.\n帧指针(fp)存在的意义 上面说了, 如果一直使用sp相对寻址来操作栈, 那么fp的存在似乎是非必要的.\n我了解到的事实也是如此, fp存在的必要性似乎就是使得一些调试功能更加方便. 堆栈回溯是一个典型的利用fp的场景, 从callee的fp可以找到其caller的fp, 也就是caller的堆栈空间, 以此类推可以找到caller-caller的fp\u0026hellip;\n如何关闭帧指针 仅针对AArch64来说, GCC提供了一些相关的编译选项来给程序员选择是否启用fp的权利.\n -fomit-frame-pointer 强制省略fp -fno-omit-frame-pointer 强制不省略fp  参考  x86 call 指令执行前需要esp对齐到 16-byte: x86 - What are the following instructions after this call (assembly) - Stack Overflow x86栈帧原理 - 知乎 (zhihu.com) 破获ARM64位CPU下linux crash要案之神技能：手动恢复函数调用栈  结语 能够正确达到函数调用和返回的实现方式有很多, 不是仅有这一种方式, 约定仅仅是一个约定, 大家都这样去做降低了开发的难度.\n","date":"2022-11-21T10:30:35+08:00","permalink":"https://wangloo.github.io/posts/armv8/function-call-conventions/","section":"posts","tags":["armv8","x86","Operating System"],"title":"AArch64/X86 函数调用约定"},{"categories":["C Language"],"contents":"问题源于我在知乎刷到的一个回答: 能分享你C指针用得最灵活（飘）的一次吗?\n文中提到了Linus关于无头节点单项链表的删除操作给出的一种新的思路, 我觉得对理解指针非常有帮助, 所以在这里详细描述一下这件事.\n从我学习数据结构起, 对不含头节点的单向链表的删除操作, 做法常是: 借用pre指针搜索. 这种情况下避免不了对于链表中第一个节点的特判(第一个节点没有pre).\nLinus提到了一种借助二级指针避免该分支的方法.\n1void remove_if(node ** head, remove_fn rm) 2{ 3 for (node** curr = head; *curr; ) 4 { 5 node * entry = *curr; 6 if (rm(entry)) 7 { 8 *curr = entry-\u0026gt;next; 9 free(entry); 10 } 11 else 12 curr = \u0026amp;entry-\u0026gt;next; 13 } 14} 指针的内容就是地址, int *p = a 也就意味着变量p 中保存着变量a的地址. 所以参数head在内存中的含义为:\n假如要删除node2, 那么改变*curr实际上就是改了node1的next成员.\n","date":"2022-11-20T23:40:30+08:00","permalink":"https://wangloo.github.io/posts/c/pointers-pointers-list/","section":"posts","tags":["c"],"title":"二级指针操作链表技巧"},{"categories":["Operating System"],"contents":"大小端问题的由来 为什么计算机世界需要区分大小端? 内存里存取的单位是字节, 如果所有的数据类型长度都是一个字节, 那就完全不需要大小端了, 每个变量都仅占据单独一个字节.\n例如, 三个变量 a=10, b=20, c=30, 在内存中的布局可能就是:\n1 ┌────────────┐ 2 │ │ 3 │ 10 │ a 4 ├────────────┤ 5 │ │ 6 │ 20 │ b 7 ├────────────┤ 8 │ │ 9 │ 30 │ c 10 ├────────────┤ 11 │ │ 12 │ │ 13 │ │ 14 │ │ 15 │ │ 16 └────────────┘ 但是我们最常使用的数据类型肯定有超过一个字节的, int类型在64位的系统中就占4个字节. 例如变量a=0xaabbccdd\n一个变量的大小一旦超过4个字节, 内存的存取又是以字节位单位的, 那么要把它塞到内存里就必然会产生两种不同存放方式: 先放0xaa还是先放0xdd\n首先, 0xdd是变量a的低8位, 0xaa是最高8位, 这是确定的.\n  如果先放0xaa, 即低地址放高位, 就叫做大端, 如左图;\n  如果先放0xdd, 即低地址放低位, 就叫小端, 如右图.\n  1 2 start addr of `a` start addr of `a` 3 ┌────────────┐ ┌────────────┐ 4 │ │ │ │ 5 │ aa │ │ dd │ 6 ├────────────┤ ├────────────┤ 7 │ │ │ │ 8 │ bb │ │ cc │ 9 ├────────────┤ ├────────────┤ 10 │ │ │ │ 11 │ cc │ │ bb │ 12 ├────────────┤ ├────────────┤ 13 │ │ │ │ 14 │ dd │ │ aa │ 15 ├────────────┤ ├────────────┤ 16 │ │ │ │ 17 │ │ │ │ 18 └────────────┘ └────────────┘ 什么情况? 看下面的代码, 猜测输出的结果\n1unsigned int i = 0x00646c72; 2printf(\u0026#34;Hello Wo%s\u0026#34;, \u0026amp;i); %s 会按字节一直打印内存中的字符, 直到遇到\\0. 首先打印的字符便是变量i的地址处的内容.\n如果是小端存储方式, 变量i的地址处的一个字节值是0x72, 即字符r. 以此类推, 所以如果CPU的字节序是小端形式, 那么printf的结果是: Hello world\n大小端形式的优缺点 小端的优势:\n  以不同的长度读取变量非常方便, 不用计算地址. 例如u64 a=0x1234, 当(u16)a时, CPU不需要重新计算读取的起始位置, 永远都是变量a的起始地址.\n  Easily to do mathematical computations “because of the 1:1 relationship between address offset and byte number (offset 0 is byte 0), multiple precision math routines are correspondingly easy to write.”\n  ","date":"2022-11-17T10:30:35+08:00","permalink":"https://wangloo.github.io/posts/os/big-little-endian/","section":"posts","tags":["Operating System"],"title":"操作系统：大小端问题"},{"categories":["Operating System"],"contents":"本文基于AArch64执行环境, 介绍现代操作系统中上下文切换的相关内容.\n何为上下文 我们正在看一本书的时候如果被其他的事情打断, 返回时为了能够从上次被打断的位置继续读, 就要在被打断的时候记下来当前是读到了哪个第几页的第几行.\n操作系统对待线程也是如此, 需要保存的用于恢复线程执行的信息就称为线程的上下文.\n那么对于线程来说需要记下的内容有什么呢? 寄存器和栈即可. 拿 AArch64 架构来距离, 线程的上下文就是:\n 通用寄存器x0-x29: 函数调用的参数, 某些计算过程的中间值, 都要用到这些寄存器. 线程的执行流可能在任何时候被打断, 当然这些内容也不能丢. 通用寄存器lr(x30): lr 保存着返回地址, 即当前函数结束之后该返回到哪执行. 栈顶指针 sp: 栈的重要性无需多言. 程序计数器 pc: 被打断的线程如果再次执行, 从哪里执行呢? 显然是被打断指令的下一条(或者重新执行当前). 这个指令的地址当然也需要被保存好. PSTATE: 想一下, 有了以上的内容就能够保证线程完整的恢复之前的环境吗? 其他的例如中断是开还是关, 有哪些标志位(NZCV)被设置了. 这些信息在 AArch64 中是保存在 PSTATE 的各个字段中. ttbr0：保存着进程的页表  上下文保存和恢复 TODO\n协程的上下文 协程是用户级别的线程,\n 协程之间的切换不进入内核 切换协程只能是某个协程主动放弃控制权  我们在这里讨论一下协程切换时需要保存的上下文是否与线程有所不同.\n首先, PC 一定属于, 这个毋庸置疑. 其次是栈顶指针 sp, 每个协程都有单独的栈, 如果不保存栈的位置, 那么协程内部定义局部变量就没法访问了(局部变量的访问指令都是以 sp 为 base 的偏移来做的).\n另外, 关于通用寄存器, 由于协程的切换需要主动调用某个函数(通常叫做yield()), 在函数的最后将 PC 设置为新协程的上下文 PC. 保存当前协程上下文的操作也在这个函数中, 而其参数我们并不关心, 即x0-x7没必要保存. 同样的, caller-saved 寄存器也是没必要保存的, 因为这些寄存器作为函数调用使用的临时变量, 当再次返回该协程时, PC=yield()返回地址, caller 如果关心这些寄存器应当自己执行保存和恢复. 但是callee-saved 寄存器必须要保存到上下文中, 因为在 yield()中, 我们如果修改了 callee-saved 寄存器, 就需要在返回时(也就是再次调度到该协程时) 恢复, 这是 callee 该做的, 也就是上下文中应该有的唯一通用寄存器组.\n","date":"2022-11-14T22:13:06+08:00","permalink":"https://wangloo.github.io/posts/os/context/","section":"posts","tags":["Operating System"],"title":"操作系统：上下文切换"},{"categories":["C Language"],"contents":"介绍 setjmp() and longjmp() 是一对组合使用的函数, 可以实现全局的goto.\nsetjmp() 构造一个运行环境, 调用longjmp() 则将执行流切换到该环境.\n1/* setjmp() 保存当前的运行环境(上下文)到 env 参数中 */ 2int setjmp(jmp_buf env); 3 4/* longjmp() 将控制流切换到 env 指定的运行环境 */ 5void longjmp(jmp_buf env, int val); 使用方法 1#include \u0026lt;setjmp.h\u0026gt;2#include \u0026lt;stdio.h\u0026gt;3 4jmp_buf e; 5 6void foo() { 7 longjmp(e, 1); 8} 9 10int main(void) { 11 int ret; 12 13 /* After calling longjmp(), the execution flow back to setjmp(), 14and setjmp() will return not 0. */ 15 ret = setjmp(e); 16 if (ret == 0) { 17 printf(\u0026#34;Return from setjmp\\n\u0026#34;); 18 foo(); 19 } else { 20 printf(\u0026#34;Return from longjmp\\n\u0026#34;); 21 } 22 23 return 0; 24} 基于 AArch64 的实现 1.macro func _name 2.global \\_name 3.type \\_name, %function 4\\_name: 5.endm 6 7.macro endfunc _name 8.size \\_name, .-\\_name 9.endm 10 11 12/** 13 * setjmp (jmp_buf env) 14 * 15 * See also: 16 * longjmp 17 * 18 * @return 0 - if returns from direct call, 19 * nonzero - if returns after longjmp. 20 */ 21 22func setjmp 23 stp x19, x20, [x0], #16 24 stp x21, x22, [x0], #16 25 stp x23, x24, [x0], #16 26 stp x25, x26, [x0], #16 27 stp x27, x28, [x0], #16 28 stp x29, x18, [x0], #16 29 mov x9, sp 30 stp lr, x9, [x0], #16 31 mov x0, #0 32 33 ret 34endfunc setjmp 35 36/** 37 * longjmp (jmp_buf env, int val) 38 * 39 * Note: 40 * if val is not 0, then it would be returned from setjmp, 41 * otherwise - 1 would be returned. 42 * 43 * See also: 44 * setjmp 45 */ 46 47func longjmp 48 ldp x19, x20, [x0], #16 49 ldp x21, x22, [x0], #16 50 ldp x23, x24, [x0], #16 51 ldp x25, x26, [x0], #16 52 ldp x27, x28, [x0], #16 53 ldp x29, x18, [x0], #16 54 ldp lr, x9, [x0], #16 55 mov sp, x9 56 57 mov x0, x1 58 cbnz x0, 1f 59 add x0, x0, #1 601: 61 62 ret 63endfunc longjmp 需要保存的上下文包括\n callee-saved 通用寄存器, 因为可能第一次调用 setjmp() 之后的执行流修改了这些寄存器, 从第二次回到 setjmp() 的角度来看, 就是执行setjmp() 中破坏的. caller-saved 寄存器则不必, 因为本来即便看作是 setjmp() 破坏的, 也是正常的.  解释一下：在如下的调用场景中, 可以看到在setjmp()之前分别赋值了x2和x19， 这其中x2是caller-saved，x19属于callee-saved。 callee-saved寄存器在子函数调用之前和之后应该是不变的，所以说如果子函数需要修改他们应该在函数进入前进行备份。 所以说显然在(1)的步骤中应该有x19的备份过程，(6)中也应该有对应的恢复。\n那么对于setjmp()呢？它自身也是一个函数，也需要满足规定。所以必须保证(5)访问到数据一定是(3)中保存的。 问题是对于setjmp()的使用方法来说，不是都遵循(1)(2)(3)(4)(5)的调用，下次会从别的位置直接跳到(4)。 此时仍然需要确保x19寄存器的正确性，只能在首次调用setjmp()时将x19保存下来，以后每次不管从哪里调过来先去恢复保存的x19。这样就能够实现callee-saved寄存器的正确性。\n再说说caller-saved寄存器，也就是demo中的x2为例，在中间跨越一个setjmp()的条件下， arch不能保证(4)中得到的值一定是(2)保存的，因为setjmp()可以随意的修改caller-saved寄存器。所以说，如果func()不得不要求(4)访问值的正确性， 一个解决方法就是在调用setjmp()之前保存x2到栈中，在setjmp()之后立马恢复。 这是caller的责任，所以这个过程会在func()完成，而不是setjmp()内部。\n以上就是为什么setjmp()只需要保存callee-saved寄存器的解释。\n1func() 2{ 3 // (1) 4 Set x2 // (2) 5 Set x19 // (3) 6 setjmp() 7 Access x2 // (4) 8 Access x19 // (5) 9 // (6) 10} setjmp() 实现 try-catch ","date":"2022-11-01T23:38:54+08:00","permalink":"https://wangloo.github.io/posts/c/setjmp_and_longjmp/","section":"posts","tags":["armv8","c"],"title":"ARM64 上实现 setjmp/longjmp"},{"categories":null,"contents":" Kernel Monitor 是什么 Kernel Monitor 是一个适配我们微内核操作系统的 Kernel 调试和监控系统. 它能实现内核的动态调试和监控. 同时, 它还接管内核的同步异常和系统错误, 使开发者能够了解发生异常时系统的状态.\nKernel Monitor 具有一定的可扩展性, 例如通过统计内核中存储的 TCB 来实时监控系统中所有线程的状态. 可根据开发者的需求添加统计的对象, 如 Endpoint, Capability等.\n Kernel Monitor 总体设计 Kernel Monitor 系统包含 Clinet 和 Server 两个部分. 简单来说, Client 负责处理用户输入, 并将输入进行解析, 封装为 一系列基础命令. 发送给 Server. Server 负责执行这些 基础的命令, 如设置断点, 查看某个地址的值等.\n整个系统有两种架构: 本地 Monitor 和远程 Monitor.\n本地monitor 和远程 monitor 的区别是: Monitor Client 的位置在哪, 是否与 Server 在同一个机器上.\n 先说 Monitor Server, 它必须嵌入要调试的 Kernel 中, 位于一个地址空间, 方便操作 Kernel 的内存.\n 本地 Monitor 在本地 Monitor 中, client 和 sever 都位于目标机(Target)上, 目标机通常是开发板.\n对于 AArch64 体系结构来说, 最多有四个异常等级(EL0-EL3). Client 可以运行在EL2.\n远程 Monitor 远程 Monitor 架构则不同, Clinet 运行在宿主机(Host)上, 通常是Linux. 它与 Server 的通信是通过网络/UART实现的.\n Monitor Client 运行在本地和远程对于实现的难度和用户体验有影响.\n  如果 Client 实现在本地, 则 Client 无需实现网口和串口的驱动, 但Monitor 输入输出的串口与操作系统本身的串口相同, 信息冗杂在一起不易查看; 同时, 如果 Client 实现在本地, 那么对于ELF的解析需要在无操作系统提供的库支持下完成, 可能比较复杂.\n  如果 Client 实现在远程, 即为 Linux 上的一个APP. 那么它和 Server 的通信就需要通过外部的网口或者串口(对于我们使用的64位开发板只引出了一个串口, 所以只能使用网口). 需要在 Server 上实现网口的驱动, 这部分比较复杂. 但是好处是 Client 的实现简单很多, 因为有 Linux APP 运行环境的支持. 同时, 远程 Monitor 架构下, Monitor 和 操作系统自身的输入输出分开, 用户可读性更好.\n   Server 是嵌入到Kernel的代码中, 与Client进行交互. 它是整个 Monitor 系统的后端, 负责实现基础的调试操作. 例如, 设置断点, 内存的读写, 寄存器的读写等.\n 由于Server与 Kernel 位于同一个地址空间, 所以查看/修改内存的值是非常方便的. 对于寄存器也是同理. 断点(Breakpoint), 监视点(Watchpoint), 单步执行(Soft step)的实现依赖与 ARMv8 提供的的 self-hosted debug 支持.  同时, Server 还负责监视系统中所有的 同步异常和系统错误. 一旦发生, 可在 Monitor 中查看某些内存, 寄存器的值定位问题发生的原因.\nMonitor Client 设计 Client 的构成可分为三个模块 :\n 用户交互模块 符号处理模块 消息收发模块  用户交互模块负责处理用户的输入输出, 调用其他两个模块完成调试命令.\n符号处理模块负责解析可执行文件(ELF), 并建立静态符号表, 存储符号和地址的对应关系. 将用户输入的符号解析为虚拟地址, 或者反向解析.\n消息收发模块负责处理用户的输入, 将其转化为基础, 标准的命令, 发送给Server执行. Client 和 Server之间通信的数据包协议可以使用 GDB Remote Serial Protocol (以下简称RSP协议), 或者自己规定一个协议也是可行的.\n RSP协议支持三种基础命令:\n 寄存器相关 内存相关 程序控制命令   启用 Monitor 时 Kernel 启动流程  Kernel 首先做必要的初始化, GIC, 异常向量表, MMU等. 将控制权交给 Monitor, 等待用户输入.   Kernel debug 过程示例 示例一: 查看变量 var 的值  用户输入 print var 指令. 由符号处理模块, 将var符号转为var 虚拟地址. 由消息收发指令将请求封装为RSP协议包格式, 并发送到 Monitor Server. 执行流程交给 Monitor Server, 它访问该地址, 将内容封装发回 Monitor Client. Client 输出var的值, 继续等待用户输入  示例二: 添加断点到 main 函数  用户输入 break main 指令 由符号处理模块, 解析得到 main 函数的地址. 消息收发模块将请求封装为RSP包格式, 发送到Monitor Server. 执行流程交给 Server. 它执行 breakpoint exception 指令, 并设置相关软件断点相关寄存器 执行流交给 Kernel, 直到达到断点处(可使用地址+ContextID双重验证), 触发Debug异常 Debug异常属于同步异常, 由 Monitor 系统接管, 回到 Client 继续等待用户输入  示例三: 单步执行  用户输入 step 指令 消息收发模块将请求封装为RSP包格式, 发送到 Monitor Server. 执行流程交给 Server, 启用 software step. 然执行一次异常返回, 回到Kernel 继续执行. 因为启用了 Software step, 回到 Kernel 执行完一条指令后, 就会触发 Debug异常 Debug 异常属于同步异常, 由 Monitor 系统接管, 回到 Client 继续等待用户输入   其他拓展功能 back trace\n性能分析\n","date":"2022-10-28T22:56:19+08:00","permalink":"https://wangloo.github.io/posts/os/monitor/","section":"posts","tags":null,"title":"Armv8 Kernel Monitor"},{"categories":["Architecture"],"contents":"Introduction MMU: 专用于将虚拟地址转换为物理地址. 通常配合分页机制来工作.\n页表: 页表中的表项包含提供虚拟地址和物理地址之间的映射.\nMMU就是直接访问页表, 并且通过将频繁使用的映射缓存到TLB中.\nMMU 的结构 MMU是一种硬件, 可以通过在适当的安全状态下对其进行配置. 每个Core都有自己的MMU, 每个MMU包括:\n 一个TLB, 缓存最近访问的映射. 一个Table Walk Unit, 从内存中查询页表, 得到最终的虚拟地址-物理地址的映射.  MMU 控制着整个系统的缓存策略, 内存属性和访问权限. MMU开启后, 软件发出的所有内存访问都使用虚拟地址, 要求MMU为每次访问进行地址转换.\nMMU 的配置 在启用MMU前, 必须告知其页表存放的位置.\nMMU 地址转换的过程 对于每个转换请求, MMU首先检查TLB是否已经对该地址缓存, 如果该地址未缓存, 则需要遍历页表.\n页表遍历单元在页表中搜索相关的映射表项.\n 一旦找到映射, MMU就会检查权限和属性. 决定允许本次访问, 或者发出故障信号. 若未找到映射, 则触发缺页异常.  页表的工作原理 页表的工作方式是将虚拟地址空间和物理地址空间划分为大小相等的块, 称为页面.\n页表中的每个表项对应着一块虚拟地址空间中的块, 表项的值就是这块虚拟地址空间对应的物理地址块, 以及访问物理地址时要使用的属性.\n在查表过程中, 将虚拟地址分为两部分:\n 高阶位用作页表的索引. 用来找到对应的物理块 低地址是块内的偏移量, 不会因为映射而改变. 页表项中的物理地址与该偏移组合形成用于访问内存的物理地址.  多级页表 实际实现中, 多采用多级页表的方案, 各级页表自定向下组成树的形式, 协作实现虚拟到物理地址的转换.\n树中的分支成为页目录, 页目录中的表项不是直接存储目标物理地址, 而是下一级页表的地址; 最后一级页表的表项中保存着目标物理地址.\n 多级页表是减小页表占用存储空间过大的有效方案.\n 顶级页表将地址空间划分为大块, 每个表项可以指向大小相等的内存块. 也可以指向将块进行再次细分的下一级页表. 支持大块的优点:\n 大的内存块需要查表的次数更少 提升TLB的效率, 因为一个TLB表项覆盖更大的内存区域.  凡事都是有利有弊, 使用大块也增加了内存浪费, 实际使用时需要根据需要来权衡.\n内存类型 普通类型内存 普通类型的内存是弱一致性的(weakly ordered)内存模型, 没有额外的约束, 可以提供最高的内存访问性能.\n通常代码段, 数据段以及其他数据都放在普通内存中.\n普通内存允许处理器做很多优化, 如分支预测, 数据预取, Cache line预取, 乱序执行等.\n设备类型内存 CPU访问设备内存会有很多限制, 如不能进行数据预取等. 设备类型的内存严格按照指令的顺序来执行的.\n设备类型内容通常留给设备来访问, 例如中断控制器(GIC), 串口, 定时器等.\n两套页表  当CPU访问的地址属于用户空间时, MMU会自动选择TTBR0指向的页表. 当CPU访问的地址属于内核空间时. MMU会自动选择TTBR1指向的页表  EL2和EL3没有TTBR1, 只有TTBR0. 也就意味着:\n• If EL2 is using AArch64, it can only use Virtual Addresses in the range 0x0 to 0x0000FFFF_FFFFFFFF. • If EL3 is using AArch64, it can only use Virtual Addresses in the range 0x0 to 0x0000FFFF_FFFFFFFF.\n越权, 越界 在未使用虚拟地址空间之前, 所有的用户程序都可以访问全部的物理内存, 所以恶意程序可以修改其他程序的内存数据, 这使得整个系统处于危险的状态. 每个进程的地址空间都要受到保护, 以免被其他进程有意/无意的破坏.\n现代操作系统中, 每个进程都有独立的虚拟地址空间. 在进程的角度上, 它拥有整个虚拟地址空间. 不同的进程可以同时使用一个虚拟地址, MMU通过页表将其映射到合适的物理地址.\n两个物理地址空间 ARMv8 体系结构定义两个物理地址空间: secure address space 和 non-secure address space.\n理论上, 安全和非安全的地址空间是相互独立的, 然而现实中大多数系统都将安全和非安全视为访问控制的属性. 正常(非安全)世界只能访问非安全的物理内存; 而安全世界可以访问这两个地址空间.\nARMv8 MMU权限控制 程序请求某个地址时, MMU需要进行权限检查. 如果请求的地址是数据, 则检查读写权限; 如果请求的是地址, 则检查其可执行权限.\nARMv8 页表项的AP字段控制该不同异常等级下, 页面的读写权限.\n[表格]\nARMv8 页表项的PNX字段和XN/UXN字段来设置CPU是否对这个页面有执行权限.\n  当系统有两套页表时, UXN是用来设置用户空间页面是否有可执行权限; PXN 用来设置特权空间的页面是否有可执行权限.\n  若系统只有一套页表, 则通过XN字段控制\n  页表的结构 地址宽度 48bit\n页面粒度 页面粒度表示一次最小分配内存块的大小. AArch64支持三种页的大小, 4KB, 16KB, 64KB. 支持哪一种是由实现定义的。创建页表的代码能够读取系统寄存器ID_AA64MMFR0_EL1，以找出哪些是受支持的大小。Cortex-A53处理器支持所有三种尺寸，但有些处理器的早期版本并非如此，例如Cortex-A57，它不支持16K粒度。\nAArch64 页表项结构 无效页表项 table block 页表结构(4KB页面为例) 以4KB页面粒度, 虚拟地址宽度为 48位. 使用4级页表.\n48位地址每层转换有9个地址位，即每层512个条目，最后12位选择4kB内的一个字节，直接来自原始地址\n虚拟地址到物理地址的转换过程 当处理器为获取指令或数据访问发出一个64位的虚拟地址时，MMU硬件将虚拟地址转换为相应的物理地址。对于虚拟地址，前16位[63:47]必须全部为0或1，否则地址将触发故障。\nNon-secure and secure access ARMv8-A架构定义了两种安全状态:安全的和非安全的。它还定义了两个物理地址空间:安全的和非安全的. 正常(非安全)世界只能访问非安全物理地址空间。安全世界可以访问两个物理地址空间。这也是通过转换表来控制的。\n在非安全状态下，转换表中的NS位和NSTable位将被忽略。只能访问非安全内存。在安全状态下，NS位和NSTable位控制虚拟地址转换为安全物理地址还是非安全物理地址。\nYou can use SCR_EL3.SIF 来禁用安全世界访问非安全地址.\n相关的寄存器 与地址转换相关的寄存器主要有以下几个:\n 转换控制寄存器(TCR) 系统控制寄存器(SCTLR) 页表基地址寄存器(TTBR)  TCR IPS: 配置地址转换后输出物理地址的最大值\nTxSz: 配置输入地址的最大值, 即虚拟地址的宽度\nTG1: 配置TTBR1页表的页面粒度大小\nSHx: 配置TTBRx相关内存的Cache共享属性\nORGNx:\nIRGNx:\nSCTLR M: Disable/Enable MMU地址转换\nC: Disable/Enable Data Cache\nI: Disable/Enable Instruction Cache\nTTBR 存储页表的基地址\nAArch32 虚拟内存系统 ARMv8 AArch32 的虚拟内存系统向后兼容ARMv7, 与ARMv7的基本一致.\n","date":"2022-09-29T08:01:33+08:00","permalink":"https://wangloo.github.io/posts/armv8/mmu/","section":"posts","tags":["armv8"],"title":"AArch64 MMU介绍"},{"categories":["Architecture"],"contents":"ARMv8 异常返回指令 当异常处理程序结束后，需要执行异常返回指令恢复进入异常之前的状态.\n具体要做的事情包括:\n  恢复发生异常前的PC\n  从SPSR中恢复PSTATE寄存器(现场)\n  异常返回的指令根据当前执行状态为AArch32还是AArch64有所不同.\nAArch32 AArch32的异常返回指令在不同的模式下也有所不同:\n若异常是在Hyp模式下处理: 仅可执行ERET指令从异常返回.\n若异常是在其他模式下处理, AArch32提供了以下的异常返回指令:\n  ERET 指令\n  使用带S后缀的数据处理指令直接操作PC(例如, MOVS, PC, LR), 恢复PSTATE\n  RFE 指令: RFE \u0026lt;Rn\u0026gt;. 从基址寄存器指向的地址依次加载PC和PSTATE\n  LDM 指令: LDM \u0026lt;Rn\u0026gt; {pc..}. 若目标寄存器中包含PC, 则会同时恢复PSTATE\n  AArch64 AArch64下统一使用 ERET 指令进行异常返回.\n指令格式及用法参考 ERET ERET指令完成了:\n  从ELR_ELx中恢复PC指针\n  从SPSR_ELx中恢复PSTATE寄存器的状态.\n  LDM(Load Multiple) 格式: LDM \u0026lt;Rn\u0026gt; {registers}\n含义: 从基址寄存器\u0026lt;Rn\u0026gt;指向的地址开始依次加载多个寄存器值. 若目标寄存器中包含PC, 则同时恢复PSTATE.\n例如: LDM \u0026lt;r0\u0026gt; {pc, r1} 等价于:\n1pc = [r0] 2r1 = [r0+4] 3PSTATE = SPSR ;仅当目标寄存器包含PC时自动完成 RFE(Return From Exception) 格式: LDM \u0026lt;Rn\u0026gt; \n含义: 从基址寄存器\u0026lt;Rn\u0026gt;指向的地址依次加载PC和PSTATE.\n例如: RFE \u0026lt;r0\u0026gt; 等价于:\n1pc = [r0] 2PSTATE = [r0+4] ","date":"2022-09-24T21:19:01+08:00","permalink":"https://wangloo.github.io/posts/armv8/exception_return/","section":"posts","tags":["armv8"],"title":"AArch64 异常等级切换"},{"categories":["C Language"],"contents":"语句结构 1asm asm-qualifiers ( AssemblerTemplate 2 : OutputOperands 3 : InputOperands 4 : Clobbers 5 : GotoLabels) The asm keyword is a GNU extension. 当使用编译选项 -ansi 或 -std 时, 使用 __asm__代替 asm.\nQualifiers  volatile: 向编译器说明禁止内敛的语句与其他语句 reorder。但不能保证内部 reorder，那是内存屏障的任务 goto inline  Parameters AssemblerTemplate: 字符串, 汇编代码的模板\nOutputOperands: 输出操作数; 指令将会修改的变量集合\nInputOperands: 输入操作数; 指令将读取的变量集合\nClobbers: ???TODO\nGotoLabels: 仅当 qualifiers 使用goto时, 声明label集合.\n The total number of input + output + goto operands is limited to 30.\n  Param #1: AssemblerTemplate 多条语句可以放在一个asm字符串中, 但是更常见的是每条汇编语句使用一个字符串, 并在结束时使用换行符和制表符(\\n, \\t)来表示换行.\n 貌似对于 arm 汇编, 只用 \\n 也OK?\n  Param #2: OutputOperands 多个 OutputOperands 之间使用,隔开, 每个 OutputOperands 的格式如下:\n1[ [asmSymbolicName] ] constraint (cvariablename) asmSymbolicName: 指定该操作数的名称\nconstraint: 对该操作数的一些限制\n1// 描述操作数的权限, 输出操作数的约束必须以此开头 2= 忽略现有值 3+ 读写, 当原先值有意义时用它 4\u0026amp; 禁止编译器将该操作数与不相关的输入操作数分配同一个寄存器 5 6// 描述输出操作数所在位置, 如果你不知道, 可以同时设置, 编译器会帮你决定 7r 寄存器 8m 内存 9 10// 架构相关的 11z AArch64中存在. 表达可以使用零寄存器(XZR or WZR). Useful when combined 12 with `r` to represent an operand that can be either a general-purpose register 13 or the zero register. cvariablename: 输出到的 C 语言变量名\n Param #3: Input Operands 输入操作数的格式与输出操作数基本一致:\n1[ [asmSymbolicName] ] constraint (cexpression)  对于输入操作数, 一般没有别的限制, 仅使用\u0026quot;r\u0026quot;(val)\n  Param #4: Clobbers 每个 clobber 都是用双引号括起来, 并用逗号分隔的字符串常量.\n常用的 clobber 参数:\n  \u0026ldquo;memory\u0026rdquo;\n向编译器说明对于所有内存访问操作，不能使用 asm 之前预加载到寄存器中的值， 而必须在 asm 内部重新加载。保证其内部访问内存值具有可见性和正确性。\n  \u0026ldquo;cc\u0026rdquo;\nThis stands for \u0026ldquo;condition codes\u0026rdquo;. Since the add instruction will affect the carry flag amongst other things, we need to tell gcc about it. Otherwise it might want to split a test-and-branch around our code. If it did so, the branch might go the wrong way due to the condition codes being corrupted. Basically, any inline asm that does arithmetic should explicitly clobber the flags like this.\n   Param #5: GotoLabels 尽量不使用, 可以在ASM的内部直接定义 label\nTODO\n 样例 最简单的模板 1int src = 1; 2int dst; 3 4asm (\u0026#34;mov %1, %0\\n\\t\u0026#34; 5 \u0026#34;add $1, %0\u0026#34; 6 : \u0026#34;=r\u0026#34; (dst) 7 : \u0026#34;r\u0026#34; (src)); 8 9printf(\u0026#34;%d\\n\u0026#34;, dst); 操作数使用 asmSymbolicName 1uint32_t c = 1; 2uint32_t d; 3uint32_t *e = \u0026amp;c; 4 5asm (\u0026#34;mov %[e], %[d]\u0026#34; 6 : [d] \u0026#34;=rm\u0026#34; (d) 7 : [e] \u0026#34;rm\u0026#34; (*e)); 内部定义 label 1 long temp; 2 long ret; 3\tasm volatile( 4 \u0026#34;1: \\n\u0026#34; 5 \u0026#34;ldxr %0, [%2]\\n\u0026#34; 6 \u0026#34;sub %0, %0, %3\\n\u0026#34; 7 \u0026#34;stxr %w1, %0, [%2]\\n\u0026#34; 8 \u0026#34;cbnz %w1, 1b\\n\\t\u0026#34; 9 : \u0026#34;=\u0026amp;r\u0026#34;(ret), \u0026#34;=\u0026amp;r\u0026#34;(temp) 10 : \u0026#34;r\u0026#34;(p), \u0026#34;r\u0026#34;(val) 11 : \u0026#34;memory\u0026#34; 12 ); Reference Extended Asm (Using the GNU Compiler Collection (GCC))\nAArch64 Constraint codes\n","date":"2022-09-24T16:48:58+08:00","permalink":"https://wangloo.github.io/posts/c/inline-asm/","section":"posts","tags":["c"],"title":"GNU C 内联汇编学习"},{"categories":["Shellscript"],"contents":" ℹ️ 如未特殊说明，以下的命令在bash和zsh中都能正确生效。\n 变量的定义和引用 1# 何时变量赋值要加\u0026#34;\u0026#34;? 2# =\u0026gt; 包含分隔符，空格或tab时 3qemu_opt=\u0026#34;-machine raspi3b\u0026#34; 4 5# 引用变量时为什么加{}? ${var} 6 7# 引用变量时为什么加\u0026#34;\u0026#34;? \u0026#34;$var\u0026#34; 8 9# 变量赋值为什么$()? 10# =\u0026gt; ()里面是shell命令时用 11qemu_ver=$($qemu --version | head -n 1) 常用Shell命令的注意事项 echo的参数 1# echo不自动换行 2echo -n \u0026#34;some-string\u0026#34; 3 4# echo转义特殊字符 5echo \u0026#34;some-string\\n\u0026#34; # 不转义\\ 6echo -e \u0026#34;some-string\\n\u0026#34; # 正确转义换行  Zsh中，echo默认带-e，bash中则不是。 所以说，如果输出的字符串有转义字符，不管要不要转义，都显式指定一下。\n -e 强制转义 -E 强制不转义   sort 应付多种场景 1# 对版本号进行排序(x.y.z) 2echo -ne \u0026#34;1.2.3\\n4.5.6\\n3.4.5\u0026#34; | sort -V shift 操作参数 shift命令将参数左移，应用场景:\n1# 场景1：提取第二个参数及后面的所有 2# ./shell qemu-system-aarch64 -machine raspi3b -smp 3qemu=$1 4shift # 默认左移1 5qemu_opt=$@ 6 7 8## 场景2: 处理多参数且位置不定的情况 9while [ \u0026#34;$#\u0026#34; -gt 0 ]; do 10 case \u0026#34;$1\u0026#34; in 11 -f|--file) 12 file=\u0026#34;$2\u0026#34; 13 shift 2 14 ;; 15 -d|--directory) 16 directory=\u0026#34;$2\u0026#34; 17 shift 2 18 ;; 19 -m|--mode) 20 mode=\u0026#34;$2\u0026#34; 21 shift 2 22 ;; 23 *) 24 echo \u0026#34;Unknown option: $1\u0026#34; 25 exit 1 26 ;; 27 esac 28done Shellscript的编写技巧  Bash脚本正式语句开始前加 set -e, 使得任何命令返回非0时立即退出整个Shell脚本。 规定分隔符。默认Shell会采用空格、tab、换行都作为分隔符， 有时需要屏蔽某些，仅使用空格 1export IFS=\u0026#39; \u0026#39; # 启用空格分隔only 2flag=\u0026#34;false\u0026#34; 3for str in $qemu_ver; 4do 5 # do something 6done 7unset IFS # 恢复默认   统计代码量 列出所有的文件及其代码行数, 只统计.c 和.h, 过滤./scripts目录.\n1find -name \u0026#39;*.[c|h]\u0026#39; ! -path \u0026#39;./scripts/*\u0026#39; | xargs wc -l +将内容按照代码行数降序排列\n1find -name \u0026#39;*.[c|h]\u0026#39; ! -path \u0026#39;./scripts/*\u0026#39; | xargs wc -l | sort -rn 若仅列出总的代码行数, 去除空行\n1(find ./ -name \u0026#39;*.[c|h]\u0026#39; -print0 | xargs -0 cat) | sed \u0026#39;/^\\s*$/d\u0026#39; | wc -l 删除目录下所有的可执行文件 1find . -maxdepth 1 -executable -type f | xargs rm 判断执行脚本时带的参数 1if [ $# -ne 1 ]; then 2 echo \u0026#34;ONE parameter is needed\u0026#34; 3 exit -1 4fi 5 6if [ $1 == \u0026#39;build\u0026#39; ]; then 7 # do something 8elif [ $1 == \u0026#39;run\u0026#39; ]; then 9 # do something 10elif [ $1 == \u0026#39;gdb\u0026#39; ]; then 11 # do something 12else 13 echo \u0026#34;Not supported command\u0026#34; 14fi 自动拷贝文件到 SD Card  TODO\n 添加进度条   1#!/bin/bash 2sd_path=$(find /media/$USER -maxdepth 1 -type d -name \u0026#34;*-*\u0026#34;) 3 4while [ ! -d \u0026#34;${sd_path}\u0026#34; ] 5do 6 sleep 1 7 echo \u0026#34;waiting for inserting SD-Card\u0026#34; 8done 9 10echo \u0026#34;SD-Card is inserted\u0026#34; 11cp ./output/kernel/kernel.bin ${sd_path} 12echo \u0026#34;Copy completely\u0026#34; 获取所有文件信息(可递归进入子目录) 获取dir路径下的所有文件的信息, 这里获取的是文件的完整路径.\n TODO\n 操作数组下标的方式可能有待改进? filenum感觉没必要, 暂时还不会改 通过拼接获得文件信息(路径)的方式也有点怪异   1dir=./ 2files=() 3filenum=0 4function getfiles() 5{ 6 for file in `ls $dir`; 7 do 8 if [ -d $file ]; then 9 cd $file 10 getfiles 11 cd .. 12 else 13 files[$filenum]=$(pwd $file)/$(basename $file) 14 # echo file=$(pwd $file)/$(basename $file) 15 let filenum++ 16 fi 17 done 18} 带颜色的输出 使用ANSI escape code\n1Black 0;30 Dark Gray 1;30 2Red 0;31 Light Red 1;31 3Green 0;32 Light Green 1;32 4Brown/Orange 0;33 Yellow 1;33 5Blue 0;34 Light Blue 1;34 6Purple 0;35 Light Purple 1;35 7Cyan 0;36 Light Cyan 1;36 8Light Gray 0;37 White 1;37 Code example:\n1#!/bin/bash 2 3RED=\u0026#39;\\033[0;31m\u0026#39; 4GREEN=\u0026#39;\\033[0;32m\u0026#39; 5YELLOW=\u0026#39;\\033[1;33m\u0026#39; 6BLUE=\u0026#39;\\033[0;34m\u0026#39; 7CYAN=\u0026#39;\\033[0;36m\u0026#39; 8NC=\u0026#39;\\033[0m\u0026#39; # No Color 9 10echo -e \u0026#34;${YELLOW}HELLO, YELLOW${NC}\u0026#34; 11echo -e \u0026#34;${GREEN}HELLO, GREEN${NC}\u0026#34; 12echo -e \u0026#34;${RED}HELLO, RED${NC}\u0026#34; 13echo -e \u0026#34;${BLUE}HELLO, BLUE${NC}\u0026#34; 14echo -e \u0026#34;${CYAN}HELLO, CYAN${NC}\u0026#34; 15 16######################################################### 17# generic functions ##################################### 18 19function ERROR(){ 20 echo -e \u0026#34;${RED}[error] $*${NC}\u0026#34;; 21 exit 1 22} 23 24function INFO { 25 echo -e \u0026#34;${BLUE}[info] $*${NC}\u0026#34;; 26} 27 28function WARN { 29 echo -e \u0026#34;${YELLOW}[warn] $*${NC}\u0026#34;; 30} 31 32function LOG { 33 echo -e \u0026#34;${GREEN}[log] $*${NC}\u0026#34; \u0026gt;\u0026gt; $LOG 34} 35 36INFO \u0026#34;This is an infomation\u0026#34; 37WARN \u0026#34;This is a log\u0026#34; ","date":"2022-07-20T11:54:13+08:00","permalink":"https://wangloo.github.io/posts/shell/shell-script/","section":"posts","tags":["Shellscript"],"title":"Shellscript"},{"categories":["C Language"],"contents":"连续内存取n bit 1#include \u0026lt;stdio.h\u0026gt;2#include \u0026lt;stdint.h\u0026gt;3#include \u0026lt;assert.h\u0026gt;4 5#define bitmask(n) ((1ul \u0026lt;\u0026lt; (n)) - 1) 6 7/* 8* 从ptr指向的内存开始，抽取第start个bit开始的连续n个bit 9* 限制: n \u0026lt; 32 10*/ 11uint32_t extract_bits(uint8_t *ptr, uint32_t start, uint32_t n) 12{ 13 uint32_t start_byte = start / 8; 14 uint32_t start_offset = start % 8; 15 uint32_t *pstart = (uint32_t *)(ptr + start_byte); 16 17 uint32_t end = start + n - 1; 18 uint32_t end_byte = end / 8; 19 uint32_t end_offset = end % 8; 20 uint32_t *pend = (uint32_t *)(ptr + end_byte); 21 22 uint32_t data = *pstart \u0026gt;\u0026gt; start_offset; 23 24 if (n \u0026gt; 32 - start_offset) { 25 /* 由于n \u0026lt; 32, 所以补齐*pend一定就够了， 26* end_offset对齐到最后一位(n-1). 27* 28* 严谨性证明: n 一定\u0026gt; end_offset + 1 29* 因为n \u0026gt; 32-start_offset ==\u0026gt; n \u0026gt; 25, 30* 且end_offset + 1 \u0026lt; 9, 故得证 31*/ 32 data |= *pend \u0026lt;\u0026lt; (n - end_offset - 1); 33 } 34 35 return data \u0026amp; bitmask(n); 36} 37 38void test_val(uint32_t val, uint32_t expect) 39{ 40 if (val != expect) { 41 printf(\u0026#34;error: val: 0x%x, expect: 0x%x\\n\u0026#34;, val, expect); 42 } 43 assert(val == expect); 44} 45 46 47int main(void) 48{ 49 uint32_t vals[] = {0x11223344, 0x11223344}; 50 uint32_t ret; 51 52 ret = extract_bits((uint8_t *)vals, 31, 30); 53 test_val(ret, 0x22446688); 54 55 56 printf(\u0026#34;Test Passed!\\n\u0026#34;); 57 return 0; 58} 一个数取连续n bit 1/* 2* 从一个数中取第start个bit开始的连续n个bit 3*/ 4uint32_t extract_bits (uint32_t val, uint32_t start, uint32_t n) 5{ 6 return (val \u0026gt;\u0026gt; start) \u0026amp; bitmask(n); 7} 判断一个数是否为2的幂 1unsigned int v; 2 3if ((v \u0026amp; (v - 1)) == 0) 4 printf(\u0026#34;v is a power of 2\\n\u0026#34;); 5else 6 printf(\u0026#34;v is not a power of 2\\n\u0026#34;);  统计一个数的二进制中1的数量 依然是利用v \u0026amp; (v -1)的运算结果会将v的最低位的1(如果有的话)置0.\n循环执行此操作就可统计v中1的数量.\n1int numberof1(int v) { 2 int count = 0; 3 4 while(v) { 5 count++; 6 v = v \u0026amp; (v -1); 7 } 8 return count; 9}  将一个数向上取整为2的幂 用一个1一直左移, 直到比这个数大为止.\n1uint32_t roundup_pow_of_two(const uint32_t x) { 2 uint32_t ret = 1; 3 4 while (ret \u0026lt; x) { 5 ret = ret \u0026lt;\u0026lt; 1; 6 } 7 return ret; 8} Linux内核中使用了一种更快的方案, amazing!!!\n1static __inline__ int generic_fls(int x) 2{ 3\tint r = 32; 4 5\tif (!x) 6\treturn 0; 7\tif (!(x \u0026amp; 0xffff0000u)) { 8\tx \u0026lt;\u0026lt;= 16; 9\tr -= 16; 10\t} 11\tif (!(x \u0026amp; 0xff000000u)) { 12\tx \u0026lt;\u0026lt;= 8; 13\tr -= 8; 14\t} 15\tif (!(x \u0026amp; 0xf0000000u)) { 16\tx \u0026lt;\u0026lt;= 4; 17\tr -= 4; 18\t} 19\tif (!(x \u0026amp; 0xc0000000u)) { 20\tx \u0026lt;\u0026lt;= 2; 21\tr -= 2; 22\t} 23\tif (!(x \u0026amp; 0x80000000u)) { 24\tx \u0026lt;\u0026lt;= 1; 25\tr -= 1;1 26\t} 27\treturn r; 28} 29 30static inline unsigned long __attribute_const__ roundup_pow_of_two(unsigned long x) 31{ 32\treturn (1UL \u0026lt;\u0026lt; generic_fls(x - 1)); 33}  向上/向下对齐, 检查是否对齐 1/* uintptr_t 代表指针的位数 2* 加uintptr_t转换的原因是: (void *)不能进行运算 3*/ 4#define IS_ALIGNED(X, align) (((uintptr_t)(const void *)(X)) % (align) == 0) 5#define ALIGN_UP(X, align) (((X) + ((align) - 1)) \u0026amp; ~((align) - 1)) 6#define ALIGN_DOWN(x, align) ((X) \u0026amp; ~((align) - 1)) 7 8#define X (0x12345675) 9#define align (1 \u0026lt;\u0026lt; 2) 10 11int main() 12{ 13 int v = IS_ALIGNED(X, align); 14 15 if (0 == v) { 16 printf(\u0026#34;Given X(0x%x) is not align to 0x%08x\\n\u0026#34;, X, align); 17 printf(\u0026#34;After align up, new X = 0x%x\\n\u0026#34;, ALIGN_UP(X, align)); 18 printf(\u0026#34;After align down, new X = 0x%x\\n\u0026#34;, ALIGN_DOWN(X, align)); 19 } else { 20 printf(\u0026#34;Give X(0x%x) is aligned to 0x%08x\\n\u0026#34;, X, align); 21 printf(\u0026#34;After align up, new X = 0x%x\\n\u0026#34;, ALIGN_UP(X, align)); 22 printf(\u0026#34;After align down, new X = 0x%x\\n\u0026#34;, ALIGN_DOWN(X, align)); 23 } 24 25 return 0; 26}  检查两个有符号数是否异号 1int x,y; 2 3if ((x ^ y) \u0026lt; 0) 4 printf(\u0026#34;They have opposite signs\\n\u0026#34;); 5else 6 printf(\u0026#34;They have same signs\\n\u0026#34;);  大小端转换  对某个位的get/set/clear操作 1#define GET_BIT(x, bit) ( ((x) \u0026amp; (1ULL \u0026lt;\u0026lt; (bit))) \u0026gt;\u0026gt; (bit) ) 2#define SET_BIT(x, bit) ( (x) |= (1ULL \u0026lt;\u0026lt; (bit)) ) 3#define CLEAR_BIT(x, bit) ( (x) \u0026amp;= ~(1ULL \u0026lt;\u0026lt; (bit)) )  Release note:\n 添加对unsigned long long长度的支持    Sign extending from a varaiable bit-width 1 int bits = 2 * 8; // number of bits representing the number in x 2 int x = 0xFFC1; // ready to get sign-extended 3 int rst; // resulting sign-extended number 4 int const mask = 1U \u0026lt;\u0026lt; (bits - 1); // mask can be pre-computed if bits if fixed. 5 6 x = x \u0026amp; ((1U \u0026lt;\u0026lt; bits) - 1); // cut x if it holds more bits 7 rst = (x ^ mask) - mask; // excellent trick! 8 9 printf(\u0026#34;INPUT: 0x%x, RESULT: 0x%x\\n\u0026#34;, x, rst);  字符/字符数组的大小写转换 1#define TO_LOWER(c) (unsigned char)((c \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;Z\u0026#39;) ? (c | 0x20) : c) 2#define TO_UPPER(c) (unsigned char)((c \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;z\u0026#39;) ? (c \u0026amp; ~0x20) : c) 3 4#define TO_LOWER_STR(s, len) { \\ 5for (int i = 0; i \u0026lt; len \u0026amp;\u0026amp; s[i] != \u0026#39;\\0\u0026#39;; i++) { \\ 6s[i] = TO_LOWER(s[i]); \\ 7} \\ 8} 9 10#define TO_UPPER_STR(s, len) {\\ 11for (int i = 0; i \u0026lt; len \u0026amp;\u0026amp; s[i] != \u0026#39;\\0\u0026#39;; i++) { \\ 12s[i] = TO_UPPER(s[i]); \\ 13} \\ 14} ","date":"2022-07-03T09:44:13+08:00","permalink":"https://wangloo.github.io/posts/c/bitops/","section":"posts","tags":["c"],"title":"C 语言位操作技巧"},{"categories":null,"contents":" 堆的含义 我们都知道malloc动态申请的变量是存放在堆中. 所以相比栈来说, 堆是动态的.\n堆占据进程虚拟地址空间的大部分, 我们可能通过堆来申请1GB的数组, 但是栈通常不行 , 大多也就几兆的空间.\n 堆空间的管理 进程中堆空间的管理是运行库负责的, 在Linux中是GLIBC.\n运行库在初始化时会像操作系统申请一大块的堆空间, 再为每个进行分别分配需求. 当然, 如果某些程序的需求过大, 运行库也可以使用mmap系统调用直接向操作系统申请, 然后 返回给用户进程.\n GLIBC的malloc函数的处理方式是: 对于小于128KB的申请, 会从运行库\u0026quot;批发的\u0026quot;堆空间 里分出一块来; 但若申请的空间过大, 则使用mmap系统调用来创建匿名空间分配给用户.\n  Linux中虚拟地址块(VMA)的管理使用了红黑树, 可以用于运行库管理自己向操作系统 \u0026ldquo;批发\u0026quot;的堆空间. 使得用户程序动态申请和释放内存性能提高.\n ","date":"2022-06-28T16:41:54+08:00","permalink":"https://wangloo.github.io/posts/os/stack-and-heap/","section":"posts","tags":["Operating system","Virtual memory"],"title":"Stack and Heap"},{"categories":["Operating System"],"contents":"静态链接带来的问题   像是libc这种几乎每个程序都要用到的库, 如果是静态的, 那么不仅意外着每个程序的 可执行文件很大, 浪费磁盘空间. 并且当程序加载到内存时, 可能许多程序都会用到printf , 使得内存中会存在好多份的printf源码.\n  维护和更新难. 一旦静态链接的其中一个目标文件更新, 所有的可执行程序都要重新链接.\n  不满足局部性原理. 上面提到, 内存中同时存在多份的printf源码会破坏局部性原理的. 显然如果所有的程序共享一份printf源码的想法更好. 即动态加载.\n  可移植性差. 静态链接, 只要有一个依赖目标文件的实现不同, 软件厂商就得专门发布一个 版本. 而动态链接则信赖客户电脑上的动态库, 相当于一个中间层.\n  动态链接的过程 对比静态链接使用ld链接器在编译后即执行链接, 动态链接则是将链接过程推迟到运行时, 即装载到内存时.\n这样, 链接器在链接产生可执行文件时就有两种做法:\n 对于静态符号, 按照静态链接的规则进行地址引用重定位 对于动态符号, 链接器则仅标记其为动态链接中的符号, 不进行处理. 而是等到装载时由 专门的动态链接器来完成动态符号的链接工作.  ⁉️ 链接器如何确定一个符号是静态的 or 动态的?\n在动态共享对象(.so)中保存了完整的动态符号表*, 表中存在的符号即为动态的, 否则为静态.\n Linux 的 C 语言运行库glib的动态链接版本叫libc.so. 它在外存上只保存一份, 所有的程序 都可以在运行时使用它. 所以千万不要删掉它.\n  动态链接有一定的性能损失, 因为每次运行程序时都要重新链接, 并不像静态链接是一劳永逸的. 也有例如延迟绑定对性能进行优化的方法, 大概仅有 5%的损耗, 与带来的便利相比可以忽略不计.\n 地址无关代码 PIC GCC 生成动态库时需要添加参数-fPIC, 含义就是生成地址无关码\n地址无关码的含义是代码中不包含任何的绝对地址引用, 全都是相对地址.\n 对于模块内的跳转/数据引用, 使用相对的跳转/加载指令. 例如 ARM 指令集中的B, ADR, 经过汇编器之后, 目标的地址都会转为相对于该指令(PC)的偏移. 对于模块间的跳转/数据引用, 借用GOT 表来间接实现地址无关.  而如果该动态库中全部使用相对地址, 那么加载时也就不需要进行重定位, 即所有的程序都可以 共享这些地址无关代码.\n 上面说 PIC 的动态库不需要重定位其实是错误的, 只不过它的重定位过程不需要修改代码段, 而是设置了一个放置在数据段的GOT表来实现代码段部分的地址无关特性.\n  现在貌似 GCC ARM 版本在编译动态库时强制使用-fPIC 选项, 否则会报错. 对此我不是 非常确定!\n  一般来说, 不将主程序编译为地址无关码. 因为主程序不需要共享, 而且地址无关码的调用 需要两个指令: 计算地址 + 跳转. 多了一步根据偏移得到绝对地址.\n 动态加载 上面说的，有了动态链接之后，库文件的重定位到运行时。运行时一定是库加载到内存时候吗？ 看你怎么理解“运行时”，是主程序运行的时刻，还是库中的代码运行的时刻。所以我可以回答的是： 主程序运行时，动态库不一定立马加载到内存，也就不一定发生动态链接。\n动态加载这种思想类似于 COW，可以提升主程序启动的速度，启动消耗的内存更小。 缺点就是第一次调用库的速度变慢，因为加载、重定位都需要发生。\n有一个需要注意的点，一般的动态链接过程（不考虑动态加载）就是所有的库一股脑加载到内存， 然后进行重定位工作。重定位完所有符号后，会将主程序的 GOT 表设置为只读，避免 got 表被恶意修改， 这个过程是动态链接器ld.so做的。\n 这个说法可以通过看 elf 的 section 布局确定，got 表都会和一些其他的只读 section 放在一起， 而与总是 RW 的 section 分开，这样布局以后设置 got 只读的时候更加方便。    这里图中的 got 虽然是可写入的，只是为了可以被重定位修改，改完之后由 ld.so 重映射为只读。\n 加入动态加载之后，其实 got 表不能在主程序加载完后就设为只读，因为链接延后到了动态库加载到内存时， 现在的做法时，将 got 表进行拆分==\u0026gt; .got 和.got.plt, .got.plt 保存的是以后运行中随时需要重定位的符号， 就不能被设为只读，而为了兼容，.got 就会在主程序加载后被设为只读，因为里面没有需要执行时重定位的符号了。\n 主程序编译时添加选项 -Wl,-z,lazy 启用动态加载\n      动态链接和动态加载关系 动态加载和动态链接并不进行绑定\n 静态链接-动态加载：因为是静态链接，所以库的地址已经确定，但加载时只分配虚拟地址空间 动态链接-动态加载：用到库时才加载到内存，此时才进行动态重定位 动态链接-静态加载：运行主程序时库同时被加载到内存，然后立马执行动态重定位  ","date":"2022-06-26T19:50:45+08:00","permalink":"https://wangloo.github.io/posts/os/dynamic-link/","section":"posts","tags":["Operating System"],"title":"操作系统：动态链接/动态加载"},{"categories":["Operating System"],"contents":"ELF是什么 ELF（Executable Linkable Format）可执行文件格式不止是单指“可以被执行的文件”， 动态链接库、静态链接库都按照可执行文件格式来存储。\nELF标准里把采用ELF格式的文件分为四类：\n   Type description 实例     Relocatable File 这些文件包含了代码和data, 可以被用来链接成可执行文件或共享目标文件. .o, .a   Executable File 直接可执行的文件 /bin/ls   Shared Object File Including code and data. 链接器可将其与其他Relocatable File或Shared Object File结合, 生成新的目标文件. 动态链接器可将其与Executable File结合, 作为进程映像的一部分来运行. .so   Core Dump File Restore critical infomation when process is terminated unexpectedly core dump     📌 file command in Linux can output the format of a file.\n 关于静态库 一个静态库可以简单的看作是 a set of object file.\n这些 object file 可能包括: 输入输出相关的printf.o, scanf.o, 日期时间相关的time.o, date.o等.\n❓ 为什么不直接提供这些目标文件呢?\n这些零散的文件若直接提供给使用者, 很大程度上造成文件传输, 管理等方面的不便.\n于是人们通常使用ar压缩程序将这些目标文件压缩到一起.\n❓ 如何查看一个静态库是由哪些object file压缩到一起的?\nShell commandar -t libc.a 可以查看libc.a中包含的所有object files.\nELF 文件组成的结构 知道了ELF文件是什么，接下来就看看其内部的结构。\n1+---------------------------------+ 2| ELF Header | 包含描述整个ELF的基本信息, 如版本, 入口地址... 3+---------------------------------+ 4| .text | 5+---------------------------------+ 6| .data | 7+---------------------------------+ 紧接着是各个段 8| .bss | 9+---------------------------------+ 10| ... | 11| other sections | 12+---------------------------------+ 13| | 与section相关最重要的结构 14| Section Header table | 描述了每个section的名称,长度,权限... 15| | 16+---------------------------------+ 17| | 与segment相关最重要的结构 18| Program Header table | 描述了每个segment的位置、属性(RWX)、size... 19| | 20+---------------------------------+ 21| String tables | 22| Symbol tables | 23+---------------------------------+ ELF Header    字段 含义     e_machine 目标架构   e_entry 入口地址   e_machine 目标架构   e_phnum number of entries in the program header table   e_shnum number of entries in the section header table   e_shoff offset, in bytes, of the section header table   e_phoff offset, in bytes, of the program header table   e_machine 目标架构   e_machine 目标架构    Program Header Table 每个表项对应一个segment，表明其位置、属性(LOAD?动态链接用?)、memory size和file size，权限(RWX)等。\n Memory Size \u0026gt;= Segment Size, 因为有BSS段存在。\n Section Header Table 相应地，每个表项指定一个section的信息，包括名字、大小、地址等。\n如何生成一个ELF可执行文件 从一个C文件到一个ELF可执行文件包括编译、链接两个步骤，具体来说，共包含4个步骤：\n   预编译 1gcc –E hello.c –o hello.i 预编译过程主要处理那些源代码文件中的以“#”开始的预编译指令。比如 “#include”、“#define ”等\n 将所有的 “#define ”删除，并且展开所有的宏定义。 处 理 所 有 条 件 预 编 译 指 令， 比 如 “#if”、“#ifdef”、“#elif”、“#else”、“#endif ”。 处理 “#include ”预编译指令，将被包含的文件插入到该预编译指令的位 置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其 他文件。 删除所有的注释“//”和“/* */”。 添加行号和文件名标识，比如#2“hello.c”2，以便于编译时编译器产生调 试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。 保留所有的 #pragma 编译器指令，因为编译器须要使用它们。  编译 1gcc –S hello.i –o hello.s # or 2gcc –S hello.c –o hello.s 编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件\n汇编 1as hello.s –o hello.o # or 2gcc –c hello.c –o hello.o 汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都 对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单， 它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指 令和机器指令的对照表一一翻译就可以了\n链接 一个可执行文件可能需要用到许多个目标文件，例如C库、pthread库、自己写的库等。 链接的过程就是把他们组合在一起，生成最终的可执行文件。\n仅编译过程中，如果对于外部的函数，编译器无法确定实际跳转的地址， 只能先写0，链接过程会对这个值进行修改。\n主要包含两个过程：（1）地址空间分配（2）重定位\n 地址空间分配：这么多.o，这么多section，他们结合为可执行文件后地址怎么规划呢？是不是有的 section 可以合并，比如多个代码段。 重定位：对于外部调用的函数，这些实际的值也需要更正，或者采用别的方法来间接寻址（动态链接）  静态链接 重定位\n合并后的每个section都有一个重定位表.rel.xx， 里面的内容大概是:\n1RELOCATION RECORDS FOR [.text]: 2OFFSET TYPE VALUE 30000001c R_386_32 shared 400000027 R_386_PC32 swap 对于每个需要重定位的指令，都会在这里表里对应到，所以链接时需要遍历它，填充上真正的地址。\n动态链接 静态链接的做法就决定了，程序A和B不能共享同一份库，浪费内存。库编进了可执行文件中，所以生成的可执行文件就很大， 另外这样如果要修改库的话就需要对所有依赖的A和B都重新编译。\n动态链接是目的是解决上面的问题，也就是说，库不编到ELF里，ELF在运行的时候能找到它就行。 这样一个程序编译链接后其实不能确定库的地址, 而是将这个过程推迟到运行时的某个时间。\n 详细可见动态链接\n ELF 加载  废了半天劲编译生成的ELF文件, 想要最终跑起来则包含的instruction and data必须要在内存中.\n 我们能想到的最简单的办法是: 把整个ELF的所有指令和数据在运行之前就全部load到内存中. 这就是静态加载.\n更加高效的做法是: 充分利用局部性原理, 将指令和数据划分为模块, 只有当该模块被使用时, 才load进内存, 否则就在外存中老老实实呆着. 这就是动态加载.\n静态加载  读取ELF header, 校验magic number和架构是否正确 根据ELF header中指定的 program header table地址去读 segments 加载segments 中属性为LOAD的segment, 先要分配对应的虚拟空间, 根据ELF的LMA 加载程序为ELF分配栈空间，并填充argc, argv，env等。  参数、环境变量怎么填充需要参考体系结构的ABI手册\n  将PC设置为ELF header中entry point, 返回到用户态开始执行  动态加载  详细可见动态加载\n 其他问题汇总 为什么要区分section和segment segment是加载关心的, section是链接过程关心的。\n segment中包含了多个section, 这些section地址相连、属性类似, 加载器只按照segment去加载。 而链接时, 链接器会对每个section进行重定位, 同时也需要 .rel* section来完成重定位。 调试信息也是按照section进行存储的，调试器依赖他们得到符号信息。  为什么目标文件中代码和数据要分开放? 一方面, 程序被加载进内存后, 代码段和数据段分别被映射到两个virtual memory region. 通过MMU的支持, 可以将代码段的区域设置为只读, 防止恶意篡改.\n另一方面, 当下CPU Cache多划分为Instruction Cache和Data Cache, 再配合互相独立的 地址区域能够提高局部性原理的效果.\n最后, 代码段可以被多个进程共享(例如都调用同一外部函数), 节省内存空间.\n 针对嵌入式设备, 如果内存空间不够大, 只读的代码段可存放在ROM中\n 段地址对齐技术  由前面动态加载的步骤可知, ELF文件中的代码和数据被按page划分. 并只有在用到时才被加载到内存, 并建立虚拟内存-物理内存的映射.\n 假设一个ELF有三个段需要被LOAD, ELF段表如下:\n   Segment Length offset     SEG 0 127 B 34 B   SEG 1 9899 B 164 B   SEG 2 1988 B 0 B    ❓ 这三个段在ELF文件中的布局如何? 根据前面ELF文件格式的介绍, 这三个段必然是挨着的(简单考虑, ELF中仅有这三个段).\n❓ 这三个段在物理内存中的布局? 发生page fault之后, OS会为页面分配合适的物理页面, 如利用buddy system等.\n可以保证段内的连续, 不能保证段与段是连续的.\n 未使用段对齐技术之前, SEG0的长度不足一页, 但是也给它分配一页的空间. 同理为SEG1分配两页, SEG2分配一页. 总共占用 1+2+1=5个物理页.\n ❓ 这三个段在用户virtual addrspace下的布局如何? todo\n❓ 何为段地址对齐技术? 上面说了, 在为这三个段分配物理内存时, 虽然他们的真实大小远小于5个页面, 但由于简单采用: 每个段的开头必须是page align, 导致实际上产生了巨大的内部碎片.\n段地址对齐实际上就是在为ELF文件中的段分配物理内存时, 不考虑其段的独立性, 强制按照page来划分. 划分的行为如下图所示. 结果就是仅需占用3个物理页面.\n1+---+---------------+ 2| P | SEG0 | 3| A +---------------+ 4| G | | 5| E | | 6+---+ | 7| P | SEG1 | 8| A | | 9| G | | 10| E | | 11+---+ | 12| P +---------------+ 13| A | | 14| G | SEG2 | 15| E | | 16+---+---------------+  目前, gcc(更准确是说是GUN ld)默认启用段对齐技术. 各个段的虚拟地址并不是page align.\n  🍀 物理页面到虚拟页面的映射阶段, 那些同时包含两个段的页面会被映射两次, 即一个物理页面对应两个 虚拟页.\n原因是: 在一个页面的不同段可能权限不同, 所以不能使用同一映射.\n ","date":"2022-06-20T16:21:27+08:00","permalink":"https://wangloo.github.io/posts/binary/elf-format/","section":"posts","tags":["Operating System"],"title":"ELF 文件的链接与加载"},{"categories":["C Language"],"contents":"添加更多的编译选项(comiler options)来防止bug 对于我常用的GCC, 推荐开启一下的compiler options:\n  -Wall: enable a lot of common warnings\n  -Wno-format-truncation: warns about the snprintf output buffer not being large enough for a corresponding “%s” in the format string.\n  -Werror: turn warnings into errors.\n   动态申请的空间到底要不要释放 When using a barebones embedded OS, you absolutely need to tightly manage your memory.\n但是, 如果你是写应用业务的代码, 特别是在内存足够的场景下. 最好不要手动释放内存, 因为当线程/进程退出时, 操作系统会自动帮我们释放. 某些情况下, 释放内存的操作会很大程度上增加逻辑的复杂度.\n 如果你是一个内核程序员, 则必须手动的释放. 不用怀疑.\n  尽可能在创建变量时赋初值 放置某些变量创建后是 magic value. 而使用这些变量可能不会立马导致错误, 但是这是一个隐患.\n但这会产生一个问题, 有时我们定义变量之后的不久之后就会对其赋予正确的值, 这时候初值就是 多余的. 而且维护者可能认为这个值是meaningful, 这就要求我们如果要赋初值, 就要说明这个值 仅仅是无意义的初值.\n 使用#define, enum 对于代码在不同地方使用的同一个值, 应使用#define来声明使得代码maintainable.\n如果这些值有多个且能规划为同一类别, 则还可将#define的方式换为enum. 这会使代码更加meaningful\n 使用enum使还要注意其所占内存空间在不同架构中可能不同的问题, see enum的优势和漏洞\n  使用typedef优化function pointer  重定义一套自己的类型 在开发大项目时, 需要考虑可移植性的情况下, 最好利用typedef对类型进行重定义.\n1#if SYSTEM1 2 typedef int INT32; 3 ... 4#else 5 typedef long INT32; 6 ... 7#endif 如上, 对于某些架构int类型可能不是32bit, 此时就要使用long. 这种定义的方式会保证我们的系统 在任何架构中都不会出现类型的bug. 而且也增加了代码的readability.\n 善用~0 在做嵌入式编程时, 有时在设置掩码(mask)或者其他情况会要用到全1的变量值, 你是否经常这样声明?\n1int mask = 0xffff; 暂且不谈int类型到底占多少字节的问题. 就像上面一样, 我们程序员经常忘记某个类型的大小, 而少添加了f. 会导致变量mask的值不是全1(32位情况下).\n这是要变换一下思维, 使用~0的定义方法就可轻松化解, 无需管变量的类型是什么.\n1int mask = ~0;  合理的使用goto语句 在大学课堂中, 我们老师说过禁止使用goto语句, 但却没有给出明确的原因.\n实际上, 合理的使用goto能够极大的减少程序的冗余度.\ngoto语句常用于程序出现错误要退出时, 可能有多个情况会使用重复的代码处理, 例如释放一些allocated memory. 相较于使用flag, 使用goto显然更加clearly and readability.\n所以, 在面对重复的错误处理代码时, 想想能不能用goto进行优化. 当然, 避免过早优化.\n 注意, goto出现的场景其实很受限. Never use a backward goto or jump into control statements.\n  定义合理, 正确的结构体 结构体是C语言编程应用中常用的数据结构, 关于结构体也有许多要注意的点.\n#1 Flexible Array Member C99开始支持Flexible Array Member. 且看我lstring库的结构体定义:\n1struct str { 2 int length; 3 int size; 4 char data[]; // Flexible array member - C99 only 5}; 对于这种不定长的数组元素, 我之前都是定义一个指针, 占用一个sizeof(char *)的空间. 而Flexible Array Member本身不占用空间. 需要在malloc时为他单独声明空间.\n1int n = 100 2struct str *s = malloc(sizeof(struct str) + sizeof(char[n]));  这里也有一个小trick, 使用sizeof(char[n]) 比 sizeof(char) * n 更简洁!\n # 2 Padding and Packed 有关结构体的大小, 和地址对齐的问题. 假设我有一个结构体如下:\n1struct mystruct_A 2{ 3 char a; int b; char c; 4} x; Padding是编译器对结构体默认做的事情. 它会在成员之间插入一些 gap 来保证地址对齐:\n1struct mystruct_A { 2 char a; 3 char gap_0[3]; /* inserted by compiler: for alignment of b */ 4 int b; /* int 在32位上其地址是4字节对齐的 */ 5 char c; 6 char gap_1[3]; /* -\u0026#34;-: for alignment of the whole struct in an array */ 7} x;  除了保证每个成员的地址是对齐的, 整个结构体的地址也是按照其最大的成员类型来对齐, 即对齐到int(4字节).\n 如果你不想要这些 gap, 那么可以对结构体声明使用 __attribute__((__packed__))关键字. 整个结构体大小仅为6个字节.\n1struct __attribute__((__packed__)) mystruct_A { 2 char a; 3 int b; 4 char c; 5};  永远为你的函数设置error return value 一旦你的函数可能被其他人调用, 那么养成设置return value的习惯. 即便你现在的实现 并不会产生任何错误, 也请返回success.\n这样做的原因是, caller可以根据你的定义做错误判断, 即便以后你的实现加上了出错情况, 上层的代码也不需要修改.\n 变量类型的选择  名字, 特定不变的字符串使用const char *, 甚至const char const* 长度使用size_t 表示类型的参数尽可能使用enum 循环变量i使用signed, 避免溢出后出错   Reference How I Improve My (C) Code Quality\nTen Fallacies of Good C Code\n","date":"2022-06-14T17:59:22+08:00","permalink":"https://wangloo.github.io/posts/c/improve_quality/","section":"posts","tags":["c"],"title":"写高质量的C语言工程的规范"},{"categories":["Operating System"],"contents":"seL4 Capabilities In seL4, capabilities are stored in C-space. C-space is a hierarchical data structure very similar to page table.\n page table is a mapping from virtual address to physical address. C-space is a mapping from object ID to capability. Kernel object is made up of several C-nodes, just like a page table made up of individual page tables. Each C-nodes is an array of cap slots, which contain capability.  Inaccessible to userland, you can never hold an actual capability\n You can only hold a reference to capability, which pointers into C-space(slot addresses) These C-space addresses are called CPTRs   You don\u0026rsquo;t need to do the transform, because this is typically extracted in some libs.\n Capabilities convey specific privilege (acces rights)\n Read, Write, Execute, GrantReply(call), Grant(cap transfer)  Main operations on capabilities:\n Invokeperform operation on object referred to by cap.  For example, map some frame into memory. You need to have capabilities to both the frame and address space.   Copy|Mint|Grant: create copy of cap with same/lesser privilege. Move|Mutate: transfer to different address with same/lesser privilege.  Between C-space or within C-space.   Delete: invalidate slot(cleans up object if this is the only cap to it) Revoke: delete any derived(eg. copied or minted) caps  Capability Derivation MINT OPERATION The Mint operation creates a new, less powerful cap\n Can add badge Can strip access rights, eg RW-\u0026gt;RO  1mint(dest, src, rights, badge)  The first two arguement are capability pointers(CPTR) to a C-space(represented by C-node), which are references inside C-node. The destination C-node cap must allow modification Then you have the rights and the batch of the new cap.  📌 This is an alternative of sending addressed capabilities by IPC operation. That is what operating system do to set up protection domains for user level process.\nCOPY OPERATION  Copy as a version of Mint.\n  seL4 Kernel Objects In file libsel4\\include\\sel4\\objecttype.h\n1typedef enum api_object { 2 seL4_UntypedObject, 3 seL4_TCBObject, 4 seL4_EndpointObject, 5 seL4_NotificationObject, 6 seL4_CapTableObject, 7#ifdef CONFIG_KERNEL_MCS 8 seL4_SchedContextObject, 9 seL4_ReplyObject, 10#endif 11 seL4_NonArchObjectTypeCount, 12} seL4_ObjectType;  seL4 System Calls seL4 has 11 syscalls:\nYield(): invokes scheduler\n does NOT require a capability!  Send(),Recv() and variants/combinations thereof: IPC operations\n Call(),ReplyRecv(): usually invokes by client/server Send(), NBSend(): send-only and non-blocking version of it. Recv(), NBRecv(), NBSendRecv() Wait(), NBWait(), NBSendWait()   We just use Call() normally, the others are only for bootstrapping protocols and exception handling.\n Call() is atomic Send() + reply-object setup + Wait()\n cannot be simulated with one-way operations!  ReplyRecv() is NBSend() + Recv()\nDifferent object support different operations ENDPOINTS Endpoints support all 10 IPC variants.\nNOTIFICATIONS Notifications support:\n NBSend() - aliased as Signal() Wait() NBWait() - aliased as Poll()  OTHER OBJECTS Other objects only supports Call() operation.\n Appear as (kernel-implemented) servers. If you invoking a method on an object, this is done by treating the object as a kernel-implemented server. And you invoke it with a call() operation just as you do a normal server invocation. Each of these kernel objects has a different kernel-defined protocol  operations encoded in message tag parameters passed in message words   Mostly hidden behind syscall wrappers, user do not need to know this details.   seL4 IPC  IPC in seL4 is a way to realize cross-domain invocation.\n seL4 IPC is not a mechanism for shipping data. Transfering data is axillary but not the primary purpose.\nseL4 IPC is a protected procedure call, a user-controlled context switch(from clients context into server context).\n seL4 Threads Creating a thread  Obtain a TCB object Set attributes: V-space, C-space, fault endpoint, IPC buffer Set Scheduling parameters:  priority, scheduling context, timeout endpoint(maybe MCP)   Set architecture-related registers  Threads and Stacks Stacks are completely user-managed, kernel doesn\u0026rsquo;t care!\n Kernel only preserves SP.. on context switch\n Stack location, allocation, size must be managed by userland.\nKernel beware of stack overflow\n","date":"2022-06-04T11:52:51+08:00","permalink":"https://wangloo.github.io/posts/os/sel4/","section":"posts","tags":null,"title":"操作系统：SeL4 基础概念"},{"categories":["Hugo"],"contents":"本章将解答Hugo是什么, 以及Hugo是如何工作的. 只有了解Hugo的工作机制之后, 才能发挥想象力进行DIY.\n本章内容大多来自官方手册或者搜索引擎提供的结果.\nHugo 项目结构 一个hugo 项目通常包含以下内容:\n1. 2├── archetypes 3├── config.toml 4├── content 5├── data 6├── layouts 7├── public 8├── static 9└── themes 这里面有些是必须的, 有些是可选的.\narchetypes\n定义新创建post时, header的格式.\nasserts\n Note: assets directory is not created by default.\n config\nHugo uses the config.toml, config.yaml, or config.json (if found in the site root) as the default site config file.\nThe user can choose to override that default with one or more site config files using the command-line --config switch.\n1hugo --config debugconfig.toml 2hugo --config a.toml,b.toml,c.toml  Config directory is not created by default.\n content\n显然, 存储所有的post.\ndata\nThis directory is used to store configuration files that can be used by Hugo when generating your website.\n像是你 website 的一个mini 数据库, 你可以放置 toml, yaml, json格式的文件.\nlayouts\nStores templates in the form of .html files that specify how views of your content will be rendered into a static website. Templates include list pages, your homepage, taxonomy templates, partials, single page templates, and more.\npublic\n保存build生成的站点. 当运行hugo [flag]时生成.\n拷贝该目录下的内容, 可以部署到web 服务器上了.\nstatic\nStores all the static content: images, CSS, JavaScript, etc. 当Hugo构建您的站点时，静态目录中的所有资源都会按原样复制。\n即当构建website时, static/下的所有文件都会复制到 public/下.\nThe static files are served on the site root path (eg. if you have the file static/image.png you can access it using http://{server-url}/image.png, to include it in a document you can use ![Example image](/image.png) ).\nresources\n一些缓存文件\n resources directory is not created by default.\n Hugo Cli Command hugo 支持的所有命令可以通过 hugo help 命令来查看. 每一条命令的具体用法, 可以执行 hugo [command] help 来查看\n1Usage: 2 hugo [flags] 3 hugo [command] hugo completion\n用来配置补全 hugo command 和 flag 的. 该命令会输出一段脚本, 将该脚本复制到你的 shell 的配置文件中就可以使用 hugo tab 补全了.\nhugo config\n打印hugo的配置文件, 即根目录下的 config.toml.\nhugo env\n打印 hugo 的版本和环境信息\nhugo list\n打印所有post的info, 包含标题, 发布日志, 链接等.\nhugo new\n非常重要的命令, 可以用来新建一个 website, 主题, 或者一篇post(常用). 带有许多 flag可以使用.\nhugo server\n执行hugo server之后, 首先构建了你的网站(但是默认并不在本地创建文件, 而是放在内存), 然后启动hugo 自带的 web服务器让我们能看见网站的效果.\n同时, 默认情况下, server 会同步你的本地更改, 然后实时的reload你的页面. 这样你就能同时看到修改的效果.\nhugo server 的常用flag:\n1-D 包含标记为草稿的post. 默认不构建草稿. 2--theme strings 使用[strings]主题进行构建 hugo [flags]\nhugo 自身就是一个命令, 用于build website, 放到 public/目录下.\n常用 Flag(All supported flags):\n1--gc 在build后会清除一些cache文件. 与 resource/有关 2--minify minify any supported output format (HTML, XML etc.)  hugo 命令不会删除之前的文件. 而是仅新增改动. 所以每次build时需要你手动删除 public/ 目录.\n Hugo 内容管理 hugo build 后的website页面的布局和你源文件的布局相同, 所有源文件都放置在 content/ 目录下.\n1└── content 2 ├── _index.md // \u0026lt;- https://example.com 3 | 4 ├── about 5 | └── index.md // \u0026lt;- https://example.com/about/ 6 ├── posts 7 | ├── _index.md // https://example.com/posts/ 8 | ├── firstpost.md // \u0026lt;- https://example.com/posts/firstpost/ 9 | ├── happy 10 | | └── ness.md // \u0026lt;- https://example.com/posts/happy/ness/ 11 | └── secondpost.md // \u0026lt;- https://example.com/posts/secondpost/ 12 └── quote 13 ├── first.md // \u0026lt;- https://example.com/quote/first/ 14 └── second.md // \u0026lt;- https://example.com/quote/second/  hugo 将content/ 下的那级目录(例如 content/posts)特殊看待, 称为 section.\n 页面资源(Page Resources) 页面资源指每个页面私有的图片, 文档等静态资源. 与static/ 中全局的资源不同.\n页面资源放在content/下的任意位置, 但不是所有页面都能访问. page bundles 中的index.md or _index.md 能够访问该 bundles 下的资源.\n1content 2└── post 3 ├── first-post 4 │ ├── images 5 │ │ ├── a.jpg 6 │ │ ├── b.jpg 7 │ │ └── c.jpg 8 │ ├── index.md (root of page bundle, 能够访问first-post/下的所有资源) 9 │ ├── notice.md 不能访问任何资源, 但其自身作为一个资源可被index.md访问 10 │ ├── office.mp3 11 │ ├── pocket.mp4 12 │ ├── rating.pdf 13 │ └── safety.txt 14 └── second-post 15 └── index.md (root of page bundle, 但不能访问first-post/下的资源) 内容分类(Taxonomy) Taxonomy: How to group the content together. Two default taxonomies are tags and categories.\n代码高亮(Syntax Highlight) 代码高亮的配置(in config.toml):\nHugo 使用chroma来执行代码高亮。\n Example of all style: https://xyproto.github.io/splash/docs/index.html  页面分类 从布局上来看, 页面可以分为两类: List page 和 single page.\n显而易见, list page比较特殊, 它负责列出当前目录下的所有post. 所以一个目录地址必然是一个list page.\n在下面的例子中, https://example.com , https://example.com/posts/happy/ 都可以叫做 list page.\n  https://example.com/posts/happy/ 是list page, 目录下的_index.md 不是必须的, hugo 会默认仅显示所有post的title. 详见\n  https://example.com/about/ 不是list page, 因为其目录下有index.md, 强制表明这是一个 single page. 详见\n  1└── content 2 ├── _index.md // \u0026lt;- https://example.com 3 | 4 ├── about 5 | └── index.md // \u0026lt;- https://example.com/about/ 6 └── posts 7 ├── _index.md // https://example.com/posts/ 8 ├── firstpost.md // \u0026lt;- https://example.com/posts/firstpost/ 9 ├── happy 10 | └── ness.md // \u0026lt;- https://example.com/posts/happy/ness/ 11 └── secondpost.md // \u0026lt;- https://example.com/posts/secondpost/  Homepage 和 section page 都属于特殊的 list page.\n homepage 特指 content/_index.md section page 特指 content/[section]/_index.md   shortcodes shortcode 可以理解为 hugo 为了封装了一些代码块, 通过 shortcode 来调用.\n模板(Template) 模板是hugo的一个高级用法, 用来定义你网站的style. 模板不等同与主题(themes), 可以理解为主题是一套模板的集合. 我们可以在使用模板的同时添加DIY的 style. 😎 Hugo 会有优先级的判断.\n不同的页面类型需要定义不同的模板. List page 的模板称为 List template, single page 的模板称为 single template. 同理还有 homepage template, section template.\n存储模板的目录为layout/, 上面介绍hugo的目录结构时已经说过. 如果你使用了一个 theme, 那么themes/[your-theme]/layout/就是该theme的模板.\nhomepage 模板 Base 模板 对应layouts/_default/baseof.html\nbase 模板是整个website的核心. 所有的模板包括 list template, single template, homepage template\u0026hellip; 都是独立的, base template 将其他的模板联系到一起.\n分页模板 对于条数过多的场景（比如所有的post list，某个tag的post list），可以构建一个分页器，用【上一页】【下一页】来使单个页面简洁一点，避免滑不到头的情况 :X\n不过对于目前，我还没有那么多条目看不过来，所以暂且没细看。\nPagination模板 官方说明\npartial 模板 包含网站的许多元素, 增加模块化. 我可以为网站的 header 或者 footer 写一个模板(html), 这些HTML可以嵌入其他的模板.\n模板优先级 既然同一种页面的模板可以定义在多个位置, 如果他们同时存在时, 优先级规则必然存在. 常见的情况比如我们使用了某个模板, 然而, 我们对模板中的一些布局不满意, 直接修改模板中的文件显然不是一个好方法, 那么该怎么做呢?\n一般来说, 如果你只想重写theme中的某个模板, 例如section template. 那么你只需要新建 layout/_default/section.html 即可, hugo 构建你的网站时, 如果检测到本地和theme的layout/_default下都有 section.html, 它会使用我们自己定义的那个.\n 完整的, 多级的优先级规则: Hugo\u0026rsquo;s Lookup Order | Hugo (gohugo.io)\n 变量(Variables) ❗ Hugo 变量仅设计给模板使用, 即在layouts/下的html文件.\nPage Variables 与post相关的变量, 定义在post 的 front matter中.\n1// Define Page variables in front matter of post 2---------------- 3title: \u0026#34;使用 HuGo 搭建个人网站\u0026#34; 4description: 学习正确的 Hugo 食用方式, DIY 属于自己的 website~ 5Myvar: \u0026#34;my value\u0026#34; 6---------------- 7 8// Use Page Variables 9{{.Description}} // Get the description of the post 10{{.Params.Myvar}} // Get the value of Myvar, that is, \u0026#34;my value\u0026#34; Site Variables 站点层面的变量大部分是网站配置相关.\n函数(Functions) 函数是hugo为你封装的一些方法你可以直接调用.\n❗ Hugo 函数仅设计给模板使用, 即在layouts/下的html文件. Same as variables.\nHugo pipes 支持 Emoji Adding emoji tutorial\nEmoji chart\n","date":"2022-05-21T17:39:42+08:00","permalink":"https://wangloo.github.io/posts/hugo/basic/","section":"posts","tags":["hugo"],"title":"Hugo 基础概念"},{"categories":null,"contents":"Content Fourteen years ago, Steve stood on this stage and told your predecessors \u0026ldquo;Your time is limited. So don\u0026rsquo;t waste is living someone else\u0026rsquo;s life.\u0026rdquo;\nSo what is true then is true now. Don\u0026rsquo;t waste your time living someone else\u0026rsquo;s life. Don\u0026rsquo;t try to emulate the people who came before you to the exclusion of everything else, contorting into a shape that doesn\u0026rsquo;t fit.\nGraduates, the fact is, when your time comes, and it will, you will never be ready. But you\u0026rsquo;re not suppposed to be. Find the hope in the unexpected. Find the hope int the challenge. Find your vision on the solitary road. Don\u0026rsquo;t get distracted. There are too many people who want credit without responsibility. Too many who show up for the ribbon cutting without building anything worth a damn.\nBe different. Leave something worthy. And always remember that you can\u0026rsquo;t take it with you. You\u0026rsquo;re going to have to pass it on.\nThank you very much. And Congratulations to the Class of 2019!\nYouTube vidio\n","date":"2022-05-18T19:32:38+08:00","permalink":"https://wangloo.github.io/posts/motivation/2019-stanford-commencement-timcook/","section":"posts","tags":["tim cook","address"],"title":"2019 Stanford Commencement Timcook"},{"categories":["HTML/CSS"],"contents":"Get start What is HTML\u0026amp;CSS?   HTML is resonsible for the content of the page. That\u0026rsquo;s the text, images, buttons, etc.\n  CSS is resonsible for the presentation of the content. That\u0026rsquo;s the color, layout, etc.\n  Web designers create the overall look and fell of a website.\n  Web developers implement the design using HTML, CSS and JavaScript code.\n  Configure VIM as HTML code-editor  Finally in the arms of vscode 🙉\n Add vim plugin:\n emmet: Coding HTML faster.  CSS autocomplete key: \u0026lt;C-x\u0026gt; \u0026lt;C-o\u0026gt;\nHTML and CSS live previes plugin: bracey\n urlopen error solution   HTML Fundamentals Anatomy of an HTML element 1\u0026lt;p\u0026gt; THML is a markup language\u0026lt;/p\u0026gt; The HTML element is composed of opening tag, content, closing tag.\nHTML good styles  \u0026lt;img/\u0026gt; element should add alt attritube at all time, for the convenience of the blind. An important principle in web design is making the HTML elements meaningful. That is semantic HTML.   CSS Fundamentals CSS describes the visual style and presentation of the contend in HTML.\nAnatomy of an HTML element 1h1 { 2 color: blue; 3 text-align: center; 4 font-size: 20px; 5} h1 is Seletor, every style has proporty and value.\nCSS good styles  Class selector is more commonly used than ID selector, as ID is unique in HTML. For scalability, remember always using class selector. We should always specify all the four state of \u0026lt;a\u0026gt; element in order, which including link, visited, hover and active.  Priority conflicts between selectors CSS style priority from high to low:\n Inline style(style attribute in HTML) ID selector class or pseudo-class selector element selector universal element selector   The CSS box model The box model defines how elements are displayed on a webpage and how they are sized.\nIn the box model, every element on a webpage can be seen as a rectangular box.\n Universal element \u0026amp; \u0026lt;body\u0026gt; element Styles in \u0026lt;body\u0026gt; selector take effect because of inheritance. But the text-independent elements do not support inheritance.\nThat is where universal element selector is needed. It\u0026rsquo;s styles take effect on all element.\nWhen we want to set padding and margin of all elements to 0. Must put the code in universal element selector.\n Inline elements \u0026amp; Block elements Inline elements:\n Occupies only the space necessary for its content. Box model applies in different way: heights and widths do no apply. Paddings and margins are applied only horizontally(left and right).  Block elements:\n 100% of parent\u0026rsquo;s width vertivally, one after another  Inline-Block elements:\n Good example is \u0026lt;img\u0026gt;.   The 3 ways of building layouts with CSS Float Layouts: The old way of building layouts, using the float CSS property. Still used, but getting outdated fase.\n Element is removed from the normal flow: out of flow. Like absolutely positioning. Text and inline elements will wrap around the floated elements. Different from absolutely elements. The container will NOT adjust its height to the elements.  FlexBox: Modern way of laying out elements in a 1-dimensional row without using floats. Prefect for component layouts.\n One of its most useful applications is vertical centering. Flex container property:  gap: To create space between items. justify-content: To align items along main axis(horizontally, by default) align-items: To align items along cross axis(vertically, by dedauly) flex-wrap: To allow items to wrap into a new line if they are too large align-content: Only applies when there are multiple lines(flex-wrap: wrap)   Flex Items property:  align-self: To overwrite align-items for individual flex items. flex-grow: To allow an element to grow. flex-shrink: To allow an element to shrink. flex-basis: To define an item\u0026rsquo;s width, instead of the width property. flex: Recommended shorthand for flex-grow, -shrink, -basis.    CSS Grid: For laying out elements in a fully-fledged 2-dimensional grid. Perfect for page layouts and complex components.\n  CSS grid is a set of CSS properties for building 2-dimensional layouts\n  The main idea behind CSS Grid is that we divide a container element into rows and columns that can be filled with its child elements\n  CSS grid is not meant to replace flexbox!. Instead, they work perfectly together. Need a 1D layouts? Use flexbox. Need a 2D layout? Use CSS grid\n  Grid container\n grid-template-rows/grid-template-columns: To establish the grid row and column tracks. One length uniit for each track. Any unit can be used, new fr fills unused space row-gap/colum-gap: To create empty space between tracks justify-items/align-items: To align items inside rows/columns(horizontally/vertically)    Grid items\n grid-column/grid-row: To place a grid item into a specific cell, based on line numbers. span keyword can be used to span an item across more cells justify-self/align-self: To overwrite justify-items/align-items for single items    ","date":"2022-05-17T11:02:04+08:00","permalink":"https://wangloo.github.io/posts/html-css/0/","section":"posts","tags":["html","css"],"title":"Html Css Learning note (0)"},{"categories":["Vim"],"contents":"Search a word quickly: put cursor on the word, press / and press \u0026lt;C-R\u0026gt; \u0026lt;C-W\u0026gt;.\n 缩写的含义(Meaning of abbreviations) Operation\n d - delete y - yank(copy, 因为c被占了) c - change r - replace v - visual select  Scope or location\n i - inside a - around f - forward t - to  Object\n w - word s - sentence p - paragraph  窗口  \u0026lt;c-w\u0026gt;w 切换到下一个窗口 \u0026lt;c-w\u0026gt;+ 当前窗口大小增加一行 \u0026lt;c-w\u0026gt;- 当前窗口大小减少一行 2\u0026lt;c-w\u0026gt;+ 当前窗口大小增加两行  书签: Bookmark ma: create bookmark a inside file.\nmA: create global bookmark A.\n`a: jump to bookmark a.\n:marks: display all bookmarks\ntag 目前用的生成tags文件工具是 ctag, 感觉还可以。\n1ta \u0026lt;tag\u0026gt; \u0026#34; 跳转到一个tag，如果有多个应该是随机一个 2CTRL-] \u0026#34; 快捷键跳转到当前光标下的tag 3ts \u0026lt;tag\u0026gt; \u0026#34; 多个tag时，可以选择跳转到哪一个 45help tag \u0026#34; 查看更多帮助 缩进: indent   \u0026gt;: increase indent , \u0026lt;: decrease indent ,=: auto indent\n  \u0026gt;\u0026gt;: 增加当前行的缩进\n  gg=G: 缩进全文, 无论当前光标在哪\n   以上命令都可以配合visual mode使用\n 自动缩进的规则 主要有四种可用缩进的方式, 分别是:\n1\u0026#39;autoindent\u0026#39; 沿用上一行的缩进。 2\u0026#39;smartindent\u0026#39; 类似 \u0026#39;autoindent\u0026#39;，但是可以识别一些 C 语法以能在合适的地方 3 增加 / 减少缩进。 4\u0026#39;cindent\u0026#39; 比上面两个更聪明；可以设置不同的缩进风格。 5\u0026#39;indentexpr\u0026#39; 最灵活的一个: 根据表达式来计算缩进。若此选项非空，则优先于其它 6 选项覆盖。参见 indent-expression 。 自定义的快速命令:\n1command IndentOff setl noai nocin nosi indentexpr=\u0026#34;\u0026#34; 2command IndentOn setl ai cin si \u0026#34;indentexpr can\u0026#39;t be re-enabled. 3command IndentStatus set ai? si? cin? indentexpr?  cindent 不一定对所有的语言都有效果. 只是 C-like 风格, 其中一个要求是顶层函数必须在第一列中含有 {.\n  只有当indentexpr计算不出当前需要缩进几格时(return -1), 才使用上面的三个规则. 它是优先级最高的.\n Find and Tail f(: 从当前cursor处向右查找下一个(, 并将光标移动到(处.\nF(: Like f(, but 向左查找.\nt(: Like f(, but 将cursor移动到(的前一个.\nT(: You can guess.\nTrick vt(c: With visual, 删除当前光标到下一个(前的所有内容.\n;/,: 查找下一个/上一个 f/F/t/T 的内容.\n Substitute and Global  See: :help :s and :help :g\n 这两个都属于vim的命令. vim 的替换和sed 的s命令使用方式基本一致. 就不多介绍了.\n而 vim 的 global 命令和sed有些许差别. 使用Sed删除包含个字符串的行的指令为: sed '/STRING/d' input_file, 而在vim中则多了一个g前缀, :g/STRING/d.\nglobal 可以和 substitute 结合使用, 例如想要在包含某个字符串的行中替换good为excellent\n1:g/STRING/s/good/excellent/  TODO:\n More [cmd] in global. Power of g | Vim Tips Wiki | Fandom vim subtitute使用的正则表达式集包含 \\zs和\\ze, 然而 sed 没有(Sed 为 POSIX Basic Regular Expression).    大小写转换    cmd description     g~ 翻转大小写   gu 转换为小写   gU 转换为大写    以上命令(严格来说叫操作符)需要配合动作命令来使用.\n gUaw: 将光标所在位置的单词转为大写 gUap: 将光标所在位置的段落转为大写   Search and replace case 1: search and convert to uppercase/lowercase 我直觉想到的方式是%s/html/HTML/gc\n这种方式在简单情况下也行, 比较灵活且直观, 但是对于复杂文件不够通用且容易出错\n还有一种方式是先搜索, 然后一步步替换\n 搜索: /\\vhtml\\C 替换: 执行命令gUgn, 然后使用n和.来重复操作下一个选中项.   gn命令进对于sreach的匹配项使用, 类似于n, 但会将下一个匹配项(若光标停在match上, 那则选中当前匹配项) 转为visual模式选中的状态.\n  其实对于简单的文本, n和.也可以简化为.. 唯一的坏处就是如果两个匹配的距离太大, 你不能确认是否search了你想要的内容.\n case 2: search the text seleted in visual mode  vim 本身并未提供这个功能, 需要借助一个脚本来完成\n search the text selected in visual mode\n Visual Block 模式   选中后, 编辑所有行: I(captial i), 编辑完成后按两次ESC\n  重复visual 选中上次的 block: Normal模式下gv即可.\n   单词间跳转 w: Move cursor to begin of next word.\nb: Move cursor to begin of last word.\ne: Move cursor to end of next word.\nTrick w/b配合ce使用可达到在某一行中快速移动到某个单词, 然后删除该单词开始edit.\ndaw: 即 Delete A Word, 可以删除一个完整的单词, 无论当前光标的位置在哪.\n 编辑二进制/十六进制文件 可以使用xxd命令将一个文件中的文本转换为hex格式显示. 在vim中键入:%!xxd 即可. 得到的效果如下:\n10000000: 5468 6973 2069 7320 6120 7465 7374 0a41 This is a test.A 20000010: 6e6f 7468 6572 206c 696e 650a 416e 6420 nother line.And 30000020: 7965 7420 616e 6f74 6865 720a yet another. 后面的对应文本是自动生成的, 仅需要修改十六进制的部分即可. 修改完成后, 要返回原本的模式, 键入:%!xxd -r.\n 可通过设置文本格式对十六进制内存高亮显示 set ft=xxd.\n  删除光标前/后的所有字符  d^ \u0026ndash; delete to first non-whitespace character in the line d0 \u0026ndash; delete to beginning of the line c-u in insert mode. Same as bash command shortkeys, see here   文件恢复/swp文件 正确对待swp文件的姿势:\n vim 打开原文件, 此时会提示Found a swap file the name .xxx.swp, 显然选择(R)ecover 来恢复未保存的内容. 使用:w将恢复的内容保存下来 但是此时原本的swp文件还是存在, 此时我们执行:e刷新一下当前bufffer, 仍然会提示恢复的选项, 但此时文件内容已经恢复, 选择(D)elete 就可将对应的swp文件删除了   删除当前目录中所有swp file的脚本?\n需要确保:\n 所有文件内容已恢复 当前窗口或者其他窗口没有vim正在打开文件(会生成swp file)  1find . -type f -name \u0026#34;.*.sw[klmnop]\u0026#34; -delete  How to handle swapfiles in Vim (longwood.edu)\n Debug VIM key mapping https://vi.stackexchange.com/a/7723/43494\n如何同步 VIM Dotfiles vim 的 dotfiles 主要包含.vimrc和.vim/中的插件.\n  对于.vimrc, 我选择使用mackup 软件和其他system dotfiles 一起备份. Git repo 一个单独的vimrc太大，将其分成多个子文件，所以就没用mackup， 而是一个单独的仓库进行管理。wangloo/myvimrcs: My vimrcs\n  对于 plugins, 传统的管理插件的方式(使用vim-plug), 也就是放在~/.vim/plugged/目录中的, 可以通过:PlugInstall命令在新机器上重新从网上克隆. 能够保证使用的是新版本. VIM 8.0 之后, 引入 pack system 新的插件管理方式。 wangloo/myvimpack: My Vim8 plugins 使用方法见README.\n  Good plugins  Reference: The Ultimate vimrc\n TODO Installed NERD Commneter - 快速注释\nNERD Tree - 目录树\nOpen File Under Cursor - 打开光标处的文件目录\n 不支持vim-plug安装. 直接clone源码到plugged目录即可. Usage: gf: 在当前window打开文件. \u0026lt;C-w\u0026gt;\u0026lt;C-f\u0026gt;: new vertical windows中打开文件.  Ack.vim - 快速定位内容\nLeaderF - Like Ctrlp but better?\nbarbaric - normal模式切换英文输入法\n Helpful script search text selected in visual mode 1xnoremap * :\u0026lt;C-u\u0026gt;call \u0026lt;SID\u0026gt;VSetSearch(\u0026#39;/\u0026#39;)\u0026lt;CR\u0026gt;/\u0026lt;C-R\u0026gt;=@/\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt; 2xnoremap # :\u0026lt;C-u\u0026gt;call \u0026lt;SID\u0026gt;VSetSearch(\u0026#39;?\u0026#39;)\u0026lt;CR\u0026gt;?\u0026lt;C-R\u0026gt;=@/\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt; 3function! s:VSetSearch(cmdtype) 4let temp = @s 5norm! gv\u0026#34;sy 6let @/ = \u0026#39;\\V\u0026#39; . substitute(escape(@s, a:cmdtype.\u0026#39;\\\u0026#39;), \u0026#39;\\n\u0026#39;, \u0026#39;\\\\n\u0026#39;, \u0026#39;g\u0026#39;) 7let @s = temp 8endfunction ","date":"2022-05-09T19:28:12+08:00","permalink":"https://wangloo.github.io/posts/tools/vim/basic/","section":"posts","tags":["Vim"],"title":"我的 vim 调教随笔"},{"categories":null,"contents":"Change code theme Default use monokai.css. see 官方文档\n修改需要下载新的css放到plugin/highlight/目录下.\n其他可用的css在highlight.js仓库中下载.\nAlign Slide Align 取消center对齐方式:\n1Reveal.initialize({ 2 ... 3 center: false, 4 ... }) 所有slide左对齐: https://github.com/hakimel/reveal.js/issues/1897\n用markdown写的方式下使某一幻灯片左对齐: https://github.com/hakimel/reveal.js/issues/890#issuecomment-129735291\n","date":"2022-05-08T19:34:44+08:00","permalink":"https://wangloo.github.io/posts/revealjs/","section":"posts","tags":null,"title":"reveal.js Tutorial"},{"categories":["Architecture"],"contents":"Load/Store 指令 寻址模式 Base register - w0=[x1]\n1ldr w0, [x1] Offset addressing mode - w0=[x1+12]\n1ldr w0, [x1, 12] Pre-index addressing mode - x1+=12; w0=[x1]\n1ldr w0, [x1, 12]! Post-index addressing mode - w0=[x1]; x1+=12\n1ldr w0, [x1], 12 更多示例 1// load a byte from x1 2ldrb w0, [x1] 3 4// load a signed byte from x1 5ldrsb w0, [x1] 6 7// store a 32-bit word to address in x1 8str w0, [x1] 9 10// load two 32-bit words from stack, then add 8-byte to sp 11ldp w0, w1, [sp], 8 12 13// Store two 64-bit regs in [sp-96] and subtract 96-byte from sp. 14// ==\u0026gt; [sp]=x1, [sp+8]=x2 15stp x1, x2, [sp, -16]! 16 17// LDR伪指令. load 32-bit immediate from literal pool(addr: 0x12345678) 18ldr w0, =0x12345678 数据处理指令 Bitfield 操作指令 Bitfield 指令常用于设置/提取寄存器的某个字段.\n1;BFI(Bit Field Insert) 2BFI w0, w0, #9, #6 ;w0[0, 5] = w0[9, 14] 3 4;BFC(Bit Field Clear) 5BFC w0, #4, #2 ;w0[4, 5] = 0 6 7;UBFX(Unsigned Bit Field Extract) 8UBFX w1, w0, #18, #7 ;w1=w0[18, 24]  与 UBFX 相对的是 SBFX, 若提取后的字段高位为 1, 会进行符号扩展\n 分支/控制指令 获得地址的相关指令 写汇编中，常常会获取一个变量或者函数(label)的地址，A64 中一共有几种获取地址的指令， 包括adr, adrp, adrl, ldr等，下面我就对这些指令进行介绍。\nADR 首先是 adr，它的作用是加载 PC 相对地址。PC相对的另一层含义就是物理地址， 而不一定是编译后指令的VMA，仅仅取决于当前的PC在哪，返回的就是偏移后的结果。\n 我们都知道，指令正常运行不一定PC对应的指令一等等于其在可执行文件中的VMA， 就拿bring-up代码做参考即可。这时候指令能正常执行的原因是：取指动作永远都是简单的PC+1， 仅仅与PC有关而已。\n adr 指令的格式是:\n1adr reg, offset 输入一个 offset，输出 PC+offset 的值，但我们常用的是 offset 填某一个 label，例如函数 或者变量，此时 reg 中存的就是此函数的地址了。例如，\n1adr x0, a_func # x0 = addr(a_func) adr 指令中留给 offset 的位数是 21，所以最大的寻址范围为+-1MB。\nADRP adrp 的指令格式与 adr 相同，不同点是会将计算的结果向下对齐到 4k，但这样直接计算的 地址结果往往是不正确的，因为少了页内的偏移。需要一个额外的 add 指令进行纠正，一般来说 是组合起来用的：\n1adrp x0, a_func 2add x0, x0, :lo12:a_func 显然 adrp 这样做是为了更大的寻址空间，能到+-4GB。\nLDR 伪指令 一般通用的ldr指令都是用来加载内存中的值，比如常见的 ldr x0, [x1]。 或者说容易混淆的加载label处内存的值: ldr x0, label。\n如果 ldr 指令的参数是=\u0026lt;label\u0026gt;，那就代表伪指令，作用是加载 label 的绝对地址， 注意不是内存的值，而是地址, 拿到的地址是绝对地址，即VMA。 好处是可以获取到一个位于任意 label 的地址，不受寻址空间的约束。\n 简单说下ldr和ldr伪指令的区别\n1label_1: // assmue VMA of label_1 = 0x12345678 2 .word 0xabcdabcd 3 4ldr x0, addr // x0 = 0xabcdabcd 5ldr x0, =addr // x0 = 0x12345678   当目前指令执行地址不等于它们的虚拟地址时，比如当 MMU 未开始时通过 uboot 加载到内存 中直接运行的那段程序，此时用adr/adrp这些加载 pc 相对地址的指令就会正确的返回 label 的实际运行地址；而ldr则是永远返回其编译链接后绑定的虚拟地址。这种情况下 如果寻址范围允许，用adr*指令更方便。\n 有趣特性/常见误区 \u0026lsquo;#\u0026rsquo; before the immediate value  A64 assembly language does not require the # to introduce constant immediate value. But the assembler can also indentify the #. In armv7, there must be a # or $ before other than using .syntax unified. About syntax unified.   Agreed Recommendation\nUse .syntax unified in v7 code, and never use # on any literal on either v7 or v8. Unified syntax is newer and better, and those # and $ signs are just more code noise.\n ","date":"2022-05-07T21:19:01+08:00","permalink":"https://wangloo.github.io/posts/armv8/a64/","section":"posts","tags":["arm64"],"title":"AArch64 A64 指令集"},{"categories":["Architecture"],"contents":"寄存器分类 通用寄存器  x0-x7 参数寄存器: Restore function parameters and return vaule. x9-x15 caller-saved 临时寄存器: callee 默认可以直接使用来保存临时变量, 不需要保存和恢复. 如果 caller 在里面存储了非临时信息, 那么在函数调用之前应当由 caller 负责保存. x19-x28 callee-saved 寄存器: callee 应该避免使用. 如果必须要使用，那么在返回前必须恢复. special registers:  x8 restore indirect result. Commonly used when returning a struct. x18 platform reserved register. x29 frame pointer register(FP). x30 link register(LR).     All general-purpose register xN is 64-bit width. They all have corresponding wN register using the lower 32-bit of xN. And write to wN will clear the upper 32bit of xN.\n  💫 The different between Caller-saved and callee-saved registers\n Caller-saved 寄存器又称为临时寄存器, 常用来存放临时变量. 例如A() 调用 B(), 那么 B() 可以直接使用 caller-saved 寄存器, 也就是说 A() 在调用 B() 之前不会在这些寄存器里保存重要信息(编译器实现), 不能保证调用 B() 前后其值不变. 如果必须要保证, 那么保存和恢复(利用栈)这件事是 A() 来做. Callee-saved 寄存器则相反, 通常持续使用的值会保存到这些寄存器中. 还是拿 A() call B() 来举例. 如果 A() 中的一个变量需要在调用 B() 前后持续有效, 那么它应当保存到 callee-saved 寄存器中. 而且 B() 正常来说不应该动这些寄存器, 如果非得动(例如寄存器不够用), 那么 B() 需要在使用他们的前后进行保存和恢复(利用栈).   每个EL的特殊寄存器  sp_el0/1/2/3 stack pointer register of each EL. elr_el1/2/3 exception link register of each EL except EL0. spsr_el1/2/3 save program status register of each EL except EL0.   sp is an alias of sp_el0. Do NOT treat sp as general-purpose register.\n ","date":"2022-05-07T20:19:44+08:00","permalink":"https://wangloo.github.io/posts/armv8/register/","section":"posts","tags":["armv8"],"title":"AArch64 寄存器"},{"categories":["Math"],"contents":"考试大纲 🎯 To Reader:\nThis blog is JUST FOR EXAMINATION! If you are interested in numberical analysis, please quit this web. I try to sort out the knowledge points of the course, just to pass the exam.\nBased on the course of Professor Zhong Erjie of UESTC.\n💢 I hate mathematics!\n 第二章 非线性方程/方程组的求解 1. 二分法及迭代  二分法误差估计定理  2. 不动点迭代  不动点及不动点迭代的概念 迭代格式的选择? 是否收敛? 迭代的初值是否合适?  3. 牛顿法解非线性方程  背景: 如果函数f(x)是线性的, 那么它的求根问题就会简化. 牛顿法实质上是一种线性化方法, 将非线性方程逐步归结为某种线性方程来求解.\n 牛顿法的迭代格式: $$ x^{k+1} = x^k - \\frac{f(x^k)}{f^\u0026rsquo;(x^k)} $$\n4. 弦截法  背景: 弦截法是牛顿法的一个改进. 牛顿法求根时需要计算f'(x), 而导数的计算往往困难. 弦截法使用差商来回避导数的计算.\n 5. 收敛阶 6. 非线性方程组的牛顿迭代格式  雅可比矩阵是什么?   第三章 直接法解线性方程组 1. Gauss消元法 求解过程的算法复杂度为O(n^2), 消元过程的算法复杂度为O(n^3).\n2. 直接三角分解法(Doolittle分解法)  背景: 直接意味着可以由A的元素直接计算L和U, 不需要任何的中间步骤.\n 一旦L和U得到, 求解Ax=b就可以等价表示为求解两个三角形方程组:\n Ly=b, 求y Ux=y. 求x   第四章 迭代法解线性方程组  背景: 对于线性方程组Ax=b, 当A为低阶稠密矩阵时, [选主元消去法]是求解的有效方法.\n但是实际情况中A大都是巨型的稀疏矩阵, 这是采用迭代法来求解是合适的. 迭代法可以利用A中有大量零元素的特点.\n  迭代法不一定最终能够逼近方程组的解, 认识误差向量的概念.  1. Jacobi迭代 雅可比迭代格式和收敛性的判别\n快速计算Bj的特征值\nJacobi迭代由A直接看出Bj\n2. Seidel迭代 Seidel迭代收敛格式和收敛性的判别\nSeidel迭代独有的判断收敛性的方式: 若A为对称阵, 且A正定, 那么迭代收敛.\n 第五章 插值法 1. 插值方法与插值问题  背景: 仅已知某些点和该点的函数值的情况下, 如何模拟一个插值函数P(x), 使得误差最小.\n  什么是插值函数P(x)? 被插函数? 插值节点? 插值余项?  2. 多项式插值  可证明多项式P(x)存在唯一. 多项式插值通过解方程组就能得到解(a0, a1,..., an).  3. 拉格朗日插值公式  背景: 虽然上面的多项式插值能否解决n+1个点的光滑函数, 且解是唯一的. 但是解方程组是很麻烦的.\n 拉格朗日插值公式: $$ L_n(x) = l_0(x)y_0 + l_1(x)y_1 + \\dots + l_n(x)y_n $$ 插值基函数:\n插值条件(插值系数): $$ y_0 = f(x_0), y_1 = f(x_1), \\dots,y_n = f(x_n) $$\n误差余项Rn(x)\n4. 牛顿插值公式  背景: 给定5个插值节点及其函数值, 可以得到L4(x); 由于某种原因, 需要加入一个新的插值节点. Lagrange插值法之前的计算结果(l)均失效, 需要重新计算. 非常的不方便.\n  牛顿法是基于差商的概念. 导数是差商的极限. 差商的差商是高阶差商.  牛顿插值法的插值函数(以二次插值举例): $$ P(x) = a_0 + a_1(x-x_0) + a_2(x-x_0)(x-x_1) $$ 需要做的就是解出系数a0,a1,....\n所以引入差商的符号: $$ a_1=f[x_0,x_1]=\\frac{f(x_1)-f(x_0)}{x_1-x_0} $$ $$ a_2=f[x_0,x_1,x_2]=\\frac{f[x_1,x_2]-f[x_0,x_1]}{x_2-x_0} $$\n5. Hermite插值  背景: 有时我们已知的条件不都是函数值, 也有导数值. 例如已知两个点的函数值和两个点的导数值, 可以应用Heimite插值法得到三次多项式.\n 求Hermite插值函数的方法: 构造差商表, 重复节点特殊处理.\nHermite插值方法的余项证明与Langrange插值法相同.\n6. 分段低次插值  背景: 次数太高的多项式插值的效果不好. 比如龙格现象.\n  分段: 把被插值函数所在的大区间分成一个个的小区间. 低次: 每个小区间上用次数不超过3的函数来逼近  6.1 分段线性插值 就是分段折线\n分段线性插值的优点:\n 简单 当二阶导数趋近0时, 一定收敛  分段线性插值的缺点:\n 分段折线不光滑, 分段点处不能求导.  6.2 分段Hermite插值  背景: 为了解决分段线性插值的缺点(存在尖点).\n 已知函数在(n+1)个点的函数值值以及其导数值, 去构造一阶连续可导函数.\n分段Hermite插值根据(n+1)个已知点划分为(n+1)个区间. 这样在每个小区间上都已知4个条件, 可以使用3次Hermite插值.\n结论: 已知(2n+2)个条件的情况下, 居然只得到一阶连续可微函数. 结论太差!\n 第六章 拟合 🔍 插值, 拟合, 逼近的区别\n1. 最佳平方逼近 2. 最小二乘法  背景: 已知不共线的三点, 如何确定一条可信的直线.\n 三个点可以用插值来模拟二次多项式, 但题目要求了用一次多项式, 这是插值无法做到的.\n不共线的三点不可能同时经过一条直线, 所以要用逼近的思想. 找一条近似的直线, 使得误差最小.\n 与插值的区别: 插值是明确给出n+1个插值条件, 得到n次多项式. 如何定义误差最小?: 函数间的距离.  1. 线性拟合 拟合的函数是n次多项式, 可转化为超定方程GX.\n 其中规定G为系数矩阵, X为变量的列向量. 同时定义列向量F为给出的函数值. GX=F是超定方程组, 没有准确解. 得到残差最小的解的方法即最小二乘法.  所以线性拟合的残差r = |GX - F|, 而找到目标函数的宗旨就是使r最小. 使用初等变分原理将这个问题转化为正规方程组求解的问题.\n 第七章 数值积分  背景: 定积分的计算中可能无法找到原函数的情况. 考虑定积分的本质是一句具体的数, 我们的目标就是找到这个数的近似值, 越接近越好.\n 解决的两种思路: 积分中值定理 和 插值型求积公式(近似被积函数).\n1. 积分中值定理 基本的积分中值定理: $$ \\int_{a}^{b}f(x)dx = f(\\xi)(b-a) $$\n将一个区域的面积转化为矩形的面积. 如何确定矩形的高呢? 左矩阵, 右矩阵, 中间矩阵, 梯形公式.\n更常用的积分公式是 在乘积函数积分中, 如果g(x)不变号, 则有: $$ \\int_{a}^{b}g(x)f(x)dx =f(\\xi)\\int_{a}^{b}g(x)dx $$\n2. 插值型求积公式 在被积函数很复杂的情况下, 可以对其进行近似处理, 例如使用Lagrange插值法.\n二次插值: Simpson公式 取二次插值的步长h=(b-a)/2, 即增加一个插值节点(b-a)/2, Simpson公式化简的结果为: $$ \\int_{a}^{b}f(x)dx = \\frac{b-a}{6}[f(a)+4f(\\frac{a+b}{2})+f(b)]+R[f] $$\n📌 Simpson公式满足3阶代数精度. 虽然它只是二次插值得到的.\n3. 余项  插值型求积公式的余项, 即对应的插值方法(如Lagrange, Newton)的余项在区间上的积分. 梯形公式方法的余项可以用积分中值定理来优化. Simpson公式的余项不能使用积分中值定理来优化, 因为不满足保号的条件.  4. 衡量求积公式的好坏 代数精度: 不是一种误差, 而是对误差的描述.\n如何得知某个公式的代数精度: 只要带入一个m次多项式验证余项是否为0即可.\n5.复合求积公式 为了提高精度通常把积分区间分为若干个子区间, 再在每个子区间上应用低阶求积公式.\n 复合梯形公式: 将区间等分. 复合simpson公式: 将区间偶数等分.   第八章 常微分方程初值问题数值解法 将研究的内容进一步限定为: 一阶初值问题, 单步法.\n 背景: 在无法给出解析表达式时如果利用数值方法求出y的近似解?\n 1. 简单的数值方法 1.1 Euler公式 使用一阶向前差商近似替代y'. 得到递推的数列表达式: $$ y_{n+1} = y_{n} + hf(x_n,y_n), n=0,1,2,\u0026hellip; $$\n误差: Euler法使用的近似代替只有一阶精度, 所以误差很大. 此时有两种解决方案:\n 加细步长h, 若不行再加细. 总是能得到正确的, 如果你不嫌弃带来的计算变得缓慢的问题. 换方法.  1.2 梯形公式  背景:为得到比Euler法精度更高的计算公式. 梯形公式具有二阶精度.\n 对y' = f(x,y)的两端进行局部的积分, 然后用梯形公式近似计算右边.\n1.3 改进Euler公式 先用欧拉公式求得一个近似的yn+1, 带入梯形公式, 得到矫正的yn+1.\n","date":"2022-05-07T18:04:58+08:00","permalink":"https://wangloo.github.io/posts/numberical-analysis/","section":"posts","tags":["Math","Examination"],"title":"Numberical Analysis Exam"},{"categories":["Vim"],"contents":"Use plugin vimtex Vim build-in support of LaTeX files is just OK. When we need more excellent exprience, good plugins is very recommended.\nvimtex is a nice and modern vim plugin for LaTeX files.\nUseful Futures of vimtex IMO\n \u0026lt;leader\u0026gt;ll Complier. By default, it will auto-complier when you type :w. \u0026lt;leader\u0026gt;lt Open content tree as a sidebar. \u0026lt;leader\u0026gt;lv View PDF with configured PDF viewer. \u0026lt;leader\u0026gt;li File information. cse Change surrounding \\begin \\end environment. tse Exchange between \\begin{env} and \\begin{env*}. tsc Exchange between \\command{} and \\command*{}.   Add Support of Simplified Chinese Install xetex I use xetex to add supports for Chinese fonts in LaTex files. Actually the magician is amacro package of xetex named xeCJK.\nAnd xetex is included intexlive. so we install it from source:\n1sudo apt install texlive-xetex Install Chinese Font If there is no Chinese font in your system, you must install one. I choose WinQingYuan microhei as a instance.\n1sudo apt install ttf-wqy Excute fc-list to check if install successfully, here is excepted output:\n1fc-list | grep wqy 1/usr/share/fonts/truetype/wqy/wqy-microhei.ttc: WenQuanYi Micro Hei,文泉驛微米黑,文泉驿微米黑:style=Regular 2/usr/share/fonts/truetype/wqy/wqy-microhei.ttc: WenQuanYi Micro Hei Mono,文泉驛等寬微米黑,文泉驿等宽微米黑:style=Regular Configure your tex file 1\\documentclass {article} 2\\usepackage{xeCJK} 3\\setCJKmainfont{WenQuanYi Micro Hei} 4 5\\begin{document} 6Hello, LaTeX! 7 8你好, LaTex! 9 10\\end{document} Complier it and see, the Chinese font is displayed!\n Confusing Tools Difference between {pdf,lua,xe}Tex and {pdf,lua,xe}LaTeX If a .texfile starts with \\documentclass, it\u0026rsquo;s a LaTex format file rather than the Plain Tex format file.\nThe LaTeX format file has some specific macro like \\documentclass that cannot be compliered by [pdf]Tex, so that\u0026rsquo;s the job of [pdf]LaTeX. Same goes for other engines.\nWhat is xetex/xelatex? xetex/xelatex is one of the TeX/LaTeX engines. Others are pdfTex, LuaTex, etc. Wiki\nxetex/xelatex add fonts and character sets support for TeX/LaTeX file.\n Treat input as Unicode Allow us to use many system fonts in LaTeX file easily  What is latexmk? LaTeXmk 是一个集成化的命令行工具, it must work with one LaTeX engine.\nThe fundamental issue that latexmk solves is that the number of runs of [pdf]latex is highly dynamically dependent on the document and the class file used. latex just need to be run once a time.\nDifferent between CTeX/MiKTeX/TeXlive ? They are all 包含与.tex文件关联的各种编辑、查看工具、常用宏包及文档.\nCTex packages add complete Chinese support based on MiKTeX.\n CTex is only avilable in windows.  ","date":"2022-05-04T17:07:51+08:00","permalink":"https://wangloo.github.io/posts/tools/vim/latex_vim/","section":"posts","tags":["Vim"],"title":"LaTeX Vim Tutorial"},{"categories":null,"contents":"When reading C standard documents, we usually see phrases like \u0026ldquo;Implementation-defined\u0026rdquo;, \u0026ldquo;Unspecified\u0026rdquo;,.etc.\nSo, what do they really mean?\n术语 我们将这些难以直接理解的词汇称为术语，在ANSI C中，术语可以分为描述不可移植代码(unportable), 坏代码(bad), 可移植的代码(portable)三类.\nunportable code Implementation-defined\n需要由编译器设计者决定采取何种行为，他们可能不同，但都不能说是错误的.\n例如：当整型数右移时，是否需要扩展符号位. 右移代替除法可能导致的灾难.\nunspecified\n在某些正确情况下的做法，标准并未明确规定应该怎样做.\n例如：参数求值的顺序.\nbad code undefined\n在某些不正确情况下的做法，但标准并未规定应该怎样做。意味着你可以采取任何行动，可以什么都不做，也可以发出一条警告信息, 或者终止CPU重启等等. 你甚至可以发射核导弹(只要你安装了能发射核导弹的硬件系统).\n例如：当一个有符号整数溢出时该采取什么行动.\nconstraint\n这是一个必须遵守的限制或要求. 如果你不遵守, 那么你的程序的行为就会变成如上所说的undefined. 这出现了一种很有意思的情况: 分辨某种东西是否是一个constaint是很容易的, 因为每个标准的主题都附有一个constraint小节, 列出了所有的约束条件。\n例如: %操作符的操作数必须为整型. 所以,在非整型数据上使用%操作符肯定会导致undefined.\nportable code strictly conforming\n严格遵守标准的. 符合该条件的程序应当是:\n 只使用已确定的特性 不突破任何由编译器实现(Implementation-defined)的限制. 不使用unspecified和undefined特性  这样规定的目的是最大程序保证代码的可移植性. 但符合该术语的代码并不常见, 例如INT_MAX的值在不同架构的机器上结果可能不同.\ncomforming\n遵循标准的; 一个遵循标准的程序可以依赖一些对于某种编译器特有的不可移植的特性. 这样一个程序对于某个编译器可能是遵循标准的, 但对于另外一个编译器又是不遵循标准的.\n","date":"2022-05-01T16:41:35+08:00","permalink":"https://wangloo.github.io/posts/reading-notes/expert_c_programming/portability_issues/","section":"posts","tags":null,"title":"Portability Issues"},{"categories":null,"contents":"","date":"2022-05-01T16:41:35+08:00","permalink":"https://wangloo.github.io/posts/third-blog/","section":"posts","tags":null,"title":"Third Blog"},{"categories":["Makefile"],"contents":"As we all know, there are huge number of parameters for GCC. With them, we can make many things possible. Now we talk about -M and related ones. After reading this article, you will know the meaning of there magic parameters. And I will put some little demos follows. Finally, we will see what can they do in really project. Let\u0026rsquo;s go ahead.\n实例规则 以下的分析都是基于这样一个生成目标文件的规则, 应该来说具有一定的通用性。\n1build/obj/main.o: src/main.c 2 $(CC) $(CFLAGS) $(INCLUDES) -c $\u0026lt; -o $@ main.c中的内容：\n1/* File: main.c */ 2#include \u0026lt;stdio.h\u0026gt; // system header file3#include \u0026#34;header.h\u0026#34; // user defined header file4int main() { 5 return 0; 6} -M Output the dependencies of the input source file. Incluing the names of itself and all included files.\n-M(and 下面的-MM)和-o 不能同时使用，因为都隐含-E。 假设我们只想输出依赖文件，我们可以将示例中的规则如此改造：\n1build/obj/main.o: src/main.c 2 $(CC) $(CFLAGS) $(INCLUDES) -c $\u0026lt; -M We will get messy output like following. Notice that the first two words is object filename and a colon.\n1main.o: src/main.c /usr/include/stdc-predef.h /usr/include/stdio.h \\ 2 /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \\ 3 /usr/include/features.h /usr/include/x86_64-linux-gnu/sys/cdefs.h \\ 4 /usr/include/x86_64-linux-gnu/bits/wordsize.h \\ 5 /usr/include/x86_64-linux-gnu/bits/long-double.h \\ 6 /usr/include/x86_64-linux-gnu/gnu/stubs.h \\ 7 /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \\ 8 /usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h \\ 9 /usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h \\ 10 /usr/include/x86_64-linux-gnu/bits/types.h \\ 11 /usr/include/x86_64-linux-gnu/bits/timesize.h \\ 12 /usr/include/x86_64-linux-gnu/bits/typesizes.h \\ 13 /usr/include/x86_64-linux-gnu/bits/time64.h \\ 14 /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \\ 15 /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \\ 16 /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \\ 17 /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \\ 18 /usr/include/x86_64-linux-gnu/bits/types/FILE.h \\ 19 /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \\ 20 /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \\ 21 /usr/include/x86_64-linux-gnu/bits/sys_errlist.h 22 src/header.h -MM Like -M but do NOT output system header files.\n1main.o: src/main.c src/header.h -MF \u0026lt;file\u0026gt; Use with -M or -MM. Specify output dependencies to file instead of STDOUT.\n注意，只要使用追加上-MF，就可以和-o选项并存了，可以写在一条语句中\n-MD -MD is same as -M -MF \u0026lt;file\u0026gt;. But the filename is basd on the object file but replacing .o with .d.\n如果将示例中的代码换成：\n1build/obj/main.o: src/main.c FORCE 2 $(CC) $(CFLAGS) $(INCLUDES) -c $\u0026lt; -o $@ -MD 1$ ll build/obj/ 2 3total 16 4drwxrwxr-x 2 soben soben 4096 3月 23 20:45 ./ 5drwxrwxr-x 3 soben soben 4096 3月 23 20:35 ../ 6-rw-rw-r-- 1 soben soben 1144 3月 23 20:45 main.d 7-rw-rw-r-- 1 soben soben 1368 3月 23 20:45 main.o  Note: -MD and -MMD 因为有-MT，也不隐含 -E.\n -MMD -MMD is same as -MM -MF \u0026lt;file\u0026gt;. Also named on object file but replacing .o with .d.\n-MT \u0026lt;target\u0026gt; MT 是一个单独的选项，不与上面的冲突。作用是改变生成依赖规则的目标格式。在此之前，默认的格式是文件名.o，去除任何前缀目录。\n而使用-MT之后可以自定义规则中目标的格式， 由\u0026lt;target\u0026gt;指定。\n例如，对于前面的选项，依赖规则目前总是main.o，很多使用，我们需要的是其编译规则中目标的形式，包含路径，并不仅仅是文件名本身。这时我们就需要使用-MT，可以将示例中的规则做如下修改:\n1build/obj/main.o: src/main.c FORCE 2 $(CC) $(CFLAGS) $(INCLUDES) -c $\u0026lt; -o $@ -MMD -MT $@ 依赖文件的内容就变为:\n1build/obj/main.o: src/main.c src/header.h  实际上，从我的开发经验来看，大项目中编译规则的目标并不直接是目标文件，总有一个路径前缀，例如：$(objdir)/%.o: $(srcdir)/%c, 这时如果 include 的依赖文件的目标只是一个文件名，其实没什么意义。 所以 -MT 应该是在开发大型项目中很常见的。\n -MQ \u0026lt;target\u0026gt; 与MT类似，而且我没有验证成功官网说出的和 MT 的区别. 所以，这是一个 TODO。\nApplication Here is an important question you may ask me: Why do we struggle to get the dependencies formats? What can they do?\nIf you are familiar with make and Makefile, aha, that\u0026rsquo;s it! With the help of M-related parameters, you can easily handle the problem of tracing header files.\nGive you a little demo about my point.\n1-include *.d 2%.o:%.c 3 $(CC) $(CFLAGS) $(INCLUDES) $\u0026lt; -c -MMD -o $@ Actually, we do two things in order:\n When complieing source files, we generate dependency files xxx.d at the same time. After geting xxx.d, we include them in makefile. As its format is exactly the dependency format required by makefile.  Summary Hope this article can give you a clear understanding of M-related parameters in GCC. We can sometimes find them in large projects\u0026rsquo; makefile. It\u0026rsquo;s very useful to automatic build dependency for header files. So try to use them in your current or next project.\nReference  GNU GCC options GCC -M, -MM, -MMD, -MF, -MT  ","date":"2022-04-26T19:08:22+08:00","permalink":"https://wangloo.github.io/posts/c/make/gcc_-m_related/","section":"posts","tags":["c","makefile"],"title":"\"GCC -M\" 选项在Makefile中的使用"},{"categories":null,"contents":"This is my second blog.\n Wish you have a good life.\n  happy smile   sunset   ","date":"2022-04-26T15:32:11+08:00","permalink":"https://wangloo.github.io/posts/second-blog/second-blog/","section":"posts","tags":null,"title":"Second Blog"},{"categories":null,"contents":"This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog.\n1#include \u0026lt;stdio.h\u0026gt;2 3int main(void) { 4 printf(\u0026#34;hello, hugo\\n\u0026#34;); 5 return 0; 6} ","date":"2022-04-26T15:13:07+08:00","permalink":"https://wangloo.github.io/posts/first-blog/first-blog/","section":"posts","tags":null,"title":"First Blog"},{"categories":null,"contents":"编译Linux 源码 上海交通大学镜像站\n1# get linux source code 2wget http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/ 3# extract 4tar xvf linux-4.12.1.tar.gz 5# enter dir 6cd linux-4.12.1/ 7 8# generate .config 9make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- defconfig 10make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- menuconfig 11# compile  12make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- Image -j16 构建根文件系统 使用 Busybox 构建, 下载源码时可能比较慢, 暂时没有发现国内镜像站\n1# Download busybox source code 2wget https://busybox.net/downloads/busybox-1.35.0.tar.bz2 3 4# menuconfig - generate .config 5make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- menuconfig 6# compile 7make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- -j16 8 9make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- install 10 11# create rootfs 12cd ../ 13qemu-img create -f raw qemu_rootfs.img 128M 14# set ext4 filesystem 15mkfs.ext4 qemu_rootfs.img 16# mount on host 17mkdir mnt-tmp 18sudo mount -o loop qemu_rootfs.img ./mnt-tmp 19# copy file 20sudo cp busybox-1.35.0/_install/* mnt-tmp/ -r 21cd mnt-tmp 22# create other path 23sudo mkdir proc sys dev etc etc/init.d 在etc/init.d/rcS中写入启动脚本\n1#!/bin/sh 2mount -t proc none /proc 3mount -t sysfs none /sys 4/sbin/mdev -s 赋予rcS可执行权限\n1sudo chmod +x rcS 改为mount -a 之后启动脚本会自动挂在/etc/fstab文件中声明的所有分区\nfstab 在 Linux 开机以后自动配置哪些需要自动挂载的分区\n1#device mount-point type options dump fsck order 2proc /proc proc defaults 0 0 3tmpfs /tmp tmpfs defaults 0 0 4sysfs /sys sysfs defaults 0 0 5tmpfs /dev tmpfs defaults 0 0 6debugfs /sys/kernel/debug debugfs defaults 0 0 7tracefs /sys/kernel/tracing tracefs defaults 0 0 添加软件 perf perf已经集成到了Linux 主分支中，源码的位置在tools/perf\n编译命令:\nstrace 下载源码：Releases · strace/strace (github.com)\n编译\u0026amp;\u0026amp;安装:\n1# 确定编译的参数 2./configure \\ 3--host=aarch64-linux \\ 4--prefix=/home/soben/linux-qemu/strace-6.0/_install \\ 5--enable-mpers=no \\ 6CC=aarch64-none-linux-gnu-gcc \\ 7LD=aarch64-none-linux-gnu-ld \\ 8RANLIB=aarch64-none-linux-gnu-ranlib 9 10# 编译为静态链接方式 11make LDFLAGS+=\u0026#39;-static -pthread\u0026#39; -j16 12 13# 拷贝到 _install 目录 14make install 启动 QEMU 运行 Linux ","date":"0001-01-01T00:00:00Z","permalink":"https://wangloo.github.io/posts/os/arm64-linux-qemu/","section":"posts","tags":null,"title":""},{"categories":null,"contents":"名词解释 probe 一个probe是一个位置或者活动, 动态追踪工具可以在probe上绑定一些action. 例如记录栈帧位置, 查看参数等.\nprobe就像是一个可编程的传感器, 你可以为他设定触发的事件或者指令. 当probe 触发时, 可以执行你提前绑定的函数, 了解此时系统的状态\n","date":"0001-01-01T00:00:00Z","permalink":"https://wangloo.github.io/posts/os/trace/","section":"posts","tags":null,"title":""},{"categories":null,"contents":"Clang是个啥 Clang与llvm\nllvm有两种含义：llvm框架和llvm Core\n llvm框架定义了一个编译器的组成架构，此时Clang可以作为框架中针对C/C++语言的前端。 当然llvm框架也并不只是包含这一个前端，也可以有其他的前端。 llvm Core是除了前端之外的其他构成编译器的部分，包括中端优化和后端。  Clang与Gcc\n Clang是一个编译器前端，Clang+llvm Core=编译器，Gcc也是一个编译器 Clang的代码结构更好，扩展性强  Clangd VSCode配置Clangd补全 一般写C代码，用C/C++这个插件来进行自动补全， 效果不太好因为它是基于代码进行分析， 理论上不能准确的区别同名函数到底是调用谁的情况。 而且在实践中也经常产生莫名其妙找不到定义的情况。\n“听说”Clangd可以支持基于编译的分析做代码补全， 原理上它解析一个调用数据库文件compile_commands.json 来做解析补全。\nVim配置Clangd补全 我目前使用coc-nvim插件来调用Clangd进行补全。\nClangd配置文件 Clangd支持的所有配置项：https://clangd.llvm.org/config.html\n有两种方式对Clangd的配置进行设定：\n 全局配置 ~/.config/clangd/config.yaml 工程内部 .clangd 仅在工程目录内生效  以上两个都是YAML类型的文件，我目前使用到了忽略一些编译参数:\n1CompileFlags: 2 Remove: [-march=armv8-a] # invalid target CPU values in clangd-15 Clang-format 代码格式化工具\nReference  Clangd config   ","date":"0001-01-01T00:00:00Z","permalink":"https://wangloo.github.io/posts/tools/clang/","section":"posts","tags":null,"title":""},{"categories":null,"contents":"Googletest 移植 Arm64 交叉编译 Download source code\n1git clone https://github.com/google/googletest.git -b v1.14.0 编写适用于Arm64平台的规则，指定交叉编译器的位置。此文件放在项目的根目录下。\n1set(CMAKE_CROSSCOMPILING TRUE) 2 3set(CMAKE_FIND_ROOT_PATH ~/tools/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/) 4 5# Cross compiler 6SET(CMAKE_C_COMPILER aarch64-none-linux-gnu-gcc) 7SET(CMAKE_CXX_COMPILER aarch64-none-linux-gnu-g++) 8set(CMAKE_LIBRARY_ARCHITECTURE aarch64-none-linux-gnu) 9 10# Search for programs in the build host directories 11SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER) 12 13# Libraries and headers in the target directories 14set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY) 15set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY) 16set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY) 编译，这里没有编译Googlemock\n1#!/bin/bash 2 3rm -rf build 4mkdir build \u0026amp;\u0026amp; cd build 5 6cmake .. -DCMAKE_TOOLCHAIN_FILE=../toolchain_arm64.cmake -DGTEST_HAS_PTHREAD=0 -DBUILD_GMOCK=OFF 7 8# check file: lib/libgtest_main.a and lib/libgtest.a ","date":"0001-01-01T00:00:00Z","permalink":"https://wangloo.github.io/posts/tools/gtest/","section":"posts","tags":null,"title":""}]