<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/syntax_pastie.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>课程笔记：cs152（计算机体系结构）</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#cisc%e7%9a%84%e5%8f%91%e5%b1%95%e5%88%b0risc%e8%af%9e%e7%94%9f aria-label=CISC的发展到RISC诞生>CISC的发展到RISC诞生</a></li><li><a href=#%e6%b5%81%e6%b0%b4%e7%ba%bf-pipeline aria-label="流水线 Pipeline">流水线 Pipeline</a><ul><li><a href=#%e6%95%b0%e6%8d%ae%e7%ab%9e%e4%ba%89%e7%9a%84%e4%b8%89%e7%a7%8d%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88 aria-label=数据竞争的三种解决方案>数据竞争的三种解决方案</a></li></ul></li><li><a href=#%e5%bc%82%e5%b8%b8-exception aria-label="异常 Exception">异常 Exception</a></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>课程笔记：cs152（计算机体系结构）</div></header><h2 id=cisc的发展到risc诞生>CISC的发展到RISC诞生</h2><ul><li>1940-1950<ul><li>冯诺依曼架构被提出：以存储器为中心，软件和硬件的设计分离，减少了系统中的硬连接，实现了可编程的计算机！</li><li>用户程序（二进制指令）被存储到存储器中。存储器的容量，几k字，不能放下很大的程序。</li><li>存储器有CRT磷光线存储器（支持随机存储），磁芯（Core memory）（<a href=https://zhuanlan.zhihu.com/p/144628785>磁芯存储：统治存储领域20年 - 知乎</a>）。</li></ul></li><li>1960-1970<ul><li>PDP-6典型设计，16个通用寄存器，SP+FP，ISA逐渐变得复杂</li><li>此时人们用汇编指令写程序，认为每个常见操作都应该实现为一条特殊的指令（三角函数、CRC&mldr;）。<strong>（？？？与ROM和RAM的速度差异有关吗）</strong></li><li>这么多种类的指令硬连线的方式太复杂 ==> 微码</li><li>微码ROM是一张表：ISA指令和微操作之间的映射，一条指令对应多个微操作</li><li>有了微码，创造一条新的指令很容易，使用不同微操作的组合即可</li></ul></li><li>1980<ul><li>高级语言和编译器来了，不用再手写指令</li><li>编译器很难利用到这么多复杂的指令，生成的汇编代码常用几条指令占95%，大量的不常用指令占据了微码ROM。</li><li>发明出基于Mos的SRAM，比原先的快2-10倍！<strong>？？？所以呢</strong></li><li>CISC不适合与流水线<ul><li>decode时间不一致，边decode边取指，不确定的时间段</li><li>寻址模式多，容易引发数据竞争，而且不容易检测</li></ul></li></ul></li></ul><h2 id=流水线-pipeline>流水线 Pipeline</h2><p>RISC的架构中出现的，旨在提高处理器处理效率，<strong>争取在一个时钟周期中完成一条指令（CPI=1）</strong>。</p><style type=text/css>.notice{--root-color:#444;--root-background:#eff;--title-color:#fff;--title-background:#7bd;--warning-title:#c33;--warning-content:#fee;--info-title:#fb7;--info-content:#fec;--note-title:#6be;--note-content:#e7f2fa;--tip-title:#5a5;--tip-content:#efe}@media(prefers-color-scheme:dark){.notice{--root-color:#ddd;--root-background:#eff;--title-color:#fff;--title-background:#7bd;--warning-title:#800;--warning-content:#400;--info-title:#a50;--info-content:#420;--note-title:#069;--note-content:#023;--tip-title:#363;--tip-content:#121}}body.dark .notice{--root-color:#ddd;--root-background:#eff;--title-color:#fff;--title-background:#7bd;--warning-title:#800;--warning-content:#400;--info-title:#a50;--info-content:#420;--note-title:#069;--note-content:#023;--tip-title:#363;--tip-content:#121}.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:var(--root-color);background:var(--root-background)}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:var(--title-color);background:var(--title-background)}.notice.warning .notice-title{background:var(--warning-title)}.notice.warning{background:var(--warning-content)}.notice.info .notice-title{background:var(--info-title)}.notice.info{background:var(--info-content)}.notice.note .notice-title{background:var(--note-title)}.notice.note{background:var(--note-content)}.notice.tip .notice-title{background:var(--tip-title)}.notice.tip{background:var(--tip-content)}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:.125em;position:relative}</style><div class="notice tip" id=CPI指标的意义><p class=notice-title><span class="icon-notice baseline"><svg xmlns="http://www.w3.org/2000/svg" viewBox="300.5 134 300 300"><path d="M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32.0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32.0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984s1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32.0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789zM600.5 284c0 82.813-67.188 150-150 150-82.813.0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813.0 150 67.188 150 150z"/></svg></span><span>CPI指标的意义</span></p><p>CPI 总是衡量大量指令的平均结果，单讨论一两个指令的CPI是没有意义的</p><p>Pipeline CPI计算：从第一条指令结束到最后一条指令结束的周期数/指令数</p><figure><img src=/cs152_cpi.png width=70%></figure><p>￼
PS：为什么不从第一条指令的开始进行计算？==> 因为通常有大量的指令（百万），所以第一条指令开始到结束的时间段没什么实际意义，影响不大。</p></div><p>最经典的当属MIPS(无内部互锁的流水线处理器)的五级流水线技术。MIPS体系结构本身就是为了流水线而设计的，每条指令的执行过程都分成五级。每一级成为一个流水线阶段，每个阶段占用固定的时间，通常是一个时钟周期。</p><div class="notice info"><p class=notice-title><span class="icon-notice baseline"><svg xmlns="http://www.w3.org/2000/svg" viewBox="92 59.5 300 300"><path d="M292 303.25V272c0-3.516-2.734-6.25-6.25-6.25H267v-1e2c0-3.516-2.734-6.25-6.25-6.25h-62.5c-3.516.0-6.25 2.734-6.25 6.25V197c0 3.516 2.734 6.25 6.25 6.25H217v62.5h-18.75c-3.516.0-6.25 2.734-6.25 6.25v31.25c0 3.516 2.734 6.25 6.25 6.25h87.5c3.516.0 6.25-2.734 6.25-6.25zm-25-175V97c0-3.516-2.734-6.25-6.25-6.25h-37.5c-3.516.0-6.25 2.734-6.25 6.25v31.25c0 3.516 2.734 6.25 6.25 6.25h37.5c3.516.0 6.25-2.734 6.25-6.25zm125 81.25c0 82.813-67.188 150-150 150-82.813.0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813.0 150 67.188 150 150z"/></svg></span><span></span></p><p>像是取指、访存阶段都比较耗时，超过了一个时钟周期。</p></div><figure><img src=/cs152_mips.jpg width=90%></figure><p>有的微架构就使用超长的流水线（多级），将指令阶段进一步细分，有助于增加并行度。
但是呢，阶段分的太细，在微架构层面会比较复杂，因为各个阶段之间需要发送信号，会浪费一些时间。</p><h3 id=数据竞争的三种解决方案>数据竞争的三种解决方案</h3><ol><li>等待。其他竞争的指令等着当前指令执行完再执行。</li><li>Bypass。需要额外硬件，</li><li>预测。需要额外硬件，先猜一个值，如果错了再刷新流水线重退。</li></ol><h2 id=异常-exception>异常 Exception</h2><p>流水线的各个阶段都会产生异常，怎么设计？</p><p>难道在每个时钟周期都检测流水线中有无异常吗？显然不行，因为假设指令B在Decode阶段产生了异常，如果此时就认定指令B触发异常。但殊不知上一条指令A会在回写阶段也触发异常。
而一般来说，按照程序员的视角我们认为指令一条一条的执行，所以也希望异常按照指令顺序产生。</p><p>进而，就提出了<strong>在流水线的最后【提交】阶段才检查异常</strong>。</p><ul><li>流水线中多了3个额外的寄存器用于标记每个阶段是否产生异常。</li><li>前面指令产生的异常标记可以覆盖后面指令。这就使得异常按照指令顺序产生。</li><li>若一条指令在前面阶段已经产生异常，后续阶段Bubble。</li><li>在最后提交阶段之前，会检查是不是有异常或者异步中断？（如果两者都有，实现定义）之后下一个PC就是异常向量。</li></ul><figure><img src=/cs152_pipeline_exception.jpg width=90%></figure></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2024-04-05T19:28:12, Lastmod: 2024-04-17T23:52:53</p></main></div></body></html>