<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>Python 基础知识</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e5%86%99 aria-label=为什么写>为什么写</a></li><li><a href=#%e5%88%97%e8%a1%a8-list aria-label="列表 list">列表 list</a><ul><li><a href=#%e7%9b%b8%e5%85%b3%e6%93%8d%e4%bd%9c aria-label=相关操作>相关操作</a><ul><li><a href=#%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%88%97%e8%a1%a8 aria-label=创建一个列表>创建一个列表</a></li><li><a href=#%e5%85%b6%e4%bb%96%e6%93%8d%e4%bd%9c aria-label=其他操作>其他操作</a></li></ul></li></ul></li><li><a href=#python-%e5%86%85%e7%bd%ae%e7%b1%bb%e5%9e%8b aria-label="Python 内置类型">Python 内置类型</a><ul><li><a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2 aria-label=字符串>字符串</a><ul><li><a href=#string-%e7%9a%84%e4%b8%89%e7%a7%8d%e5%bd%a2%e5%bc%8f aria-label="string 的三种形式">string 的三种形式</a></li></ul></li><li><a href=#%e5%ad%97%e5%85%b8 aria-label=字典>字典</a><ul><li><a href=#%e5%ad%97%e5%85%b8%e7%9a%84%e6%93%8d%e4%bd%9c aria-label=字典的操作>字典的操作</a></li><li><a href=#%e5%ad%97%e5%85%b8%e7%9a%84%e9%99%90%e5%88%b6 aria-label=字典的限制>字典的限制</a></li><li><a href=#%e5%85%83%e7%bb%84 aria-label=元组>元组</a></li></ul></li></ul></li><li><a href=#%e5%9f%ba%e7%a1%80%e8%af%ad%e6%b3%95 aria-label=基础语法>基础语法</a><ul><li><a href=#iterator aria-label=iterator>iterator</a></li></ul></li><li><a href=#python-%e5%86%85%e7%bd%ae%e5%8a%9f%e8%83%bd%e5%87%bd%e6%95%b0 aria-label="Python 内置功能函数">Python 内置功能函数</a><ul><li><a href=#%e8%81%9a%e5%90%88%e5%8f%af%e7%b4%a2%e5%bc%95%e7%9a%84%e7%b1%bb%e5%9e%8b aria-label=聚合可索引的类型>聚合可索引的类型</a><ul><li><a href=#sumiterable-start aria-label="sum(iterable[, start])">sum(iterable[, start])</a></li><li><a href=#max aria-label=max>max</a></li></ul></li></ul></li><li><a href=#%e5%85%b6%e4%bb%96%e7%89%b9%e6%80%a7 aria-label=其他特性>其他特性</a><ul><li><a href=#nonlocal%e5%a3%b0%e6%98%8e aria-label=nonlocal声明><code>nonlocal</code>声明</a></li><li><a href=#python-%e5%8a%a8%e6%80%81%e7%b1%bb%e5%9e%8b aria-label="Python 动态类型">Python 动态类型</a><ul><li><a href=#%e5%af%b9%e8%b1%a1%e7%9a%84%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6 aria-label=对象的垃圾回收>对象的垃圾回收</a></li><li><a href=#%e6%b7%b1%e6%8b%b7%e8%b4%9d%e5%92%8c%e6%b5%85%e6%8b%b7%e8%b4%9d aria-label=深拷贝和浅拷贝>深拷贝和浅拷贝</a></li><li><a href=#%e5%88%a4%e6%96%ad%e7%9b%b8%e7%ad%89 aria-label=判断相等>判断相等</a></li></ul></li><li><a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2-1 aria-label=字符串>字符串</a><ul><li><a href=#%e7%89%b9%e6%ae%8a%e5%ad%97%e7%ac%a6%e7%9a%84%e8%bd%ac%e4%b9%89 aria-label=特殊字符的转义>特殊字符的转义</a></li><li><a href=#%e7%b4%a2%e5%bc%95%e5%92%8c%e5%88%86%e7%89%87 aria-label=索引和分片>索引和分片</a><ul><li><a href=#%e5%a4%84%e7%90%86%e5%8f%82%e6%95%b0 aria-label=处理参数>处理参数</a></li><li><a href=#%e5%a4%84%e7%90%86%e6%96%87%e4%bb%b6 aria-label=处理文件>处理文件</a></li></ul></li><li><a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%92%8c%e5%85%b6%e4%bb%96%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2 aria-label=字符串和其他类型转换>字符串和其他类型转换</a></li><li><a href=#%e4%bf%ae%e6%94%b9%e5%ad%97%e7%ac%a6%e4%b8%b2 aria-label=修改字符串>修改字符串</a></li><li><a href=#python-%e4%b8%ad%e7%9a%84-sprintf aria-label="Python 中的 sprintf">Python 中的 sprintf</a></li><li><a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%9a%84%e6%96%b9%e6%b3%95 aria-label=字符串的方法>字符串的方法</a></li></ul></li><li><a href=#%e5%88%97%e8%a1%a8 aria-label=列表>列表</a><ul><li><a href=#%e5%88%97%e8%a1%a8%e5%ae%9e%e7%8e%b0-lifo aria-label="列表实现 LIFO">列表实现 LIFO</a></li></ul></li><li><a href=#%e5%ad%97%e5%85%b8-1 aria-label=字典>字典</a><ul><li><a href=#%e7%94%a8%e5%ad%97%e5%85%b8%e6%a8%a1%e6%8b%9f%e7%81%b5%e6%b4%bb%e7%9a%84%e5%88%97%e8%a1%a8 aria-label=用字典模拟灵活的列表>用字典模拟灵活的列表</a></li><li><a href=#%e5%ad%97%e5%85%b8%e6%8f%8f%e8%bf%b0%e7%a8%80%e7%96%8f%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=字典描述稀疏数据结构>字典描述稀疏数据结构</a></li><li><a href=#%e5%ad%97%e5%85%b8%e5%88%9b%e5%bb%ba%e7%9a%84%e6%96%b9%e6%b3%95 aria-label=字典创建的方法>字典创建的方法</a></li></ul></li></ul></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>Python 基础知识</div></header><h1 id=为什么写>为什么写</h1><p>因为平常的工作中很少用到python, 但是不得不承认 python是一门优秀的语言,
对于我目前要准备秋招的情况来看, 有的公司做题如果支持python那会简单很多,
同样的代码,用C写要100行, 换到python最多30搞定.</p><p>有人说C++也可以啊,而且对于常用C的人来说学习门槛更低, 但是我实在是受不了
C++的语法, 包括但不限于模板、迭代器，STL操作，感觉有点四不像的味道。
当然，这只是我的个人习惯，使用C++的人也是很多的，还是根据自己的习惯
选择一套趁手的工具比较好。</p><p>因为我其他时间基本都在用C，所以在本篇文章中我会更多拿C来进行比较，这样更好记忆。</p><p>我学习 Python 的知识点来源:</p><ol><li>《Python 学习手册 第 4 版》李军等</li><li>UCB CS61A</li></ol><h1 id=列表-list>列表 list</h1><p>列表支持下标索引，所以它就像C语言中的“数组”，列表支持大小动态增长，所以更像“数组plus”，类似C++中的vector吧（不太确定）。</p><p>列表支持定长声明或变长声明，像创建一些flag列表，用下标进行查找时，定长创建就是必要的。</p><h2 id=相关操作>相关操作</h2><h3 id=创建一个列表>创建一个列表</h3><p>以下的创建操作都是支持的:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#888># 创建一个空列表</span>
</span></span><span style=display:flex><span>lst = []
</span></span><span style=display:flex><span><span style=color:#888># 创建一个带有初值的列表</span>
</span></span><span style=display:flex><span>lst = [<span style=color:#00d;font-weight:700>1</span>, <span style=color:#00d;font-weight:700>2</span>]
</span></span><span style=display:flex><span><span style=color:#888># 创建二维空列表</span>
</span></span><span style=display:flex><span><span style=color:#888># 应用的场景是: 按照索引来修改list, 此时如果单纯的初始化list=[],</span>
</span></span><span style=display:flex><span><span style=color:#888># 那么对list[1].append()会提示超出范围. 所以我们要提前规定list的长度,</span>
</span></span><span style=display:flex><span><span style=color:#888># 即将list声明为目标长度的二维list.</span>
</span></span><span style=display:flex><span>lst = [[] <span style=color:#080;font-weight:700>for</span> _ <span style=color:#080>in</span> <span style=color:#038>range</span>(<span style=color:#00d;font-weight:700>5</span>)]
</span></span><span style=display:flex><span><span style=color:#888># 创建定长列表并附初值</span>
</span></span><span style=display:flex><span>lst = [<span style=color:#00d;font-weight:700>0</span> <span style=color:#080;font-weight:700>for</span> _ <span style=color:#080>in</span> <span style=color:#038>range</span>(<span style=color:#00d;font-weight:700>5</span>)]
</span></span><span style=display:flex><span><span style=color:#888># 创建二维定长列表并附处置0</span>
</span></span><span style=display:flex><span>lst = [[<span style=color:#00d;font-weight:700>0</span> <span style=color:#080;font-weight:700>for</span> _ <span style=color:#080>in</span> <span style=color:#038>range</span>(<span style=color:#00d;font-weight:700>5</span>)] <span style=color:#080;font-weight:700>for</span> _ <span style=color:#080>in</span> <span style=color:#038>range</span>(<span style=color:#00d;font-weight:700>5</span>)]
</span></span></code></pre></div><p>以下的方式是错误的! 因为每个子列表都指向同一个对象, 修改一个会同步其他的</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>lst = [[]] * <span style=color:#00d;font-weight:700>5</span>
</span></span></code></pre></div><p>List 的高级构建方法，充分利用python的灵活性:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>&gt;&gt;&gt; odds = [<span style=color:#00d;font-weight:700>1</span>, <span style=color:#00d;font-weight:700>3</span>, <span style=color:#00d;font-weight:700>5</span>, <span style=color:#00d;font-weight:700>7</span>, <span style=color:#00d;font-weight:700>9</span>]
</span></span><span style=display:flex><span>&gt;&gt;&gt; [x+<span style=color:#00d;font-weight:700>1</span> <span style=color:#080;font-weight:700>for</span> x <span style=color:#080>in</span> odds]
</span></span><span style=display:flex><span>[<span style=color:#00d;font-weight:700>2</span>, <span style=color:#00d;font-weight:700>4</span>, <span style=color:#00d;font-weight:700>6</span>, <span style=color:#00d;font-weight:700>8</span>, <span style=color:#00d;font-weight:700>10</span>]
</span></span><span style=display:flex><span>&gt;&gt;&gt; [x <span style=color:#080;font-weight:700>for</span> x <span style=color:#080>in</span> odds <span style=color:#080;font-weight:700>if</span> <span style=color:#00d;font-weight:700>25</span> % x == <span style=color:#00d;font-weight:700>0</span>]
</span></span><span style=display:flex><span>[<span style=color:#00d;font-weight:700>1</span>, <span style=color:#00d;font-weight:700>5</span>]
</span></span></code></pre></div><h3 id=其他操作>其他操作</h3><ul><li>直接使用 <code>+</code>, <code>*</code>运算符实现多个列表的组合, 与字符串类似</li><li>append: 为列表增加一个对象(末尾)</li><li>pop(pos): 删除列表中的某个元素(按位置)，并返回其值</li><li>insert(pos, val): 在列表的任意位置插入对象</li><li>remove: 删除列表中的某个元素(按内容)</li><li>多级列表是被支持的，像二维数组一样，但是操作比较复杂，一般不使用内置的列表来实现。</li><li>&mldr;</li></ul><h1 id=python-内置类型>Python 内置类型</h1><p>实例的类型可以通过内置函数<code>type()</code>来查看。</p><h2 id=字符串>字符串</h2><p>定义一个 python 字符串</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>S = <span style=color:#d20;background-color:#fff0f0>&#39;Spam&#39;</span>
</span></span></code></pre></div><p>支持索引其中元素，也支持<strong>反向索引</strong>（即从右边开始计算），一般来说负的索引号会简单地与字符串的长度相加。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>&gt;&gt;&gt; S[<span style=color:#00d;font-weight:700>0</span>]
</span></span><span style=display:flex><span><span style=color:#d20;background-color:#fff0f0>&#39;S&#39;</span>
</span></span><span style=display:flex><span>&gt;&gt;&gt; S[-<span style=color:#00d;font-weight:700>1</span>]
</span></span><span style=display:flex><span><span style=color:#d20;background-color:#fff0f0>&#39;m&#39;</span>
</span></span><span style=display:flex><span>&gt;&gt;&gt; S[<span style=color:#038>len</span>(S)-<span style=color:#00d;font-weight:700>1</span>]
</span></span><span style=display:flex><span><span style=color:#d20;background-color:#fff0f0>&#39;m&#39;</span>
</span></span></code></pre></div><p>python 也支持字符串分片操作，左边界的默认值为 0，右边界的默认值为字符串的长度。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>&gt;&gt;&gt; S[<span style=color:#00d;font-weight:700>1</span>:]
</span></span><span style=display:flex><span><span style=color:#d20;background-color:#fff0f0>&#39;pam&#39;</span>
</span></span><span style=display:flex><span>&gt;&gt;&gt; S[<span style=color:#00d;font-weight:700>0</span>:<span style=color:#00d;font-weight:700>3</span>]
</span></span><span style=display:flex><span><span style=color:#d20;background-color:#fff0f0>&#39;Spa&#39;</span>
</span></span><span style=display:flex><span>&gt;&gt;&gt; S[:-<span style=color:#00d;font-weight:700>1</span>]
</span></span><span style=display:flex><span><span style=color:#d20;background-color:#fff0f0>&#39;Spa&#39;</span>
</span></span></code></pre></div><p>字符串对于<code>+</code>操作符的表现是字符串的连接，这体现了 python 的多态性。
字符串创建后无法直接通过索引改变其元素，可以转而通过同名对象覆盖来实现：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>&gt;&gt;&gt; S[<span style=color:#00d;font-weight:700>0</span>] = <span style=color:#d20;background-color:#fff0f0>&#39;z&#39;</span>
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  File <span style=color:#d20;background-color:#fff0f0>&#34;&lt;stdin&gt;&#34;</span>, line <span style=color:#00d;font-weight:700>1</span>, <span style=color:#080>in</span> &lt;module&gt;
</span></span><span style=display:flex><span><span style=color:#b06;font-weight:700>TypeError</span>: <span style=color:#d20;background-color:#fff0f0>&#39;str&#39;</span> <span style=color:#038>object</span> does <span style=color:#080>not</span> support item assignment
</span></span><span style=display:flex><span>&gt;&gt;&gt; S = <span style=color:#d20;background-color:#fff0f0>&#39;z&#39;</span> + S[<span style=color:#00d;font-weight:700>1</span>:]
</span></span><span style=display:flex><span>&gt;&gt;&gt; S
</span></span><span style=display:flex><span><span style=color:#d20;background-color:#fff0f0>&#39;zpam&#39;</span>
</span></span></code></pre></div><p>字符串支持的属性，例如<code>.find()</code>可以通过内置命令 <code>dir(S)</code>来查看。</p><blockquote><p>dir 函数仅仅给出了方法的名称，如果想查询其具体使用方法，可以利用内置函数<code>help(S.find)</code>。</p></blockquote><h3 id=string-的三种形式>string 的三种形式</h3><p>Python 允许字符串被包括在单引号或者双引号中(<strong>它们的含义相同</strong>），它也允许在三个引号（单或双均可）中包含<strong>多行</strong>字符串常量，当 Python 脚本中嵌入像 HTML 这样的内容时，这是很方便的。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>&gt;&gt;&gt; msg = <span style=color:#d20;background-color:#fff0f0>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#d20;background-color:#fff0f0>... aaaaa
</span></span></span><span style=display:flex><span><span style=color:#d20;background-color:#fff0f0>... bbbbb
</span></span></span><span style=display:flex><span><span style=color:#d20;background-color:#fff0f0>... ccccc
</span></span></span><span style=display:flex><span><span style=color:#d20;background-color:#fff0f0>... &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>&gt;&gt;&gt; msg
</span></span><span style=display:flex><span><span style=color:#d20;background-color:#fff0f0>&#39;</span><span style=color:#04d;background-color:#fff0f0>\n</span><span style=color:#d20;background-color:#fff0f0>aaaaa</span><span style=color:#04d;background-color:#fff0f0>\n</span><span style=color:#d20;background-color:#fff0f0>bbbbb</span><span style=color:#04d;background-color:#fff0f0>\n</span><span style=color:#d20;background-color:#fff0f0>ccccc</span><span style=color:#04d;background-color:#fff0f0>\n</span><span style=color:#d20;background-color:#fff0f0>&#39;</span>
</span></span></code></pre></div><h2 id=字典>字典</h2><p>键值对</p><p>支持通过 key 索引来修改， 所以与字符串和列表不同。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>&gt;&gt;&gt; D = {}
</span></span><span style=display:flex><span>&gt;&gt;&gt; D[<span style=color:#d20;background-color:#fff0f0>&#39;name&#39;</span>] = <span style=color:#d20;background-color:#fff0f0>&#39;Bob&#39;</span>
</span></span><span style=display:flex><span>&gt;&gt;&gt; D[<span style=color:#d20;background-color:#fff0f0>&#39;age&#39;</span>] = <span style=color:#00d;font-weight:700>40</span>
</span></span><span style=display:flex><span>&gt;&gt;&gt; D
</span></span><span style=display:flex><span>{<span style=color:#d20;background-color:#fff0f0>&#39;name&#39;</span>: <span style=color:#d20;background-color:#fff0f0>&#39;Bob&#39;</span>, <span style=color:#d20;background-color:#fff0f0>&#39;age&#39;</span>: <span style=color:#00d;font-weight:700>40</span>}
</span></span></code></pre></div><p>字典也支持嵌套操作，在 json 中常用</p><h3 id=字典的操作>字典的操作</h3><ul><li>keys() 返回 key 的列表</li><li>value() 返回 value 的列表</li><li>item(): 返回<code>(key,value)</code>构成的元组列表</li></ul><h3 id=字典的限制>字典的限制</h3><ul><li>在<em>python3.6</em>之前字典是 unordered, 即存储的顺序不按照加入时间; 而在<em>python3.6+</em>,
字典改为 ordered.</li><li>key 是唯一的, 如果你想让一个 key 对应多个值, 将其 value 设置为 list 是一种方案!</li><li>list 只能是 value, 不能是 key</li></ul><h3 id=元组>元组</h3><p>元祖像一个<strong>不可改变</strong>的列表</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>&gt;&gt;&gt; T = (<span style=color:#00d;font-weight:700>1</span>, <span style=color:#00d;font-weight:700>2</span>, <span style=color:#00d;font-weight:700>3</span>, <span style=color:#00d;font-weight:700>4</span>)
</span></span><span style=display:flex><span>&gt;&gt;&gt; T
</span></span><span style=display:flex><span>(<span style=color:#00d;font-weight:700>1</span>, <span style=color:#00d;font-weight:700>2</span>, <span style=color:#00d;font-weight:700>3</span>, <span style=color:#00d;font-weight:700>4</span>)
</span></span></code></pre></div><p>其专有的方法：</p><ul><li>index(x) 返回 x 所在元组中的下标</li><li>count(x) 计算 x 在元组中出现的次数</li></ul><blockquote><p>为什么要使用元组？
一般来说，元组不如列表那样常用，因为它的不可被改变的特性。但是，这也赋予了元组天然的完整性约束，可应用在期望不会被改变的场景中</p></blockquote><h1 id=基础语法>基础语法</h1><h2 id=iterator>iterator</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>l = [<span style=color:#00d;font-weight:700>1</span>, <span style=color:#00d;font-weight:700>2</span>, <span style=color:#00d;font-weight:700>3</span>]
</span></span><span style=display:flex><span>k = <span style=color:#038>iter</span>(l)  <span style=color:#888># 得到一个可以遍历的iterator</span>
</span></span><span style=display:flex><span><span style=color:#038>next</span>(k)      <span style=color:#888># get 1</span>
</span></span><span style=display:flex><span><span style=color:#038>next</span>(k)      <span style=color:#888># get 2</span>
</span></span></code></pre></div><p>iterator 任何情况下都可以等价于一个 for 循环!</p><p>list 的 iterator 像是一个 list, 不同的是它存在一个"监视者"会记录你当前所在的位置, 使得你可以调用一些方法(<code>next()</code>)
来得到当前位置的元素, 并监视下一个位置的元素.</p><p>当然, 不仅仅 list 有对应的 iterator, 对于其他数据结构来说亦是如此.</p><blockquote><p>如果在遍历<code>k</code>的途中改变了遍历对象的结构(例如<code>lst.append(4)</code>), 该 iterator 将不可再用!</p><p>所以以下代码的行为是错误的:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>lst = [<span style=color:#00d;font-weight:700>1</span>, <span style=color:#00d;font-weight:700>2</span>, <span style=color:#00d;font-weight:700>3</span>]
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>for</span> item <span style=color:#080>in</span> lst:
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>if</span> item == <span style=color:#00d;font-weight:700>1</span>:
</span></span><span style=display:flex><span>    lst.remove(<span style=color:#00d;font-weight:700>1</span>)
</span></span></code></pre></div><p>可以专门创建一个 <code>lst</code> 的副本用于循环:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#080;font-weight:700>for</span> item <span style=color:#080>in</span> <span style=color:#038>list</span>(lst):
</span></span><span style=display:flex><span> ...
</span></span></code></pre></div><p>但修改其中的值不影响(例如<code>lst[0] = 0</code>)</p></blockquote><p>另一个有趣的事情是: 如果使用<code>list()</code>方法创建一个 iterator 的 list, python 实际的行为是
<strong>调用<code>next()</code>直到结尾来得到元素并插入新的 list</strong>. 所以下面的代码行为就容易理解了:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>t = <span style=color:#038>iter</span>([<span style=color:#00d;font-weight:700>1</span>, <span style=color:#00d;font-weight:700>2</span>, <span style=color:#00d;font-weight:700>3</span>])
</span></span><span style=display:flex><span><span style=color:#038>list</span>(t)  <span style=color:#888># [1, 2, 3]</span>
</span></span><span style=display:flex><span><span style=color:#038>list</span>(t)  <span style=color:#888># []</span>
</span></span></code></pre></div><h1 id=python-内置功能函数>Python 内置功能函数</h1><h2 id=聚合可索引的类型>聚合可索引的类型</h2><p>一些内置的功能函数可以将<strong>可索引的</strong>参数转换为有意义的<strong>数值</strong>. 例如 range, list 等.</p><h3 id=sumiterable-start>sum(iterable[, start])</h3><p>返回可索引的参数元素之和(不能是字符串), 加上 start(默认是 0). 当 <code>iterable</code> 为空时, 返回 <code>start</code></p><blockquote><p>为什么要有一个<code>start</code>?
使得如果输入字符串组成的列表(可以是其他可索引的数据结构), 会抛出异常. 详见下面实例</p></blockquote><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>&gt;&gt;&gt; <span style=color:#038>sum</span>([<span style=color:#00d;font-weight:700>2</span>, <span style=color:#00d;font-weight:700>3</span>, <span style=color:#00d;font-weight:700>4</span>])
</span></span><span style=display:flex><span><span style=color:#00d;font-weight:700>9</span>
</span></span><span style=display:flex><span>&gt;&gt;&gt; <span style=color:#038>sum</span>([<span style=color:#d20;background-color:#fff0f0>&#39;2&#39;</span>, <span style=color:#d20;background-color:#fff0f0>&#39;3&#39;</span>, <span style=color:#d20;background-color:#fff0f0>&#39;4&#39;</span>])
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  File <span style=color:#d20;background-color:#fff0f0>&#34;&lt;stdin&gt;&#34;</span>, line <span style=color:#00d;font-weight:700>1</span>, <span style=color:#080>in</span> &lt;module&gt;
</span></span><span style=display:flex><span><span style=color:#b06;font-weight:700>TypeError</span>: unsupported operand <span style=color:#038>type</span>(s) <span style=color:#080;font-weight:700>for</span> +: <span style=color:#d20;background-color:#fff0f0>&#39;int&#39;</span> <span style=color:#080>and</span> <span style=color:#d20;background-color:#fff0f0>&#39;str&#39;</span>
</span></span></code></pre></div><p>其实现的原理是: 保证前面<code>iterable</code>中元素求和的结果与<code>start</code>的类型相同. 例如:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>&gt;&gt;&gt; <span style=color:#038>sum</span>([<span style=color:#00d;font-weight:700>2</span>, <span style=color:#00d;font-weight:700>3</span>, <span style=color:#00d;font-weight:700>4</span>], <span style=color:#00d;font-weight:700>5</span>)
</span></span><span style=display:flex><span><span style=color:#00d;font-weight:700>14</span>
</span></span><span style=display:flex><span>&gt;&gt;&gt; <span style=color:#038>sum</span>([[<span style=color:#00d;font-weight:700>2</span>, <span style=color:#00d;font-weight:700>3</span>], [<span style=color:#00d;font-weight:700>4</span>]], [])
</span></span><span style=display:flex><span>[<span style=color:#00d;font-weight:700>2</span>, <span style=color:#00d;font-weight:700>3</span>, <span style=color:#00d;font-weight:700>4</span>]
</span></span><span style=display:flex><span>&gt;&gt;&gt; <span style=color:#038>sum</span>([[<span style=color:#00d;font-weight:700>2</span>, <span style=color:#00d;font-weight:700>3</span>], [<span style=color:#00d;font-weight:700>4</span>]])
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  File <span style=color:#d20;background-color:#fff0f0>&#34;&lt;stdin&gt;&#34;</span>, line <span style=color:#00d;font-weight:700>1</span>, <span style=color:#080>in</span> &lt;module&gt;
</span></span><span style=display:flex><span><span style=color:#b06;font-weight:700>TypeError</span>: unsupported operand <span style=color:#038>type</span>(s) <span style=color:#080;font-weight:700>for</span> +: <span style=color:#d20;background-color:#fff0f0>&#39;int&#39;</span> <span style=color:#080>and</span> <span style=color:#d20;background-color:#fff0f0>&#39;list&#39;</span>
</span></span></code></pre></div><h3 id=max>max</h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#038>max</span>(iterable[, key=func]) -&gt; value
</span></span><span style=display:flex><span><span style=color:#038>max</span>(a, b, c, ...[,key=func]) -&gt; value
</span></span></code></pre></div><p><code>key</code>是用来预处理数据的, 默认为 <code>lambda x: x</code></p><h1 id=其他特性>其他特性</h1><h2 id=nonlocal声明><code>nonlocal</code>声明</h2><p>使用方法:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#080;font-weight:700>nonlocal</span> &lt;name&gt;
</span></span></code></pre></div><p>效果: 在声明某个变量为<code>nonlocal</code>之后, 对其所有赋值语句, 都不会建立一个局部的绑定, 而是将该变量重新绑定到<strong>当前 frame 向上能找到的第一个非局部 frame</strong>中对该变量的绑定.</p><p>简单来说, 就是对该变量的所有赋值操作都改为操作能找到的第一个全局(这个全局是相对的)同名变量. 当然, 如果找不到一个同名全局变量, 就抛出异常.</p><p>下面的例子中, 如果在<code>withdrew()</code>中不将<code>balance</code>声明为 nonlocal:</p><ul><li>if 语句是可以通过的, 因为<strong>访问</strong><code>balance</code>会找到当前 frame 的 parent,
即<code>make_withdraw()</code>中声明的<code>balance</code>.</li><li>而 python 处理<strong>赋值</strong>操作就不一样了. 他会默认将<code>balance</code>绑定到局部, 而
这就与 if 语句产生了冲突, 会抛出异常.</li></ul><p>所以就需要<code>nonlocal</code>的声明, 告诉 python: <strong>赋值语句也得去上面 frame 中找一个全局的.</strong></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#888># make_withdraw 建立一个银行账户, 并给出初始金额,</span>
</span></span><span style=display:flex><span><span style=color:#888># 其返回一个函数withdrew(), 调用该函数的行为是从</span>
</span></span><span style=display:flex><span><span style=color:#888># 银行账户里扣款</span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>def</span> <span style=color:#06b;font-weight:700>make_withdraw</span>(balance):
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>def</span> <span style=color:#06b;font-weight:700>withdraw</span>(amount):
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>nonlocal</span> balance
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>if</span> amount &gt; balance:
</span></span><span style=display:flex><span>            <span style=color:#080;font-weight:700>return</span> <span style=color:#d20;background-color:#fff0f0>&#39;Insufficient funds&#39;</span>
</span></span><span style=display:flex><span>        balance = balance - amount
</span></span><span style=display:flex><span>        <span style=color:#080;font-weight:700>return</span> balance
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>return</span> withdraw
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>wd = make_withdraw(<span style=color:#00d;font-weight:700>20</span>)
</span></span><span style=display:flex><span>wd(<span style=color:#00d;font-weight:700>8</span>)
</span></span></code></pre></div><h2 id=python-动态类型>Python 动态类型</h2><h3 id=对象的垃圾回收>对象的垃圾回收</h3><p>在 Python 中，每当一个变量被赋予了一个新的对象，之前对象占用的空间就会被回收。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>&gt;&gt;&gt; x = <span style=color:#00d;font-weight:700>42</span>
</span></span><span style=display:flex><span>&gt;&gt;&gt; x = <span style=color:#00d;font-weight:700>3.14</span>
</span></span><span style=display:flex><span>&gt;&gt;&gt; x = <span style=color:#d20;background-color:#fff0f0>&#34;hello&#34;</span>
</span></span></code></pre></div><p>对象的引用值在此过程中被逐个回收，每次 x 指向一个新的对象，Python 将自动回收原来对象的内存空间。</p><p>Python 使用<strong>引用计数</strong>来实现该功能。为每个对象维护了一个引用计数器，记录了当前引用该对象的变量数目，一旦计数值变成 0，则其空间被回收。</p><h3 id=深拷贝和浅拷贝>深拷贝和浅拷贝</h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>L1 = [<span style=color:#00d;font-weight:700>2</span>, <span style=color:#00d;font-weight:700>3</span>, <span style=color:#00d;font-weight:700>4</span>]
</span></span><span style=display:flex><span>L2 = L1
</span></span></code></pre></div><p>产生的结果是， L1 是一个包含了对象 2、3、4 的列表，当然列表自身也是个对象。L1 是一个变量，引用了该列表的对象。运行 L2 的赋值操作后，L1 和 L2 引用了相同的对象。</p><p><strong>此时如果使用索引对 L1 列表的某个元素进行修改，由于 L1 和 L2 引用的是同一个对象，相当于 L2 也做了修改</strong>。这就是浅拷贝</p><p>浅拷贝是默认的，如果你希望使用深拷贝，即拷贝对象，而不是创建索引。对于列表来说，可以使用分片来实现</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>L1 = [<span style=color:#00d;font-weight:700>2</span>, <span style=color:#00d;font-weight:700>3</span>, <span style=color:#00d;font-weight:700>4</span>]
</span></span><span style=display:flex><span>L2 = L1[:]
</span></span></code></pre></div><p>对于其他的内置类型，有的也可以用 X.copy()方法；而且标准库的<code>copy</code>模块有一个通用的赋值任意对象类型的方法，也有一个用于<strong>嵌套深拷贝</strong>的特殊方法。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#080;font-weight:700>import</span> <span style=color:#b06;font-weight:700>copy</span>
</span></span><span style=display:flex><span>X = copy.copy(Y)    <span style=color:#888># 只深拷贝top-level</span>
</span></span><span style=display:flex><span>X = copy.deepcopy(Y) <span style=color:#888># 嵌套进行深拷贝</span>
</span></span></code></pre></div><h3 id=判断相等>判断相等</h3><p>基于上述深拷贝和浅拷贝的理论，就有关于 Python 中变量判断相等的方法。
Python 中有两种不同的方法检查变量是否相等：</p><ul><li><code>==</code> 操作符：测试两个变量引用的对象是否具有相同的值</li><li><code>is</code>操作符：检查对象的同一性，即是否指向<strong>同一个对象</strong>，是一种更加严格的相等性判断</li></ul><h2 id=字符串-1>字符串</h2><h3 id=特殊字符的转义>特殊字符的转义</h3><p>字符串中的<code>\n</code>会被识别为换行符，与 C 语言类似，但 Python 不识别结束符(<code>\0</code>)</p><p>在字符串第一个引号之前输入<code>r</code>，会关闭转义机制，将反斜杠当做普通字符来保持。常用与 Windows 环境中打开文件</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>file = <span style=color:#038>open</span>(<span style=color:#d20;background-color:#fff0f0>r</span><span style=color:#d20;background-color:#fff0f0>&#39;C:\my\path\file.txt&#39;</span>, <span style=color:#d20;background-color:#fff0f0>&#39;w&#39;</span>)
</span></span></code></pre></div><h3 id=索引和分片>索引和分片</h3><p>分片的常见作用</p><h4 id=处理参数>处理参数</h4><p>在系统命令行中启动 python 程序时，获取附加的参数，需要使用内置的 sys 模块中的 argv 属性：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#888># file echo.py</span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>import</span> <span style=color:#b06;font-weight:700>sys</span>
</span></span><span style=display:flex><span><span style=color:#038>print</span>(sys.argv)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>% python echo.py -a -b -c
</span></span><span style=display:flex><span>[<span style=color:#d20;background-color:#fff0f0>&#39;echo.py&#39;</span>, <span style=color:#d20;background-color:#fff0f0>&#39;-a&#39;</span>, <span style=color:#d20;background-color:#fff0f0>&#39;-b&#39;</span>, <span style=color:#d20;background-color:#fff0f0>&#39;-c&#39;</span>]
</span></span></code></pre></div><p>通常你只对跟随在程序名后边的参数感兴趣，这就是分片的典型应用，<code>sys.argv[1:]</code>就能满足你</p><h4 id=处理文件>处理文件</h4><p>分片也常常用作清理输入文件的内容。如果知道一行会以换行符结尾，就可以使用<code>line[:-1]</code>，把这行去除最后一个字符之外的内容提取出来。</p><blockquote><p>值得注意的是，去除换行符常常推荐采用<code>line.rstrip</code>方法，因为这个方法将会正确的处理<strong>最后一行</strong>的情况。</p></blockquote><h3 id=字符串和其他类型转换>字符串和其他类型转换</h3><p>字符串和整数</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>&gt;&gt;&gt; <span style=color:#038>int</span>(<span style=color:#d20;background-color:#fff0f0>&#34;42&#34;</span>), <span style=color:#038>str</span>(<span style=color:#00d;font-weight:700>42</span>)
</span></span><span style=display:flex><span>(<span style=color:#00d;font-weight:700>42</span>, <span style=color:#d20;background-color:#fff0f0>&#39;42&#39;</span>)
</span></span></code></pre></div><p>字符和 ASCII 码</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>&gt;&gt;&gt; <span style=color:#038>ord</span>(<span style=color:#d20;background-color:#fff0f0>&#39;s&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#00d;font-weight:700>115</span>
</span></span><span style=display:flex><span>&gt;&gt;&gt; <span style=color:#038>chr</span>(<span style=color:#00d;font-weight:700>115</span>)
</span></span><span style=display:flex><span><span style=color:#d20;background-color:#fff0f0>&#39;s&#39;</span>
</span></span></code></pre></div><h3 id=修改字符串>修改字符串</h3><p>字符串是<em>不可变序列</em>，即不能通过索引来修改。</p><p>若想改变一个字符串，需要利用合并、分片这样的工具来建立一个新的字符串，并将结果赋值给原始字符串变量</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>S = S[:<span style=color:#00d;font-weight:700>4</span>] + <span style=color:#d20;background-color:#fff0f0>&#39;Bureger&#39;</span>
</span></span></code></pre></div><p>如果不得不对一个超长字符串进行多处的修改，为了优化脚本的性能和代码，可能需要将字符串转换为一个支持原处修改的对象，如 List</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>&gt;&gt;&gt; S = <span style=color:#d20;background-color:#fff0f0>&#39;spammy&#39;</span>
</span></span><span style=display:flex><span>&gt;&gt;&gt; L = <span style=color:#038>list</span>(S)
</span></span><span style=display:flex><span>&gt;&gt;&gt; L
</span></span><span style=display:flex><span>[<span style=color:#d20;background-color:#fff0f0>&#39;s&#39;</span>, <span style=color:#d20;background-color:#fff0f0>&#39;p&#39;</span>, <span style=color:#d20;background-color:#fff0f0>&#39;a&#39;</span>, <span style=color:#d20;background-color:#fff0f0>&#39;m&#39;</span>, <span style=color:#d20;background-color:#fff0f0>&#39;m&#39;</span>, <span style=color:#d20;background-color:#fff0f0>&#39;y&#39;</span>]
</span></span></code></pre></div><p>对于 L 可以使用索引来修改，完成后需要将其转换回字符串，可以使用字符串的<code>join</code>方法来实现:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>&gt;&gt;&gt; S = <span style=color:#d20;background-color:#fff0f0>&#39;&#39;</span>.join(L)
</span></span></code></pre></div><h3 id=python-中的-sprintf>Python 中的 sprintf</h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>&gt;&gt;&gt; <span style=color:#d20;background-color:#fff0f0>&#39;That is </span><span style=color:#33b;background-color:#fff0f0>%d</span><span style=color:#d20;background-color:#fff0f0> </span><span style=color:#33b;background-color:#fff0f0>%s</span><span style=color:#d20;background-color:#fff0f0> bird!&#39;</span> % (<span style=color:#00d;font-weight:700>1</span>, <span style=color:#d20;background-color:#fff0f0>&#39;dead&#39;</span>)
</span></span><span style=display:flex><span>That <span style=color:#080>is</span> <span style=color:#00d;font-weight:700>1</span> dead bird
</span></span></code></pre></div><h3 id=字符串的方法>字符串的方法</h3><p>see Python standard manual</p><h2 id=列表>列表</h2><p>列表与字典都是<strong>其他对象的集合</strong>。</p><p>列表能够完成 C 中结构体的工作，不需要手动实现。</p><p>Python 中的列表是：</p><ul><li>任意对象的有序集合</li><li>通过偏移读取</li><li>可变长度、异构以及任意嵌套</li><li>对象引用的数组。类似与 C 语言中的指针数组</li></ul><h3 id=列表实现-lifo>列表实现 LIFO</h3><p>在某些应用中，会使用列表的<code>pop</code>和<code>append</code>方法，实现快速的 LIFO 对战结构。</p><h2 id=字典-1>字典</h2><p>字典可以称作 Python 中最灵活的内置数据结构。字典当中的元素是通过 key 来存取，而不是通过偏移，类似 C++的 map。</p><p>作为内置类型，字典可以取代许多搜索算法和数据结构。有时也能执行其他语言中的记录、符号表的功能，可以表示稀疏（多数为空）的数据结构等。</p><p>字典的主要属性如下：</p><ul><li>任意对象的无序集合</li><li>可变长、异构、任意嵌套</li><li>对象引用的散列表。字典的底层实现是散列表，一开始很小，根据要求增长。</li></ul><blockquote><p>列表和字典，不会经常用常量来创建，常使用动态方法</p></blockquote><h3 id=用字典模拟灵活的列表>用字典模拟灵活的列表</h3><p>列表对在其末尾外的元素赋值是非法的：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>&gt;&gt;&gt; L = []
</span></span><span style=display:flex><span>&gt;&gt;&gt; L[<span style=color:#00d;font-weight:700>99</span>] = <span style=color:#00d;font-weight:700>1</span>
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  File <span style=color:#d20;background-color:#fff0f0>&#34;&lt;stdin&gt;&#34;</span>, line <span style=color:#00d;font-weight:700>1</span>, <span style=color:#080>in</span> &lt;module&gt;
</span></span><span style=display:flex><span><span style=color:#b06;font-weight:700>IndexError</span>: <span style=color:#038>list</span> assignment index out of <span style=color:#038>range</span>
</span></span></code></pre></div><p>虽然你可以预先分配足够的大空间，但这种情况用字典更为方便。字典的 key 为整数时，可以效仿列表在偏移赋值时增长：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>&gt;&gt;&gt; D = {}
</span></span><span style=display:flex><span>&gt;&gt;&gt; D[<span style=color:#00d;font-weight:700>99</span>] = <span style=color:#d20;background-color:#fff0f0>&#39;spam&#39;</span>
</span></span><span style=display:flex><span>&gt;&gt;&gt; D[<span style=color:#00d;font-weight:700>99</span>]
</span></span><span style=display:flex><span><span style=color:#d20;background-color:#fff0f0>&#39;spam&#39;</span>
</span></span><span style=display:flex><span>&gt;&gt;&gt; D
</span></span><span style=display:flex><span>{<span style=color:#00d;font-weight:700>99</span>: <span style=color:#d20;background-color:#fff0f0>&#39;spam&#39;</span>}
</span></span></code></pre></div><p>好处是， 此时的 D 仅有一个元素，看上去好像是有 100 个元素。</p><h3 id=字典描述稀疏数据结构>字典描述稀疏数据结构</h3><h3 id=字典创建的方法>字典创建的方法</h3><p>共有四种不同的方案：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>{<span style=color:#d20;background-color:#fff0f0>&#39;name&#39;</span>: <span style=color:#d20;background-color:#fff0f0>&#39;mel&#39;</span>, <span style=color:#d20;background-color:#fff0f0>&#39;age&#39;</span>: <span style=color:#00d;font-weight:700>45</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>D = {}
</span></span><span style=display:flex><span>D[<span style=color:#d20;background-color:#fff0f0>&#39;name&#39;</span>] = <span style=color:#d20;background-color:#fff0f0>&#39;mel&#39;</span>
</span></span><span style=display:flex><span>D[<span style=color:#d20;background-color:#fff0f0>&#39;age&#39;</span>] = <span style=color:#00d;font-weight:700>45</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#038>dict</span>(name=<span style=color:#d20;background-color:#fff0f0>&#39;mel&#39;</span>, age=<span style=color:#00d;font-weight:700>45</span>)
</span></span><span style=display:flex><span><span style=color:#038>dict</span>([(<span style=color:#d20;background-color:#fff0f0>&#39;name&#39;</span>, <span style=color:#d20;background-color:#fff0f0>&#39;mel&#39;</span>), (<span style=color:#d20;background-color:#fff0f0>&#39;age&#39;</span>, <span style=color:#00d;font-weight:700>45</span>)])
</span></span></code></pre></div><p>上面四种方案建立的字典是相同的，它们分别应用与不同的条件：</p><ul><li>如果你可以事先拼出整个字典，那么第一种是很方便的</li><li>如果你需要一次动态地建立字典的一个字段，第二种比较合适</li><li>第三种关键字形式所需代码量比较少，但是 key 必须都是字符串才行</li><li>如果你需要在程序运行时把 key 和 value 逐步构建成序列，那么用第四种</li></ul><p>如今的 Python 代码中，第三种方式比较流行。</p></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2023-04-01T10:30:35, Lastmod: 2023-09-24T18:08:59</p><script src=/js/copy-to-clipboard.js></script></main></div></body></html>