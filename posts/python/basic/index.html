<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/syntax_pastie.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>Python 基础知识</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e5%86%99 aria-label=为什么写>为什么写</a></li><li><a href=#%e5%88%97%e8%a1%a8-list aria-label="列表 list">列表 list</a><ul><li><a href=#%e7%9b%b8%e5%85%b3%e6%93%8d%e4%bd%9c aria-label=相关操作>相关操作</a><ul><li><a href=#%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%88%97%e8%a1%a8 aria-label=创建一个列表>创建一个列表</a></li><li><a href=#%e5%85%b6%e4%bb%96%e6%93%8d%e4%bd%9c aria-label=其他操作>其他操作</a></li></ul></li></ul></li><li><a href=#python-%e5%86%85%e7%bd%ae%e7%b1%bb%e5%9e%8b aria-label="Python 内置类型">Python 内置类型</a><ul><li><a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2 aria-label=字符串>字符串</a><ul><li><a href=#string-%e7%9a%84%e4%b8%89%e7%a7%8d%e5%bd%a2%e5%bc%8f aria-label="string 的三种形式">string 的三种形式</a></li></ul></li><li><a href=#%e5%ad%97%e5%85%b8 aria-label=字典>字典</a><ul><li><a href=#%e5%ad%97%e5%85%b8%e7%9a%84%e6%93%8d%e4%bd%9c aria-label=字典的操作>字典的操作</a></li><li><a href=#%e5%ad%97%e5%85%b8%e7%9a%84%e9%99%90%e5%88%b6 aria-label=字典的限制>字典的限制</a></li><li><a href=#%e5%85%83%e7%bb%84 aria-label=元组>元组</a></li></ul></li></ul></li><li><a href=#%e5%9f%ba%e7%a1%80%e8%af%ad%e6%b3%95 aria-label=基础语法>基础语法</a><ul><li><a href=#iterator aria-label=iterator>iterator</a></li></ul></li><li><a href=#python-%e5%86%85%e7%bd%ae%e5%8a%9f%e8%83%bd%e5%87%bd%e6%95%b0 aria-label="Python 内置功能函数">Python 内置功能函数</a><ul><li><a href=#%e8%81%9a%e5%90%88%e5%8f%af%e7%b4%a2%e5%bc%95%e7%9a%84%e7%b1%bb%e5%9e%8b aria-label=聚合可索引的类型>聚合可索引的类型</a><ul><li><a href=#sumiterable-start aria-label="sum(iterable[, start])">sum(iterable[, start])</a></li><li><a href=#max aria-label=max>max</a></li></ul></li></ul></li><li><a href=#%e5%85%b6%e4%bb%96%e7%89%b9%e6%80%a7 aria-label=其他特性>其他特性</a><ul><li><a href=#nonlocal%e5%a3%b0%e6%98%8e aria-label=nonlocal声明><code>nonlocal</code>声明</a></li><li><a href=#python-%e5%8a%a8%e6%80%81%e7%b1%bb%e5%9e%8b aria-label="Python 动态类型">Python 动态类型</a><ul><li><a href=#%e5%af%b9%e8%b1%a1%e7%9a%84%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6 aria-label=对象的垃圾回收>对象的垃圾回收</a></li><li><a href=#%e6%b7%b1%e6%8b%b7%e8%b4%9d%e5%92%8c%e6%b5%85%e6%8b%b7%e8%b4%9d aria-label=深拷贝和浅拷贝>深拷贝和浅拷贝</a></li><li><a href=#%e5%88%a4%e6%96%ad%e7%9b%b8%e7%ad%89 aria-label=判断相等>判断相等</a></li></ul></li><li><a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2-1 aria-label=字符串>字符串</a><ul><li><a href=#%e7%89%b9%e6%ae%8a%e5%ad%97%e7%ac%a6%e7%9a%84%e8%bd%ac%e4%b9%89 aria-label=特殊字符的转义>特殊字符的转义</a></li><li><a href=#%e7%b4%a2%e5%bc%95%e5%92%8c%e5%88%86%e7%89%87 aria-label=索引和分片>索引和分片</a><ul><li><a href=#%e5%a4%84%e7%90%86%e5%8f%82%e6%95%b0 aria-label=处理参数>处理参数</a></li><li><a href=#%e5%a4%84%e7%90%86%e6%96%87%e4%bb%b6 aria-label=处理文件>处理文件</a></li></ul></li><li><a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%92%8c%e5%85%b6%e4%bb%96%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2 aria-label=字符串和其他类型转换>字符串和其他类型转换</a></li><li><a href=#%e4%bf%ae%e6%94%b9%e5%ad%97%e7%ac%a6%e4%b8%b2 aria-label=修改字符串>修改字符串</a></li><li><a href=#python-%e4%b8%ad%e7%9a%84-sprintf aria-label="Python 中的 sprintf">Python 中的 sprintf</a></li><li><a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%9a%84%e6%96%b9%e6%b3%95 aria-label=字符串的方法>字符串的方法</a></li></ul></li><li><a href=#%e5%88%97%e8%a1%a8 aria-label=列表>列表</a><ul><li><a href=#%e5%88%97%e8%a1%a8%e5%ae%9e%e7%8e%b0-lifo aria-label="列表实现 LIFO">列表实现 LIFO</a></li></ul></li><li><a href=#%e5%ad%97%e5%85%b8-1 aria-label=字典>字典</a><ul><li><a href=#%e7%94%a8%e5%ad%97%e5%85%b8%e6%a8%a1%e6%8b%9f%e7%81%b5%e6%b4%bb%e7%9a%84%e5%88%97%e8%a1%a8 aria-label=用字典模拟灵活的列表>用字典模拟灵活的列表</a></li><li><a href=#%e5%ad%97%e5%85%b8%e6%8f%8f%e8%bf%b0%e7%a8%80%e7%96%8f%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=字典描述稀疏数据结构>字典描述稀疏数据结构</a></li><li><a href=#%e5%ad%97%e5%85%b8%e5%88%9b%e5%bb%ba%e7%9a%84%e6%96%b9%e6%b3%95 aria-label=字典创建的方法>字典创建的方法</a></li></ul></li></ul></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>Python 基础知识</div></header><h1 id=为什么写>为什么写</h1><p>因为平常的工作中很少用到python, 但是不得不承认 python是一门优秀的语言,
对于我目前要准备秋招的情况来看, 有的公司做题如果支持python那会简单很多,
同样的代码,用C写要100行, 换到python最多30搞定.</p><p>有人说C++也可以啊,而且对于常用C的人来说学习门槛更低, 但是我实在是受不了
C++的语法, 包括但不限于模板、迭代器，STL操作，感觉有点四不像的味道。
当然，这只是我的个人习惯，使用C++的人也是很多的，还是根据自己的习惯
选择一套趁手的工具比较好。</p><p>因为我其他时间基本都在用C，所以在本篇文章中我会更多拿C来进行比较，这样更好记忆。</p><p>我学习 Python 的知识点来源:</p><ol><li>《Python 学习手册 第 4 版》李军等</li><li>UCB CS61A</li></ol><h1 id=列表-list>列表 list</h1><p>列表支持下标索引，所以它就像C语言中的“数组”，列表支持大小动态增长，所以更像“数组plus”，类似C++中的vector吧（不太确定）。</p><p>列表支持定长声明或变长声明，像创建一些flag列表，用下标进行查找时，定长创建就是必要的。</p><h2 id=相关操作>相关操作</h2><h3 id=创建一个列表>创建一个列表</h3><p>以下的创建操作都是支持的:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 创建一个空列表</span>
</span></span><span class=line><span class=cl><span class=n>lst</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=c1># 创建一个带有初值的列表</span>
</span></span><span class=line><span class=cl><span class=n>lst</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=c1># 创建二维空列表</span>
</span></span><span class=line><span class=cl><span class=c1># 应用的场景是: 按照索引来修改list, 此时如果单纯的初始化list=[],</span>
</span></span><span class=line><span class=cl><span class=c1># 那么对list[1].append()会提示超出范围. 所以我们要提前规定list的长度,</span>
</span></span><span class=line><span class=cl><span class=c1># 即将list声明为目标长度的二维list.</span>
</span></span><span class=line><span class=cl><span class=n>lst</span> <span class=o>=</span> <span class=p>[[]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>5</span><span class=p>)]</span>
</span></span><span class=line><span class=cl><span class=c1># 创建定长列表并附初值</span>
</span></span><span class=line><span class=cl><span class=n>lst</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>5</span><span class=p>)]</span>
</span></span><span class=line><span class=cl><span class=c1># 创建二维定长列表并附处置0</span>
</span></span><span class=line><span class=cl><span class=n>lst</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>5</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>5</span><span class=p>)]</span>
</span></span></code></pre></div><p>以下的方式是错误的! 因为每个子列表都指向同一个对象, 修改一个会同步其他的</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>lst</span> <span class=o>=</span> <span class=p>[[]]</span> <span class=o>*</span> <span class=mi>5</span>
</span></span></code></pre></div><p>List 的高级构建方法，充分利用python的灵活性:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>odds</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>9</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=p>[</span><span class=n>x</span><span class=o>+</span><span class=mi>1</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>odds</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>10</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>odds</span> <span class=k>if</span> <span class=mi>25</span> <span class=o>%</span> <span class=n>x</span> <span class=o>==</span> <span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>5</span><span class=p>]</span>
</span></span></code></pre></div><h3 id=其他操作>其他操作</h3><ul><li>直接使用 <code>+</code>, <code>*</code>运算符实现多个列表的组合, 与字符串类似</li><li>append: 为列表增加一个对象(末尾)</li><li>pop(pos): 删除列表中的某个元素(按位置)，并返回其值</li><li>insert(pos, val): 在列表的任意位置插入对象</li><li>remove: 删除列表中的某个元素(按内容)</li><li>多级列表是被支持的，像二维数组一样，但是操作比较复杂，一般不使用内置的列表来实现。</li><li>&mldr;</li></ul><h1 id=python-内置类型>Python 内置类型</h1><p>实例的类型可以通过内置函数<code>type()</code>来查看。</p><h2 id=字符串>字符串</h2><p>定义一个 python 字符串</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>S</span> <span class=o>=</span> <span class=s1>&#39;Spam&#39;</span>
</span></span></code></pre></div><p>支持索引其中元素，也支持<strong>反向索引</strong>（即从右边开始计算），一般来说负的索引号会简单地与字符串的长度相加。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>S</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=s1>&#39;S&#39;</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>S</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=s1>&#39;m&#39;</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>S</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=n>S</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=s1>&#39;m&#39;</span>
</span></span></code></pre></div><p>python 也支持字符串分片操作，左边界的默认值为 0，右边界的默认值为字符串的长度。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>S</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl><span class=s1>&#39;pam&#39;</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>S</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=s1>&#39;Spa&#39;</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>S</span><span class=p>[:</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=s1>&#39;Spa&#39;</span>
</span></span></code></pre></div><p>字符串对于<code>+</code>操作符的表现是字符串的连接，这体现了 python 的多态性。
字符串创建后无法直接通过索引改变其元素，可以转而通过同名对象覆盖来实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>S</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=s1>&#39;z&#39;</span>
</span></span><span class=line><span class=cl><span class=n>Traceback</span> <span class=p>(</span><span class=n>most</span> <span class=n>recent</span> <span class=n>call</span> <span class=n>last</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=n>File</span> <span class=s2>&#34;&lt;stdin&gt;&#34;</span><span class=p>,</span> <span class=n>line</span> <span class=mi>1</span><span class=p>,</span> <span class=ow>in</span> <span class=o>&lt;</span><span class=n>module</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=ne>TypeError</span><span class=p>:</span> <span class=s1>&#39;str&#39;</span> <span class=nb>object</span> <span class=n>does</span> <span class=ow>not</span> <span class=n>support</span> <span class=n>item</span> <span class=n>assignment</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>S</span> <span class=o>=</span> <span class=s1>&#39;z&#39;</span> <span class=o>+</span> <span class=n>S</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>S</span>
</span></span><span class=line><span class=cl><span class=s1>&#39;zpam&#39;</span>
</span></span></code></pre></div><p>字符串支持的属性，例如<code>.find()</code>可以通过内置命令 <code>dir(S)</code>来查看。</p><blockquote><p>dir 函数仅仅给出了方法的名称，如果想查询其具体使用方法，可以利用内置函数<code>help(S.find)</code>。</p></blockquote><h3 id=string-的三种形式>string 的三种形式</h3><p>Python 允许字符串被包括在单引号或者双引号中(<strong>它们的含义相同</strong>），它也允许在三个引号（单或双均可）中包含<strong>多行</strong>字符串常量，当 Python 脚本中嵌入像 HTML 这样的内容时，这是很方便的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>msg</span> <span class=o>=</span> <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>... aaaaa
</span></span></span><span class=line><span class=cl><span class=s2>... bbbbb
</span></span></span><span class=line><span class=cl><span class=s2>... ccccc
</span></span></span><span class=line><span class=cl><span class=s2>... &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>msg</span>
</span></span><span class=line><span class=cl><span class=s1>&#39;</span><span class=se>\n</span><span class=s1>aaaaa</span><span class=se>\n</span><span class=s1>bbbbb</span><span class=se>\n</span><span class=s1>ccccc</span><span class=se>\n</span><span class=s1>&#39;</span>
</span></span></code></pre></div><h2 id=字典>字典</h2><p>键值对</p><p>支持通过 key 索引来修改， 所以与字符串和列表不同。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>D</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>D</span><span class=p>[</span><span class=s1>&#39;name&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=s1>&#39;Bob&#39;</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>D</span><span class=p>[</span><span class=s1>&#39;age&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=mi>40</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>D</span>
</span></span><span class=line><span class=cl><span class=p>{</span><span class=s1>&#39;name&#39;</span><span class=p>:</span> <span class=s1>&#39;Bob&#39;</span><span class=p>,</span> <span class=s1>&#39;age&#39;</span><span class=p>:</span> <span class=mi>40</span><span class=p>}</span>
</span></span></code></pre></div><p>字典也支持嵌套操作，在 json 中常用</p><h3 id=字典的操作>字典的操作</h3><ul><li>keys() 返回 key 的列表</li><li>value() 返回 value 的列表</li><li>item(): 返回<code>(key,value)</code>构成的元组列表</li></ul><h3 id=字典的限制>字典的限制</h3><ul><li>在<em>python3.6</em>之前字典是 unordered, 即存储的顺序不按照加入时间; 而在<em>python3.6+</em>,
字典改为 ordered.</li><li>key 是唯一的, 如果你想让一个 key 对应多个值, 将其 value 设置为 list 是一种方案!</li><li>list 只能是 value, 不能是 key</li></ul><h3 id=元组>元组</h3><p>元祖像一个<strong>不可改变</strong>的列表</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>T</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>T</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
</span></span></code></pre></div><p>其专有的方法：</p><ul><li>index(x) 返回 x 所在元组中的下标</li><li>count(x) 计算 x 在元组中出现的次数</li></ul><blockquote><p>为什么要使用元组？
一般来说，元组不如列表那样常用，因为它的不可被改变的特性。但是，这也赋予了元组天然的完整性约束，可应用在期望不会被改变的场景中</p></blockquote><h1 id=基础语法>基础语法</h1><h2 id=iterator>iterator</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>l</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>k</span> <span class=o>=</span> <span class=nb>iter</span><span class=p>(</span><span class=n>l</span><span class=p>)</span>  <span class=c1># 得到一个可以遍历的iterator</span>
</span></span><span class=line><span class=cl><span class=nb>next</span><span class=p>(</span><span class=n>k</span><span class=p>)</span>      <span class=c1># get 1</span>
</span></span><span class=line><span class=cl><span class=nb>next</span><span class=p>(</span><span class=n>k</span><span class=p>)</span>      <span class=c1># get 2</span>
</span></span></code></pre></div><p>iterator 任何情况下都可以等价于一个 for 循环!</p><p>list 的 iterator 像是一个 list, 不同的是它存在一个"监视者"会记录你当前所在的位置, 使得你可以调用一些方法(<code>next()</code>)
来得到当前位置的元素, 并监视下一个位置的元素.</p><p>当然, 不仅仅 list 有对应的 iterator, 对于其他数据结构来说亦是如此.</p><blockquote><p>如果在遍历<code>k</code>的途中改变了遍历对象的结构(例如<code>lst.append(4)</code>), 该 iterator 将不可再用!</p><p>所以以下代码的行为是错误的:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>lst</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>item</span> <span class=ow>in</span> <span class=n>lst</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=n>item</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>lst</span><span class=o>.</span><span class=n>remove</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></div><p>可以专门创建一个 <code>lst</code> 的副本用于循环:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=k>for</span> <span class=n>item</span> <span class=ow>in</span> <span class=nb>list</span><span class=p>(</span><span class=n>lst</span><span class=p>):</span>
</span></span><span class=line><span class=cl> <span class=o>...</span>
</span></span></code></pre></div><p>但修改其中的值不影响(例如<code>lst[0] = 0</code>)</p></blockquote><p>另一个有趣的事情是: 如果使用<code>list()</code>方法创建一个 iterator 的 list, python 实际的行为是
<strong>调用<code>next()</code>直到结尾来得到元素并插入新的 list</strong>. 所以下面的代码行为就容易理解了:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>t</span> <span class=o>=</span> <span class=nb>iter</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=nb>list</span><span class=p>(</span><span class=n>t</span><span class=p>)</span>  <span class=c1># [1, 2, 3]</span>
</span></span><span class=line><span class=cl><span class=nb>list</span><span class=p>(</span><span class=n>t</span><span class=p>)</span>  <span class=c1># []</span>
</span></span></code></pre></div><h1 id=python-内置功能函数>Python 内置功能函数</h1><h2 id=聚合可索引的类型>聚合可索引的类型</h2><p>一些内置的功能函数可以将<strong>可索引的</strong>参数转换为有意义的<strong>数值</strong>. 例如 range, list 等.</p><h3 id=sumiterable-start>sum(iterable[, start])</h3><p>返回可索引的参数元素之和(不能是字符串), 加上 start(默认是 0). 当 <code>iterable</code> 为空时, 返回 <code>start</code></p><blockquote><p>为什么要有一个<code>start</code>?
使得如果输入字符串组成的列表(可以是其他可索引的数据结构), 会抛出异常. 详见下面实例</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=nb>sum</span><span class=p>([</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=mi>9</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=nb>sum</span><span class=p>([</span><span class=s1>&#39;2&#39;</span><span class=p>,</span> <span class=s1>&#39;3&#39;</span><span class=p>,</span> <span class=s1>&#39;4&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>Traceback</span> <span class=p>(</span><span class=n>most</span> <span class=n>recent</span> <span class=n>call</span> <span class=n>last</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=n>File</span> <span class=s2>&#34;&lt;stdin&gt;&#34;</span><span class=p>,</span> <span class=n>line</span> <span class=mi>1</span><span class=p>,</span> <span class=ow>in</span> <span class=o>&lt;</span><span class=n>module</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=ne>TypeError</span><span class=p>:</span> <span class=n>unsupported</span> <span class=n>operand</span> <span class=nb>type</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=k>for</span> <span class=o>+</span><span class=p>:</span> <span class=s1>&#39;int&#39;</span> <span class=ow>and</span> <span class=s1>&#39;str&#39;</span>
</span></span></code></pre></div><p>其实现的原理是: 保证前面<code>iterable</code>中元素求和的结果与<code>start</code>的类型相同. 例如:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=nb>sum</span><span class=p>([</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>],</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=mi>14</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=nb>sum</span><span class=p>([[</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>],</span> <span class=p>[</span><span class=mi>4</span><span class=p>]],</span> <span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=nb>sum</span><span class=p>([[</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>],</span> <span class=p>[</span><span class=mi>4</span><span class=p>]])</span>
</span></span><span class=line><span class=cl><span class=n>Traceback</span> <span class=p>(</span><span class=n>most</span> <span class=n>recent</span> <span class=n>call</span> <span class=n>last</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=n>File</span> <span class=s2>&#34;&lt;stdin&gt;&#34;</span><span class=p>,</span> <span class=n>line</span> <span class=mi>1</span><span class=p>,</span> <span class=ow>in</span> <span class=o>&lt;</span><span class=n>module</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=ne>TypeError</span><span class=p>:</span> <span class=n>unsupported</span> <span class=n>operand</span> <span class=nb>type</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=k>for</span> <span class=o>+</span><span class=p>:</span> <span class=s1>&#39;int&#39;</span> <span class=ow>and</span> <span class=s1>&#39;list&#39;</span>
</span></span></code></pre></div><h3 id=max>max</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nb>max</span><span class=p>(</span><span class=n>iterable</span><span class=p>[,</span> <span class=n>key</span><span class=o>=</span><span class=n>func</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=n>value</span>
</span></span><span class=line><span class=cl><span class=nb>max</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>,</span> <span class=o>...</span><span class=p>[,</span><span class=n>key</span><span class=o>=</span><span class=n>func</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=n>value</span>
</span></span></code></pre></div><p><code>key</code>是用来预处理数据的, 默认为 <code>lambda x: x</code></p><h1 id=其他特性>其他特性</h1><h2 id=nonlocal声明><code>nonlocal</code>声明</h2><p>使用方法:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=k>nonlocal</span> <span class=o>&lt;</span><span class=n>name</span><span class=o>&gt;</span>
</span></span></code></pre></div><p>效果: 在声明某个变量为<code>nonlocal</code>之后, 对其所有赋值语句, 都不会建立一个局部的绑定, 而是将该变量重新绑定到<strong>当前 frame 向上能找到的第一个非局部 frame</strong>中对该变量的绑定.</p><p>简单来说, 就是对该变量的所有赋值操作都改为操作能找到的第一个全局(这个全局是相对的)同名变量. 当然, 如果找不到一个同名全局变量, 就抛出异常.</p><p>下面的例子中, 如果在<code>withdrew()</code>中不将<code>balance</code>声明为 nonlocal:</p><ul><li>if 语句是可以通过的, 因为<strong>访问</strong><code>balance</code>会找到当前 frame 的 parent,
即<code>make_withdraw()</code>中声明的<code>balance</code>.</li><li>而 python 处理<strong>赋值</strong>操作就不一样了. 他会默认将<code>balance</code>绑定到局部, 而
这就与 if 语句产生了冲突, 会抛出异常.</li></ul><p>所以就需要<code>nonlocal</code>的声明, 告诉 python: <strong>赋值语句也得去上面 frame 中找一个全局的.</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=c1># make_withdraw 建立一个银行账户, 并给出初始金额,</span>
</span></span><span class=line><span class=cl><span class=c1># 其返回一个函数withdrew(), 调用该函数的行为是从</span>
</span></span><span class=line><span class=cl><span class=c1># 银行账户里扣款</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>make_withdraw</span><span class=p>(</span><span class=n>balance</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>withdraw</span><span class=p>(</span><span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>nonlocal</span> <span class=n>balance</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>amount</span> <span class=o>&gt;</span> <span class=n>balance</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=s1>&#39;Insufficient funds&#39;</span>
</span></span><span class=line><span class=cl>        <span class=n>balance</span> <span class=o>=</span> <span class=n>balance</span> <span class=o>-</span> <span class=n>amount</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>balance</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>withdraw</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>wd</span> <span class=o>=</span> <span class=n>make_withdraw</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>wd</span><span class=p>(</span><span class=mi>8</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=python-动态类型>Python 动态类型</h2><h3 id=对象的垃圾回收>对象的垃圾回收</h3><p>在 Python 中，每当一个变量被赋予了一个新的对象，之前对象占用的空间就会被回收。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>42</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=mf>3.14</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=s2>&#34;hello&#34;</span>
</span></span></code></pre></div><p>对象的引用值在此过程中被逐个回收，每次 x 指向一个新的对象，Python 将自动回收原来对象的内存空间。</p><p>Python 使用<strong>引用计数</strong>来实现该功能。为每个对象维护了一个引用计数器，记录了当前引用该对象的变量数目，一旦计数值变成 0，则其空间被回收。</p><h3 id=深拷贝和浅拷贝>深拷贝和浅拷贝</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>L1</span> <span class=o>=</span> <span class=p>[</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>L2</span> <span class=o>=</span> <span class=n>L1</span>
</span></span></code></pre></div><p>产生的结果是， L1 是一个包含了对象 2、3、4 的列表，当然列表自身也是个对象。L1 是一个变量，引用了该列表的对象。运行 L2 的赋值操作后，L1 和 L2 引用了相同的对象。</p><p><strong>此时如果使用索引对 L1 列表的某个元素进行修改，由于 L1 和 L2 引用的是同一个对象，相当于 L2 也做了修改</strong>。这就是浅拷贝</p><p>浅拷贝是默认的，如果你希望使用深拷贝，即拷贝对象，而不是创建索引。对于列表来说，可以使用分片来实现</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>L1</span> <span class=o>=</span> <span class=p>[</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>L2</span> <span class=o>=</span> <span class=n>L1</span><span class=p>[:]</span>
</span></span></code></pre></div><p>对于其他的内置类型，有的也可以用 X.copy()方法；而且标准库的<code>copy</code>模块有一个通用的赋值任意对象类型的方法，也有一个用于<strong>嵌套深拷贝</strong>的特殊方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=kn>import</span> <span class=nn>copy</span>
</span></span><span class=line><span class=cl><span class=n>X</span> <span class=o>=</span> <span class=n>copy</span><span class=o>.</span><span class=n>copy</span><span class=p>(</span><span class=n>Y</span><span class=p>)</span>    <span class=c1># 只深拷贝top-level</span>
</span></span><span class=line><span class=cl><span class=n>X</span> <span class=o>=</span> <span class=n>copy</span><span class=o>.</span><span class=n>deepcopy</span><span class=p>(</span><span class=n>Y</span><span class=p>)</span> <span class=c1># 嵌套进行深拷贝</span>
</span></span></code></pre></div><h3 id=判断相等>判断相等</h3><p>基于上述深拷贝和浅拷贝的理论，就有关于 Python 中变量判断相等的方法。
Python 中有两种不同的方法检查变量是否相等：</p><ul><li><code>==</code> 操作符：测试两个变量引用的对象是否具有相同的值</li><li><code>is</code>操作符：检查对象的同一性，即是否指向<strong>同一个对象</strong>，是一种更加严格的相等性判断</li></ul><h2 id=字符串-1>字符串</h2><h3 id=特殊字符的转义>特殊字符的转义</h3><p>字符串中的<code>\n</code>会被识别为换行符，与 C 语言类似，但 Python 不识别结束符(<code>\0</code>)</p><p>在字符串第一个引号之前输入<code>r</code>，会关闭转义机制，将反斜杠当做普通字符来保持。常用与 Windows 环境中打开文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>file</span> <span class=o>=</span> <span class=nb>open</span><span class=p>(</span><span class=sa>r</span><span class=s1>&#39;C:\my\path\file.txt&#39;</span><span class=p>,</span> <span class=s1>&#39;w&#39;</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=索引和分片>索引和分片</h3><p>分片的常见作用</p><h4 id=处理参数>处理参数</h4><p>在系统命令行中启动 python 程序时，获取附加的参数，需要使用内置的 sys 模块中的 argv 属性：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=c1># file echo.py</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>sys</span><span class=o>.</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>%</span> <span class=n>python</span> <span class=n>echo</span><span class=o>.</span><span class=n>py</span> <span class=o>-</span><span class=n>a</span> <span class=o>-</span><span class=n>b</span> <span class=o>-</span><span class=n>c</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=s1>&#39;echo.py&#39;</span><span class=p>,</span> <span class=s1>&#39;-a&#39;</span><span class=p>,</span> <span class=s1>&#39;-b&#39;</span><span class=p>,</span> <span class=s1>&#39;-c&#39;</span><span class=p>]</span>
</span></span></code></pre></div><p>通常你只对跟随在程序名后边的参数感兴趣，这就是分片的典型应用，<code>sys.argv[1:]</code>就能满足你</p><h4 id=处理文件>处理文件</h4><p>分片也常常用作清理输入文件的内容。如果知道一行会以换行符结尾，就可以使用<code>line[:-1]</code>，把这行去除最后一个字符之外的内容提取出来。</p><blockquote><p>值得注意的是，去除换行符常常推荐采用<code>line.rstrip</code>方法，因为这个方法将会正确的处理<strong>最后一行</strong>的情况。</p></blockquote><h3 id=字符串和其他类型转换>字符串和其他类型转换</h3><p>字符串和整数</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=nb>int</span><span class=p>(</span><span class=s2>&#34;42&#34;</span><span class=p>),</span> <span class=nb>str</span><span class=p>(</span><span class=mi>42</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=mi>42</span><span class=p>,</span> <span class=s1>&#39;42&#39;</span><span class=p>)</span>
</span></span></code></pre></div><p>字符和 ASCII 码</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=nb>ord</span><span class=p>(</span><span class=s1>&#39;s&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=mi>115</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=nb>chr</span><span class=p>(</span><span class=mi>115</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=s1>&#39;s&#39;</span>
</span></span></code></pre></div><h3 id=修改字符串>修改字符串</h3><p>字符串是<em>不可变序列</em>，即不能通过索引来修改。</p><p>若想改变一个字符串，需要利用合并、分片这样的工具来建立一个新的字符串，并将结果赋值给原始字符串变量</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>S</span> <span class=o>=</span> <span class=n>S</span><span class=p>[:</span><span class=mi>4</span><span class=p>]</span> <span class=o>+</span> <span class=s1>&#39;Bureger&#39;</span>
</span></span></code></pre></div><p>如果不得不对一个超长字符串进行多处的修改，为了优化脚本的性能和代码，可能需要将字符串转换为一个支持原处修改的对象，如 List</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>S</span> <span class=o>=</span> <span class=s1>&#39;spammy&#39;</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>L</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>S</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>L</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=s1>&#39;s&#39;</span><span class=p>,</span> <span class=s1>&#39;p&#39;</span><span class=p>,</span> <span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=s1>&#39;m&#39;</span><span class=p>,</span> <span class=s1>&#39;m&#39;</span><span class=p>,</span> <span class=s1>&#39;y&#39;</span><span class=p>]</span>
</span></span></code></pre></div><p>对于 L 可以使用索引来修改，完成后需要将其转换回字符串，可以使用字符串的<code>join</code>方法来实现:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>S</span> <span class=o>=</span> <span class=s1>&#39;&#39;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>L</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=python-中的-sprintf>Python 中的 sprintf</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=s1>&#39;That is </span><span class=si>%d</span><span class=s1> </span><span class=si>%s</span><span class=s1> bird!&#39;</span> <span class=o>%</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=s1>&#39;dead&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>That</span> <span class=ow>is</span> <span class=mi>1</span> <span class=n>dead</span> <span class=n>bird</span>
</span></span></code></pre></div><h3 id=字符串的方法>字符串的方法</h3><p>see Python standard manual</p><h2 id=列表>列表</h2><p>列表与字典都是<strong>其他对象的集合</strong>。</p><p>列表能够完成 C 中结构体的工作，不需要手动实现。</p><p>Python 中的列表是：</p><ul><li>任意对象的有序集合</li><li>通过偏移读取</li><li>可变长度、异构以及任意嵌套</li><li>对象引用的数组。类似与 C 语言中的指针数组</li></ul><h3 id=列表实现-lifo>列表实现 LIFO</h3><p>在某些应用中，会使用列表的<code>pop</code>和<code>append</code>方法，实现快速的 LIFO 对战结构。</p><h2 id=字典-1>字典</h2><p>字典可以称作 Python 中最灵活的内置数据结构。字典当中的元素是通过 key 来存取，而不是通过偏移，类似 C++的 map。</p><p>作为内置类型，字典可以取代许多搜索算法和数据结构。有时也能执行其他语言中的记录、符号表的功能，可以表示稀疏（多数为空）的数据结构等。</p><p>字典的主要属性如下：</p><ul><li>任意对象的无序集合</li><li>可变长、异构、任意嵌套</li><li>对象引用的散列表。字典的底层实现是散列表，一开始很小，根据要求增长。</li></ul><blockquote><p>列表和字典，不会经常用常量来创建，常使用动态方法</p></blockquote><h3 id=用字典模拟灵活的列表>用字典模拟灵活的列表</h3><p>列表对在其末尾外的元素赋值是非法的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>L</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>L</span><span class=p>[</span><span class=mi>99</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=n>Traceback</span> <span class=p>(</span><span class=n>most</span> <span class=n>recent</span> <span class=n>call</span> <span class=n>last</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=n>File</span> <span class=s2>&#34;&lt;stdin&gt;&#34;</span><span class=p>,</span> <span class=n>line</span> <span class=mi>1</span><span class=p>,</span> <span class=ow>in</span> <span class=o>&lt;</span><span class=n>module</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=ne>IndexError</span><span class=p>:</span> <span class=nb>list</span> <span class=n>assignment</span> <span class=n>index</span> <span class=n>out</span> <span class=n>of</span> <span class=nb>range</span>
</span></span></code></pre></div><p>虽然你可以预先分配足够的大空间，但这种情况用字典更为方便。字典的 key 为整数时，可以效仿列表在偏移赋值时增长：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>D</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>D</span><span class=p>[</span><span class=mi>99</span><span class=p>]</span> <span class=o>=</span> <span class=s1>&#39;spam&#39;</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>D</span><span class=p>[</span><span class=mi>99</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=s1>&#39;spam&#39;</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>D</span>
</span></span><span class=line><span class=cl><span class=p>{</span><span class=mi>99</span><span class=p>:</span> <span class=s1>&#39;spam&#39;</span><span class=p>}</span>
</span></span></code></pre></div><p>好处是， 此时的 D 仅有一个元素，看上去好像是有 100 个元素。</p><h3 id=字典描述稀疏数据结构>字典描述稀疏数据结构</h3><h3 id=字典创建的方法>字典创建的方法</h3><p>共有四种不同的方案：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=p>{</span><span class=s1>&#39;name&#39;</span><span class=p>:</span> <span class=s1>&#39;mel&#39;</span><span class=p>,</span> <span class=s1>&#39;age&#39;</span><span class=p>:</span> <span class=mi>45</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>D</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=n>D</span><span class=p>[</span><span class=s1>&#39;name&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=s1>&#39;mel&#39;</span>
</span></span><span class=line><span class=cl><span class=n>D</span><span class=p>[</span><span class=s1>&#39;age&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=mi>45</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>dict</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s1>&#39;mel&#39;</span><span class=p>,</span> <span class=n>age</span><span class=o>=</span><span class=mi>45</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>dict</span><span class=p>([(</span><span class=s1>&#39;name&#39;</span><span class=p>,</span> <span class=s1>&#39;mel&#39;</span><span class=p>),</span> <span class=p>(</span><span class=s1>&#39;age&#39;</span><span class=p>,</span> <span class=mi>45</span><span class=p>)])</span>
</span></span></code></pre></div><p>上面四种方案建立的字典是相同的，它们分别应用与不同的条件：</p><ul><li>如果你可以事先拼出整个字典，那么第一种是很方便的</li><li>如果你需要一次动态地建立字典的一个字段，第二种比较合适</li><li>第三种关键字形式所需代码量比较少，但是 key 必须都是字符串才行</li><li>如果你需要在程序运行时把 key 和 value 逐步构建成序列，那么用第四种</li></ul><p>如今的 Python 代码中，第三种方式比较流行。</p></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2023-04-01T10:30:35, Lastmod: 2023-09-24T18:08:59</p><script src=/js/copy-to-clipboard.js></script></main></div></body></html>