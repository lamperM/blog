<!doctype html><html><head><title>面试总结：特斯拉实习</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=description content><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><link rel=stylesheet href=/scss/journal.min.ea0f3d3af5cc437a42b1ad2f9b5ebeeaf367c8f8fc3004c55b78f4f503cea3a2.css integrity="sha256-6g89OvXMQ3pCsa0vm16+6vNnyPj8MATFW3j09QPOo6I=" media=screen><link rel=stylesheet href=/scss/dark-mode.min.2509d1ab7a8b17f2ca6b95285afc4f5ef50f8699b8114c954f01351654b5ceba.css integrity="sha256-JQnRq3qLF/LKa5UoWvxPXvUPhpm4EUyVTwE1FlS1zro=" media=screen><script src=/vendor/js/loadCSS.js></script>
<script>loadCSS("https://fonts.googleapis.com/css?family=Fira+Mono|Material+Icons")</script><script src=/js/toc.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script>
<script src=/vendor/js/md5.min.js></script>
<script>var gitalk=new Gitalk({clientID:"12dfb0f809e5e6afde3d",clientSecret:"72aaf5660b3a7b43b0bffb4d683a605a7ea65dad",repo:"blogcomments_gitalk",owner:"wangloo",admin:["wangloo"],id:md5(location.pathname),distractionFreeMode:"false"});window.onload=function(){gitalk.render("gitalk-container")}</script></head><body><div id=app><div id=sideContainer class=side-container><a class="a-block nav-head false" href=https://wangloo.github.io/><div class=nav-title>Wangloo's BLOG</div><div class=nav-subtitle>花有重开日, 人无再少年</div></a><div class=nav-link-list><a class="a-block nav-link-item active" href=/posts>Archive</a>
<a class="a-block nav-link-item false" href=/tags>Tags</a>
<a class="a-block nav-link-item false" href=/categories>Categories</a></div><div class=nav-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://risehere.net/>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
@2019 Notepadium.</div></div><div id=extraContainer class=extra-container><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc-content><center>- CATALOG -</center><ul><li><a href=#%e4%ba%8c%e9%9d%a2 onclick="onNavClick(`#二面-nav`)" id=二面-nav>二面</a></li><ul><li><a href=#elf-%e6%96%87%e4%bb%b6%e7%9a%84%e5%8a%a0%e8%bd%bd%e6%b5%81%e7%a8%8b onclick="onNavClick(`#elf-文件的加载流程-nav`)" id=elf-文件的加载流程-nav>ELF 文件的加载流程</a></li><li><a href=#%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e5%ad%98%e5%9c%a8%e5%93%aa%e8%b0%81%e8%b4%9f%e8%b4%a3%e5%88%9d%e5%a7%8b%e5%8c%96%e7%9a%84 onclick="onNavClick(`#全局变量存在哪谁负责初始化的-nav`)" id=全局变量存在哪谁负责初始化的-nav>全局变量存在哪？谁负责初始化的</a></li><li><a href=#aligned_alloc%e8%ae%be%e8%ae%a1 onclick="onNavClick(`#aligned_alloc设计-nav`)" id=aligned_alloc设计-nav>aligned_alloc()设计</a></li><ul><li><a href=#%e5%8e%9f%e9%97%ae%e9%a2%98 onclick="onNavClick(`#原问题-nav`)" id=原问题-nav>原问题</a></li><li><a href=#%e6%80%9d%e8%b7%af%e5%8f%8a%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88 onclick="onNavClick(`#思路及解决方案-nav`)" id=思路及解决方案-nav>思路及解决方案</a></li></ul></div></div><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a>
<a type=button class=pagination-action id=darkModeToggleButton><span class="material-icons pagination-action-icon" id=darkModeToggleIcon>dark_mode</span></a></div></div><div class=single-column-drawer-container id=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item active" href=/posts>Archive</a>
<a class="a-block drawer-menu-item false" href=/tags>Tags</a>
<a class="a-block drawer-menu-item false" href=/categories>Categories</a><div class=toc><div class=toc-content><center>- CATALOG -</center><ul><li><a href=#%e4%ba%8c%e9%9d%a2 onclick="onNavClick(`#二面-nav`)" id=二面-nav>二面</a></li><ul><li><a href=#elf-%e6%96%87%e4%bb%b6%e7%9a%84%e5%8a%a0%e8%bd%bd%e6%b5%81%e7%a8%8b onclick="onNavClick(`#elf-文件的加载流程-nav`)" id=elf-文件的加载流程-nav>ELF 文件的加载流程</a></li><li><a href=#%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e5%ad%98%e5%9c%a8%e5%93%aa%e8%b0%81%e8%b4%9f%e8%b4%a3%e5%88%9d%e5%a7%8b%e5%8c%96%e7%9a%84 onclick="onNavClick(`#全局变量存在哪谁负责初始化的-nav`)" id=全局变量存在哪谁负责初始化的-nav>全局变量存在哪？谁负责初始化的</a></li><li><a href=#aligned_alloc%e8%ae%be%e8%ae%a1 onclick="onNavClick(`#aligned_alloc设计-nav`)" id=aligned_alloc设计-nav>aligned_alloc()设计</a></li><ul><li><a href=#%e5%8e%9f%e9%97%ae%e9%a2%98 onclick="onNavClick(`#原问题-nav`)" id=原问题-nav>原问题</a></li><li><a href=#%e6%80%9d%e8%b7%af%e5%8f%8a%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88 onclick="onNavClick(`#思路及解决方案-nav`)" id=思路及解决方案-nav>思路及解决方案</a></li></ul></div></div></div></div></div><transition name=fade><div id=drawer-mask v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav id=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div id=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu</i></button>
<a id=navTitle class=navbar-brand href=https://wangloo.github.io/>Wangloo's BLOG</a>
<button type=button class=nav-darkmode-toggle id=darkModeToggleButton2>
<i class=material-icons id=darkModeToggleIcon2>dark_mode</i></button></div></nav><div class=single-column-header-container id=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=https://wangloo.github.io/><div class=single-column-header-title>Wangloo's BLOG</div><div class=single-column-header-subtitle>花有重开日, 人无再少年</div></a></div><div id=content><div id=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only><div class=post-title>面试总结：特斯拉实习<div class=post-meta><time itemprop=datePublished>2023-06-10 08:51</time>
<i class=material-icons>label</i>
<a href=/tags/work>work</a>
&nbsp;
<i class=material-icons>schedule</i>
6 min
56 s.</div></div></div><div class=post-body-wrapper><div class=post-body v-pre><p>上午结束了特斯拉<em>嵌入式实习生-Linux platform</em>的二面，特斯拉实习生
一共有三轮面试，一轮和二轮都是技术面，三面是主管面。
目前我完成了所有的技术面，且不论结果如何，整个面试过程对我而言还是收获颇丰的，
故以此文整理下自己的欠缺的技术知识，希望下次能够表现的更好。</p><h1 id=二面>二面</h1><p>首先，此轮面试的面试官显然比上一轮更有礼貌一些，准时与会+介绍自己，不过有一点
是我开了摄像头他没开，也没有进行说明吧。 不过这些都是小事，我们这次主要谈论
技术的内容。</p><p>我在此回顾几个没有回答好的问题，供以后做参考。</p><h2 id=elf-文件的加载流程>ELF 文件的加载流程</h2><blockquote><p>原回答</p><ol><li>拿到 ELF 存储的地址后，先将头部读出来，长度是固定的。头部有校验字段，
maigic number, 然后是确认 ELF 编译的架构，位数是否正确。</li><li>确认格式正确后，读取程序头表，其中保存了各个需要加载的段的偏移，根据
base+段偏移能够得到该段的位置，然后根据段属性的不同，选择映射到不同
的区域和属性，例如 text 段映射为 RE, 代码段映射为 RW，清空 BSS 等</li><li>说明自己没接触过动态库文件，所以对动态加载不是很熟悉</li></ol></blockquote><p>点评如下: 对段表、程序头表，这些概念的区分还不是很熟，不清楚什么时候用
section table， 什么时候用 program header table. 以前都看过，只是
时间长了不用就忘记了，这一部分需要好好的做下笔记。</p><h2 id=全局变量存在哪谁负责初始化的>全局变量存在哪？谁负责初始化的</h2><blockquote><p>原回答</p><p>不知道。</p></blockquote><p>全局保量存在的位置：</p><ul><li>未初始化的全局变量 ==> bss段</li><li>const修饰的全局变量 ==> rodata段</li><li>其他已初始化的全局变量 ==> data段</li></ul><p>对于已初始化的全局变量的访问，编译时，编译器将值存入data段，访问的指令是通过
相对寻址来做，例如相对于data段开头。对于静态链接来说，编译完成后访问指令的
基地址和偏移都是空，当链接时修改指令，即重定位的过程。</p><h2 id=aligned_alloc设计>aligned_alloc()设计</h2><p>这是面试最后的程序设计题，我也是没有做好，后面好歹在面试官的无数次提示中，
写出了一个解，题目很棒，只是自己实习不够，怪不得其他。</p><h3 id=原问题>原问题</h3><p>对<code>malloc()</code>和<code>free()</code>进行封装，设计一个返回满足任意字节对齐要求的
<code>align_alloc()</code>和<code>align_free()</code>函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span><span style=color:#50fa7b>align_alloc</span>(size_t size, size_t align);
</span></span><span style=display:flex><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>align_free</span>(<span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>addr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>main</span>(<span style=color:#8be9fd>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  size_t alignment[<span style=color:#bd93f9>6</span>] <span style=color:#ff79c6>=</span> {<span style=color:#bd93f9>5</span>, <span style=color:#bd93f9>8</span>, <span style=color:#bd93f9>32</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>128</span>, <span style=color:#bd93f9>12</span>};
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>int</span> i;
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>char</span> <span style=color:#ff79c6>*</span>p;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>for</span> (i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; i <span style=color:#ff79c6>&lt;</span> <span style=color:#bd93f9>6</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>    p <span style=color:#ff79c6>=</span> align_alloc(<span style=color:#bd93f9>10</span>, alignment[i]);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> ((<span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>long</span>)p <span style=color:#ff79c6>%</span> alignment[i]) {
</span></span><span style=display:flex><span>      printf(<span style=color:#f1fa8c>&#34;FAILED!, alignment: %ld, addr: %p</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>,
</span></span><span style=display:flex><span>          alignment[i], p);
</span></span><span style=display:flex><span>      exit(<span style=color:#bd93f9>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    memset(p, <span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>10</span>);
</span></span><span style=display:flex><span>    align_free(p);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  printf(<span style=color:#f1fa8c>&#34;PASS</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=思路及解决方案>思路及解决方案</h3><p>思路也写在代码里了，就是思路比较难想，代码倒是不难写。</p><p>PS: 丢人的是，我在一开始居然还提了: <code>malloc()</code>返回的地址能够保证是参数<code>size</code>对齐的，
真是令人耻笑啊！！</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;stdio.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;string.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;stdlib.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span><span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span><span style=color:#50fa7b>align_alloc</span>(size_t size, size_t align);
</span></span><span style=display:flex><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>align_free</span>(<span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>addr);
</span></span><span style=display:flex><span><span style=color:#6272a4>// 如何保证对齐到align?
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ==&gt; 申请更多空间, 返回对齐的地址
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// 不能保证malloc返回的地址是对齐到哪的，怎么确定多申请多大呢?
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ==&gt; 多申请align的空间，就能保证这align的地址范围里，总有
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     满足对齐条件的地址
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// 如何计算返回的地址? 比如malloc(10)=12, align=5, 此时我们会
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// 申请的空间为malloc(10+5), 即(12-27)都是可用的，我们需要
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// 经过计算后返回地址 15
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ==&gt; 计算的规则是(12+5)-(12+5)%5
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// aligned_free()只接受addr一个参数，如何释放malloc()申请的空间?
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ==&gt; 传入的addr是经过align之后的，确实需要一定的方法才能
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     求得malloc()返回的地址，这通过计算是无法得到的，因为
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     不知道这个地址的align是多少。所以可以想到在p_ret之前
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     再多借用一个地址的长度来存放malloc()返回的原地址。
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span><span style=color:#50fa7b>align_alloc</span>(size_t size, size_t align)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>p_malloc;
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>p_ret;
</span></span><span style=display:flex><span>  size_t aligned_size;
</span></span><span style=display:flex><span>  size_t ptr_size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  ptr_size <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>sizeof</span>(<span style=color:#8be9fd>char</span> <span style=color:#ff79c6>*</span>);
</span></span><span style=display:flex><span>  aligned_size <span style=color:#ff79c6>=</span> size <span style=color:#ff79c6>+</span> align <span style=color:#ff79c6>+</span> ptr_size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  p_malloc <span style=color:#ff79c6>=</span> malloc(aligned_size);
</span></span><span style=display:flex><span>  p_ret    <span style=color:#ff79c6>=</span> (p_malloc<span style=color:#ff79c6>+</span>ptr_size<span style=color:#ff79c6>+</span>align) <span style=color:#ff79c6>-</span>
</span></span><span style=display:flex><span>              ((<span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>long</span>)p_malloc<span style=color:#ff79c6>+</span>ptr_size<span style=color:#ff79c6>+</span>align) <span style=color:#ff79c6>%</span> align;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>*</span>((<span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>long</span> <span style=color:#ff79c6>*</span>)p_ret<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>) <span style=color:#ff79c6>=</span> (<span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>long</span>)p_malloc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// debug
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  printf(<span style=color:#f1fa8c>&#34;[ALLOC] p_malloc: %p, p_ret: %p, align: %ld</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>,
</span></span><span style=display:flex><span>      p_malloc, p_ret, align);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> p_ret;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>align_free</span>(<span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>addr)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>p_malloc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  p_malloc <span style=color:#ff79c6>=</span> (<span style=color:#8be9fd>void</span> <span style=color:#ff79c6>*</span>)(<span style=color:#ff79c6>*</span>((<span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>long</span> <span style=color:#ff79c6>*</span>)addr<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  printf(<span style=color:#f1fa8c>&#34;[ FREE] p_malloc: %p</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>, p_malloc);
</span></span><span style=display:flex><span>  free(p_malloc);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>main</span>(<span style=color:#8be9fd>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  size_t alignment[<span style=color:#bd93f9>6</span>] <span style=color:#ff79c6>=</span> {<span style=color:#bd93f9>5</span>, <span style=color:#bd93f9>8</span>, <span style=color:#bd93f9>32</span>, <span style=color:#bd93f9>64</span>, <span style=color:#bd93f9>128</span>, <span style=color:#bd93f9>12</span>};
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>int</span> i;
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>char</span> <span style=color:#ff79c6>*</span>p;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>for</span> (i <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>; i <span style=color:#ff79c6>&lt;</span> <span style=color:#bd93f9>6</span>; i<span style=color:#ff79c6>++</span>) {
</span></span><span style=display:flex><span>    p <span style=color:#ff79c6>=</span> align_alloc(<span style=color:#bd93f9>10</span>, alignment[i]);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> ((<span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>long</span>)p <span style=color:#ff79c6>%</span> alignment[i]) {
</span></span><span style=display:flex><span>      printf(<span style=color:#f1fa8c>&#34;FAILED!, alignment: %ld, addr: %p</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>,
</span></span><span style=display:flex><span>          alignment[i], p);
</span></span><span style=display:flex><span>      exit(<span style=color:#bd93f9>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    memset(p, <span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>10</span>);
</span></span><span style=display:flex><span>    align_free(p);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  printf(<span style=color:#f1fa8c>&#34;PASS</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr width=100% id=EOF><p style=color:#777>Last modified on 2023-07-18</p></div></div><nav class=post-pagination><a class=newer-posts href=/posts/tools/dev_env/>Next<br>我的开发环境构建指南</a>
<a class=older-posts href=/posts/os/linux/data_struct/hlist/>Previous<br>Linux 内核数据结构 hlist</a></nav><div class=post-comment-wrapper><div id=gitalk-container></div></div></div></div></div></div><div id=single-column-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://risehere.net/>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
@2019 Notepadium.</div></div><script src=/js/journal.js></script></body></html>