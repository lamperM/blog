<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>面试总结：特斯拉实习</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>所有文章</a></div><div class="a-block nav-link-item"><a href=/tags>Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput><ul id=searchResults></ul></div></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><h1>面试总结：特斯拉实习</h1></header><p>上午结束了特斯拉<em>嵌入式实习生-Linux platform</em>的二面，特斯拉实习生
一共有三轮面试，一轮和二轮都是技术面，三面是主管面。
目前我完成了所有的技术面，且不论结果如何，整个面试过程对我而言还是收获颇丰的，
故以此文整理下自己的欠缺的技术知识，希望下次能够表现的更好。</p><h1 id=二面>二面</h1><p>首先，此轮面试的面试官显然比上一轮更有礼貌一些，准时与会+介绍自己，不过有一点
是我开了摄像头他没开，也没有进行说明吧。 不过这些都是小事，我们这次主要谈论
技术的内容。</p><p>我在此回顾几个没有回答好的问题，供以后做参考。</p><h2 id=elf-文件的加载流程>ELF 文件的加载流程</h2><blockquote><p>原回答</p><ol><li>拿到 ELF 存储的地址后，先将头部读出来，长度是固定的。头部有校验字段，
maigic number, 然后是确认 ELF 编译的架构，位数是否正确。</li><li>确认格式正确后，读取程序头表，其中保存了各个需要加载的段的偏移，根据
base+段偏移能够得到该段的位置，然后根据段属性的不同，选择映射到不同
的区域和属性，例如 text 段映射为 RE, 代码段映射为 RW，清空 BSS 等</li><li>说明自己没接触过动态库文件，所以对动态加载不是很熟悉</li></ol></blockquote><p>点评如下: 对段表、程序头表，这些概念的区分还不是很熟，不清楚什么时候用
section table， 什么时候用 program header table. 以前都看过，只是
时间长了不用就忘记了，这一部分需要好好的做下笔记。</p><h2 id=全局变量存在哪谁负责初始化的>全局变量存在哪？谁负责初始化的</h2><blockquote><p>原回答</p><p>不知道。</p></blockquote><p>全局保量存在的位置：</p><ul><li>未初始化的全局变量 ==> bss段</li><li>const修饰的全局变量 ==> rodata段</li><li>其他已初始化的全局变量 ==> data段</li></ul><p>对于已初始化的全局变量的访问，编译时，编译器将值存入data段，访问的指令是通过
相对寻址来做，例如相对于data段开头。对于静态链接来说，编译完成后访问指令的
基地址和偏移都是空，当链接时修改指令，即重定位的过程。</p><h2 id=aligned_alloc设计>aligned_alloc()设计</h2><p>这是面试最后的程序设计题，我也是没有做好，后面好歹在面试官的无数次提示中，
写出了一个解，题目很棒，只是自己实习不够，怪不得其他。</p><h3 id=原问题>原问题</h3><p>对<code>malloc()</code>和<code>free()</code>进行封装，设计一个返回满足任意字节对齐要求的
<code>align_alloc()</code>和<code>align_free()</code>函数。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#2b91af>void</span> *align_alloc(size_t size, size_t align);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#2b91af>void</span> align_free(<span style=color:#2b91af>void</span> *addr);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span><span style=color:#2b91af>int</span> main(<span style=color:#2b91af>void</span>)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>  size_t alignment[6] = {5, 8, 32, 64, 128, 12};
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>  <span style=color:#2b91af>int</span> i;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>  <span style=color:#2b91af>char</span> *p;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>  <span style=color:#00f>for</span> (i = 0; i &lt; 6; i++) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>    p = align_alloc(10, alignment[i]);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>    <span style=color:#00f>if</span> ((<span style=color:#2b91af>unsigned</span> <span style=color:#2b91af>long</span>)p % alignment[i]) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>      printf(<span style=color:#a31515>&#34;FAILED!, alignment: %ld, addr: %p</span><span style=color:#a31515>\n</span><span style=color:#a31515>&#34;</span>,
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>          alignment[i], p);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>      exit(1);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span>    memset(p, 0, 10);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span>    align_free(p);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>  }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span>  printf(<span style=color:#a31515>&#34;PASS</span><span style=color:#a31515>\n</span><span style=color:#a31515>&#34;</span>);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span>  <span style=color:#00f>return</span> 0;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span>}
</span></span></code></pre></div><h3 id=思路及解决方案>思路及解决方案</h3><p>思路也写在代码里了，就是思路比较难想，代码倒是不难写。</p><p>PS: 丢人的是，我在一开始居然还提了: <code>malloc()</code>返回的地址能够保证是参数<code>size</code>对齐的，
真是令人耻笑啊！！</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#00f>#include</span> <span style=color:#00f>&lt;stdio.h&gt;</span><span style=color:#00f>
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#00f>#include</span> <span style=color:#00f>&lt;string.h&gt;</span><span style=color:#00f>
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span><span style=color:#00f>#include</span> <span style=color:#00f>&lt;stdlib.h&gt;</span><span style=color:#00f>
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span><span style=color:#00f></span><span style=color:#2b91af>void</span> *align_alloc(size_t size, size_t align);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span><span style=color:#2b91af>void</span> align_free(<span style=color:#2b91af>void</span> *addr);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span><span style=color:green>// 如何保证对齐到align?
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span><span style=color:green>// ==&gt; 申请更多空间, 返回对齐的地址
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span><span style=color:green>//
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span><span style=color:green>// 不能保证malloc返回的地址是对齐到哪的，怎么确定多申请多大呢?
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span><span style=color:green>// ==&gt; 多申请align的空间，就能保证这align的地址范围里，总有
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span><span style=color:green>//     满足对齐条件的地址
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span><span style=color:green>//
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span><span style=color:green>// 如何计算返回的地址? 比如malloc(10)=12, align=5, 此时我们会
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span><span style=color:green>// 申请的空间为malloc(10+5), 即(12-27)都是可用的，我们需要
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span><span style=color:green>// 经过计算后返回地址 15
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span><span style=color:green>// ==&gt; 计算的规则是(12+5)-(12+5)%5
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span><span style=color:green>//
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span><span style=color:green>// aligned_free()只接受addr一个参数，如何释放malloc()申请的空间?
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span><span style=color:green>// ==&gt; 传入的addr是经过align之后的，确实需要一定的方法才能
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span><span style=color:green>//     求得malloc()返回的地址，这通过计算是无法得到的，因为
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span><span style=color:green>//     不知道这个地址的align是多少。所以可以想到在p_ret之前
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span><span style=color:green>//     再多借用一个地址的长度来存放malloc()返回的原地址。
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span><span style=color:green></span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24</span><span><span style=color:#2b91af>void</span> *align_alloc(size_t size, size_t align)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26</span><span>  <span style=color:#2b91af>void</span> *p_malloc;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27</span><span>  <span style=color:#2b91af>void</span> *p_ret;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28</span><span>  size_t aligned_size;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29</span><span>  size_t ptr_size;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31</span><span>  ptr_size = <span style=color:#00f>sizeof</span>(<span style=color:#2b91af>char</span> *);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32</span><span>  aligned_size = size + align + ptr_size;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34</span><span>  p_malloc = malloc(aligned_size);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35</span><span>  p_ret    = (p_malloc+ptr_size+align) -
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36</span><span>              ((<span style=color:#2b91af>unsigned</span> <span style=color:#2b91af>long</span>)p_malloc+ptr_size+align) % align;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38</span><span>  *((<span style=color:#2b91af>unsigned</span> <span style=color:#2b91af>long</span> *)p_ret-1) = (<span style=color:#2b91af>unsigned</span> <span style=color:#2b91af>long</span>)p_malloc;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40</span><span>  <span style=color:green>// debug
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41</span><span><span style=color:green></span>  printf(<span style=color:#a31515>&#34;[ALLOC] p_malloc: %p, p_ret: %p, align: %ld</span><span style=color:#a31515>\n</span><span style=color:#a31515>&#34;</span>,
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42</span><span>      p_malloc, p_ret, align);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44</span><span>  <span style=color:#00f>return</span> p_ret;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45</span><span>}
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46</span><span><span style=color:#2b91af>void</span> align_free(<span style=color:#2b91af>void</span> *addr)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">47</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">48</span><span>  <span style=color:#2b91af>void</span> *p_malloc;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">49</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">50</span><span>  p_malloc = (<span style=color:#2b91af>void</span> *)(*((<span style=color:#2b91af>unsigned</span> <span style=color:#2b91af>long</span> *)addr-1));
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">51</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">52</span><span>  printf(<span style=color:#a31515>&#34;[ FREE] p_malloc: %p</span><span style=color:#a31515>\n</span><span style=color:#a31515>&#34;</span>, p_malloc);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">53</span><span>  free(p_malloc);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">54</span><span>}
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">55</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">56</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">57</span><span><span style=color:#2b91af>int</span> main(<span style=color:#2b91af>void</span>)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">58</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">59</span><span>  size_t alignment[6] = {5, 8, 32, 64, 128, 12};
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">60</span><span>  <span style=color:#2b91af>int</span> i;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">61</span><span>  <span style=color:#2b91af>char</span> *p;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">62</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">63</span><span>  <span style=color:#00f>for</span> (i = 0; i &lt; 6; i++) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">64</span><span>    p = align_alloc(10, alignment[i]);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">65</span><span>    <span style=color:#00f>if</span> ((<span style=color:#2b91af>unsigned</span> <span style=color:#2b91af>long</span>)p % alignment[i]) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">66</span><span>      printf(<span style=color:#a31515>&#34;FAILED!, alignment: %ld, addr: %p</span><span style=color:#a31515>\n</span><span style=color:#a31515>&#34;</span>,
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">67</span><span>          alignment[i], p);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">68</span><span>      exit(1);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">69</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">70</span><span>    memset(p, 0, 10);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">71</span><span>    align_free(p);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">72</span><span>  }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">73</span><span>  printf(<span style=color:#a31515>&#34;PASS</span><span style=color:#a31515>\n</span><span style=color:#a31515>&#34;</span>);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">74</span><span>  <span style=color:#00f>return</span> 0;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">75</span><span>}
</span></span></code></pre></div></article></body></main></div></body></html>