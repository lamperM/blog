<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/syntax_pastie.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>ARMv8 基础</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#armv8-%e4%b8%8e-armv7-%e7%9b%b8%e6%af%94%e7%9a%84%e6%94%b9%e5%8a%a8 aria-label="ARMv8 与 ARMv7 相比的改动">ARMv8 与 ARMv7 相比的改动</a></li><li><a href=#%e5%85%b3%e4%ba%8e-spsel-%e5%af%84%e5%ad%98%e5%99%a8%e7%9a%84%e4%bd%bf%e7%94%a8 aria-label="关于 Spsel 寄存器的使用">关于 Spsel 寄存器的使用</a></li><li><a href=#%e5%85%b3%e4%ba%8e-pmu aria-label="关于 PMU">关于 PMU</a><ul><li><a href=#pmu-%e5%92%8c-etm-%e7%9a%84%e5%8c%ba%e5%88%ab aria-label="PMU 和 ETM 的区别">PMU 和 ETM 的区别</a></li></ul></li><li><a href=#%e9%80%9a%e7%94%a8%e5%af%84%e5%ad%98%e5%99%a8 aria-label=通用寄存器>通用寄存器</a></li><li><a href=#%e5%bc%82%e5%b8%b8%e8%bf%94%e5%9b%9e%e6%8c%87%e4%bb%a4arm3264 aria-label=异常返回指令（ARM32/64）>异常返回指令（ARM32/64）</a><ul><li><a href=#aarch32 aria-label=AArch32>AArch32</a></li><li><a href=#aarch64 aria-label=AArch64>AArch64</a></li><li><a href=#%e6%8c%87%e4%bb%a4%e6%a0%bc%e5%bc%8f%e5%8f%8a%e7%94%a8%e6%b3%95 aria-label=指令格式及用法>指令格式及用法</a><ul><li><a href=#eret aria-label=ERET>ERET</a></li><li><a href=#ldmload-multiple aria-label="LDM(Load Multiple)">LDM(Load Multiple)</a></li><li><a href=#rfereturn-from-exception aria-label="RFE(Return From Exception)">RFE(Return From Exception)</a></li></ul></li></ul></li><li><a href=#armv82-spe aria-label="Armv8.2 SPE">Armv8.2 SPE</a><ul><li><a href=#%e5%80%9f%e5%8a%a9-perf-%e4%bd%bf%e7%94%a8-spe aria-label="借助 perf 使用 SPE">借助 perf 使用 SPE</a></li></ul></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>ARMv8 基础</div></header><h2 id=armv8-与-armv7-相比的改动>ARMv8 与 ARMv7 相比的改动</h2><ul><li>指令集： 新增 A64 指令集， 但也兼容原来的 A32 指令集</li><li>权限等级： AArch64 下新增 EL0-EL3 异常等级，对应 V7 的特权等级</li><li>通用寄存器：31 个通用寄存器，V7 15 个</li><li>虚拟地址长度：64 位的地址长度，理论支持 256TB 的寻址范围</li></ul><h2 id=关于-spsel-寄存器的使用>关于 Spsel 寄存器的使用</h2><p>linux 内核里，内核（EL1）和用户态（EL0）都使用各自的栈空间，即 spsel 始终为 1。
这种情况下，当内核里时，sp_el0 是可以复用的寄存器。进入内核前保存原值，然后将其保存当前进程 task_strcut 结构体的地址。因为内核中经常会调用 current 宏，这时可以快很多。</p><p>atf 中，在 EL3 用 sp_el0 作为运行时栈空间，而 sp_el3 保存一个重要结构上下文的地址。在进入 EL3 时，系统会自动切换到 spsel=1，即 sp_el3，此时
（1）保存当前的上下文到 sp_el3
（2）切换到 sp_el0 当作 c 调用栈
看起来好像是反过来，我能想到的原因是：</p><ul><li>ATF 在 ELF 如果用 sp_el0 指向结构体，在外面有可能被破坏？而用 sp_el3 在外面不会被动</li></ul><p><a href=https://developer.arm.com/documentation/ka005621/latest/>https://developer.arm.com/documentation/ka005621/latest/</a></p><h2 id=关于-pmu>关于 PMU</h2><p>PMU 是一个独立的单元，不和体系结构绑定。而是每个 SOC 都可以不同。比如说 Cortex-A53 实现了 PMUv3 架构，但别的基于 ARMv8 架构的 Soc 可能实现 PMUv4 或者其他版本。</p><p>PMU 内部有六个计数器，所以可以记录六个事件的发生次数。计数器的数值不一定绝对的正确，因为管道的存在，所以一般来说还是通过长时间计数来减弱影响。</p><h3 id=pmu-和-etm-的区别>PMU 和 ETM 的区别</h3><p>记录的事件不同</p><ul><li>PMU：Cache Miss、分支预测失败、TLB Miss 等</li><li>ETM：记录分支指令、内存屏障指令等所有指令的执行，包括地址、结果等。
另外还可以记录数据读写的地址、结果（可选）。</li></ul><p>记录的粒度不同</p><ul><li>PMU：仅用计数器来记录事件发生的次数</li><li>ETM：指令的类型、地址、执行结果等。数据访问也类似。</li></ul><p>所以说，ETM 的信息量大，需要专门的缓存机制。而 PMU 只需在定时器结束时记录发生的次数就行，
不需要什么缓存，没有实际的数据流。</p><h2 id=通用寄存器>通用寄存器</h2><ol><li><code>x0-x7</code> 参数寄存器: Restore function parameters and return vaule.</li><li><code>x9-x15</code> caller-saved 临时寄存器: callee 默认可以直接使用来保存临时变量, 不需要保存和恢复. 如果 caller 在里面存储了非临时信息, 那么在函数调用之前应当由 caller 负责保存.</li><li><code>x19-x28</code> callee-saved 寄存器: callee 应该避免使用. 如果必须要使用，那么在返回前必须恢复.</li><li>特殊寄存器:<ul><li><code>x8</code> restore indirect result. Commonly used when returning a struct.</li><li><code>x18</code> platform reserved register.</li><li><code>x29</code> frame pointer register(FP).</li><li><code>x30</code> link register(LR).</li></ul></li></ol><blockquote><p>All general-purpose register <code>xN</code> is 64-bit width. They all have corresponding <code>wN</code> register using the lower 32-bit of <code>xN</code>. And write to <code>wN</code> will clear the upper 32bit of <code>xN</code>.</p></blockquote><style type=text/css>.notice{--root-color:#444;--root-background:#eff;--title-color:#fff;--title-background:#7bd;--warning-title:#c33;--warning-content:#fee;--info-title:#fb7;--info-content:#fec;--note-title:#6be;--note-content:#e7f2fa;--tip-title:#5a5;--tip-content:#efe}@media(prefers-color-scheme:dark){.notice{--root-color:#ddd;--root-background:#eff;--title-color:#fff;--title-background:#7bd;--warning-title:#800;--warning-content:#400;--info-title:#a50;--info-content:#420;--note-title:#069;--note-content:#023;--tip-title:#363;--tip-content:#121}}body.dark .notice{--root-color:#ddd;--root-background:#eff;--title-color:#fff;--title-background:#7bd;--warning-title:#800;--warning-content:#400;--info-title:#a50;--info-content:#420;--note-title:#069;--note-content:#023;--tip-title:#363;--tip-content:#121}.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:var(--root-color);background:var(--root-background)}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:var(--title-color);background:var(--title-background)}.notice.warning .notice-title{background:var(--warning-title)}.notice.warning{background:var(--warning-content)}.notice.info .notice-title{background:var(--info-title)}.notice.info{background:var(--info-content)}.notice.note .notice-title{background:var(--note-title)}.notice.note{background:var(--note-content)}.notice.tip .notice-title{background:var(--tip-title)}.notice.tip{background:var(--tip-content)}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:.125em;position:relative}</style><div class="notice info" id=Caller-saved&callee-saved><p class=notice-title><span class="icon-notice baseline"><svg xmlns="http://www.w3.org/2000/svg" viewBox="92 59.5 300 300"><path d="M292 303.25V272c0-3.516-2.734-6.25-6.25-6.25H267v-1e2c0-3.516-2.734-6.25-6.25-6.25h-62.5c-3.516.0-6.25 2.734-6.25 6.25V197c0 3.516 2.734 6.25 6.25 6.25H217v62.5h-18.75c-3.516.0-6.25 2.734-6.25 6.25v31.25c0 3.516 2.734 6.25 6.25 6.25h87.5c3.516.0 6.25-2.734 6.25-6.25zm-25-175V97c0-3.516-2.734-6.25-6.25-6.25h-37.5c-3.516.0-6.25 2.734-6.25 6.25v31.25c0 3.516 2.734 6.25 6.25 6.25h37.5c3.516.0 6.25-2.734 6.25-6.25zm125 81.25c0 82.813-67.188 150-150 150-82.813.0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813.0 150 67.188 150 150z"/></svg></span><span>Caller-saved&callee-saved</span></p><ul><li>Caller-saved 寄存器又称为<em>临时寄存器</em>, 常用来存放临时变量. 例如 A() 调用 B(), 那么 B() 可以直接使用 caller-saved 寄存器, 也就是说 A() 在调用 B() 之前不会在这些寄存器里保存重要信息(编译器实现), 不能保证调用 B() 前后其值不变. 如果必须要保证, 那么保存和恢复(利用栈)这件事是 A() 来做.</li><li>Callee-saved 寄存器则相反, 通常持续使用的值会保存到这些寄存器中. 还是拿 A() call B() 来举例. 如果 A() 中的一个变量需要在调用 B() 前后持续有效, 那么它应当保存到 callee-saved 寄存器中. 而且 B() 正常来说不应该动这些寄存器, 如果非得动(例如寄存器不够用), 那么 B() 需要在使用他们的前后进行保存和恢复(利用栈).</li></ul></div><h2 id=异常返回指令arm3264>异常返回指令（ARM32/64）</h2><p>当异常处理程序结束后，需要执行<em>异常返回指令</em>恢复进入异常之前的状态。具体来说:</p><ol><li>恢复发生异常前的 PC</li><li>从 SPSR 中恢复 PSTATE 寄存器(现场)</li></ol><p>异常返回的指令根据当前<strong>执行状态</strong>为 AArch32 还是 AArch64 有所不同.</p><h3 id=aarch32>AArch32</h3><p>AArch32 的异常返回指令在不同的<strong>模式</strong>下也有所不同:</p><ul><li><p><strong>若异常是在 Hyp 模式下处理:</strong> 仅可执行<code>ERET</code>指令从异常返回.</p></li><li><p><strong>若异常是在其他模式下处理</strong>, AArch32 提供了以下的异常返回指令:</p><ul><li><code>ERET</code> 指令</li><li>使用带 S 后缀的数据处理指令直接操作 PC(例如, <code>MOVS, PC, LR</code>), 恢复 PSTATE</li><li>RFE 指令: <code>RFE &lt;Rn></code>. 从基址寄存器<rn>指向的地址依次加载 PC 和 PSTATE</li><li>LDM 指令: <code>LDM &lt;Rn> {pc..}</code>. 若目标寄存器中包含 PC, 则会同时恢复 PSTATE</li></ul></li></ul><h3 id=aarch64>AArch64</h3><p>AArch64 下<strong>统一使用</strong> <code>ERET</code> 指令进行异常返回.</p><h3 id=指令格式及用法>指令格式及用法</h3><h4 id=eret>ERET</h4><p>ERET 指令自动完成:</p><ol><li>从 ELR_ELx 中恢复 PC 指针</li><li>从 SPSR_ELx 中恢复 PSTATE 寄存器的状态.</li></ol><h4 id=ldmload-multiple>LDM(Load Multiple)</h4><ul><li>格式: <code>LDM &lt;Rn> {registers}</code></li><li>含义: 从基址寄存器<code>&lt;Rn></code>指向的地址开始依次加载多个寄存器值. 若目标寄存器中包含 PC, 则同时恢复 PSTATE.</li></ul><p>例如: <code>LDM &lt;r0> {pc, r1}</code> 等价于:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>pc = [r0]
</span></span><span class=line><span class=cl>r1 = [r0+4]
</span></span><span class=line><span class=cl>PSTATE = SPSR  ;仅当目标寄存器包含PC时自动完成
</span></span></code></pre></div><h4 id=rfereturn-from-exception>RFE(Return From Exception)</h4><ul><li>格式: <code>LDM &lt;Rn></code></li><li>含义: 从基址寄存器<code>&lt;Rn></code>指向的地址依次加载 PC 和 PSTATE.</li></ul><p>例如: <code>RFE &lt;r0></code> 等价于:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>pc = [r0]
</span></span><span class=line><span class=cl>PSTATE = [r0+4]
</span></span></code></pre></div><h2 id=armv82-spe>Armv8.2 SPE</h2><p>SPE 的全称为 Statistical Profiling Extension, 统计分析扩展，
是 Armv8.2 引入的一个特性。</p><p>PMU 能统计事件发生的次数，但是无法直到是哪一条指令导致的。
采样因为要通过中断的方式，所以准确性不高，太高的准确率会造成系统很大的负担。
因此开发者一般只能确定是哪一个函数，但是确定哪一行就比较困难。</p><p>SPE 就是通过硬件的方式解决这个问题，直接在流水线上对指令进行采样。
用硬件对性能的损耗就会很低。</p><p>有个计数器，没取指一次，计数器-1，减到 0 之后的指令就是要采样的指令。</p><p>采集的指令非常全面：时间戳、PC、指令的分类、运行的时间等。</p><p>采集之后，可以做一次过滤，只保存关心的事件（执行时间大于几个 Cycle？指令类型 lr/str？）</p><p>保存的 buffer 满了之后，触发中断，软件读取。</p><h3 id=借助-perf-使用-spe>借助 perf 使用 SPE</h3><ul><li>FEAT_SPE Armv8.2 Support from 4.14 and 5.3</li><li>FEAT_SPEv1p1 Armv8.5 Only support from 5.11</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>perf list <span class=p>|</span> grep arm_spe_0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>perf record -e arm_spe_0/branch_filter<span class=o>=</span>1,ts_enable<span class=o>=</span>1,pct_enable<span class=o>=</span>1,pa_enable<span class=o>=</span>1,<span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=nv>load_filter</span><span class=o>=</span>1,jitter<span class=o>=</span>1,store_filter<span class=o>=</span>1,min_latency<span class=o>=</span>0/ -- ./user.app
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>perf report -D -i perf.data
</span></span></code></pre></div><ul><li><a href="https://developer.aliyun.com/live/252287?spm=a2c6h.28322828.J_3909373260.17.88865488AzlJRR">Arm 架构下性能分析与优化介绍-云视频-阿里云开发者社区</a></li></ul></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2023-05-09T21:19:01, Lastmod: 2024-05-12T21:54:13</p><script src=/js/copy-to-clipboard.js></script></main></div></body></html>