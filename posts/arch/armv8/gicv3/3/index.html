<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/syntax_pastie.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>ARMv8 中断管理(3): 中断服务程序</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%9c%9f%e6%ad%a3%e7%9a%84%e4%b8%ad%e6%96%ad%e6%9c%8d%e5%8a%a1%e7%a8%8b%e5%ba%8f aria-label=“真正的”中断服务程序>“真正的”中断服务程序</a><ul><li><a href=#%e6%89%bf%e8%ae%a4%e4%b8%80%e4%b8%aa%e4%b8%ad%e6%96%ad aria-label=承认一个中断>承认一个中断</a></li><li><a href=#%e6%a0%87%e8%ae%b0%e4%b8%ad%e6%96%ad%e5%a4%84%e7%90%86%e5%ae%8c%e6%af%95 aria-label=标记中断处理完毕>标记中断处理完毕</a></li></ul></li><li><a href=#%e4%b8%ad%e6%96%ad%e7%9a%84%e4%b8%8a%e4%b8%8b%e9%83%a8%e6%9c%ba%e5%88%b6 aria-label=中断的上下部机制>中断的上下部机制</a><ul><li><a href=#armv8-%e5%a6%82%e4%bd%95%e6%94%af%e6%8c%81%e4%b8%ad%e6%96%ad%e4%b8%8a%e4%b8%8b%e9%83%a8 aria-label="ARMv8 如何支持中断上下部">ARMv8 如何支持中断上下部</a></li></ul></li><li><a href=#softirq aria-label=softIRQ>softIRQ</a></li><li><a href=#tasklet aria-label=tasklet>tasklet</a></li><li><a href=#workqueue aria-label=workqueue>workqueue</a></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>ARMv8 中断管理(3): 中断服务程序</div></header><p>从进入 IRQ/FIQ 中断向量开始，中断处理的完整流程:</p><ol><li>保存上下文</li><li>切换中断栈，为进入“真正的”中断服务程序做准备</li><li>执行真正的中断服务程序</li><li>恢复之前的上下文</li></ol><h2 id=真正的中断服务程序>“真正的”中断服务程序</h2><p>“真正的”意为不算那些对于所有异常、中断来说都相同的“套话”
，只讨论对于中断特有的行为。</p><h3 id=承认一个中断>承认一个中断</h3><p>真正的中断服务程序从<strong>接受 CPU Interface 传来的中断</strong>
开始算起，这一步的实现通过读取<code>ICC_IAR1_EL1</code>, 返回当前
中断的 INTID。</p><p>拿到 INTID 后，就根据不同的 ID 调用各自对应场景下的服务函数，
比如若 INTID 是对应与时钟中断，那么此步需要清楚状态寄存器、
重新开启时钟定时器。</p><h3 id=标记中断处理完毕>标记中断处理完毕</h3><p>做完相干的事情后，需要将该中断标记为已完成，方便后面的中断进来，
也就是上一节说的<strong>优先级下降</strong>和<strong>中断失效</strong>过程。</p><p>GICv3 支持将这两步合为一次操作，实际我们也是这样做的，通过写入
<code>ICC_EOI1_EL1</code>寄存器来完成标记处理完成。此中断的状态也就从
active->inactive.</p><blockquote><p>中断服务程序中，承认中断和标记完成两步操作应该是用 while 循环
包裹起来的。</p><p>反复的读取 IAR、标记中断已完成&mldr; 如果此时该 CPU 上已经没有
中断待处理了，读取 IAR 会返回特殊 INTID: 1023</p></blockquote><h2 id=中断的上下部机制>中断的上下部机制</h2><p>中断服务函数的停留时间应该越短越好，否则影响其他任务占用 CPU，这是老生常谈的。</p><p>以上观点存在的原因是：中断服务函数中是关闭中断的，CPU 只有串行的处理完当前
中断后， 才能继续做下一件事情，即便是高优先级任务也得等待，因为时钟中断被关闭！</p><p>所以 Linux 在 2.6 引入了中断的上下部机制，将整个中断服务函数拆分为上部和下部:</p><ul><li>上部：那些不能被打断的步骤，比如保存上下文，承认和标记中断完成等</li><li>下部：宽松的管理方式，执行过程就算被打断也没关系，指的就是上面说的<em>对应各自中断
应用场景下的服务函数</em>，比如一个按键触发代表的实际行为</li></ul><h3 id=armv8-如何支持中断上下部>ARMv8 如何支持中断上下部</h3><p>ARMv8 中，进入异常向量是自动关中断的，可执行<code>msr DAIFClr, #imm</code>来手动开启。</p><p>所以说，直到手动开中断之前的所有操作都属于中断的上部。</p><p>那么，应该在何时开启中断呢？我认为分割后的正确中断处理流程应该是：</p><ol><li>承认一个中断</li><li>根据 INTID 标记其应该做的行为，注意只是标记</li><li>标记该中断完成</li><li>待该 CPU 上的所有中断都完成后，开中断</li><li>遍历检查所有标记，如果有待完成的任务在此时执行</li></ol><p>上面说的标记和执行过程可以用许多方式实现，包括 softirq, tasklet, workqueue 等，
都属于实现中断上下部机制的实现。</p><h2 id=softirq>softIRQ</h2><p>softirq 定义了一些中断事件和处理函数，在中断的上半部中，如果 INTID 属于定义的软中断
之一， 则添加标志其处理函数需要被执行，只是标志，并不实际执行。</p><p>当中断服务程序退出之前，会遍历软中断列表中的状态，如果有需要处理的，则调用注册的处理函数。</p><p>注意，软中断处理函数的执行是在中断上下文中，用户进程只能等待中断完成才能有机会被调用，
所以软中断的一个问题是， 如果需要执行的处理函数过多，会导致一般线程长时间不能被调度。</p><p>同样地，因为处理函数的执行在中断上下文，所以也不能执行可能导致进程睡眠的操作，
例如申请锁，可能导致优先级反转。</p><h2 id=tasklet>tasklet</h2><h2 id=workqueue>workqueue</h2></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2023-04-13T23:51:49, Lastmod: 2024-05-12T21:54:13</p><script src=/js/copy-to-clipboard.js></script></main></div></body></html>