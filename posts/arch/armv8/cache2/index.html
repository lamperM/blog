<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/syntax_pastie.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>ARMv8: cache相关知识2</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#cache-alias%e5%88%ab%e5%90%8d%e9%97%ae%e9%a2%98 aria-label="Cache alias（别名）问题">Cache alias（别名）问题</a></li><li><a href=#cache-%e7%9a%84%e7%bb%84%e7%bb%87%e6%96%b9%e5%bc%8f aria-label="Cache 的组织方式">Cache 的组织方式</a><ul><li><a href=#vivtvirtual-index-virtual-tag aria-label="VIVT(Virtual Index Virtual Tag)">VIVT(Virtual Index Virtual Tag)</a></li><li><a href=#viptvirtual-index-physical-tag aria-label="VIPT(Virtual Index Physical Tag)">VIPT(Virtual Index Physical Tag)</a></li><li><a href=#piptphysical-index-physical-tag aria-label="PIPT(Physical Index Physical Tag)">PIPT(Physical Index Physical Tag)</a></li></ul></li><li><a href=#memory-barriers%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c aria-label="Memory Barriers（内存屏障）">Memory Barriers（内存屏障）</a><ul><li><a href=#instruction-synchronization-barrier aria-label="Instruction Synchronization Barrier">Instruction Synchronization Barrier</a></li></ul></li><li><a href=#data-synchronization-barrierdsb aria-label="Data Synchronization Barrier(DSB)">Data Synchronization Barrier(DSB)</a></li><li><a href=#dsb-dmb-%e6%90%ba%e5%b8%a6%e5%8f%82%e6%95%b0 aria-label="DSB, DMB 携带参数">DSB, DMB 携带参数</a></li><li><a href=#dc-%e6%8c%87%e4%bb%a4 aria-label="DC 指令">DC 指令</a></li><li><a href=#ic-%e6%8c%87%e4%bb%a4 aria-label="IC 指令">IC 指令</a></li><li><a href=#%e6%a1%88%e4%be%8b-1 aria-label="案例 1">案例 1</a></li><li><a href=#%e6%a1%88%e4%be%8b-2 aria-label="案例 2">案例 2</a></li><li><a href=#%e6%a1%88%e4%be%8b-3 aria-label="案例 3">案例 3</a></li><li><a href=#%e6%a1%88%e4%be%8b-4 aria-label="案例 4">案例 4</a></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>ARMv8: cache相关知识2</div></header><p>作为一个 OS 开发者，到底什么时候需要维护 Cache ？</p><h2 id=cache-alias别名问题>Cache alias（别名）问题</h2><h2 id=cache-的组织方式>Cache 的组织方式</h2><p>如何检索 Cache 表项，因为访问地址/数据时有虚拟地址转物理地址的过程，所以检索可能以虚拟地址为索引，或者是先翻译，再以物理地址为索引去查找 Cache。Cache 检索时的行为取决与 Cache 的组织方式，这是由硬件决定的。</p><p>?I?T，I 代表 Index，即以哪种地址去索引。T 代表 Tag，即索引到表项后以什么地址去检查。因为 Cache 支持多路的原因，同一个 Index 可能对应多个表项，需要依次的和 Tag 比对，直到匹配成功或者 Cache Miss。</p><h3 id=vivtvirtual-index-virtual-tag>VIVT(Virtual Index Virtual Tag)</h3><p>早期的 ARM 处理器一般采用这种方式，全使用虚拟地址，这种方式会导致 cache 别名(cache alias)问题。</p><h3 id=viptvirtual-index-physical-tag>VIPT(Virtual Index Physical Tag)</h3><p>使用虚拟地址做索引，物理地址做 Tag。在利用虚拟地址索引 cache 同时，同时会利用 TLB/MMU 将虚拟地址转换为物理地址。然后将转换后的物理地址，与虚拟地址索引到的 cache line 中的 Tag 作比较，如果匹配则命中。</p><p>这种方式要比 VIVT 实现复杂，当进程切换时，不在需要对 cache 进行 invalidate 等操作(因为匹配过程中需要借物理地址)。但是这种方法仍然存在 cache 别名的问题，但是可以通过一定手段解决。</p><h3 id=piptphysical-index-physical-tag>PIPT(Physical Index Physical Tag)</h3><p>使用物理地址做索引，物理地址做 Tag。现代的 ARM Cortex-A 大多采用 PIPT 方式，由于采用物理地址作为 Index 和 Tag，所以不会产生 cache alias 问题。不过 PIPT 的方式在芯片的设计要比 VIPT 复杂得多，而且需要等待 TLB/MMU 将虚拟地址转换为物理地址后，才能进行 cache line 寻找操作。</p><blockquote><p>Data cache invalidate on reset</p></blockquote><blockquote><p>The Armv8-A architecture does not support an operation to invalidate the entire data cache. If software requires this function, it must be constructed by iterating over the cache geometry and executing a series of individual invalidate by set/way instructions.</p></blockquote><p>outof-order and speculative execution</p><h2 id=memory-barriers内存屏障>Memory Barriers（内存屏障）</h2><p>指令流水线，指令预取，Store buffer 等很多优化为了提高性能。然而，有时候一些前后的依赖微架构自身并不能保证，所以 ARM 指令集提供了一些显式的或者说强制的 barrier 来保证一些指令执行顺序/数据读写顺序。</p><h3 id=instruction-synchronization-barrier>Instruction Synchronization Barrier</h3><p>Instruction Synchronization Barrier(ISB) 指令确保后续指令在 isb 执行之后重新 fetch，即起到了刷新 pipeline 的效果。
用到 isb 的地方一般与内存、Cache 操作相关。确保ISB之前的context-changing操作会被之后的指令看到。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>	MRS X1, CPACR_EL1 // Copy contents of CPACR to X1
</span></span><span class=line><span class=cl>	ORR X1, X1, #(0x3 &lt;&lt; 20) // Write to bit 20 of X1. (Enable FPU and SIMD)
</span></span><span class=line><span class=cl>	MSR CPACR_EL1, X1 // Write contents of X1 to CPACR
</span></span><span class=line><span class=cl>	ISB  // enable FPU 和 SIMD 后，后续指令执行的方式就会发生变化，
</span></span><span class=line><span class=cl>		 // 所以当前流水线上的指令必须重新fetch
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// Linux kernel: arch/arm64/kernel/head.S
</span></span><span class=line><span class=cl>// 其他的指令后面会介绍到，这个例子中可以仅关注isb
</span></span><span class=line><span class=cl>	msr	sctlr_el1, x19			// re-enable the MMU
</span></span><span class=line><span class=cl>	isb               // 开启MMU后，流水线上按照原来页表取得的指令就可能不对
</span></span><span class=line><span class=cl>					// 需要重新按照新的mapping来fetch
</span></span><span class=line><span class=cl>	ic	iallu				// 改变了mapping，Icache上的映射需要invalid
</span></span><span class=line><span class=cl>	dsb	nsh				// 确保前面icache invalid操作执行完毕
</span></span><span class=line><span class=cl>	isb               // 确保后面预取的指令不受 ICache old value 的影响
</span></span><span class=line><span class=cl>	                  // ，后续之行必须重新 Fetch
</span></span></code></pre></div><h2 id=data-synchronization-barrierdsb>Data Synchronization Barrier(DSB)</h2><p>当处理器执行 DSB 指令时，会 block 后面指令执行，直到 DSB 前面的指令执行完成。</p><h2 id=dsb-dmb-携带参数>DSB, DMB 携带参数</h2><p>OSHLD Operation that waits only for loads to complete, and only to the outer shareable domain</p><p>ISH | Inner SHareable | Operation only to the Inner Shareable domain.</p><h2 id=dc-指令>DC 指令</h2><h2 id=ic-指令>IC 指令</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>IC &lt;ic_op&gt;, {&lt;Xt&gt;}
</span></span></code></pre></div><ul><li>IC IALLU: Invalidate ALL to PoU，无效化所有到 PoU 的指令缓存行。</li><li>IC IALLUIS: 表示 Invalidate all to PoU, Inner Shareable，无效化所有到 PoU 的，内部可共享（Inner Shareable）的指令缓存行。</li><li>IC IVAU: 表示 Invalidate Virtual Address to PoU，无效化虚拟地址到 PoU 的指令缓存行。</li></ul><h2 id=案例-1>案例 1</h2><p><a href=https://stackoverflow.com/questions/58636551/does-aarch64-need-a-dsb-after-creating-a-page-table-entry>assembly - Does AArch64 need a DSB after creating a page table entry? - Stack Overflow</a></p><p>填充一个空的页表，然后立马用虚拟地址去访问，这之间需要什么 fence 类指令吗？</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>str</span> <span class=no>x1</span><span class=p>,</span> <span class=p>[</span><span class=no>x0</span><span class=p>]</span> <span class=c>;x1 is phy addr for pte, x0 is pte_entry
</span></span></span><span class=line><span class=cl><span class=c>; &lt;&lt; need any fence?
</span></span></span><span class=line><span class=cl><span class=c></span><span class=no>ldr</span> <span class=no>x2</span><span class=p>,</span> <span class=p>[</span><span class=no>x3</span><span class=p>]</span> <span class=c>;x3 has VA that is mapped by above instruction
</span></span></span></code></pre></div><p>ARMv8 requires what they call a &ldquo;break-before-make&rdquo; procedure when 更新页表项。 This procedure is described in G5.9.1 in the ARMv8 ARM:</p><blockquote><p>A break-before-make sequence on 修改页表项 requires the following steps:</p><ol><li>Replace the old translation table entry with <strong>an invalid entry</strong>, and execute a DSB instruction.</li><li>Invalidate the translation table entry with a broadcast TLB invalidation instruction, and execute a DSB instruction to ensure the completion of that invalidation.</li><li>Write the new translation table entry, and execute a DSB instruction to ensure that the new entry is visible. This sequence ensures that at no time are both the old and new entries simultaneously visible to different threads of execution, and therefore the problems described at the start of this subsection cannot arise.</li></ol></blockquote><p>对于该问题来说，因为原来已经是无效的表项，所以可以直接跳过 1、2 步，直接执行第三步即可。
同时，针对这种情况，DSB 可以规定为 SH 参数来优化性能。<strong>DSB 之后的 ISB 也是必须的，使后面的 ldr 指令重新 fetch</strong>，因为页表已经更新，可能更新了下一条指令地址的页表项，使得新的 fetch 对应不同的指令，所以加一个 isb 比较安全。</p><h2 id=案例-2>案例 2</h2><p>Linux Kernel <code>__enable_mmu()</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>SYM_FUNC_START</span><span class=p>(</span><span class=no>__enable_mmu</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=na>...</span>
</span></span><span class=line><span class=cl>	<span class=nf>msr</span>	<span class=no>ttbr0_el1</span><span class=p>,</span> <span class=no>x2</span>			<span class=err>//</span> <span class=no>load</span> <span class=no>TTBR0</span>
</span></span><span class=line><span class=cl>	<span class=nf>offset_ttbr1</span> <span class=no>x1</span><span class=p>,</span> <span class=no>x3</span>
</span></span><span class=line><span class=cl>	<span class=nf>msr</span>	<span class=no>ttbr1_el1</span><span class=p>,</span> <span class=no>x1</span>			<span class=err>//</span> <span class=no>load</span> <span class=no>TTBR1</span>
</span></span><span class=line><span class=cl>	<span class=nf>isb</span>
</span></span><span class=line><span class=cl>	<span class=nf>msr</span>	<span class=no>sctlr_el1</span><span class=p>,</span> <span class=no>x0</span>
</span></span><span class=line><span class=cl>	<span class=nf>isb</span>                   <span class=err>//</span> <span class=err>开了</span><span class=no>MMU以后</span><span class=err>，后面根据</span><span class=no>PC预取的指令可能对应别的指令地址</span><span class=err>，需要重新</span><span class=no>fetch</span>
</span></span><span class=line><span class=cl>	<span class=err>/*</span>
</span></span><span class=line><span class=cl>	 <span class=err>*</span> <span class=nf>Invalidate</span> <span class=no>the</span> <span class=no>local</span> <span class=no>I-cache</span> <span class=no>so</span> <span class=no>that</span> <span class=no>any</span> <span class=no>instructions</span> <span class=no>fetched</span>
</span></span><span class=line><span class=cl>	 <span class=err>*</span> <span class=nf>speculatively</span> <span class=no>from</span> <span class=no>the</span> <span class=no>PoC</span> <span class=no>are</span> <span class=no>discarded</span><span class=p>,</span> <span class=no>since</span> <span class=no>they</span> <span class=no>may</span> <span class=no>have</span>
</span></span><span class=line><span class=cl>	 <span class=err>*</span> <span class=nf>been</span> <span class=no>dynamically</span> <span class=no>patched</span> <span class=no>at</span> <span class=no>the</span> <span class=no>PoU.</span>
</span></span><span class=line><span class=cl>	 <span class=err>*/</span>
</span></span><span class=line><span class=cl>	<span class=nf>ic</span>	<span class=no>iallu</span>
</span></span><span class=line><span class=cl>	<span class=nf>dsb</span>	<span class=no>nsh</span>     <span class=err>//</span> <span class=err>充当一个</span><span class=no>barrier</span><span class=err>，确保上面</span><span class=no>icache</span> <span class=no>clean完毕后</span><span class=err>，</span><span class=no>isb才commit</span>
</span></span><span class=line><span class=cl>	<span class=nf>isb</span>         <span class=err>//</span> <span class=err>后面的指令可能之前从</span><span class=no>icache中fetch的</span><span class=err>，在</span><span class=no>icache</span> <span class=no>clean后需要重新fetch</span>
</span></span><span class=line><span class=cl>	<span class=nf>ret</span>
</span></span><span class=line><span class=cl><span class=nf>SYM_FUNC_END</span><span class=p>(</span><span class=no>__enable_mmu</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=案例-3>案例 3</h2><p>自己做的项目中，修改当前 TTBR 寄存器后，没有做相应的处理。
正常来说，在 MMU 和 Cache 都 Enable 时，修改 TTBR 后，需要做几件事：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>dsb</span> <span class=no>st</span>     <span class=c>; Ensure writes to tables have completed
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nf>msr</span> <span class=no>ttbr0_el2</span><span class=p>,</span> <span class=no>x0</span> <span class=c>; Set the root table
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nf>tlbi</span> <span class=no>vmalle2</span> <span class=c>; Invalidate TLB entry
</span></span></span><span class=line><span class=cl><span class=c></span><span class=no>dsb</span> <span class=no>sy</span>   <span class=c>; Ensure TLB invalidation has completed
</span></span></span><span class=line><span class=cl><span class=c></span><span class=no>ic</span> <span class=no>iallu</span> <span class=c>; Clean Icache if VIVT or aliasing VIPT
</span></span></span><span class=line><span class=cl><span class=c></span><span class=no>dsb</span> <span class=no>sy</span>   <span class=c>; Ensure Icache clean has completed
</span></span></span><span class=line><span class=cl><span class=c></span><span class=no>isb</span>      <span class=c>; Refetch following instructions using 正确的 pagetable 和 cache、TLB
</span></span></span></code></pre></div><h2 id=案例-4>案例 4</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=na>.macro</span>	<span class=no>__idmap_cpu_set_reserved_ttbr1</span><span class=p>,</span> <span class=no>tmp1</span><span class=p>,</span> <span class=no>tmp2</span>
</span></span><span class=line><span class=cl>	<span class=nf>adrp</span>	<span class=err>\</span><span class=no>tmp1</span><span class=p>,</span> <span class=no>empty_zero_page</span>
</span></span><span class=line><span class=cl>	<span class=nf>phys_to_ttbr</span> <span class=err>\</span><span class=no>tmp2</span><span class=p>,</span> <span class=err>\</span><span class=no>tmp1</span>
</span></span><span class=line><span class=cl>	<span class=nf>offset_ttbr1</span> <span class=err>\</span><span class=no>tmp2</span><span class=p>,</span> <span class=err>\</span><span class=no>tmp1</span>
</span></span><span class=line><span class=cl>	<span class=nf>msr</span>	<span class=no>ttbr1_el1</span><span class=p>,</span> <span class=err>\</span><span class=no>tmp2</span>
</span></span><span class=line><span class=cl>	<span class=nf>isb</span>   <span class=err>//</span> <span class=err>必须吗？</span>
</span></span><span class=line><span class=cl>	<span class=nf>tlbi</span>	<span class=no>vmalle1</span> 
</span></span><span class=line><span class=cl>	<span class=no>dsb</span>	<span class=no>nsh</span>
</span></span><span class=line><span class=cl>	<span class=nf>isb</span>
</span></span><span class=line><span class=cl><span class=na>.endm</span>
</span></span></code></pre></div></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2024-07-14T22:02:04, Lastmod: 2024-08-22T23:53:01</p><script src=/js/copy-to-clipboard.js></script></main></div></body></html>