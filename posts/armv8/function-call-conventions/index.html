<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>AArch64/X86 函数调用约定</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><ul><li><a href=#x86-%e8%b0%83%e7%94%a8%e7%ba%a6%e5%ae%9a aria-label="X86 调用约定">X86 调用约定</a><ul><li><a href=#%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8 aria-label=函数调用>函数调用</a></li><li><a href=#%e5%87%bd%e6%95%b0%e8%bf%94%e5%9b%9e aria-label=函数返回>函数返回</a></li><li><a href=#example-%e5%87%bd%e6%95%b0%e7%9a%84%e8%b0%83%e7%94%a8%e5%92%8c%e8%bf%94%e5%9b%9e aria-label="Example: 函数的调用和返回">Example: 函数的调用和返回</a></li></ul></li></ul><li><a href=#aarch64-%e8%b0%83%e7%94%a8%e7%ba%a6%e5%ae%9a aria-label="AArch64 调用约定">AArch64 调用约定</a><ul><li><a href=#call-a-function aria-label="Call A Function">Call A Function</a></li><li><a href=#function-return aria-label="Function Return">Function Return</a></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e7%bc%96%e8%af%91%e5%87%ba%e7%9a%84%e6%b1%87%e7%bc%96%e6%96%87%e4%bb%b6%e6%b2%a1%e6%9c%89mov-sp-x29 aria-label="为什么编译出的汇编文件没有mov sp, x29?">为什么编译出的汇编文件没有<code>mov sp, x29</code>?</a></li><li><a href=#%e5%b8%a7%e6%8c%87%e9%92%88fp%e5%ad%98%e5%9c%a8%e7%9a%84%e6%84%8f%e4%b9%89 aria-label=帧指针(fp)存在的意义>帧指针(fp)存在的意义</a></li><li><a href=#%e5%a6%82%e4%bd%95%e5%85%b3%e9%97%ad%e5%b8%a7%e6%8c%87%e9%92%88 aria-label=如何关闭帧指针>如何关闭帧指针</a></li></ul></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a><ul><li><a href=#%e7%bb%93%e8%af%ad aria-label=结语>结语</a></li></ul></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>AArch64/X86 函数调用约定</div></header><p>符合调用约定使得调用函数能够正常获取参数, callee结束之后能够回到原来位置继续执行.</p><h2 id=x86-调用约定>X86 调用约定</h2><h3 id=函数调用>函数调用</h3><p>x86架构中, 函数调用以一条<code>call</code>指令为分界.</p><p>在<code>call</code>指令执行之前, 所有的参数必须都躺在栈中, 参数入栈的规则是: <strong>第一个参数最后入栈</strong>.</p><p>另外, 执行<code>call</code>指令之前, 必须确保栈指针<code>esp</code>是16-byte对齐. 这项工作是<strong>编译器</strong>完成的, 如果它判断参数入栈之后的<code>esp</code> 不满足对齐条件, 则会手动调整<code>esp</code>使之对齐. 实现方式见下面例子.</p><p><code>call</code> 指令的语义是:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#06b;font-weight:700>push</span> <span style=color:#036;font-weight:700>pc</span><span style=color:#a61717;background-color:#e3d2d2>+</span><span style=color:#00d;font-weight:700>1</span>    <span style=color:#888>;push next insttuction
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#036;font-weight:700>mov</span> <span style=color:#036;font-weight:700>pc</span>, <span style=color:#036;font-weight:700>func</span> <span style=color:#888>;set pc = new function
</span></span></span></code></pre></div><p><code>call</code> 指令之后的下一条指令就是callee的内容了, 至此就算是进入新函数的地盘.</p><p>但是在执行新的任务之前, callee还需要完成<strong>栈的转换</strong>, 因为此时使用的栈还是caller的.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#06b;font-weight:700>push</span> <span style=color:#036;font-weight:700>ebp</span>     <span style=color:#888>;preserve location of caller&#39;s stack
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#036;font-weight:700>mov</span> <span style=color:#036;font-weight:700>ebp</span>, <span style=color:#036;font-weight:700>esp</span> <span style=color:#888>;new ebp is old esp
</span></span></span></code></pre></div><p><strong>此时<code>esp</code>也就是栈指针等于<code>ebp</code>, 这是callee栈的初始条件</strong>. 万事俱备, 可以开始执行callee的实际任务了.</p><blockquote><p><code>ebp</code>在整个函数执行过程中是固定的, 好处是: 能够<strong>快速的或者函数参数, 返回地址</strong>.</p></blockquote><h3 id=函数返回>函数返回</h3><p>callee执行完毕后, 需要返回到caller继续执行. 刚才说过, callee的返回地址在栈中, 所以我们要做的是找到返回地址所在的位置, 然后使<code>pc = 返回地址</code>. 当然, 还有另一个重要的任务就是<strong>恢复caller的栈</strong>.</p><p>上述任务的实现使用两条汇编语句就可完成: <code>leave</code> 和 <code>ret</code>.</p><p><code>leave</code> 负责搞定栈, 其语义为:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#06b;font-weight:700>mov</span> <span style=color:#036;font-weight:700>esp</span>, <span style=color:#036;font-weight:700>ebp</span>   <span style=color:#888>;回滚栈空间
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#036;font-weight:700>pop</span> <span style=color:#036;font-weight:700>ebp</span>        <span style=color:#888>;恢复caller的ebp
</span></span></span></code></pre></div><p><code>ret</code> 负责搞定<code>pc</code>, 其语义为:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#06b;font-weight:700>pop</span> <span style=color:#036;font-weight:700>ebx</span>        <span style=color:#888>;取出返回地址
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#036;font-weight:700>mov</span> <span style=color:#036;font-weight:700>pc</span>, <span style=color:#036;font-weight:700>ebx</span>    <span style=color:#888>;jmp to 返回地址
</span></span></span></code></pre></div><p><code>ret</code> 之后, 就算是返回caller的地盘了. 还有一件小事别忘了做: <strong>用于保存参数的栈空间还没有回收</strong>, 回到caller之后需要先将<code>esp</code>的位置进行调整.</p><h3 id=example-函数的调用和返回>Example: 函数的调用和返回</h3><p>一个关于函数调用和返回实现的完整例子.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#888;font-weight:700>void</span> <span style=color:#06b;font-weight:700>caller</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Func(<span style=color:#00d;font-weight:700>1</span>, <span style=color:#00d;font-weight:700>2</span>, <span style=color:#00d;font-weight:700>3</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#888;font-weight:700>void</span> <span style=color:#06b;font-weight:700>Func</span>(<span style=color:#888;font-weight:700>int</span> a, <span style=color:#888;font-weight:700>int</span> b, <span style=color:#888;font-weight:700>int</span> c)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#888>/* Do something */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>(以下汇编是<strong>AT&T</strong>格式的, 请见谅).</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#888>; Caller
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#06b;font-weight:700>sub</span>    <span style=color:#036;font-weight:700>$0x4</span>,<span style=color:#369>%esp</span>  <span style=color:#888>;make 16-bytes align before call. 0x4 是由编译器计算的
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#036;font-weight:700>push</span>   <span style=color:#036;font-weight:700>$0x3</span>       <span style=color:#888>;push 参数, 顺序是从右到左
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#036;font-weight:700>push</span>   <span style=color:#036;font-weight:700>$0x2</span>
</span></span><span style=display:flex><span><span style=color:#06b;font-weight:700>push</span>   <span style=color:#036;font-weight:700>$0x1</span>
</span></span><span style=display:flex><span><span style=color:#06b;font-weight:700>call</span>   <span style=color:#00d;font-weight:700>f01000ad</span> &lt;<span style=color:#036;font-weight:700>Func</span>&gt; <span style=color:#888>;Func()&#39;addr is f01000ad
</span></span></span><span style=display:flex><span><span style=color:#888>;===========&gt;&gt; Turn to callee
</span></span></span><span style=display:flex><span><span style=color:#888></span>                            
</span></span><span style=display:flex><span>                            <span style=color:#888>;Func()
</span></span></span><span style=display:flex><span><span style=color:#888></span>                            <span style=color:#036;font-weight:700>push</span>   <span style=color:#369>%ebp</span>      <span style=color:#888>;preserve old ebp
</span></span></span><span style=display:flex><span><span style=color:#888></span>                            <span style=color:#036;font-weight:700>mov</span>    <span style=color:#369>%esp</span>,<span style=color:#369>%ebp</span> <span style=color:#888>;set new ebp, ebp=esp now
</span></span></span><span style=display:flex><span><span style=color:#888></span>                            <span style=color:#a61717;background-color:#e3d2d2>/</span>* <span style=color:#036;font-weight:700>Do</span> <span style=color:#036;font-weight:700>something</span> *<span style=color:#a61717;background-color:#e3d2d2>/</span>
</span></span><span style=display:flex><span>                            <span style=color:#06b;font-weight:700>leave</span>            <span style=color:#888>;restore stack
</span></span></span><span style=display:flex><span><span style=color:#888></span>                            <span style=color:#036;font-weight:700>ret</span>              <span style=color:#888>;restore instruction point
</span></span></span><span style=display:flex><span><span style=color:#888></span>                            
</span></span><span style=display:flex><span><span style=color:#888>;&lt;&lt;=========== Back to caller 
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#036;font-weight:700>add</span>    <span style=color:#036;font-weight:700>$0x10</span>,<span style=color:#369>%esp</span>   <span style=color:#888>;recycle stack(12 bytes parameters plus 4 bytes alignment)
</span></span></span></code></pre></div><h1 id=aarch64-调用约定>AArch64 调用约定</h1><p>大体的思想与x86相似, 只是细节有些许不同</p><h2 id=call-a-function>Call A Function</h2><p><strong>ARMv8的函数调用以bl指令为分界</strong>，在bl执行之前，caller需要将参数准备好。<strong>少于8个参数的函数在传参时, 参数是放在x0-x7中</strong>, 最左边的参数先使用x0, 以此类推. 参数超过8个的情况下才使用栈, 这与x86的方式不同.</p><p><code>bl</code>指令保存返回地址, 并跳转到callee执行, 其语义是:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#06b;font-weight:700>mov</span> <span style=color:#036;font-weight:700>lr</span>, <span style=color:#036;font-weight:700>pc</span><span style=color:#a61717;background-color:#e3d2d2>+</span><span style=color:#00d;font-weight:700>1</span>     <span style=color:#888>;preserve return address
</span></span></span><span style=display:flex><span><span style=color:#888></span>                 <span style=color:#888>;lr specially used for preservering return addr
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#036;font-weight:700>mov</span> <span style=color:#036;font-weight:700>pc</span>, <span style=color:#036;font-weight:700>new_func</span> <span style=color:#888>;set pc = new function
</span></span></span></code></pre></div><p><strong>至此到了callee的职责范围</strong>。进入函数时, 需要完成三个前置动作:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#888>; 为callee()的执行留出足够的栈空间
</span></span></span><span style=display:flex><span><span style=color:#888>; 0x10不是固定的, 编译器计算得到
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#06b;font-weight:700>sub</span> <span style=color:#036;font-weight:700>sp</span>, <span style=color:#036;font-weight:700>sp</span>, <span style=color:#888>#0x10
</span></span></span><span style=display:flex><span><span style=color:#888></span>
</span></span><span style=display:flex><span><span style=color:#888>; 保存lr和fp, 因为callee可能调用
</span></span></span><span style=display:flex><span><span style=color:#888>; 其他的函数, 会破坏当前的
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#06b;font-weight:700>stp</span> <span style=color:#036;font-weight:700>x29</span>, <span style=color:#036;font-weight:700>x30</span>, [<span style=color:#036;font-weight:700>sp</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888>; 保存sp的值, 所以x29也称为帧指针
</span></span></span><span style=display:flex><span><span style=color:#888>; 原因是sp在callee的执行过程中可能
</span></span></span><span style=display:flex><span><span style=color:#888>; 会变化. 与退出时配合理解较好
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#06b;font-weight:700>mov</span> <span style=color:#036;font-weight:700>x29</span>, <span style=color:#036;font-weight:700>sp</span>
</span></span></code></pre></div><p>上述动作完成后, sp是自由的了, callee()的函数体开始执行.</p><h2 id=function-return>Function Return</h2><p>callee()执行完后, 也需要执行一些后置动作, 以便恢复调用前caller()的环境.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#888>; 经过callee的指令执行过后, sp
</span></span></span><span style=display:flex><span><span style=color:#888>; 可能早就不是以前的sp了, 但是帧指针
</span></span></span><span style=display:flex><span><span style=color:#888>; fp总是保存着callee初始的sp
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#06b;font-weight:700>mov</span> <span style=color:#036;font-weight:700>sp</span>, <span style=color:#036;font-weight:700>x29</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888>; callee如果调用了其他函数, lr和fp
</span></span></span><span style=display:flex><span><span style=color:#888>; 也会被破坏, 所以从栈中恢复callee
</span></span></span><span style=display:flex><span><span style=color:#888>; 正确的lr和fp, 才能正确回到caller
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#06b;font-weight:700>ldp</span> <span style=color:#036;font-weight:700>x29</span>, <span style=color:#036;font-weight:700>x30</span>, [<span style=color:#036;font-weight:700>sp</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888>; 收回为callee分配的栈空间, 此时sp
</span></span></span><span style=display:flex><span><span style=color:#888>; 是调用callee之前的值.
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:#06b;font-weight:700>add</span> <span style=color:#036;font-weight:700>sp</span>, <span style=color:#036;font-weight:700>sp</span>, <span style=color:#888>#0x10
</span></span></span></code></pre></div><p>后置动作完成后, 环境已经大致恢复到调用callee()之前的状态了, 通用寄存器中的值, 其实不必担心, 因为ARMv8规定了哪些寄存器是caller-saved或者callee-saved, 再说到lr和sp, caller也会保存到栈中, 就像callee调用其他的函数时的情况相同.</p><p>所以, 完成后置动作后, 执行<code>ret</code>来返回到lr的位置即可.</p><h2 id=为什么编译出的汇编文件没有mov-sp-x29>为什么编译出的汇编文件没有<code>mov sp, x29</code>?</h2><p>如果查看实际C函数编译后的汇编结果, 大部分情况下会发现前置和后置行为不是严格的按照A64PCS中规定的样子, 常见的是后置动作缺少恢复sp的执行, 即<code>mov sp, x29</code>.</p><p>原因其实不难发现, callee中使用的寻址方式都是相对于sp寻址, 即不修改sp. 既然sp从始至终都没被改过, 自然也不需要恢复了. 这样不需要每次都需要sp, 更加高效.</p><p><strong>但是, 前置动作中的保存sp到fp的行为通常是不会被省略的, 我猜是因为调试行为(例如backtrace)的实现需要用到fp.</strong></p><p>不是每次都这样, 也有时会修改sp, 此时就必须恢复.</p><h2 id=帧指针fp存在的意义>帧指针(fp)存在的意义</h2><p>上面说了, 如果一直使用sp相对寻址来操作栈, 那么fp的存在似乎是非必要的.</p><p>我了解到的事实也是如此, fp存在的必要性似乎就是使得一些调试功能更加方便. <strong>堆栈回溯</strong>是一个典型的利用fp的场景, 从callee的fp可以找到其caller的fp, 也就是caller的堆栈空间, 以此类推可以找到caller-caller的fp&mldr;</p><h2 id=如何关闭帧指针>如何关闭帧指针</h2><p>仅针对AArch64来说, GCC提供了一些相关的编译选项来给程序员选择是否启用fp的权利.</p><ul><li><code>-fomit-frame-pointer</code> 强制省略fp</li><li><code>-fno-omit-frame-pointer</code> 强制不省略fp</li></ul><h1 id=参考>参考</h1><ol><li>x86 call 指令执行前需要esp对齐到 16-byte: <a href=https://stackoverflow.com/questions/41971481/what-are-the-following-instructions-after-this-call-assembly>x86 - What are the following instructions after this call (assembly) - Stack Overflow</a></li><li><a href=https://zhuanlan.zhihu.com/p/290689333>x86栈帧原理 - 知乎 (zhihu.com)</a></li><li><a href=https://www.cnblogs.com/coder51up/p/6940030.html>破获ARM64位CPU下linux crash要案之神技能：手动恢复函数调用栈</a></li></ol><h2 id=结语>结语</h2><p>能够正确达到函数调用和返回的实现方式有很多, <strong>不是仅有这一种方式</strong>, 约定仅仅是一个约定, 大家都这样去做降低了开发的难度.</p></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2022-11-21T10:30:35, Lastmod: 2023-11-22T18:09:39</p><script src=/js/clipboard.js></script></main></div></body></html>