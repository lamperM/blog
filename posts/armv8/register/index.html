<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>ARMv8-A 寄存器</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>所有文章</a></div><div class="a-block nav-link-item"><a href=/tags>Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput><ul id=searchResults></ul></div></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><h1>ARMv8-A 寄存器</h1></header><h1 id=寄存器分类>寄存器分类</h1><h2 id=通用寄存器>通用寄存器</h2><ol><li><code>x0-x7</code> 参数寄存器: Restore function parameters and return vaule.</li><li><code>x9-x15</code> caller-saved 临时寄存器: callee 默认可以直接使用来保存临时变量, 不需要保存和恢复. 如果 caller 在里面存储了非临时信息, 那么在函数调用之前应当由 caller 负责保存.</li><li><code>x19-x28</code> callee-saved 寄存器: callee 应该避免使用. 如果必须要使用，那么在返回前必须恢复.</li><li>special registers:<ul><li><code>x8</code> restore indirect result. Commonly used when returning a struct.</li><li><code>x18</code> platform reserved register.</li><li><code>x29</code> frame pointer register(FP).</li><li><code>x30</code> link register(LR).</li></ul></li></ol><blockquote><p>All general-purpose register <code>xN</code> is 64-bit width. They all have corresponding <code>wN</code> register using the lower 32-bit of <code>xN</code>. And write to <code>wN</code> will clear the upper 32bit of <code>xN</code>.</p></blockquote><blockquote><p>💫 The different between <strong>Caller-saved</strong> and <strong>callee-saved</strong> registers</p><ul><li>Caller-saved 寄存器又称为<em>临时寄存器</em>, 常用来存放临时变量. 例如A() 调用 B(), 那么 B() 可以直接使用 caller-saved 寄存器, 也就是说 A() 在调用 B() 之前不会在这些寄存器里保存重要信息(编译器实现), 不能保证调用 B() 前后其值不变. 如果必须要保证, 那么保存和恢复(利用栈)这件事是 A() 来做.</li><li>Callee-saved 寄存器则相反, 通常持续使用的值会保存到这些寄存器中. 还是拿 A() call B() 来举例. 如果 A() 中的一个变量需要在调用 B() 前后持续有效, 那么它应当保存到 callee-saved 寄存器中. 而且 B() 正常来说不应该动这些寄存器, 如果非得动(例如寄存器不够用), 那么 B() 需要在使用他们的前后进行保存和恢复(利用栈).</li></ul></blockquote><h2 id=每个el的特殊寄存器>每个EL的特殊寄存器</h2><ol><li><code>sp_el0/1/2/3</code> stack pointer register of each EL.</li><li><code>elr_el1/2/3</code> exception link register of each EL except EL0.</li><li><code>spsr_el1/2/3</code> save program status register of each EL except EL0.</li></ol><blockquote><p><code>sp</code> is an alias of <code>sp_el0</code>. Do NOT treat <code>sp</code> as general-purpose register.</p></blockquote></article></body></main></div></body></html>