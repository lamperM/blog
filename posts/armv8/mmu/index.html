<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>ARMv8-A MMU介绍</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>所有文章</a></div><div class="a-block nav-link-item"><a href=/tags>Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a><ul><li><a href=#mmu-%e7%9a%84%e7%bb%93%e6%9e%84 aria-label="MMU 的结构">MMU 的结构</a></li><li><a href=#mmu-%e7%9a%84%e9%85%8d%e7%bd%ae aria-label="MMU 的配置">MMU 的配置</a></li><li><a href=#mmu-%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2%e7%9a%84%e8%bf%87%e7%a8%8b aria-label="MMU 地址转换的过程">MMU 地址转换的过程</a></li><li><a href=#%e9%a1%b5%e8%a1%a8%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86 aria-label=页表的工作原理>页表的工作原理</a><ul><li><a href=#%e5%a4%9a%e7%ba%a7%e9%a1%b5%e8%a1%a8 aria-label=多级页表>多级页表</a></li></ul></li></ul></li><li><a href=#%e5%86%85%e5%ad%98%e7%b1%bb%e5%9e%8b aria-label=内存类型>内存类型</a><ul><li><a href=#%e6%99%ae%e9%80%9a%e7%b1%bb%e5%9e%8b%e5%86%85%e5%ad%98 aria-label=普通类型内存>普通类型内存</a></li><li><a href=#%e8%ae%be%e5%a4%87%e7%b1%bb%e5%9e%8b%e5%86%85%e5%ad%98 aria-label=设备类型内存>设备类型内存</a></li></ul></li><li><a href=#%e4%b8%a4%e5%a5%97%e9%a1%b5%e8%a1%a8 aria-label=两套页表>两套页表</a></li><li><a href=#%e8%b6%8a%e6%9d%83-%e8%b6%8a%e7%95%8c aria-label="越权, 越界">越权, 越界</a><ul><li><a href=#%e4%b8%a4%e4%b8%aa%e7%89%a9%e7%90%86%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4 aria-label=两个物理地址空间>两个物理地址空间</a></li><li><a href=#armv8-mmu%e6%9d%83%e9%99%90%e6%8e%a7%e5%88%b6 aria-label="ARMv8 MMU权限控制">ARMv8 MMU权限控制</a></li></ul></li><li><a href=#%e9%a1%b5%e8%a1%a8%e7%9a%84%e7%bb%93%e6%9e%84 aria-label=页表的结构>页表的结构</a><ul><li><a href=#%e5%9c%b0%e5%9d%80%e5%ae%bd%e5%ba%a6 aria-label=地址宽度>地址宽度</a></li><li><a href=#%e9%a1%b5%e9%9d%a2%e7%b2%92%e5%ba%a6 aria-label=页面粒度>页面粒度</a></li><li><a href=#aarch64-%e9%a1%b5%e8%a1%a8%e9%a1%b9%e7%bb%93%e6%9e%84 aria-label="AArch64 页表项结构">AArch64 页表项结构</a><ul><li><a href=#%e6%97%a0%e6%95%88%e9%a1%b5%e8%a1%a8%e9%a1%b9 aria-label=无效页表项>无效页表项</a></li><li><a href=#table aria-label=table>table</a></li><li><a href=#block aria-label=block>block</a></li></ul></li><li><a href=#%e9%a1%b5%e8%a1%a8%e7%bb%93%e6%9e%844kb%e9%a1%b5%e9%9d%a2%e4%b8%ba%e4%be%8b aria-label=页表结构(4KB页面为例)>页表结构(4KB页面为例)</a></li></ul></li><li><a href=#%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e5%88%b0%e7%89%a9%e7%90%86%e5%9c%b0%e5%9d%80%e7%9a%84%e8%bd%ac%e6%8d%a2%e8%bf%87%e7%a8%8b aria-label=虚拟地址到物理地址的转换过程>虚拟地址到物理地址的转换过程</a><ul><li><a href=#non-secure-and-secure-access aria-label="Non-secure and secure access">Non-secure and secure access</a></li></ul></li><li><a href=#%e7%9b%b8%e5%85%b3%e7%9a%84%e5%af%84%e5%ad%98%e5%99%a8 aria-label=相关的寄存器>相关的寄存器</a><ul><li><a href=#tcr aria-label=TCR>TCR</a></li><li><a href=#sctlr aria-label=SCTLR>SCTLR</a></li><li><a href=#ttbr aria-label=TTBR>TTBR</a></li></ul></li><li><a href=#aarch32-%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e7%b3%bb%e7%bb%9f aria-label="AArch32 虚拟内存系统">AArch32 虚拟内存系统</a></li></ul></div></details></div></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>ARMv8-A MMU介绍</div></header><h2 id=introduction>Introduction</h2><p>MMU: 专用于将虚拟地址转换为物理地址. 通常配合分页机制来工作.</p><p>页表: 页表中的表项包含提供虚拟地址和物理地址之间的映射.</p><p>MMU就是直接访问页表, 并且通过将频繁使用的映射缓存到TLB中.</p><h3 id=mmu-的结构>MMU 的结构</h3><p>MMU是一种硬件, 可以通过在适当的安全状态下对其进行配置. 每个Core都有自己的MMU, 每个MMU包括:</p><ol><li>一个TLB, 缓存最近访问的映射.</li><li>一个Table Walk Unit, 从内存中查询页表, 得到最终的虚拟地址-物理地址的映射.</li></ol><p>MMU 控制着整个系统的缓存策略, 内存属性和访问权限. MMU开启后, 软件发出的所有内存访问都使用虚拟地址, 要求MMU为每次访问进行地址转换.</p><h3 id=mmu-的配置>MMU 的配置</h3><p>在启用MMU前, 必须告知其页表存放的位置.</p><h3 id=mmu-地址转换的过程>MMU 地址转换的过程</h3><p>对于每个转换请求, MMU首先检查TLB是否已经对该地址缓存, 如果该地址未缓存, 则需要遍历页表.</p><p>页表遍历单元在页表中搜索相关的映射表项.</p><ul><li>一旦找到映射, MMU就会检查权限和属性. 决定允许本次访问, 或者发出故障信号.</li><li>若未找到映射, 则触发缺页异常.</li></ul><h3 id=页表的工作原理>页表的工作原理</h3><p>页表的工作方式是将虚拟地址空间和物理地址空间划分为大小相等的块, 称为页面.</p><p>页表中的每个表项对应着一块虚拟地址空间中的块, 表项的值就是这块虚拟地址空间对应的物理地址块, 以及访问物理地址时要使用的属性.</p><p>在查表过程中, 将虚拟地址分为两部分:</p><ul><li>高阶位用作页表的索引. 用来找到对应的物理块</li><li>低地址是块内的偏移量, 不会因为映射而改变. 页表项中的物理地址与该偏移组合形成用于访问内存的物理地址.</li></ul><h4 id=多级页表>多级页表</h4><p>实际实现中, 多采用多级页表的方案, 各级页表自定向下组成树的形式, 协作实现虚拟到物理地址的转换.</p><p>树中的分支成为页目录, 页目录中的表项不是直接存储目标物理地址, 而是下一级页表的地址; 最后一级页表的表项中保存着目标物理地址.</p><blockquote><p>多级页表是减小页表占用存储空间过大的有效方案.</p></blockquote><p>顶级页表将地址空间划分为大块, 每个表项可以指向大小相等的内存块. 也可以指向将块进行再次细分的下一级页表. 支持大块的优点:</p><ul><li>大的内存块需要查表的次数更少</li><li>提升TLB的效率, 因为一个TLB表项覆盖更大的内存区域.</li></ul><p>凡事都是有利有弊, 使用大块也增加了内存浪费, 实际使用时需要根据需要来权衡.</p><h2 id=内存类型>内存类型</h2><h3 id=普通类型内存>普通类型内存</h3><p>普通类型的内存是弱一致性的(weakly ordered)内存模型, 没有额外的约束, 可以提供最高的内存访问性能.</p><p>通常代码段, 数据段以及其他数据都放在普通内存中.</p><p>普通内存允许处理器做很多优化, 如分支预测, 数据预取, Cache line预取, 乱序执行等.</p><h3 id=设备类型内存>设备类型内存</h3><p>CPU访问设备内存会有很多限制, 如不能进行数据预取等. 设备类型的内存严格按照指令的顺序来执行的.</p><p>设备类型内容通常留给设备来访问, 例如中断控制器(GIC), 串口, 定时器等.</p><h2 id=两套页表>两套页表</h2><ul><li>当CPU访问的地址属于<em>用户空间</em>时, MMU会自动选择<strong>TTBR0</strong>指向的页表.</li><li>当CPU访问的地址属于<em>内核空间</em>时. MMU会自动选择<strong>TTBR1</strong>指向的页表</li></ul><p>EL2和EL3没有TTBR1, 只有TTBR0. 也就意味着:</p><p>• If EL2 is using AArch64, it can only use Virtual Addresses in the range 0x0 to 0x0000FFFF_FFFFFFFF.
• If EL3 is using AArch64, it can only use Virtual Addresses in the range 0x0 to 0x0000FFFF_FFFFFFFF.</p><h2 id=越权-越界>越权, 越界</h2><p>在未使用虚拟地址空间之前, 所有的用户程序都可以访问全部的物理内存, 所以恶意程序可以修改其他程序的内存数据, 这使得整个系统处于危险的状态. 每个进程的地址空间都要受到保护, 以免被其他进程有意/无意的破坏.</p><p>现代操作系统中, 每个进程都有独立的虚拟地址空间. 在进程的角度上, 它拥有整个虚拟地址空间. 不同的进程可以同时使用一个虚拟地址, MMU通过页表将其映射到合适的物理地址.</p><h3 id=两个物理地址空间>两个物理地址空间</h3><p>ARMv8 体系结构定义两个物理地址空间: secure address space 和 non-secure address space.</p><p>理论上, 安全和非安全的地址空间是相互独立的, 然而现实中大多数系统都将安全和非安全视为访问控制的属性. 正常(非安全)世界只能访问非安全的物理内存; 而安全世界可以访问这两个地址空间.</p><h3 id=armv8-mmu权限控制>ARMv8 MMU权限控制</h3><p>程序请求某个地址时, MMU需要进行权限检查. 如果请求的地址是数据, 则检查读写权限; 如果请求的是地址, 则检查其可执行权限.</p><p>ARMv8 页表项的AP字段控制该不同异常等级下, 页面的读写权限.</p><p>[表格]</p><p>ARMv8 页表项的PNX字段和XN/UXN字段来设置CPU是否对这个页面有执行权限.</p><ul><li><p>当系统有两套页表时, UXN是用来设置用户空间页面是否有可执行权限; PXN 用来设置特权空间的页面是否有可执行权限.</p></li><li><p>若系统只有一套页表, 则通过XN字段控制</p></li></ul><h2 id=页表的结构>页表的结构</h2><h3 id=地址宽度>地址宽度</h3><p>48bit</p><h3 id=页面粒度>页面粒度</h3><p>页面粒度表示一次最小分配内存块的大小. AArch64支持三种页的大小, 4KB, 16KB, 64KB. 支持哪一种是由实现定义的。创建页表的代码能够读取系统寄存器<code>ID_AA64MMFR0_EL1</code>，以找出哪些是受支持的大小。Cortex-A53处理器支持所有三种尺寸，但有些处理器的早期版本并非如此，例如Cortex-A57，它不支持16K粒度。</p><h3 id=aarch64-页表项结构>AArch64 页表项结构</h3><h4 id=无效页表项>无效页表项</h4><h4 id=table>table</h4><h4 id=block>block</h4><h3 id=页表结构4kb页面为例>页表结构(4KB页面为例)</h3><p>以4KB页面粒度, 虚拟地址宽度为 48位. 使用4级页表.</p><p>48位地址每层转换有9个地址位，即每层512个条目，最后12位选择4kB内的一个字节，直接来自原始地址</p><h2 id=虚拟地址到物理地址的转换过程>虚拟地址到物理地址的转换过程</h2><p>当处理器为获取指令或数据访问发出一个64位的虚拟地址时，MMU硬件将虚拟地址转换为相应的物理地址。对于虚拟地址，前16位[63:47]必须全部为0或1，否则地址将触发故障。</p><h3 id=non-secure-and-secure-access>Non-secure and secure access</h3><p>ARMv8-A架构定义了两种安全状态:安全的和非安全的。它还定义了两个物理地址空间:安全的和非安全的. 正常(非安全)世界只能访问非安全物理地址空间。安全世界可以访问两个物理地址空间。这也是通过转换表来控制的。</p><p>在非安全状态下，转换表中的NS位和NSTable位将被忽略。只能访问非安全内存。在安全状态下，NS位和NSTable位控制虚拟地址转换为安全物理地址还是非安全物理地址。</p><p>You can use SCR_EL3.SIF 来禁用安全世界访问非安全地址.</p><h2 id=相关的寄存器>相关的寄存器</h2><p>与地址转换相关的寄存器主要有以下几个:</p><ol><li>转换控制寄存器(TCR)</li><li>系统控制寄存器(SCTLR)</li><li>页表基地址寄存器(TTBR)</li></ol><h3 id=tcr>TCR</h3><p>IPS: 配置地址转换后输出物理地址的最大值</p><p>TxSz: 配置输入地址的最大值, 即虚拟地址的宽度</p><p>TG1: 配置TTBR1页表的页面粒度大小</p><p>SHx: 配置TTBRx相关内存的Cache共享属性</p><p>ORGNx:</p><p>IRGNx:</p><h3 id=sctlr>SCTLR</h3><p>M: Disable/Enable MMU地址转换</p><p>C: Disable/Enable Data Cache</p><p>I: Disable/Enable Instruction Cache</p><h3 id=ttbr>TTBR</h3><p>存储页表的基地址</p><h2 id=aarch32-虚拟内存系统>AArch32 虚拟内存系统</h2><p>ARMv8 AArch32 的虚拟内存系统向后兼容ARMv7, 与ARMv7的基本一致.</p></article></body></main></div></body></html>