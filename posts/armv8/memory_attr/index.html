<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>AArch64 内存属性与内存类型</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>所有文章</a></div><div class="a-block nav-link-item"><a href=/tags>Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e8%ae%be%e7%bd%ae%e5%86%85%e5%ad%98%e5%b1%9e%e6%80%a7 aria-label=设置内存属性>设置内存属性</a></li><li><a href=#%e5%a4%a7%e7%b1%bb-%e5%86%85%e5%ad%98%e7%b1%bb%e5%9e%8b aria-label="大类: 内存类型">大类: 内存类型</a></li><li><a href=#%e6%9b%b4%e7%bb%86%e5%88%86%e7%9a%84%e6%8f%8f%e8%bf%b01-cacheable aria-label="更细分的描述(1): cacheable">更细分的描述(1): cacheable</a></li><li><a href=#%e6%9b%b4%e7%bb%86%e5%88%86%e7%9a%84%e6%8f%8f%e8%bf%b02-shareable aria-label="更细分的描述(2): shareable">更细分的描述(2): shareable</a></li><li><a href=#%e6%9b%b4%e7%bb%86%e5%88%86%e7%9a%84%e6%8f%8f%e8%bf%b0x- aria-label="更细分的描述(x): &amp;hellip;">更细分的描述(x): &mldr;</a></li></ul></div></details></div></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>AArch64 内存属性与内存类型</div></header><p>有了虚拟内存系统之后，MMU 可以抽象出一些可配置的内存属性。</p><p>例如，配置某个虚拟内存区域为不可执行、不被 cache 等，不可执行的属性
有助于防范攻击，不进入 cache 经常划分给 外设 Memory-mapped 区域。</p><h2 id=设置内存属性>设置内存属性</h2><blockquote><p>相关内容可以在 ARMv8 arm 手册 D5.3.3 Attuibute fields in stage 1
VMSAv8-64 Block and Page descriptors 中找到参考</p></blockquote><p>对于每一个表示内存块(block)的页表项，都有两个属性字段: <strong>lower attr 和 upper attr</strong>.</p><p>以下任何类型或者属性的设置都是通过这两个字段完成的。</p><h2 id=大类-内存类型>大类: 内存类型</h2><p>AArch64 提供两种内存类型: 普通内存和设备内存。</p><ul><li><p>普通内存会启用架构提供的所有优化技术，例如合并访存、乱序执行等。所以
普通内存有最高的性能，但同时不是那么的“安全”，需要底层人员手动使用
<strong>内存屏障</strong>等手段保证某些情况下的顺序性要求。</p></li><li><p>设备内存，顾名思义，常映射到外设的 Memory-mapped 区域。对于设备来说，
那些提高性能的技术会造成一些问题，例如某些寄存器的配置必须按照顺序，
这时就不能使用乱序执行。设备内存就牺牲了性能，优先保证正确性。</p></li></ul><p>配置内存类型也是通过页表项中的其中一个属性字段: <code>AttrIndx[2:0]</code>,
它与系统寄存器<code>MAIR_EL1</code>配合实现。</p><p>具体表现为: <code>mair_el1</code>寄存器被划分为 8 个字段，我们为每个字段写入
不同的值可代表不同的内存类型和一些配套属性，具体的真值表可以参见
<code>mair_el1</code>寄存器的描述。</p><blockquote><p><code>mair_el1</code>中内存类型配套属性只是属性的一部分，是和设备类型绑定的
那部分。</p></blockquote><h2 id=更细分的描述1-cacheable>更细分的描述(1): cacheable</h2><p>内存支持配置为是否被 cache，这在<code>mair_el1</code>的字段中配置。</p><p>要注意，<strong>只有普通内存才支持配置是否进入 cache，所有的设备内存
都是 non-cacheable 的</strong>。</p><h2 id=更细分的描述2-shareable>更细分的描述(2): shareable</h2><p>shareable 说的是一块内存的外部可见性，也可分为 inner/outer
shareable.</p><p>shareable 的设置需要参考此内存的 cacheable 属性:</p><ul><li><p>如果一块内存是 cacheable 的，则需要硬件提供 cache 的一致性维护机制。
如果不能保证 cache 的一致性，想要启用 shareable 就必须是 non-cacheable</p></li><li><p>对于 non-cacheable 的内存，一定是 shareable 的，
不需要配置。因为此时对数据的修改直接操作内存，读取操作亦是如此，一定
是外部可见的</p></li></ul><h2 id=更细分的描述x->更细分的描述(x): &mldr;</h2><p>TODO</p></article></body></main></div></body></html>