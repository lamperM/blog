<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/syntax_pastie.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>AArch64 内存属性与内存类型</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%86%85%e5%ad%98%e5%b1%9e%e6%80%a7%e5%92%8c%e5%86%85%e5%ad%98%e7%b1%bb%e5%9e%8b aria-label=内存属性和内存类型>内存属性和内存类型</a><ul><li><a href=#cacheableshareable-%e5%82%bb%e5%82%bb%e5%88%86%e4%b8%8d%e6%b8%85 aria-label="cacheable&amp;amp;shareable 傻傻分不清">cacheable&shareable 傻傻分不清</a></li></ul></li><li><a href=#%e5%a6%82%e4%bd%95%e8%ae%be%e7%bd%ae%e5%86%85%e5%ad%98%e5%b1%9e%e6%80%a7 aria-label=如何设置内存属性>如何设置内存属性</a></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>AArch64 内存属性与内存类型</div></header><p>有了虚拟内存系统之后，MMU 可以抽象出一些可配置的内存属性。</p><p>例如，配置某个虚拟内存区域为不可执行、不被 cache 等，不可执行的属性
有助于防范攻击，不进入 cache 经常划分给外设 Memory-mapped 区域。</p><h1 id=内存属性和内存类型>内存属性和内存类型</h1><p>首先，我们没法直接设置内存类型，我们能设置的是一些细粒度的内存属性字段，
比如说权限(WRX)、cacheable、shareable 等。</p><p>我们说的内存类型也就是某些有意义的属性字段相互组合，ARM 给出了两种内存类型: 普通内存和设备内存。</p><ul><li><p>普通内存会启用架构提供的所有优化技术，例如合并访存、乱序执行等。所以
普通内存有最高的性能，但同时不是那么的“安全”，需要底层人员手动使用
<strong>内存屏障</strong>等手段保证某些情况下的顺序性要求。</p></li><li><p>设备内存，顾名思义，常映射到外设的 Memory-mapped 区域。对于设备来说，
那些提高性能的技术会造成一些问题，例如某些寄存器的配置必须按照顺序，
这时就不能使用乱序执行。设备内存就牺牲了性能，优先保证正确性。</p></li></ul><p>配置内存类型也是通过页表项中的其中一个属性字段: <code>AttrIndx[2:0]</code>,
它与系统寄存器<code>MAIR_EL1</code>配合实现。</p><p>具体表现为: <code>mair_el1</code>寄存器被划分为 8 个字段，我们为每个字段写入
不同的值可代表不同的内存类型和一些配套属性，具体的真值表可以参见
<code>mair_el1</code>寄存器的描述。</p><blockquote><p><code>mair_el1</code>中内存类型配套属性只是属性的一部分，是和设备类型绑定的那部分。</p></blockquote><h2 id=cacheableshareable-傻傻分不清>cacheable&shareable 傻傻分不清</h2><p>先说 cacheable，一段内存被设置为 non-cacheable 属性说明不会进入 cache，
inner-cacheable 是实现定义的，可能指进 L1 cache/L2 cache， outer-cacheable
说明会进入 L3 cache。</p><p>要注意，<strong>只有普通内存才支持配置是否进入 cache，所有的设备内存需要 non-cacheable</strong>。</p><blockquote><p>内存支持配置为是否被 cacheable，这在<code>mair_el1</code>的字段中配置。</p></blockquote><p>shareable 说的是一块内存的外部可见性，外部不可见并不是真的看不到，只是说不保证值的正确性。</p><p>shareable 属性和 cacheable 其实是有关联的，他们俩比如配合使用，不能随便设置:</p><ul><li>如果一块内存是 cacheable 的，则需要硬件提供 cache 的一致性维护机制。
如果不能保证 cache 的一致性，想要启用 shareable 就必须是 non-cacheable</li><li>对于 non-cacheable 的内存，一定是 shareable 的，
不需要配置。因为此时对数据的修改直接操作内存，读取操作亦是如此，一定
是外部可见的</li></ul><h1 id=如何设置内存属性>如何设置内存属性</h1><blockquote><p>相关内容可以在 ARMv8 arm 手册 D5.3.3 Attuibute fields in stage 1
VMSAv8-64 Block and Page descriptors 中找到参考</p></blockquote><p>对于每一个表示内存块(block)的页表项，都有两个属性字段: <strong>lower attr 和 upper attr</strong>.</p><p>以下任何类型或者属性的设置都是通过这两个字段完成的。</p></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2023-04-12T08:01:33, Lastmod: 2023-09-24T18:08:59</p><script src=/js/copy-to-clipboard.js></script></main></div></body></html>