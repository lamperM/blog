<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>ARMv8: cache相关知识</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>所有文章</a></div><div class="a-block nav-link-item"><a href=/tags>Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="search posts..."><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#cache-%e6%98%af%e4%b8%aa%e7%a1%ac%e4%bb%b6 aria-label="cache 是个硬件">cache 是个硬件</a></li><li><a href=#cache-%e6%8e%a7%e5%88%b6%e5%99%a8 aria-label="cache 控制器">cache 控制器</a></li><li><a href=#cache-policy%e7%ad%96%e7%95%a5 aria-label="cache policy（策略）">cache policy（策略）</a></li><li><a href=#cache-%e7%9b%b8%e5%85%b3%e7%9a%84%e5%86%85%e5%ad%98%e5%b1%9e%e6%80%a7 aria-label="cache 相关的内存属性">cache 相关的内存属性</a></li><li><a href=#cache-maintain%e7%bb%b4%e6%8a%a4 aria-label="cache maintain（维护）">cache maintain（维护）</a></li><li><a href=#armv8%e8%8e%b7%e5%8f%96cache%e4%bf%a1%e6%81%af aria-label=ARMv8获取Cache信息>ARMv8获取Cache信息</a><ul><li><a href=#clidr_el1 aria-label=CLIDR_EL1>CLIDR_EL1</a></li><li><a href=#ctr_el0 aria-label=CTR_EL0>CTR_EL0</a></li><li><a href=#csselr_el1 aria-label=CSSELR_EL1>CSSELR_EL1</a></li><li><a href=#cssidr_el1 aria-label=CSSIDR_EL1>CSSIDR_EL1</a></li></ul></li></ul></div></details></div></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>ARMv8: cache相关知识</div></header><p>之前在特斯拉面试的时候被问到了 cache 的 maintain 操作有哪些,
一时间竟想不起一个准确的词来, 这里就再学习一下, 把这个坑填上吧。</p><p>可能不会说的很细，目的只是把一些概念复习，做到心中大致有数。</p><h2 id=cache-是个硬件>cache 是个硬件</h2><p>cache 的本质是一种 SRAM, 容量很小, 速度很快(ns 级)。</p><p>拿 Cortex-A53 来说，共有三级 Cache：</p><ul><li>L1 cache 是 Core 单独的，分为数据 cache 和指令 cache，容量是 KB 级</li><li>L2 cache 一般是 cluster 内共享，容量是 MB 级</li><li>L3 cache 是所有 core 共享，容量是 MB 级</li></ul><h2 id=cache-控制器>cache 控制器</h2><p>单独的 cache 就是一个存储设备，得有一个控制器告诉它存什么以及什么时候存。</p><p>cache 控制器的任务举个例子说：比如 cache miss 的时候，需要从主存向 cache
回填数据，然而此时 CPU 那边记着要数据，我们都知道 cache 操作的单位
是 cache line 嘛，但这是 cache 控制器会有限填充一个 cache line 中
CPU 要的那一条（或几条），最后在后台默默填充完剩下的。</p><p>cache 控制器的行为是不可配置的，软件不可见，不可编程。</p><h2 id=cache-policy策略>cache policy（策略）</h2><p>cache policy 就说了两件事：</p><ul><li>cache 分配：执行 load 操作时需要分配入 cache 吗？</li><li>cache 更新：执行 str 修改数据时需不需要与主存同步？</li></ul><p>cache 的更新方式有两种：</p><ol><li>Write back，写回；即仅修改 cache 中数据，然后设置一个 dirty 标志位
，当且仅当此 cache line 被 clean 时才对 dirty 数据回写主存</li><li>Write through，写直通；即每次修改 cache 都同步修改主存，也就不需要
dirty 标志了</li></ol><h2 id=cache-相关的内存属性>cache 相关的内存属性</h2><p>一段内存可被设置为 cacheable 或者 uncacheable，uncacheable 的内存直接访问主存。</p><p>cacheable 又可划分为 inner 和 outer 两种：</p><ul><li>inner: 可入L1 cache，或者L2 cache，实现定义</li><li>outer: 可入外部板级的 cache(L3 cache)</li></ul><h2 id=cache-maintain维护>cache maintain（维护）</h2><p>为什么需要维护cache？</p><ul><li>主存中的内容更新了</li><li>此部分内存的权限改了或者映射改了</li></ul><p>cache的三种维护操作（软件可见）：</p><ul><li>[invalidation]: 设置cache line对应的invalid位。常见于reset时，cache里的内容不可信，
所以需要将所有的cache invalid</li><li>[clean]: clean的含义是清理，将原有的标记为dirty的line都与主存进行同步。当然，
<strong>仅更新策略为 write back的时候才需要</strong></li><li>[zero]: 什么也不管，直接将cache line置0，数据丢了我也不关心</li></ul><blockquote><p>以上的三种操作都是有粒度的，包括整个 cache、指定va范围、某一路等。</p></blockquote><blockquote><p>软件只能通过体系结构提供的维护指令来控制 cache。</p></blockquote><h2 id=armv8获取cache信息>ARMv8获取Cache信息</h2><p>想要管理好整个cache系统, 首先要了解的信息是:</p><ol><li>系统实现了几级cache?</li><li>Cache line 是多大?</li><li>对于每一级的Cache, 它的 set/way 分别是多少?</li></ol><p>这些信息都可以通过ARMv8的系统控制寄存器来读取.</p><h3 id=clidr_el1>CLIDR_EL1</h3><p>标识每一级Cache的类型以及系统最多支持几级Cache.</p><p><img src=C:%5CUsers%5Cwangloo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220925170644091.png alt=image-20220925170644091></p><p><code>Ctype&lt;n></code>字段用来描述缓存的类型. 系统最多支持7级缓存, 软件需要遍历<code>Ctype&lt;n></code>字段, 当读到的值为000时, 说明该级及以上都没有实现.</p><blockquote><p>具体每种类型对应的值, 和其他字段的含义, RTFM</p></blockquote><h3 id=ctr_el0>CTR_EL0</h3><p>记录了Cache line的大小, 以及Cache的策略.</p><p><img src=C:%5CUsers%5Cwangloo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220925171028981.png alt=image-20220925171028981></p><p><code>IminLine</code>: 表示所有指令cache中最小的cache line, 单位是 word.</p><p><code>DminLine</code>: 表示所有数据cache中最小的cache line, 单位是 word.</p><p><code>L1IP</code>: 表示 L1 指令cache的策略. RTFM</p><h3 id=csselr_el1>CSSELR_EL1</h3><p>与CSSIDR配合工作. CSSELR用于选定查看某级的Cache, 再去读CSSIDR就是该级Cache的信息.</p><h3 id=cssidr_el1>CSSIDR_EL1</h3><p><img src=C:%5CUsers%5Cwangloo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220925171843984.png alt=image-20220925171843984></p><p><code>LineSize</code>: 该级cache的cache line.</p><p><code>Associativity</code>: 该级Cache的way</p><p><code>NumSets</code>: 该级Cache的set</p><blockquote><p>该寄存器的字段分布与是否实现<code>FEAT_CCIDX</code>有关, RTFM## 获取Cache信息</p></blockquote></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2023-08-14T22:02:04, Lastmod: 2023-11-22T18:09:39</p></main></div></body></html>