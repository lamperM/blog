<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Wangloo's BLOG</title><link>https://wangloo.github.io/posts/</link><description>Recent content in Posts on Wangloo's BLOG</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>@2019 Notepadium.</copyright><lastBuildDate>Mon, 17 Jul 2023 19:28:12 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>我的开发环境构建指南</title><link>https://wangloo.github.io/posts/tools/dev_env/</link><pubDate>Mon, 17 Jul 2023 19:28:12 +0800</pubDate><guid>https://wangloo.github.io/posts/tools/dev_env/</guid><description>前言 写这篇博客的背景是我实在忍受不了每次换新的开发机器都得费好大的劲来完全恢复以前的环境， 而且，我平常喜欢搜集各种有用的工具、好看的主题，字体这些，如果零零散散的记录，大概率会忘记或者记不得某些细节。
所以，最后期望达到的是能够使我每次在新机器上搭建环境只需要看这一篇文章就可以了。因此这里会记录：
帮助提升开发效率的小工具 好看的字体、主题 配置某些环境的要点及注意事项 🥀 到目前为止，我还未发现一种方式能够完全达到“一键式布置”，这也不是本文的目的。 付出至少半天的时间的一定的，希望未来能发现一种好的方法。
字体 Fira Code 这款字体适合做编程字体，蛮好看的。我在 vscode 和 terminal 下都使用了这款字体。
详情及安装参考github
霞鹜文楷 开源的中文字体，做博客、PPT 不错。
详情及安装参考github
vscode 主题 vim vimrc ycm 特别注意 YCM 插件对 python, vim 的版本均有要求。
下载 可以使用 vim-plug 等工具下载, 也可以下载源码然后拷贝到.vim目录下
编译 编译用到 python3, 这里是问题最多的一步
# 编译并添加对C的提示支持 python3 install.py --clangd-completer --verbose Searching Python 3.8 libraries... ... Downloading Clangd from https://github.com/ycm-core/llvm/releases/download/13.0.0/clangd-13.0.0-x86_64-unknown-linux-gnu.tar.bz2... 使用--clangd-completer参数时, 脚本会去下载 clangd-14.0.0-x86_64-unknown-linux-gnu.tar.bz2 文件, 比较慢. 也可以提前根据提示的网站自己手动下载压缩包.
下载完成后, 放到本地目录下:</description></item><item><title>面试总结：特斯拉实习</title><link>https://wangloo.github.io/posts/work/tesla/</link><pubDate>Sat, 10 Jun 2023 08:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/work/tesla/</guid><description>上午结束了特斯拉嵌入式实习生-Linux platform的二面，特斯拉实习生 一共有三轮面试，一轮和二轮都是技术面，三面是主管面。 目前我完成了所有的技术面，且不论结果如何，整个面试过程对我而言还是收获颇丰的， 故以此文整理下自己的欠缺的技术知识，希望下次能够表现的更好。
二面 首先，此轮面试的面试官显然比上一轮更有礼貌一些，准时与会+介绍自己，不过有一点 是我开了摄像头他没开，也没有进行说明吧。 不过这些都是小事，我们这次主要谈论 技术的内容。
我在此回顾几个没有回答好的问题，供以后做参考。
ELF 文件的加载流程 原回答
拿到 ELF 存储的地址后，先将头部读出来，长度是固定的。头部有校验字段， maigic number, 然后是确认 ELF 编译的架构，位数是否正确。 确认格式正确后，读取程序头表，其中保存了各个需要加载的段的偏移，根据 base+段偏移能够得到该段的位置，然后根据段属性的不同，选择映射到不同 的区域和属性，例如 text 段映射为 RE, 代码段映射为 RW，清空 BSS 等 说明自己没接触过动态库文件，所以对动态加载不是很熟悉 点评如下: 对段表、程序头表，这些概念的区分还不是很熟，不清楚什么时候用 section table， 什么时候用 program header table. 以前都看过，只是 时间长了不用就忘记了，这一部分需要好好的做下笔记。
全局变量存在哪？谁负责初始化的 原回答
不知道。
全局保量存在的位置：
未初始化的全局变量 ==&amp;gt; bss段 const修饰的全局变量 ==&amp;gt; rodata段 其他已初始化的全局变量 ==&amp;gt; data段 对于已初始化的全局变量的访问，编译时，编译器将值存入data段，访问的指令是通过 相对寻址来做，例如相对于data段开头。对于静态链接来说，编译完成后访问指令的 基地址和偏移都是空，当链接时修改指令，即重定位的过程。
aligned_alloc()设计 这是面试最后的程序设计题，我也是没有做好，后面好歹在面试官的无数次提示中， 写出了一个解，题目很棒，只是自己实习不够，怪不得其他。</description></item><item><title>Linux 内核数据结构 hlist</title><link>https://wangloo.github.io/posts/os/linux/data_struct/hlist/</link><pubDate>Thu, 11 May 2023 20:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/os/linux/data_struct/hlist/</guid><description>linux 内核为创建【用单链表解决冲突的哈希表】设计了专门的数据结构 hlist。
hlist 整体来说是带头结点的双向链表，头结点的类型为hlist_head, 普通节点 的类型为hlist_node. 为什么要区别两种类型？节约空间， 因为哈希表的 表项类型可以是hlist_head, 它其实不需要prev指针, 比起一般的结点，一个 哈希表能节约一半的空间。
所以一个哈希表和头结点的结构可表示为:
struct hlist_head { struct hlist_node *first; }; struct hlist_head table[TALBE_SZ]; 二象性 任何事物都具有二象性，区分两种类型节约空间的空间，也带了一个问题： 首个hlist_node结点的prev指向哪呢？
正常情况下肯定毫不犹豫的指向头结点，即hlist_head，但注意此时类型是 不同的，prev不能同时是struct hlist_head*和struct hlist_node *。
解决方案有两个，首先可以使首个结点的prev=NULL, 这样虽然避免了类型引发的 问题，也能保证功能正确，但是却破坏了一致性，使得操作的复杂度上升，增加了许多 判断分支。
// delelt a node void del_node(struct hlist_head *head, struct hlist_node *node) { // 这个if 本来是不需要的，甚至参数的head 也不需要传， // 更好的处理方式见解决方案2 if (node == head-&amp;gt;first) { head-&amp;gt;first = node-&amp;gt;next; } else { node-&amp;gt;prev-&amp;gt;next = node-&amp;gt;next; } if (node-&amp;gt;next) { node-&amp;gt;next-&amp;gt;prev = node-&amp;gt;prev; } } // insert a node void add_node_before(struct hlist_head *head, struct hlist_node *new struct hlist_node *next) { // 这个if 本来是不需要的，参数head也是不需要传递的 if (next == head-&amp;gt;first) { new-&amp;gt;prev = NULL; head-&amp;gt;first = new; } else { new-&amp;gt;prev = next-&amp;gt;prev; new-&amp;gt;prev-&amp;gt;next = new; } new-&amp;gt;next = next; next-&amp;gt;prev = new; 更好的解决方案: **prev 改变struct hlist_node的构成，使用二级指针:</description></item><item><title>C语言的内存对齐</title><link>https://wangloo.github.io/posts/c/alignment/</link><pubDate>Mon, 08 May 2023 17:19:44 +0800</pubDate><guid>https://wangloo.github.io/posts/c/alignment/</guid><description>内存对齐为何被需要 架构规定了数据类型大小的同时，也规定了对这些类型的变量合法访问的对齐要求。 也就是说，变量不能随便的放在内存的任意位置，起始地址必须满足特定的对齐要求， 对不满足要求的变量强行访问就叫做非对齐访问， 非对齐访问通常会触发异常。
一般数据类型的对齐要求 对于一般的数据类型，比如 int, long, char 这些，要求其变量地址对齐到自身大小， 比如 ARM64 中，int 变量的地址必须对齐到 4 字节，long 变量地址必须对齐到 8 字节等等。
那么对于*(int *)0x1001 = 1234;, 这类的内存访问就叫非对齐的内存访问。
即 （变量 addr % 变量 size) ！= 0, 就称为非对齐内存访问。
结构体的对齐要求 上面说的还都是一般的数据类型，对于结构体这种复杂的类型，对齐的要求也复杂些。
首先是结构体成员，每个成员都必须满足其自身的对齐要求 然后是结构体变量自身的起始地址的对齐要求是其所有成员的最大对齐要求。 然而两个要求均满足有时候根本不可能，比如一个结构体声明为:
struct foo { char mem1; int mem2; short mem3; }; 不可能同时做到 foo 变量和其成员 mem2 同时满足对齐到 4 字节，所以编译器会依据 上面的两条要求在成员之间添加 padding。
除了变量中间添加 padding 外，在末尾也会添加，使得结构体数组容易满足对齐需求。
最后 foo 变量在内存中的样子可能是:</description></item><item><title>AArch64 内存属性与内存类型</title><link>https://wangloo.github.io/posts/armv8/memory_attr/</link><pubDate>Wed, 12 Apr 2023 08:01:33 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/memory_attr/</guid><description>有了虚拟内存系统之后，MMU 可以抽象出一些可配置的内存属性。
例如，配置某个虚拟内存区域为不可执行、不被 cache 等，不可执行的属性 有助于防范攻击，不进入 cache 经常划分给 外设 Memory-mapped 区域。
设置内存属性 相关内容可以在 ARMv8 arm 手册 D5.3.3 Attuibute fields in stage 1 VMSAv8-64 Block and Page descriptors 中找到参考
对于每一个表示内存块(block)的页表项，都有两个属性字段: lower attr 和 upper attr.
以下任何类型或者属性的设置都是通过这两个字段完成的。
大类: 内存类型 AArch64 提供两种内存类型: 普通内存和设备内存。
普通内存会启用架构提供的所有优化技术，例如合并访存、乱序执行等。所以 普通内存有最高的性能，但同时不是那么的“安全”，需要底层人员手动使用 内存屏障等手段保证某些情况下的顺序性要求。
设备内存，顾名思义，常映射到外设的 Memory-mapped 区域。对于设备来说， 那些提高性能的技术会造成一些问题，例如某些寄存器的配置必须按照顺序， 这时就不能使用乱序执行。设备内存就牺牲了性能，优先保证正确性。
配置内存类型也是通过页表项中的其中一个属性字段: AttrIndx[2:0], 它与系统寄存器MAIR_EL1配合实现。
具体表现为: mair_el1寄存器被划分为 8 个字段，我们为每个字段写入 不同的值可代表不同的内存类型和一些配套属性，具体的真值表可以参见 mair_el1寄存器的描述。
mair_el1中内存类型配套属性只是属性的一部分，是和设备类型绑定的 那部分。
更细分的描述(1): cacheable 内存支持配置为是否被 cache，这在mair_el1的字段中配置。</description></item><item><title>C语言enum的使用</title><link>https://wangloo.github.io/posts/c/enum/</link><pubDate>Thu, 09 Mar 2023 17:18:57 +0800</pubDate><guid>https://wangloo.github.io/posts/c/enum/</guid><description>枚举类型的优势 枚举类型完全可被宏定义替代，类如
enum Furniture { DOOR = 1, DESK, LOCK, } 与下面的代码等效
#define DOOR 1 #define DESK 2 #define LOCK 3 那么我们如何在两种设计方法中选择呢？在我看来某些情况下使用 enum 会有以下优势：
提高代码键入效率；仅适用于所需变量的值是连续的整数，就像上面的情况，可以只给第一个 DOOR 赋值，其余的值累加。如果首个变量的值要求是 0，甚至每一个都无需显式赋值 提高代码的可维护性；可以划定范围，编译器也会检查类型是否正确，偶尔会有用 提高代码的可读性；例如 DOOR, DESK, LOCK&amp;hellip; 都属于家具，均定义在 Furniture 中 枚举类型所占的大小 枚举类型所占内存的大小，即枚举变量的大小。
由于枚举变量的赋值，一次只能存放枚举结构中的某个常数。所以 枚举变量的大小，实质是常数所占内存空间的大小（常数为 int 类型，当前主流的编译器中一般是 32 位机器和 64 位机器中 int 型都是 4 个字节），枚举类型所占内存大小也是这样。
所以默认情况下，无论枚举变量的值是多少，都是占用 4 个字节。即执行：
printf(&amp;#34;sizeof(enum Furniture) = %d\n&amp;#34;, sizeof(enum Furniture)); 输入的结果是 4。
编译选项：-fshort-enums GCC 下关于这个编译选项的介绍：
-fshort-enums Allocate to an enum type only as many bytes as it needs for the declared range of possible values.</description></item><item><title>C语言的特点与难点</title><link>https://wangloo.github.io/posts/c/feature/</link><pubDate>Thu, 09 Mar 2023 17:18:57 +0800</pubDate><guid>https://wangloo.github.io/posts/c/feature/</guid><description>函数指针 指针的数组 or 指向数组的指针? &amp;gt;&amp;gt; int (*p)[10] p是指针, 指向长度为10的数组. 加括号是为了强调p是一个指针, 区别包含10个指针的array. &amp;gt;&amp;gt; int *(p[10]) p是数组, 它的元素类型是int *, 加括号是为了强调p是数组. &amp;gt;&amp;gt; int *p[10] 等效于int *(p[10]) 基础架构 // 函数指针 &amp;gt;&amp;gt; int (*f)(int) 说明f是一个指向函数的指针, 加括号为了区别返回值为int*的函数 &amp;gt;&amp;gt; f = function; 函数指针的赋值 &amp;gt;&amp;gt; (*f)(x) 函数指针指向函数的调用, 可简化为f(x). 但是容易将f误认为是函数. // 函数指针的数组 &amp;gt;&amp;gt; int (*(f[10])) (int) f是数组,元素为10个函数指针. 内层括号说明f是数组,外层括号说明元素类型是函数指针 &amp;gt;&amp;gt; int (*f[10]) (int) 与上面等效. 但外层括号不能省略 &amp;gt;&amp;gt; f[0] = function() 赋值 &amp;gt;&amp;gt; (*f[0])() 指向函数的调用, 可简化为f[0]() // 返回函数指针的函数 &amp;gt;&amp;gt; void (*signal(int sig, .</description></item><item><title>C语言程序设计的一些经验</title><link>https://wangloo.github.io/posts/c/experience/</link><pubDate>Mon, 27 Feb 2023 19:20:20 +0800</pubDate><guid>https://wangloo.github.io/posts/c/experience/</guid><description>头文件的引用形式 C 中引用一个头文件有两种形式 #include &amp;lt;&amp;gt;和#include &amp;quot;&amp;quot;，在应用开发中，需要引用一些系统库文件，我们通常使用&amp;lt;&amp;gt;，对于自己定义的头文件，我们会使用&amp;quot;&amp;quot;。
然而对于底层软件的开发，比如说操作系统，用到的库都是自己工程中的文件，那么此时用&amp;quot;&amp;quot;和&amp;lt;&amp;gt;有时都能 work，那么它们的区别是什么呢？
搜索相关关键词得到的结论是: 两种方式的区别是搜索文件的优先级， &amp;quot;&amp;quot;优先搜索的当前目录，而&amp;lt;&amp;gt;优先搜索系统库文件目录。对于这个系统库，即那些使用gcc -I&amp;lt;dir&amp;gt;参数指定的路径。 当然，如果第一优先级位置没有被找到，也会到另一个目录中搜索。这么两种方式均可，实际工程中也有部分人混合使用，毫不在意规则。但是有时会导致一些细节问题，比如说我们经常会用到-MMD或者类似选项生成目标文件的依赖，方便实现增量编译。此时就可能会产生一些问题。
假设你有一个头文件inc/father.h, 它里面会引用inc/child.h, 对于根目录下的源文件main.c，其引用语句该如何写呢？以下列出的几种形式都可以，任意的排列组合
// 编译参数: -I. -MMD // main.c #include &amp;#34;inc/father.h&amp;#34;#include &amp;lt;inc/father.h&amp;gt; // father.h #include &amp;#34;inc/child.h&amp;#34;#include &amp;lt;inc/child.h&amp;gt;#include &amp;#34;child.h&amp;#34;#include &amp;lt;child.h&amp;gt; 如果 main.c 是使用系统库路径(-I.)来找到的 father.h, 即上面 main.c 的第 2 种情况，那么其生成依赖文件的形式内容都是绝对路径，包括 father.h 中的引用（因为即便 child.h 是相对路径找到的，相对的也是 father.h，其基准就是绝对路径）。例如:main.o: main.c /home/xx/father.h /home/xx/child.h 否则即以相对路径找到 father.h,即上说 main.c 的第 1 种，那么生成 father.h 依赖的方式一定是相对路径，但 child.h 的形式却取决于其本身. 也就是说，如果 child.h 的寻找方式是绝对的（上面的第 1,2,4 种），那么依赖文件的形式就是main.o: main.c inc/father.h /home/xx/child.h. 如果 child.h 的寻找方式是相对的(上面的第 3 种)，那么依赖文件的形式是main.</description></item><item><title>行结束符在windows和linux的区别</title><link>https://wangloo.github.io/posts/c/end-of-line/</link><pubDate>Sat, 24 Dec 2022 01:35:24 +0800</pubDate><guid>https://wangloo.github.io/posts/c/end-of-line/</guid><description>使用VIM 打开一个文件时, 有时会看到例如 ^M 这类字符出现. 下面我会挖一下其出现的原因.
EOL 字符 EOL 或者说 end-of-line 表示一个新行的开始.
EOL 字符在不同的操作系统中是不同的. 本文中仅以 Linux 和 Windows 为例说明.
Windows中是以读到回车&amp;lt;CR&amp;gt;和换行&amp;lt;LF&amp;gt; 表示 EOL. Linux 中仅以换行作为EOL 回车&amp;lt;CR&amp;gt; : Carriage return. 将光标回到行首, 对应C语言中的 \r 换行&amp;lt;LF&amp;gt; : Line feed. 将光标下移一行, 对应C语言中的 \n 在 Linux 中打开 Windows 下的文件将多余的回车通常显示成 ^M 或者 Control-M
Ref End Of Line Characters</description></item><item><title>浅谈 errno 的线程安全问题</title><link>https://wangloo.github.io/posts/os/errno_thread_safe/</link><pubDate>Wed, 21 Dec 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/os/errno_thread_safe/</guid><description>我始终以为，C库中常用的 errno 仅是一个全局变量，使用了全局变量就无法保证线程安全了，因为全局变量在所有线程中都是共享的。
要实现线程安全的errno 就必须将其设置为线程私有的变量，下面就来看看GCC是如何巧妙的实现的。
正文 现在的errno定义并非一个全局变量, 而是一个宏定义, 以下是在usr/include/errno中的声明:
extern int *__errno_location (void); # define errno (*__errno_location ()) 这种方式下其实现原理大概是: __errno_location 函数返回一个int指针, 而这个函数的实现中, 返回的就恰好是实际的errno 变量(与宏同名)的地址, 所以对其解引用就相当于对其值进行操作. 所以, 这种定义规则下, 左值和右值表达式均成立.
errno = 10; // *__errno_location () = 10 int x = errno; // x = *__errno_location (); __errno_location 的实现就至关重要, 因为如果其返回的变量地址不包含任何技巧的话, 就和原先直接定义全局变量的方式没差了, 说到底能否实现线程安全, 还得看实际保存errno的变量是否为线程独有的. 目前还没有发掘到其精髓, 只是套壳而已.
以下给出/csu/errno-loc.c中__errno_location 的实现, 与我们预期一致, 返回变量的地址. 而同名变量errno则定义在/csu/errno.c中, 决定了能够实现errno的线程安全.
int * __errno_location (void) { return &amp;amp;errno; } __thread int errno; &amp;ldquo;__thread&amp;rdquo; 是GCC提供的扩展前缀, 表示该变量将被库处理为线程私有的, 注意这一步是C库完成的, 对程序员透明.</description></item><item><title>git 宝典</title><link>https://wangloo.github.io/posts/tools/git/git/</link><pubDate>Tue, 13 Dec 2022 17:39:42 +0800</pubDate><guid>https://wangloo.github.io/posts/tools/git/git/</guid><description>合并操作: git merge merge 有两种方式:
fast-forward three-way merger Fast-forward Merge 假设合并的双方为main为dev, 如果其中一个是另一个的祖先, 此时直接移动 HEAD 到前方即可, 称为 fast-forward.
例如, 当前在 main, 执行git merge dev的过程如下:
main main | | M1 --- M2 ===&amp;gt; M1 --- M2 -- F1 \ | \--- F1 dev | dev three-way Merge 合并的两者不构成直接的祖先-孩子关系, 产生了分叉. 此时进行合并就需要有个基准(参考), 对于两边相较于基准的每个 diff 来说:
合并的两者都在基准上进行了改动, 且改动不一致, 标记为冲突 如果该 diff仅在其中一方有改动, 那么就保留此次改动 合并时使用的参考就是两个合并 commit 的最近公共祖先, 这种借助三个 commit(main, dev, 公共祖先)才能完成的合并操作就叫做 three-way merge.</description></item><item><title>GNU 二进制工具集</title><link>https://wangloo.github.io/posts/os/gnu_tools/</link><pubDate>Sat, 03 Dec 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/os/gnu_tools/</guid><description>..
nm - 列出符号 nm (GNU Binary Utilities) (sourceware.org)</description></item><item><title>Makefile 一些技巧</title><link>https://wangloo.github.io/posts/c/makefile_tricks/</link><pubDate>Sat, 03 Dec 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/c/makefile_tricks/</guid><description>伪目标的依赖关系 Makefile 中的依赖关系指的是目标和依赖之间建立的关系，目标对应规则中的语句是否执行取决于依赖的状态。
最简单的依赖关系可以拿两个文件来举例:
# gcc语句执行当前仅当 main.c 新于 main.elf main.elf: main.c gcc main.c -o main.elf make 在执行main.elf的规则时，会先判断依赖关系。拿上面的例子来说， gcc 语句是否执行取决于main.c 和 main.elf的修改时间，只有当 依赖新与目标时，规则语句才会执行。
然而许多情况下，目标或者依赖并不是一个文件，而是虚拟目标。虚拟目标 并不是一个文件，即它没有修改时间这个属性，此时 make 就不能作比较，结果就是 如果目标是伪目标，那么不管依赖如何都执行规则语句；如果依赖是伪目标， 那么目标的规则语句也永远被执行。下面是两个例子：
# 伪目标作为目标文件出现 # build finish总是输出， 而gcc语句仅当main.c比main.elf新时才执行 .PHONY : all all: main.elf @echo &amp;#39;build finish&amp;#39; main.elf: main.c gcc $&amp;lt; -o $@ # 伪目标作为依赖文件中出现 # 不管main.c是否比main.elf更新，因为pre-work是伪目标 # 所以gcc语句总是执行 .PHONY : pre-work main.elf: main.c pre-work gcc $&amp;lt; -o $@ 上面的代码的效果是：两条规则中的语句都会执行，即使你并没有对 main.c 做任何修改！</description></item><item><title>Uboot: 常用命令</title><link>https://wangloo.github.io/posts/os/uboot/commands/</link><pubDate>Sun, 27 Nov 2022 22:03:48 +0800</pubDate><guid>https://wangloo.github.io/posts/os/uboot/commands/</guid><description>..
环境变量相关 内存操作 网络操作 EMMC和SD卡 BOOT操作指令 bootm go 其他命令 启动相关
md
mmcinfo
cp</description></item><item><title>常用的 shell 命令</title><link>https://wangloo.github.io/posts/shell/shell-commands/</link><pubDate>Sun, 27 Nov 2022 14:45:58 +0800</pubDate><guid>https://wangloo.github.io/posts/shell/shell-commands/</guid><description>我使用的 shell 是 Bash
mount 相关 mount 输出当前已经挂在的分区
where and which which 查看可执行文件的位置
$ which python3 /usr/bin/python3 whereis 除了可执行文件还能搜索其他类型的文件, 不常用, 详见 man whereis
- 的妙用 一些命令支持使用 - 代替文件名, 输入输出都可以:
代替标准输出; 一些命令会将-o/-O 后面的-判定为输出到STDOUT, 详见下面示例. 代替标准输入; 下面给出两个同时代替输入输出的例子:
# 将标准输入(STDIN)的内容作为gcc的输入, 编译后的结果输出到标准输出(STDOUT) echo &amp;#39;void foo() {}&amp;#39; | gcc -x c -o - - # 将下载的文件输出到标准输出, 同时作为tar命令的输入文件, 进行解压 wget -O - &amp;#34;https://www.dropbox.com/download?plat=lnx.x86_64&amp;#34; | tar xzf - - 如何被解析是取决于命令的实现, 非标准. 比如 cd - 就有特殊的含义</description></item><item><title>C语言 'inline' 关键字</title><link>https://wangloo.github.io/posts/c/inline/</link><pubDate>Thu, 24 Nov 2022 01:35:24 +0800</pubDate><guid>https://wangloo.github.io/posts/c/inline/</guid><description>TODO: inline 的发展历程: Myth and reality about inline in C99 – Jens Gustedt&amp;rsquo;s Blog (wordpress.com)
GNU89: 函数的实现之前添加不同的关键字:
inline: 表明这个函数可能被优化. 如果没有被优化, 编译器就会视为一个常规函数的定义.
extern inline: 表明这个函数可能被优化. 如果没有被优化, 编译器就将这个函数的定义转换为该函数的声明, 即 extern inline func(); 因此当此函数被调用时, 可以调用一个外部的函数来替代. 如果没有函数调用它, 那么也可以没有外部的替代函数实现.
static inline: 表明这个函数可能被优化. 如果没有被优化, 编译器就会视为一个常规静态函数.
C99: 函数的实现之前添加不同的关键字:
inline: 等效于gnu89中的extern inline extern inline: 等效于gnu89中的inline static inline: 与gnu89相同含义. C++: 只有inline一个关键字, 如果不能优化就定义为普通函数
Ref:
c++ - What does extern inline do?</description></item><item><title>C语言工具宏</title><link>https://wangloo.github.io/posts/c/c-macros/</link><pubDate>Thu, 24 Nov 2022 01:35:24 +0800</pubDate><guid>https://wangloo.github.io/posts/c/c-macros/</guid><description>计算数组元素的个数 #define nelem(array) sizeof(array)/sizeof(array[0])</description></item><item><title>x86/ARMv8 函数调用约定</title><link>https://wangloo.github.io/posts/os/function-call-conventions/</link><pubDate>Mon, 21 Nov 2022 10:30:35 +0800</pubDate><guid>https://wangloo.github.io/posts/os/function-call-conventions/</guid><description>符合调用约定使得调用函数能够正常获取参数, callee结束之后能够回到原来位置继续执行.
X86 调用约定 函数调用 x86架构中, 函数调用以一条call指令为分界.
在call指令执行之前, 所有的参数必须都躺在栈中, 参数入栈的规则是: 第一个参数最后入栈.
另外, 执行call指令之前, 必须确保栈指针esp是16-byte对齐. 这项工作是编译器完成的, 如果它判断参数入栈之后的esp 不满足对齐条件, 则会手动调整esp使之对齐. 实现方式见下面例子.
call 指令的语义是:
push pc+1 ;push next insttuction mov pc, func ;set pc = new function call 指令之后的下一条指令就是callee的内容了, 至此就算是进入新函数的地盘.
但是在执行新的任务之前, callee还需要完成栈的转换, 因为此时使用的栈还是caller的.
push ebp ;preserve location of caller&amp;#39;s stack mov ebp, esp ;new ebp is old esp 此时esp也就是栈指针等于ebp, 这是callee栈的初始条件. 万事俱备, 可以开始执行callee的实际任务了.
ebp在整个函数执行过程中是固定的, 好处是: 能够快速的或者函数参数, 返回地址.
函数返回 callee执行完毕后, 需要返回到caller继续执行. 刚才说过, callee的返回地址在栈中, 所以我们要做的是找到返回地址所在的位置, 然后使pc = 返回地址.</description></item><item><title>二级指针操作链表</title><link>https://wangloo.github.io/posts/c/pointers-pointers-list/</link><pubDate>Sun, 20 Nov 2022 23:40:30 +0800</pubDate><guid>https://wangloo.github.io/posts/c/pointers-pointers-list/</guid><description>问题源于我在知乎刷到的一个回答: 能分享你C指针用得最灵活（飘）的一次吗?
文中提到了Linus关于无头节点单项链表的删除操作给出的一种新的思路, 我觉得对理解指针非常有帮助, 所以在这里详细描述一下这件事.
从我学习数据结构起, 对不含头节点的单向链表的删除操作, 做法常是: 借用pre指针搜索. 这种情况下避免不了对于链表中第一个节点的特判(第一个节点没有pre).
Linus提到了一种借助二级指针避免该分支的方法.
void remove_if(node ** head, remove_fn rm) { for (node** curr = head; *curr; ) { node * entry = *curr; if (rm(entry)) { *curr = entry-&amp;gt;next; free(entry); } else curr = &amp;amp;entry-&amp;gt;next; } } 指针的内容就是地址, int *p = a 也就意味着变量p 中保存着变量a的地址. 所以参数head在内存中的含义为:
假如要删除node2, 那么改变*curr实际上就是改了node1的next成员.</description></item><item><title>大小端问题</title><link>https://wangloo.github.io/posts/os/big-little-endian/</link><pubDate>Thu, 17 Nov 2022 10:30:35 +0800</pubDate><guid>https://wangloo.github.io/posts/os/big-little-endian/</guid><description>大小端问题的由来 为什么计算机世界需要区分大小端? 内存里存取的单位是字节, 如果所有的数据类型长度都是一个字节, 那就完全不需要大小端了, 每个变量都仅占据单独一个字节.
例如, 三个变量 a=10, b=20, c=30, 在内存中的布局可能就是:
┌────────────┐ │ │ │ 10 │ a ├────────────┤ │ │ │ 20 │ b ├────────────┤ │ │ │ 30 │ c ├────────────┤ │ │ │ │ │ │ │ │ │ │ └────────────┘ 但是我们最常使用的数据类型肯定有超过一个字节的, int类型在64位的系统中就占4个字节. 例如变量a=0xaabbccdd
一个变量的大小一旦超过4个字节, 内存的存取又是以字节位单位的, 那么要把它塞到内存里就必然会产生两种不同存放方式: 先放0xaa还是先放0xdd
首先, 0xdd是变量a的低8位, 0xaa是最高8位, 这是确定的.
如果先放0xaa, 即低地址放高位, 就叫做大端, 如左图;
如果先放0xdd, 即低地址放低位, 就叫小端, 如右图.</description></item><item><title>操作系统——上下文切换</title><link>https://wangloo.github.io/posts/os/context/</link><pubDate>Mon, 14 Nov 2022 22:13:06 +0800</pubDate><guid>https://wangloo.github.io/posts/os/context/</guid><description>本文基于AArch64执行环境, 介绍现代操作系统中上下文切换的相关内容.
什么是上下文？ 上下文又称“现场”,
为什么需要上下文切换? (TODO: 为什么说线程是调度的单位?)
现代操作系统中同时存在着成千上百个线程, 但是一个CPU同一时刻只能运行一个线程, 他们是轮流的占用CPU, 也叫并发执行. (TODO: 如何查看线程切换的间隔?) 线程高频率的切换, 操作系统是如何保证切换到下一个执行的线程时, 它能够继续上次的工作呢?
什么是上下文? 我们正在看一本书的时候如果被其他的事情打断, 返回时为了能够从上次被打断的位置继续读, 就要在被打断的时候记下来当前是读到了哪个第几页的第几行.
操作系统对待线程也是如此, 需要保存的用于恢复线程执行的信息就称为线程的上下文.
那么对于线程来说需要记下的内容有什么呢? 寄存器和栈即可. 拿AArch64架构来距离, 线程的上下文就是:
通用寄存器x0-x29: 函数调用的参数, 某些计算过程的中间值, 都要用到这些寄存器. 线程的执行流可能在任何时候被打断, 当然这些内容也不能丢. 通用寄存器lr(x30): lr 保存着返回地址, 即当前函数结束之后该返回到哪执行. 栈顶指针 sp: 栈的重要性无需多言. 但是需要说明的是我们保存栈的方式并非将栈中的所有内容保存, 而是保存栈的位置即可. 因为操作系统有别的机制(TODO), 能够保证即便线程不在执行, 属于该线程的栈也不会被破坏. 程序计数器 pc: 被打断的线程如果再次执行, 从哪里执行呢? 显然是被打断指令的下一条(或者重新执行当前). 这个指令的地址当然也需要被保存好. PSTATE: 想一下, 有了以上的内容就能够保证线程完整的恢复之前的环境吗? 其他的例如中断是开还是关, 有哪些标志位(NZCV)被设置了. 这些信息在AArch64中是保存在PSTATE的各个字段中. 如果我们能够有一个适当的逻辑, 在线程切换出去的时候将上下文保存起来, 然后恢复新线程的上下文, 是不是线程切换这件事就能做到了. 如何组织这个保存和恢复的过程在下面会介绍到.
Linux 如何处理上下文切换 另一种处理上下文切换的思路 协程的上下文 协程是用户级别的线程,
协程之间的切换不进入内核 切换协程只能是某个协程主动放弃控制权 我们在这里讨论一下协程切换时需要保存的上下文是否与线程有所不同.</description></item><item><title>基于ARM64实现setjmp/longjmp</title><link>https://wangloo.github.io/posts/c/setjmp_and_longjmp/</link><pubDate>Tue, 01 Nov 2022 23:38:54 +0800</pubDate><guid>https://wangloo.github.io/posts/c/setjmp_and_longjmp/</guid><description>介绍 setjmp() and longjmp() 是一对组合使用的函数, 可以实现全局的goto.
setjmp() 构造一个运行环境, 调用longjmp() 则将执行流切换到该环境.
/* setjmp() 保存当前的运行环境(上下文)到 env 参数中 */ int setjmp(jmp_buf env); /* longjmp() 将控制流切换到 env 指定的运行环境 */ void longjmp(jmp_buf env, int val); 使用方法 #include &amp;lt;setjmp.h&amp;gt;#include &amp;lt;stdio.h&amp;gt; jmp_buf e; void foo() { longjmp(e, 1); } int main(void) { int ret; /* After calling longjmp(), the execution flow back to setjmp(), and setjmp() will return not 0. */ ret = setjmp(e); if (ret == 0) { printf(&amp;#34;Return from setjmp\n&amp;#34;); foo(); } else { printf(&amp;#34;Return from longjmp\n&amp;#34;); } return 0; } 基于 AArch64 的实现 需要保存的上下文包括</description></item><item><title>Armv8 Kernel Monitor</title><link>https://wangloo.github.io/posts/os/monitor/</link><pubDate>Fri, 28 Oct 2022 22:56:19 +0800</pubDate><guid>https://wangloo.github.io/posts/os/monitor/</guid><description>Kernel Monitor 是什么 Kernel Monitor 是一个适配我们微内核操作系统的 Kernel 调试和监控系统. 它能实现内核的动态调试和监控. 同时, 它还接管内核的同步异常和系统错误, 使开发者能够了解发生异常时系统的状态.
Kernel Monitor 具有一定的可扩展性, 例如通过统计内核中存储的 TCB 来实时监控系统中所有线程的状态. 可根据开发者的需求添加统计的对象, 如 Endpoint, Capability等.
 Kernel Monitor 总体设计 Kernel Monitor 系统包含 Clinet 和 Server 两个部分. 简单来说, Client 负责处理用户输入, 并将输入进行解析, 封装为 一系列基础命令. 发送给 Server. Server 负责执行这些 基础的命令, 如设置断点, 查看某个地址的值等.
整个系统有两种架构: 本地 Monitor 和远程 Monitor.
本地monitor 和远程 monitor 的区别是: Monitor Client 的位置在哪, 是否与 Server 在同一个机器上.
先说 Monitor Server, 它必须嵌入要调试的 Kernel 中, 位于一个地址空间, 方便操作 Kernel 的内存.</description></item><item><title>ARMv8-A MMU介绍</title><link>https://wangloo.github.io/posts/armv8/mmu/</link><pubDate>Thu, 29 Sep 2022 08:01:33 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/mmu/</guid><description>Introduction MMU: 专用于将虚拟地址转换为物理地址. 通常配合分页机制来工作.
页表: 页表中的表项包含提供虚拟地址和物理地址之间的映射.
MMU就是直接访问页表, 并且通过将频繁使用的映射缓存到TLB中.
MMU 的结构 MMU是一种硬件, 可以通过在适当的安全状态下对其进行配置. 每个Core都有自己的MMU, 每个MMU包括:
一个TLB, 缓存最近访问的映射. 一个Table Walk Unit, 从内存中查询页表, 得到最终的虚拟地址-物理地址的映射. MMU 控制着整个系统的缓存策略, 内存属性和访问权限. MMU开启后, 软件发出的所有内存访问都使用虚拟地址, 要求MMU为每次访问进行地址转换.
MMU 的配置 在启用MMU前, 必须告知其页表存放的位置.
MMU 地址转换的过程 对于每个转换请求, MMU首先检查TLB是否已经对该地址缓存, 如果该地址未缓存, 则需要遍历页表.
页表遍历单元在页表中搜索相关的映射表项.
一旦找到映射, MMU就会检查权限和属性. 决定允许本次访问, 或者发出故障信号. 若未找到映射, 则触发缺页异常. 页表的工作原理 页表的工作方式是将虚拟地址空间和物理地址空间划分为大小相等的块, 称为页面.
页表中的每个表项对应着一块虚拟地址空间中的块, 表项的值就是这块虚拟地址空间对应的物理地址块, 以及访问物理地址时要使用的属性.
在查表过程中, 将虚拟地址分为两部分:
高阶位用作页表的索引. 用来找到对应的物理块 低地址是块内的偏移量, 不会因为映射而改变. 页表项中的物理地址与该偏移组合形成用于访问内存的物理地址. 多级页表 实际实现中, 多采用多级页表的方案, 各级页表自定向下组成树的形式, 协作实现虚拟到物理地址的转换.
树中的分支成为页目录, 页目录中的表项不是直接存储目标物理地址, 而是下一级页表的地址; 最后一级页表的表项中保存着目标物理地址.</description></item><item><title>AArch64/32 异常返回过程</title><link>https://wangloo.github.io/posts/armv8/exception_return/</link><pubDate>Sat, 24 Sep 2022 21:19:01 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/exception_return/</guid><description>ARMv8 异常返回指令 当异常处理程序结束后，需要执行异常返回指令恢复进入异常之前的状态.
具体要做的事情包括:
恢复发生异常前的PC
从SPSR中恢复PSTATE寄存器(现场)
异常返回的指令根据当前执行状态为AArch32还是AArch64有所不同.
AArch32 AArch32的异常返回指令在不同的模式下也有所不同:
若异常是在Hyp模式下处理: 仅可执行ERET指令从异常返回.
若异常是在其他模式下处理, AArch32提供了以下的异常返回指令:
ERET 指令
使用带S后缀的数据处理指令直接操作PC(例如, MOVS, PC, LR), 恢复PSTATE
RFE 指令: RFE &amp;lt;Rn&amp;gt;. 从基址寄存器指向的地址依次加载PC和PSTATE
LDM 指令: LDM &amp;lt;Rn&amp;gt; {pc..}. 若目标寄存器中包含PC, 则会同时恢复PSTATE
AArch64 AArch64下统一使用 ERET 指令进行异常返回.
指令格式及用法参考 ERET ERET指令完成了:
从ELR_ELx中恢复PC指针
从SPSR_ELx中恢复PSTATE寄存器的状态.
LDM(Load Multiple) 格式: LDM &amp;lt;Rn&amp;gt; {registers}
含义: 从基址寄存器&amp;lt;Rn&amp;gt;指向的地址开始依次加载多个寄存器值.</description></item><item><title>GNU C内联汇编学习笔记</title><link>https://wangloo.github.io/posts/c/inline-asm/</link><pubDate>Sat, 24 Sep 2022 16:48:58 +0800</pubDate><guid>https://wangloo.github.io/posts/c/inline-asm/</guid><description>语句结构 asm asm-qualifiers ( AssemblerTemplate : OutputOperands : InputOperands : Clobbers : GotoLabels) The asm keyword is a GNU extension. 当使用编译选项 -ansi 或 -std 时, 使用 __asm__代替 asm.
Qualifiers volatile: 避免编译器的过分优化 goto inline Parameters AssemblerTemplate: 字符串, 汇编代码的模板
OutputOperands: 输出操作数; 指令将会修改的变量集合
InputOperands: 输入操作数; 指令将读取的变量集合
Clobbers: ???TODO
GotoLabels: 仅当 qualifiers 使用goto时, 声明label集合.
The total number of input + output + goto operands is limited to 30.</description></item><item><title>GICv3 介绍</title><link>https://wangloo.github.io/posts/armv8/gicv3/</link><pubDate>Sat, 10 Sep 2022 21:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/gicv3/</guid><description>GICV3(Generic Interrupt Controller - version 3) 关于GIC GIC即中断控制器, 负责管理中断的接收, 屏蔽, 路由等相关任务, 并向系统程序员提供配置的接口.
GIC与异常模型协作完成中断的整个生命周期, GIC主要负责中断源-产生IRQ/FIQ信号这段路, 关于处理IRQ/FIQ则是由CPU内部的异常模型来完成.
对比 GICv2 支持更多的处理器, 用affinity routing 方案来做中断路由. 支持中断分组, 为了配合ARMv8的异常等级模型 新增中断类型: SGI, 软件生成中断 新增中断类型: SPI, Shared Peripheral Interrupts 对于CPU interface的寄存器, 可直接使用系统寄存器接口(system register interface)来访问, 比memory-mapped的方式快. ITS, Interrupt Translation Service 暂不介绍 LPI, Locality-specific Peripheral Interrupts . 暂不介绍 GICv3支持ARMv8-A或ARMv8-R系列处理器, 但没有必然的绑定关系. ARMv8-A也可以使用GICv2.
中断类型 Locality-specific Peripheral Interrupt (LPI) LPIs are always message-based interrupts interrupts. 这里不做介绍.wiki
Private Peripheral Interrupt (PPI) PPI是路由到单个CPU的外设中断, 不同的CPU可以使用相同的中断号.</description></item><item><title>武器库: shell scripts</title><link>https://wangloo.github.io/posts/shell/shell-script/</link><pubDate>Wed, 20 Jul 2022 11:54:13 +0800</pubDate><guid>https://wangloo.github.io/posts/shell/shell-script/</guid><description>ℹ️ 以下命令/脚本的执行环境均为 bash.
统计代码量 使用到的命令包含: find, wc, xargs, sort 等
列出所有的文件及其代码行数, 只统计.c 和.h, 过滤./scripts目录.
find -name &amp;#39;*.[c|h]&amp;#39; ! -path &amp;#39;./scripts/*&amp;#39; | xargs wc -l +将内容按照代码行数降序排列
find -name &amp;#39;*.[c|h]&amp;#39; ! -path &amp;#39;./scripts/*&amp;#39; | xargs wc -l | sort -rn 若仅列出总的代码行数, 去除空行
(find ./ -name &amp;#39;*.[c|h]&amp;#39; -print0 | xargs -0 cat) | sed &amp;#39;/^\s*$/d&amp;#39; | wc -l 删除目录下所有的可执行文件 find . -maxdepth 1 -executable -type f | xargs rm 判断执行脚本时带的参数 if [ $# -ne 1 ]; then echo &amp;#34;ONE parameter is needed&amp;#34; exit -1 fi if [ $1 == &amp;#39;build&amp;#39; ]; then # do something elif [ $1 == &amp;#39;run&amp;#39; ]; then # do something elif [ $1 == &amp;#39;gdb&amp;#39; ]; then # do something else echo &amp;#34;Not supported command&amp;#34; fi 自动拷贝文件到 SD Card TODO</description></item><item><title>C 语言位操作技巧</title><link>https://wangloo.github.io/posts/c/bitops/</link><pubDate>Sun, 03 Jul 2022 09:44:13 +0800</pubDate><guid>https://wangloo.github.io/posts/c/bitops/</guid><description>连续内存取n bit #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdint.h&amp;gt;#include &amp;lt;assert.h&amp;gt; #define bitmask(n) ((1ul &amp;lt;&amp;lt; (n)) - 1) /* * 从ptr指向的内存开始，抽取第start个bit开始的连续n个bit * 限制: n &amp;lt; 32 */ uint32_t extract_bits(uint8_t *ptr, uint32_t start, uint32_t n) { uint32_t start_byte = start / 8; uint32_t start_offset = start % 8; uint32_t *pstart = (uint32_t *)(ptr + start_byte); uint32_t end = start + n - 1; uint32_t end_byte = end / 8; uint32_t end_offset = end % 8; uint32_t *pend = (uint32_t *)(ptr + end_byte); uint32_t data = *pstart &amp;gt;&amp;gt; start_offset; if (n &amp;gt; 32 - start_offset) { /* 由于n &amp;lt; 32, 所以补齐*pend一定就够了， * end_offset对齐到最后一位(n-1).</description></item><item><title>Stack and Heap</title><link>https://wangloo.github.io/posts/os/stack-and-heap/</link><pubDate>Tue, 28 Jun 2022 16:41:54 +0800</pubDate><guid>https://wangloo.github.io/posts/os/stack-and-heap/</guid><description> 堆的含义 我们都知道malloc动态申请的变量是存放在堆中. 所以相比栈来说, 堆是动态的.
堆占据进程虚拟地址空间的大部分, 我们可能通过堆来申请1GB的数组, 但是栈通常不行 , 大多也就几兆的空间.
 堆空间的管理 进程中堆空间的管理是运行库负责的, 在Linux中是GLIBC.
运行库在初始化时会像操作系统申请一大块的堆空间, 再为每个进行分别分配需求. 当然, 如果某些程序的需求过大, 运行库也可以使用mmap系统调用直接向操作系统申请, 然后 返回给用户进程.
GLIBC的malloc函数的处理方式是: 对于小于128KB的申请, 会从运行库&amp;quot;批发的&amp;quot;堆空间 里分出一块来; 但若申请的空间过大, 则使用mmap系统调用来创建匿名空间分配给用户.
Linux中虚拟地址块(VMA)的管理使用了红黑树, 可以用于运行库管理自己向操作系统 &amp;ldquo;批发&amp;quot;的堆空间. 使得用户程序动态申请和释放内存性能提高.</description></item><item><title>动态链接</title><link>https://wangloo.github.io/posts/os/dynamic-link/</link><pubDate>Sun, 26 Jun 2022 19:50:45 +0800</pubDate><guid>https://wangloo.github.io/posts/os/dynamic-link/</guid><description>静态链接带来的问题 像是libc这种几乎每个程序都要用到的库, 如果是静态的, 那么不仅意外着每个程序的 可执行文件很大, 浪费磁盘空间. 并且当程序加载到内存时, 可能许多程序都会用到printf , 使得内存中会存在好多份的printf源码.
维护和更新难. 一旦静态链接的其中一个目标文件更新, 所有的可执行程序都要重新链接.
不满足局部性原理. 上面提到, 内存中同时存在多份的printf源码会破坏局部性原理的. 显然如果所有的程序共享一份printf源码的想法更好. 即动态加载.
可移植性差. 静态链接, 只要有一个依赖目标文件的实现不同, 软件厂商就得专门发布一个 版本. 而动态链接则信赖客户电脑上的动态库, 相当于一个中间层.
 动态链接的过程 对比静态链接使用ld链接器在编译后即执行链接, 动态链接则是将链接过程推迟到运行时, 即装载到内存时.
这样, 链接器在链接产生可执行文件时就有两种做法:
对于静态符号, 按照静态链接的规则进行地址引用重定位 对于动态符号, 链接器则仅标记其为动态链接中的符号, 不进行处理. 而是等到装载时由 专门的动态链接器来完成动态符号的链接工作. ⁉️ 链接器如何确定一个符号是静态的or动态的?
在动态共享对象(.so)中保存了完整的动态符号表*, 表中存在的符号即为动态的, 否则为静态.
Linux的C语言运行库glib的动态链接版本叫libc.so. 它在外存上只保存一份, 所有的程序 都可以在运行时使用它. 所以千万不要删掉它.
动态链接有一定的性能损失, 因为每次运行程序时都要重新链接, 并不像静态链接是一劳永逸的. 也有例如延迟绑定对性能进行优化的方法, 大概仅有5%的损耗, 与带来的便利相比可以忽略不计.</description></item><item><title>ELF 文件的链接与加载</title><link>https://wangloo.github.io/posts/os/elf-format/</link><pubDate>Mon, 20 Jun 2022 16:21:27 +0800</pubDate><guid>https://wangloo.github.io/posts/os/elf-format/</guid><description>ELF is a file format Files in ELF format includes:
Type description 实例 Relocatable File 这些文件包含了代码和data, 可以被用来链接成可执行文件或共享目标文件. .o, .a Executable File 直接可执行的文件 /bin/ls Shared Object File Including code and data. 链接器可将其与其他Relocatable File或Shared Object File结合, 生成新的目标文件. 动态链接器可将其与Executable File结合, 作为进程映像的一部分来运行. .so Core Dump File Restore critical infomation when process is terminated unexpectedly core dump 📌 file command in Linux can output the format of a file.</description></item><item><title>写高质量的C语言工程的技巧</title><link>https://wangloo.github.io/posts/codestyle/improve_quality/</link><pubDate>Tue, 14 Jun 2022 17:59:22 +0800</pubDate><guid>https://wangloo.github.io/posts/codestyle/improve_quality/</guid><description>添加更多的编译选项(comiler options)来防止bug 对于我常用的GCC, 推荐开启一下的compiler options:
-Wall: enable a lot of common warnings
-Wno-format-truncation: warns about the snprintf output buffer not being large enough for a corresponding “%s” in the format string.
-Werror: turn warnings into errors.
 动态申请的空间到底要不要释放 When using a barebones embedded OS, you absolutely need to tightly manage your memory.
但是, 如果你是写应用业务的代码, 特别是在内存足够的场景下. 最好不要手动释放内存, 因为当线程/进程退出时, 操作系统会自动帮我们释放. 某些情况下, 释放内存的操作会很大程度上增加逻辑的复杂度.
如果你是一个内核程序员, 则必须手动的释放.</description></item><item><title>MicroKernel Learning: SeL4</title><link>https://wangloo.github.io/posts/microkernel/sel4/</link><pubDate>Sat, 04 Jun 2022 11:52:51 +0800</pubDate><guid>https://wangloo.github.io/posts/microkernel/sel4/</guid><description>seL4 Capabilities In seL4, capabilities are stored in C-space. C-space is a hierarchical data structure very similar to page table.
page table is a mapping from virtual address to physical address. C-space is a mapping from object ID to capability. Kernel object is made up of several C-nodes, just like a page table made up of individual page tables. Each C-nodes is an array of cap slots, which contain capability.</description></item><item><title>使用 HuGo 搭建个人网站</title><link>https://wangloo.github.io/posts/hugo/</link><pubDate>Sat, 21 May 2022 17:39:42 +0800</pubDate><guid>https://wangloo.github.io/posts/hugo/</guid><description>HuGo 基础学习 本章将解答Hugo是什么, 以及Hugo是如何工作的. 只有了解Hugo的工作机制之后, 才能发挥想象力进行DIY.
本章内容大多来自官方手册或者搜索引擎提供的结果.
Hugo 项目目录结构 一个hugo 项目通常包含以下内容:
. ├── archetypes ├── config.toml ├── content ├── data ├── layouts ├── public ├── static └── themes 这里面有些是必须的, 有些是可选的.
archetypes
定义新创建post时, header的格式.
asserts
Note: assets directory is not created by default.
config
Hugo uses the config.toml, config.yaml, or config.json (if found in the site root) as the default site config file.
The user can choose to override that default with one or more site config files using the command-line --config switch.</description></item><item><title>2019 Stanford Commencement Timcook</title><link>https://wangloo.github.io/posts/motivation/2019-stanford-commencement-timcook/</link><pubDate>Wed, 18 May 2022 19:32:38 +0800</pubDate><guid>https://wangloo.github.io/posts/motivation/2019-stanford-commencement-timcook/</guid><description>Content Fourteen years ago, Steve stood on this stage and told your predecessors &amp;ldquo;Your time is limited. So don&amp;rsquo;t waste is living someone else&amp;rsquo;s life.&amp;rdquo;
So what is true then is true now. Don&amp;rsquo;t waste your time living someone else&amp;rsquo;s life. Don&amp;rsquo;t try to emulate the people who came before you to the exclusion of everything else, contorting into a shape that doesn&amp;rsquo;t fit.
Graduates, the fact is, when your time comes, and it will, you will never be ready.</description></item><item><title>Html Css Learning note (0)</title><link>https://wangloo.github.io/posts/html-css/0/</link><pubDate>Tue, 17 May 2022 11:02:04 +0800</pubDate><guid>https://wangloo.github.io/posts/html-css/0/</guid><description>Get start What is HTML&amp;amp;CSS? HTML is resonsible for the content of the page. That&amp;rsquo;s the text, images, buttons, etc.
CSS is resonsible for the presentation of the content. That&amp;rsquo;s the color, layout, etc.
Web designers create the overall look and fell of a website.
Web developers implement the design using HTML, CSS and JavaScript code.
Configure VIM as HTML code-editor Finally in the arms of vscode 🙉</description></item><item><title>我的 vim 调教随笔</title><link>https://wangloo.github.io/posts/vim/basic/</link><pubDate>Mon, 09 May 2022 19:28:12 +0800</pubDate><guid>https://wangloo.github.io/posts/vim/basic/</guid><description>Search a word quickly: put cursor on the word, press / and press &amp;lt;C-R&amp;gt; &amp;lt;C-W&amp;gt;.
 缩写的含义(Meaning of abbreviations) Operation
d - delete y - yank(copy, 因为c被占了) c - change r - replace v - visual select Scope or location
i - inside a - around f - forward t - to Object
w - word s - sentence p - paragraph  书签: Bookmark ma: create bookmark a inside file.</description></item><item><title>reveal.js Tutorial</title><link>https://wangloo.github.io/posts/revealjs/</link><pubDate>Sun, 08 May 2022 19:34:44 +0800</pubDate><guid>https://wangloo.github.io/posts/revealjs/</guid><description>Change code theme Default use monokai.css. see 官方文档
修改需要下载新的css放到plugin/highlight/目录下.
其他可用的css在highlight.js仓库中下载.
Align Slide Align 取消center对齐方式:
Reveal.initialize({ ... center: false, ... }) 所有slide左对齐: https://github.com/hakimel/reveal.js/issues/1897
用markdown写的方式下使某一幻灯片左对齐: https://github.com/hakimel/reveal.js/issues/890#issuecomment-129735291</description></item><item><title>ARM64: A64指令集</title><link>https://wangloo.github.io/posts/armv8/a64/</link><pubDate>Sat, 07 May 2022 21:19:01 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/a64/</guid><description>Load/Store 指令 寻址模式 Base register - w0=[x1]
ldr w0, [x1] Offset addressing mode - w0=[x1+12]
ldr w0, [x1, 12] Pre-index addressing mode - x1+=12; w0=[x1]
ldr w0, [x1, 12]! Post-index addressing mode - w0=[x1]; x1+=12
ldr w0, [x1], 12 更多示例 // load a byte from x1 ldrb w0, [x1] // load a signed byte from x1 ldrsb w0, [x1] // store a 32-bit word to address in x1 str w0, [x1] // load two 32-bit words from stack, then add 8-byte to sp ldp w0, w1, [sp], 8 // store two 64-bit words at [sp-96] and subtract 96-byte from sp.</description></item><item><title>ARMv8-A 寄存器</title><link>https://wangloo.github.io/posts/armv8/register/</link><pubDate>Sat, 07 May 2022 20:19:44 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/register/</guid><description>寄存器分类 通用寄存器 x0-x7 参数寄存器: Restore function parameters and return vaule. x9-x15 caller-saved 临时寄存器: callee 默认可以直接使用来保存临时变量, 不需要保存和恢复. 如果 caller 在里面存储了非临时信息, 那么在函数调用之前应当由 caller 负责保存. x19-x28 callee-saved 寄存器: callee 应该避免使用. 如果必须要使用，那么在返回前必须恢复. special registers: x8 restore indirect result. Commonly used when returning a struct. x18 platform reserved register. x29 frame pointer register(FP). x30 link register(LR). All general-purpose register xN is 64-bit width. They all have corresponding wN register using the lower 32-bit of xN.</description></item><item><title>Numberical Analysis Exam</title><link>https://wangloo.github.io/posts/numberical-analysis/</link><pubDate>Sat, 07 May 2022 18:04:58 +0800</pubDate><guid>https://wangloo.github.io/posts/numberical-analysis/</guid><description>考试大纲 🎯 To Reader:
This blog is JUST FOR EXAMINATION! If you are interested in numberical analysis, please quit this web. I try to sort out the knowledge points of the course, just to pass the exam.
Based on the course of Professor Zhong Erjie of UESTC.
💢 I hate mathematics!
 第二章 非线性方程/方程组的求解 1. 二分法及迭代 二分法误差估计定理 2. 不动点迭代 不动点及不动点迭代的概念 迭代格式的选择? 是否收敛? 迭代的初值是否合适? 3. 牛顿法解非线性方程 背景: 如果函数f(x)是线性的, 那么它的求根问题就会简化.</description></item><item><title>LaTeX Vim Tutorial</title><link>https://wangloo.github.io/posts/latex-vim-tutorial/</link><pubDate>Wed, 04 May 2022 17:07:51 +0800</pubDate><guid>https://wangloo.github.io/posts/latex-vim-tutorial/</guid><description>Use plugin vimtex Vim build-in support of LaTeX files is just OK. When we need more excellent exprience, good plugins is very recommended.
vimtex is a nice and modern vim plugin for LaTeX files.
Useful Futures of vimtex IMO
&amp;lt;leader&amp;gt;ll Complier. By default, it will auto-complier when you type :w. &amp;lt;leader&amp;gt;lt Open content tree as a sidebar. &amp;lt;leader&amp;gt;lv View PDF with configured PDF viewer. &amp;lt;leader&amp;gt;li File information. cse Change surrounding \begin \end environment.</description></item><item><title>Portability Issues</title><link>https://wangloo.github.io/posts/reading-notes/expert_c_programming/portability_issues/</link><pubDate>Sun, 01 May 2022 16:41:35 +0800</pubDate><guid>https://wangloo.github.io/posts/reading-notes/expert_c_programming/portability_issues/</guid><description>When reading C standard documents, we usually see phrases like &amp;ldquo;Implementation-defined&amp;rdquo;, &amp;ldquo;Unspecified&amp;rdquo;,.etc.
So, what do they really mean?
术语 我们将这些难以直接理解的词汇称为术语，在ANSI C中，术语可以分为描述不可移植代码(unportable), 坏代码(bad), 可移植的代码(portable)三类.
unportable code Implementation-defined
需要由编译器设计者决定采取何种行为，他们可能不同，但都不能说是错误的.
例如：当整型数右移时，是否需要扩展符号位. 右移代替除法可能导致的灾难.
unspecified
在某些正确情况下的做法，标准并未明确规定应该怎样做.
例如：参数求值的顺序.
bad code undefined
在某些不正确情况下的做法，但标准并未规定应该怎样做。意味着你可以采取任何行动，可以什么都不做，也可以发出一条警告信息, 或者终止CPU重启等等. 你甚至可以发射核导弹(只要你安装了能发射核导弹的硬件系统).
例如：当一个有符号整数溢出时该采取什么行动.
constraint
这是一个必须遵守的限制或要求. 如果你不遵守, 那么你的程序的行为就会变成如上所说的undefined. 这出现了一种很有意思的情况: 分辨某种东西是否是一个constaint是很容易的, 因为每个标准的主题都附有一个constraint小节, 列出了所有的约束条件。
例如: %操作符的操作数必须为整型. 所以,在非整型数据上使用%操作符肯定会导致undefined.
portable code strictly conforming
严格遵守标准的. 符合该条件的程序应当是:
只使用已确定的特性 不突破任何由编译器实现(Implementation-defined)的限制. 不使用unspecified和undefined特性 这样规定的目的是最大程序保证代码的可移植性. 但符合该术语的代码并不常见, 例如INT_MAX的值在不同架构的机器上结果可能不同.
comforming
遵循标准的; 一个遵循标准的程序可以依赖一些对于某种编译器特有的不可移植的特性. 这样一个程序对于某个编译器可能是遵循标准的, 但对于另外一个编译器又是不遵循标准的.</description></item><item><title>Third Blog</title><link>https://wangloo.github.io/posts/third-blog/</link><pubDate>Sun, 01 May 2022 16:41:35 +0800</pubDate><guid>https://wangloo.github.io/posts/third-blog/</guid><description/></item><item><title>GCC '-M' and Related Parameters</title><link>https://wangloo.github.io/posts/c/gcc_-m_related/</link><pubDate>Tue, 26 Apr 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/c/gcc_-m_related/</guid><description>As we all know, there are huge number of parameters for GCC. With them, we can make many things possible. Now we talk about -M and related ones. After reading this article, you will know the meaning of there magic parameters. And I will put some little demos follows. Finally, we will see what can they do in really project. Let&amp;rsquo;s go ahead.
实例规则 以下的分析都是基于这样一个生成目标文件的规则, 应该来说具有一定的通用性。
build/obj/main.o: src/main.c $(CC) $(CFLAGS) $(INCLUDES) -c $&amp;lt; -o $@ main.</description></item><item><title>Second Blog</title><link>https://wangloo.github.io/posts/second-blog/second-blog/</link><pubDate>Tue, 26 Apr 2022 15:32:11 +0800</pubDate><guid>https://wangloo.github.io/posts/second-blog/second-blog/</guid><description>This is my second blog.
Wish you have a good life.
happy smile sunset</description></item><item><title>First Blog</title><link>https://wangloo.github.io/posts/first-blog/first-blog/</link><pubDate>Tue, 26 Apr 2022 15:13:07 +0800</pubDate><guid>https://wangloo.github.io/posts/first-blog/first-blog/</guid><description>This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog.</description></item><item><title/><link>https://wangloo.github.io/posts/os/arm64-linux-qemu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wangloo.github.io/posts/os/arm64-linux-qemu/</guid><description>编译Linux 源码 上海交通大学镜像站
# get linux source code wget http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/ # extract tar xvf linux-4.12.1.tar.gz # enter dir cd linux-4.12.1/ # generate .config make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- defconfig make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- menuconfig # compile make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- Image -j16 构建根文件系统 使用 Busybox 构建, 下载源码时可能比较慢, 暂时没有发现国内镜像站
# Download busybox source code wget https://busybox.net/downloads/busybox-1.35.0.tar.bz2 # menuconfig - generate .config make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- menuconfig # compile make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- -j16 make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- install # create rootfs cd .</description></item><item><title/><link>https://wangloo.github.io/posts/os/trace/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wangloo.github.io/posts/os/trace/</guid><description>名词解释 probe 一个probe是一个位置或者活动, 动态追踪工具可以在probe上绑定一些action. 例如记录栈帧位置, 查看参数等.
probe就像是一个可编程的传感器, 你可以为他设定触发的事件或者指令. 当probe 触发时, 可以执行你提前绑定的函数, 了解此时系统的状态</description></item></channel></rss>