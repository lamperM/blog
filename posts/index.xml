<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Soben's Secret Base</title><link>https://wangloo.github.io/posts/</link><description>Recent content in Posts on Soben's Secret Base</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>@2019 Notepadium.</copyright><lastBuildDate>Tue, 13 Dec 2022 17:39:42 +0800</lastBuildDate><atom:link href="https://wangloo.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>git 宝典</title><link>https://wangloo.github.io/posts/git/</link><pubDate>Tue, 13 Dec 2022 17:39:42 +0800</pubDate><guid>https://wangloo.github.io/posts/git/</guid><description>合并操作: git merge merge 有两种方式:
fast-forward three-way merger Fast-forward Merge 假设合并的双方为main为dev, 如果其中一个是另一个的祖先, 此时直接移动HEAD到前方即可, 称为fast-forward.
例如, 当前在main, 执行git merge dev的过程如下:
main main | | M1 --- M2 ===&amp;gt; M1 --- M2 -- F1 \ | \--- F1 dev | dev three-way Merge 合并的两者不构成直接的祖先-孩子关系, 产生了分叉. 此时进行合并就需要有个基准(参考), 对于两边相较于基准的每个diff来说:
合并的两者都在基准上进行了改动, 且改动不一致, 标记为冲突 如果该diff仅在其中一方有改动, 那么就保留此次改动 合并时使用的参考就是两个合并commit的最近公共祖先, 这种借助三个commit(main, dev, 公共祖先)才能完成的合并操作就叫做 three-way merge.
例如, 当前在main, 执行git merge dev的过程如下:
main main | | M1 --- M2 --- M3 ===&amp;gt; M1 --- M2 --- M3 --- M4 \ \ / \--- F1 \--- F1 --- | | dev dev three-way 的合并方式如果发生了冲突, 会产生一次额外的 merge commit, 下面介绍它</description></item><item><title>GNU 二进制工具集</title><link>https://wangloo.github.io/posts/compiler-tools/gnu_tools/</link><pubDate>Sat, 03 Dec 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/compiler-tools/gnu_tools/</guid><description>..
nm - 列出符号 nm (GNU Binary Utilities) (sourceware.org)</description></item><item><title>Makefile 一些技巧</title><link>https://wangloo.github.io/posts/compiler-tools/makefile_tricks/</link><pubDate>Sat, 03 Dec 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/compiler-tools/makefile_tricks/</guid><description>..
使用shell 变量 Make 将 $$var 转义为$var, 供shell处理.
demo(源自6.828 根目录GNUmakefile):
handin-check: @if test -n &amp;#34;`git status -s`&amp;#34;; then \ git status -s; \ read -p &amp;#34;Untracked files will not be handed in. Continue? [y/N] &amp;#34; r; \ test &amp;#34;$$r&amp;#34; = y; \ fi 以上demo还使用了 test 命令来终止make的执行, 如果用户没有输入y, make将会终止执行</description></item><item><title>Armv8 Kernel Monitor</title><link>https://wangloo.github.io/posts/os-learning/monitor/</link><pubDate>Fri, 28 Oct 2022 22:56:19 +0800</pubDate><guid>https://wangloo.github.io/posts/os-learning/monitor/</guid><description>Kernel Monitor 是什么 Kernel Monitor 是一个适配我们微内核操作系统的 Kernel 调试和监控系统. 它能实现内核的动态调试和监控. 同时, 它还接管内核的同步异常和系统错误, 使开发者能够了解发生异常时系统的状态.
Kernel Monitor 具有一定的可扩展性, 例如通过统计内核中存储的 TCB 来实时监控系统中所有线程的状态. 可根据开发者的需求添加统计的对象, 如 Endpoint, Capability等.
 Kernel Monitor 总体设计 Kernel Monitor 系统包含 Clinet 和 Server 两个部分. 简单来说, Client 负责处理用户输入, 并将输入进行解析, 封装为 一系列基础命令. 发送给 Server. Server 负责执行这些 基础的命令, 如设置断点, 查看某个地址的值等.
整个系统有两种架构: 本地 Monitor 和远程 Monitor.
本地monitor 和远程 monitor 的区别是: Monitor Client 的位置在哪, 是否与 Server 在同一个机器上.
先说 Monitor Server, 它必须嵌入要调试的 Kernel 中, 位于一个地址空间, 方便操作 Kernel 的内存.</description></item><item><title>ARMv8-A MMU 介绍</title><link>https://wangloo.github.io/posts/armv8/mmu/</link><pubDate>Thu, 29 Sep 2022 08:01:33 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/mmu/</guid><description>Introduction MMU: 专用于将虚拟地址转换为物理地址. 通常配合分页机制来工作.
页表: 页表中的表项包含提供虚拟地址和物理地址之间的映射.
MMU就是直接访问页表, 并且通过将频繁使用的映射缓存到TLB中.
MMU 的结构 MMU是一种硬件, 可以通过在适当的安全状态下对其进行配置. 每个Core都有自己的MMU, 每个MMU包括:
一个TLB, 缓存最近访问的映射. 一个Table Walk Unit, 从内存中查询页表, 得到最终的虚拟地址-物理地址的映射. MMU 控制着整个系统的缓存策略, 内存属性和访问权限. MMU开启后, 软件发出的所有内存访问都使用虚拟地址, 要求MMU为每次访问进行地址转换.
MMU 的配置 在启用MMU前, 必须告知其页表存放的位置.
MMU 地址转换的过程 对于每个转换请求, MMU首先检查TLB是否已经对该地址缓存, 如果该地址未缓存, 则需要遍历页表.
页表遍历单元在页表中搜索相关的映射表项.
一旦找到映射, MMU就会检查权限和属性. 决定允许本次访问, 或者发出故障信号. 若未找到映射, 则触发缺页异常. 页表的工作原理 页表的工作方式是将虚拟地址空间和物理地址空间划分为大小相等的块, 称为页面.
页表中的每个表项对应着一块虚拟地址空间中的块, 表项的值就是这块虚拟地址空间对应的物理地址块, 以及访问物理地址时要使用的属性.
在查表过程中, 将虚拟地址分为两部分:
高阶位用作页表的索引. 用来找到对应的物理块 低地址是块内的偏移量, 不会因为映射而改变. 页表项中的物理地址与该偏移组合形成用于访问内存的物理地址. 多级页表 实际实现中, 多采用多级页表的方案, 各级页表自定向下组成树的形式, 协作实现虚拟到物理地址的转换.
树中的分支成为页目录, 页目录中的表项不是直接存储目标物理地址, 而是下一级页表的地址; 最后一级页表的表项中保存着目标物理地址.</description></item><item><title>GICv3 - for ARMV8</title><link>https://wangloo.github.io/posts/armv8/gicv3/</link><pubDate>Sat, 10 Sep 2022 21:51:49 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/gicv3/</guid><description>GICV3(Generic Interrupt Controller - version 3) 关于GIC GIC即中断控制器, 负责管理中断的接收, 屏蔽, 路由等相关任务, 并向系统程序员提供配置的接口.
GIC与异常模型协作完成中断的整个生命周期, GIC主要负责中断源-产生IRQ/FIQ信号这段路, 关于处理IRQ/FIQ则是由CPU内部的异常模型来完成.
对比 GICv2 支持更多的处理器, 用affinity routing 方案来做中断路由. 支持中断分组, 为了配合ARMv8的异常等级模型 新增中断类型: SGI, 软件生成中断 新增中断类型: SPI, Shared Peripheral Interrupts 对于CPU interface的寄存器, 可直接使用系统寄存器接口(system register interface)来访问, 比memory-mapped的方式快. ITS, Interrupt Translation Service 暂不介绍 LPI, Locality-specific Peripheral Interrupts . 暂不介绍 GICv3支持ARMv8-A或ARMv8-R系列处理器, 但没有必然的绑定关系. ARMv8-A也可以使用GICv2.
中断类型 Locality-specific Peripheral Interrupt (LPI) LPIs are always message-based interrupts interrupts. 这里不做介绍.wiki
Private Peripheral Interrupt (PPI) PPI是路由到单个CPU的外设中断, 不同的CPU可以使用相同的中断号.</description></item><item><title>Useful Shell Script Examples</title><link>https://wangloo.github.io/posts/shell/shell-script/</link><pubDate>Wed, 20 Jul 2022 11:54:13 +0800</pubDate><guid>https://wangloo.github.io/posts/shell/shell-script/</guid><description>判断执行脚本时带的参数 if [ $# -ne 1 ]; then echo &amp;#34;ONE parameter is needed&amp;#34; exit -1 fi if [ $1 == &amp;#39;build&amp;#39; ]; then # do something elif [ $1 == &amp;#39;run&amp;#39; ]; then # do something elif [ $1 == &amp;#39;gdb&amp;#39; ]; then # do something else echo &amp;#34;Not supported command&amp;#34; fi  自动拷贝文件到SD Card TODO
添加进度条 #!/bin/bash sd_path=$(find /media/$USER -maxdepth 1 -type d -name &amp;#34;*-*&amp;#34;) while [ !</description></item><item><title>C 语言位操作技巧</title><link>https://wangloo.github.io/posts/codestyle/bit-operation-hacks/</link><pubDate>Sun, 03 Jul 2022 09:44:13 +0800</pubDate><guid>https://wangloo.github.io/posts/codestyle/bit-operation-hacks/</guid><description>判断一个数是否为2的幂 unsigned int v; if ((v &amp;amp; (v - 1)) == 0) printf(&amp;#34;v is a power of 2\n&amp;#34;); else printf(&amp;#34;v is not a power of 2\n&amp;#34;);  统计一个数的二进制中1的数量 依然是利用v &amp;amp; (v -1)的运算结果会将v的最低位的1(如果有的话)置0.
循环执行此操作就可统计v中1的数量.
int numberof1(int v) { int count = 0; while(v) { count++; v = v &amp;amp; (v -1); } return count; }  将一个数向上取整为2的幂 用一个1一直左移, 直到比这个数大为止.
uint32_t roundup_pow_op_two(const uint32_t x) { uint32_t ret = 1; while (ret &amp;lt; x) { ret = ret &amp;lt;&amp;lt; 1; } return ret; }  向上/向下对齐, 检查是否对齐 /* uintptr_t 代表指针的位数 * 加uintptr_t转换的原因是: (void *)不能进行运算 */ #define IS_ALIGNED(X, align) (((uintptr_t)(const void *)(X)) % (align) == 0) #define ALIGN_UP(X, align) (((X) + ((align) - 1)) &amp;amp; ~((align) - 1)) #define ALIGN_DOWN(x, align) ((X) &amp;amp; ~((align) - 1)) #define X (0x12345675) #define align (1 &amp;lt;&amp;lt; 2) int main() { int v = IS_ALIGNED(X, align); if (0 == v) { printf(&amp;#34;Given X(0x%x) is not align to 0x%08x\n&amp;#34;, X, align); printf(&amp;#34;After align up, new X = 0x%x\n&amp;#34;, ALIGN_UP(X, align)); printf(&amp;#34;After align down, new X = 0x%x\n&amp;#34;, ALIGN_DOWN(X, align)); } else { printf(&amp;#34;Give X(0x%x) is aligned to 0x%08x\n&amp;#34;, X, align); printf(&amp;#34;After align up, new X = 0x%x\n&amp;#34;, ALIGN_UP(X, align)); printf(&amp;#34;After align down, new X = 0x%x\n&amp;#34;, ALIGN_DOWN(X, align)); } return 0; }  检查两个有符号数是否异号 int x,y; if ((x ^ y) &amp;lt; 0) printf(&amp;#34;They have opposite signs\n&amp;#34;); else printf(&amp;#34;They have same signs\n&amp;#34;);  大小端转换  对某个位的get/set/clear操作 #define GET_BIT(x, bit) ( ((x) &amp;amp; (1ULL &amp;lt;&amp;lt; (bit))) &amp;gt;&amp;gt; (bit) ) #define SET_BIT(x, bit) ( (x) |= (1ULL &amp;lt;&amp;lt; (bit)) ) #define CLEAR_BIT(x, bit) ( (x) &amp;amp;= ~(1ULL &amp;lt;&amp;lt; (bit)) ) Release note:</description></item><item><title>Stack and Heap</title><link>https://wangloo.github.io/posts/os-learning/stack-and-heap/</link><pubDate>Tue, 28 Jun 2022 16:41:54 +0800</pubDate><guid>https://wangloo.github.io/posts/os-learning/stack-and-heap/</guid><description> 堆的含义 我们都知道malloc动态申请的变量是存放在堆中. 所以相比栈来说, 堆是动态的.
堆占据进程虚拟地址空间的大部分, 我们可能通过堆来申请1GB的数组, 但是栈通常不行 , 大多也就几兆的空间.
 堆空间的管理 进程中堆空间的管理是运行库负责的, 在Linux中是GLIBC.
运行库在初始化时会像操作系统申请一大块的堆空间, 再为每个进行分别分配需求. 当然, 如果某些程序的需求过大, 运行库也可以使用mmap系统调用直接向操作系统申请, 然后 返回给用户进程.
GLIBC的malloc函数的处理方式是: 对于小于128KB的申请, 会从运行库&amp;quot;批发的&amp;quot;堆空间 里分出一块来; 但若申请的空间过大, 则使用mmap系统调用来创建匿名空间分配给用户.
Linux中虚拟地址块(VMA)的管理使用了红黑树, 可以用于运行库管理自己向操作系统 &amp;ldquo;批发&amp;quot;的堆空间. 使得用户程序动态申请和释放内存性能提高.</description></item><item><title>动态链接</title><link>https://wangloo.github.io/posts/os-learning/dynamic-link/</link><pubDate>Sun, 26 Jun 2022 19:50:45 +0800</pubDate><guid>https://wangloo.github.io/posts/os-learning/dynamic-link/</guid><description>静态链接带来的问题 像是libc这种几乎每个程序都要用到的库, 如果是静态的, 那么不仅意外着每个程序的 可执行文件很大, 浪费磁盘空间. 并且当程序加载到内存时, 可能许多程序都会用到printf , 使得内存中会存在好多份的printf源码.
维护和更新难. 一旦静态链接的其中一个目标文件更新, 所有的可执行程序都要重新链接.
不满足局部性原理. 上面提到, 内存中同时存在多份的printf源码会破坏局部性原理的. 显然如果所有的程序共享一份printf源码的想法更好. 即动态加载.
可移植性差. 静态链接, 只要有一个依赖目标文件的实现不同, 软件厂商就得专门发布一个 版本. 而动态链接则信赖客户电脑上的动态库, 相当于一个中间层.
 动态链接的过程 对比静态链接使用ld链接器在编译后即执行链接, 动态链接则是将链接过程推迟到运行时, 即装载到内存时.
这样, 链接器在链接产生可执行文件时就有两种做法:
对于静态符号, 按照静态链接的规则进行地址引用重定位 对于动态符号, 链接器则仅标记其为动态链接中的符号, 不进行处理. 而是等到装载时由 专门的动态链接器来完成动态符号的链接工作. ⁉️ 链接器如何确定一个符号是静态的or动态的?
在动态共享对象(.so)中保存了完整的动态符号表*, 表中存在的符号即为动态的, 否则为静态.
Linux的C语言运行库glib的动态链接版本叫libc.so. 它在外存上只保存一份, 所有的程序 都可以在运行时使用它. 所以千万不要删掉它.
动态链接有一定的性能损失, 因为每次运行程序时都要重新链接, 并不像静态链接是一劳永逸的. 也有例如延迟绑定对性能进行优化的方法, 大概仅有5%的损耗, 与带来的便利相比可以忽略不计.</description></item><item><title>ELF 文件的链接与加载</title><link>https://wangloo.github.io/posts/os-learning/elf-format/</link><pubDate>Mon, 20 Jun 2022 16:21:27 +0800</pubDate><guid>https://wangloo.github.io/posts/os-learning/elf-format/</guid><description>ELF is a file format Files in ELF format includes:
Type description 实例 Relocatable File 这些文件包含了代码和data, 可以被用来链接成可执行文件或共享目标文件. .o, .a Executable File 直接可执行的文件 /bin/ls Shared Object File Including code and data. 链接器可将其与其他Relocatable File或Shared Object File结合, 生成新的目标文件. 动态链接器可将其与Executable File结合, 作为进程映像的一部分来运行. .so Core Dump File Restore critical infomation when process is terminated unexpectedly core dump 📌 file command in Linux can output the format of a file.</description></item><item><title>Improving the quality of C code</title><link>https://wangloo.github.io/posts/codestyle/improve_quality/</link><pubDate>Tue, 14 Jun 2022 17:59:22 +0800</pubDate><guid>https://wangloo.github.io/posts/codestyle/improve_quality/</guid><description>添加更多的编译选项(comiler options)来防止bug 对于我常用的GCC, 推荐开启一下的compiler options:
-Wall: enable a lot of common warnings
-Wno-format-truncation: warns about the snprintf output buffer not being large enough for a corresponding “%s” in the format string.
-Werror: turn warnings into errors.
 动态申请的空间到底要不要释放 When using a barebones embedded OS, you absolutely need to tightly manage your memory.
但是, 如果你是写应用业务的代码, 特别是在内存足够的场景下. 最好不要手动释放内存, 因为当线程/进程退出时, 操作系统会自动帮我们释放. 某些情况下, 释放内存的操作会很大程度上增加逻辑的复杂度.
如果你是一个内核程序员, 则必须手动的释放.</description></item><item><title>MicroKernel Learning: SeL4</title><link>https://wangloo.github.io/posts/microkernel/sel4/</link><pubDate>Sat, 04 Jun 2022 11:52:51 +0800</pubDate><guid>https://wangloo.github.io/posts/microkernel/sel4/</guid><description>seL4 Capabilities In seL4, capabilities are stored in C-space. C-space is a hierarchical data structure very similar to page table.
page table is a mapping from virtual address to physical address. C-space is a mapping from object ID to capability. Kernel object is made up of several C-nodes, just like a page table made up of individual page tables. Each C-nodes is an array of cap slots, which contain capability.</description></item><item><title>使用 HuGo 搭建个人网站</title><link>https://wangloo.github.io/posts/hugo/</link><pubDate>Sat, 21 May 2022 17:39:42 +0800</pubDate><guid>https://wangloo.github.io/posts/hugo/</guid><description>HuGo 基础学习 本章将解答Hugo是什么, 以及Hugo是如何工作的. 只有了解Hugo的工作机制之后, 才能发挥想象力进行DIY.
本章内容大多来自官方手册或者搜索引擎提供的结果.
Hugo 项目目录结构 一个hugo 项目通常包含以下内容:
. ├── archetypes ├── config.toml ├── content ├── data ├── layouts ├── public ├── static └── themes 这里面有些是必须的, 有些是可选的.
archetypes
定义新创建post时, header的格式.
asserts
Note: assets directory is not created by default.
config
Hugo uses the config.toml, config.yaml, or config.json (if found in the site root) as the default site config file.
The user can choose to override that default with one or more site config files using the command-line --config switch.</description></item><item><title>2019 Stanford Commencement Timcook</title><link>https://wangloo.github.io/posts/motivation/2019-stanford-commencement-timcook/</link><pubDate>Wed, 18 May 2022 19:32:38 +0800</pubDate><guid>https://wangloo.github.io/posts/motivation/2019-stanford-commencement-timcook/</guid><description>Content Fourteen years ago, Steve stood on this stage and told your predecessors &amp;ldquo;Your time is limited. So don&amp;rsquo;t waste is living someone else&amp;rsquo;s life.&amp;rdquo;
So what is true then is true now. Don&amp;rsquo;t waste your time living someone else&amp;rsquo;s life. Don&amp;rsquo;t try to emulate the people who came before you to the exclusion of everything else, contorting into a shape that doesn&amp;rsquo;t fit.
Graduates, the fact is, when your time comes, and it will, you will never be ready.</description></item><item><title>Html Css Learning note (0)</title><link>https://wangloo.github.io/posts/html-css-learning/0/</link><pubDate>Tue, 17 May 2022 11:02:04 +0800</pubDate><guid>https://wangloo.github.io/posts/html-css-learning/0/</guid><description>Get start What is HTML&amp;amp;CSS? HTML is resonsible for the content of the page. That&amp;rsquo;s the text, images, buttons, etc.
CSS is resonsible for the presentation of the content. That&amp;rsquo;s the color, layout, etc.
Web designers create the overall look and fell of a website.
Web developers implement the design using HTML, CSS and JavaScript code.
Configure VIM as HTML code-editor Finally in the arms of vscode 🙉</description></item><item><title>我的 vim 调教随笔</title><link>https://wangloo.github.io/posts/vim/basic/</link><pubDate>Mon, 09 May 2022 19:28:12 +0800</pubDate><guid>https://wangloo.github.io/posts/vim/basic/</guid><description>Search a word quickly: put cursor on the word, press / and press &amp;lt;C-R&amp;gt; &amp;lt;C-W&amp;gt;.
 缩写的含义(Meaning of abbreviations) Operation
d - delete y - yank(copy, 因为c被占了) c - change r - replace v - visual select Scope or location
i - inside a - around f - forward t - to Object
w - word s - sentence p - paragraph  书签: Bookmark ma: create bookmark a inside file.</description></item><item><title>reveal.js Tutorial</title><link>https://wangloo.github.io/posts/revealjs-tutorial/</link><pubDate>Sun, 08 May 2022 19:34:44 +0800</pubDate><guid>https://wangloo.github.io/posts/revealjs-tutorial/</guid><description>Change code theme Default use monokai.css. see 官方文档
修改需要下载新的css放到plugin/highlight/目录下.
其他可用的css在highlight.js仓库中下载.
Align Slide Align 取消center对齐方式:
Reveal.initialize({ ... center: false, ... }) 所有slide左对齐: https://github.com/hakimel/reveal.js/issues/1897
用markdown写的方式下使某一幻灯片左对齐: https://github.com/hakimel/reveal.js/issues/890#issuecomment-129735291</description></item><item><title>A64 Instruction Set</title><link>https://wangloo.github.io/posts/armv8/a64_isa/</link><pubDate>Sat, 07 May 2022 21:19:01 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/a64_isa/</guid><description>Load/Store Addressing Addressing mode Base register - w0=[x1] ldr w0, [x1] Offset addressing mode - w0=[x1+12] ldr w0, [x1, 12] Pre-index addressing mode - x1+=12; w0=[x1] ldr w0, [x1, 12]! Post-index addressing mode - w0=[x1]; x1+=12 ldr w0, [x1], 12 Load/store instruction example // load a byte from x1 ldrb w0, [x1] // load a signed byte from x1 ldrsb w0, [x1] // store a 32-bit word to address in x1 str w0, [x1] // load two 32-bit words from stack, then add 8-byte to sp ldp w0, w1, [sp], 8 // store two 64-bit words at [sp-96] and subtract 96-byte from sp.</description></item><item><title>ARMv8-A Register</title><link>https://wangloo.github.io/posts/armv8/register/</link><pubDate>Sat, 07 May 2022 20:19:44 +0800</pubDate><guid>https://wangloo.github.io/posts/armv8/register/</guid><description>寄存器分类 通用寄存器 x0-x7 参数寄存器: Restore function parameters and return vaule. x9-x15 caller-saved 临时寄存器: callee 默认可以直接使用来保存临时变量, 不需要保存和恢复. 如果 caller 在里面存储了非临时信息, 那么在函数调用之前应当由 caller 负责保存. x19-x28 callee-saved 寄存器: callee 应该避免使用. 如果必须要使用，那么在返回前必须恢复. special registers: x8 restore indirect result. Commonly used when returning a struct. x18 platform reserved register. x29 frame pointer register(FP). x30 link register(LR). All general-purpose register xN is 64-bit width. They all have corresponding wN register using the lower 32-bit of xN.</description></item><item><title>Numberical Analysis Exam</title><link>https://wangloo.github.io/posts/numberical-analysis/</link><pubDate>Sat, 07 May 2022 18:04:58 +0800</pubDate><guid>https://wangloo.github.io/posts/numberical-analysis/</guid><description>考试大纲 🎯 To Reader:
This blog is JUST FOR EXAMINATION! If you are interested in numberical analysis, please quit this web. I try to sort out the knowledge points of the course, just to pass the exam.
Based on the course of Professor Zhong Erjie of UESTC.
💢 I hate mathematics!
 第二章 非线性方程/方程组的求解 1. 二分法及迭代 二分法误差估计定理 2. 不动点迭代 不动点及不动点迭代的概念 迭代格式的选择? 是否收敛? 迭代的初值是否合适? 3. 牛顿法解非线性方程 背景: 如果函数f(x)是线性的, 那么它的求根问题就会简化.</description></item><item><title>LaTeX Vim Tutorial</title><link>https://wangloo.github.io/posts/latex-vim-tutorial/</link><pubDate>Wed, 04 May 2022 17:07:51 +0800</pubDate><guid>https://wangloo.github.io/posts/latex-vim-tutorial/</guid><description>Use plugin vimtex Vim build-in support of LaTeX files is just OK. When we need more excellent exprience, good plugins is very recommended.
vimtex is a nice and modern vim plugin for LaTeX files.
Useful Futures of vimtex IMO
&amp;lt;leader&amp;gt;ll Complier. By default, it will auto-complier when you type :w. &amp;lt;leader&amp;gt;lt Open content tree as a sidebar. &amp;lt;leader&amp;gt;lv View PDF with configured PDF viewer. &amp;lt;leader&amp;gt;li File information. cse Change surrounding \begin \end environment.</description></item><item><title>Portability Issues</title><link>https://wangloo.github.io/posts/reading-notes/expert_c_programming/portability_issues/</link><pubDate>Sun, 01 May 2022 16:41:35 +0800</pubDate><guid>https://wangloo.github.io/posts/reading-notes/expert_c_programming/portability_issues/</guid><description>When reading C standard documents, we usually see phrases like &amp;ldquo;Implementation-defined&amp;rdquo;, &amp;ldquo;Unspecified&amp;rdquo;,.etc.
So, what do they really mean?
术语 我们将这些难以直接理解的词汇称为术语，在ANSI C中，术语可以分为描述不可移植代码(unportable), 坏代码(bad), 可移植的代码(portable)三类.
unportable code Implementation-defined
需要由编译器设计者决定采取何种行为，他们可能不同，但都不能说是错误的.
例如：当整型数右移时，是否需要扩展符号位. 右移代替除法可能导致的灾难.
unspecified
在某些正确情况下的做法，标准并未明确规定应该怎样做.
例如：参数求值的顺序.
bad code undefined
在某些不正确情况下的做法，但标准并未规定应该怎样做。意味着你可以采取任何行动，可以什么都不做，也可以发出一条警告信息, 或者终止CPU重启等等. 你甚至可以发射核导弹(只要你安装了能发射核导弹的硬件系统).
例如：当一个有符号整数溢出时该采取什么行动.
constraint
这是一个必须遵守的限制或要求. 如果你不遵守, 那么你的程序的行为就会变成如上所说的undefined. 这出现了一种很有意思的情况: 分辨某种东西是否是一个constaint是很容易的, 因为每个标准的主题都附有一个constraint小节, 列出了所有的约束条件。
例如: %操作符的操作数必须为整型. 所以,在非整型数据上使用%操作符肯定会导致undefined.
portable code strictly conforming
严格遵守标准的. 符合该条件的程序应当是:
只使用已确定的特性 不突破任何由编译器实现(Implementation-defined)的限制. 不使用unspecified和undefined特性 这样规定的目的是最大程序保证代码的可移植性. 但符合该术语的代码并不常见, 例如INT_MAX的值在不同架构的机器上结果可能不同.
comforming
遵循标准的; 一个遵循标准的程序可以依赖一些对于某种编译器特有的不可移植的特性. 这样一个程序对于某个编译器可能是遵循标准的, 但对于另外一个编译器又是不遵循标准的.</description></item><item><title>Third Blog</title><link>https://wangloo.github.io/posts/third-blog/</link><pubDate>Sun, 01 May 2022 16:41:35 +0800</pubDate><guid>https://wangloo.github.io/posts/third-blog/</guid><description/></item><item><title>GCC '-M' and Related Parameters</title><link>https://wangloo.github.io/posts/compiler-tools/gcc_-m_related/</link><pubDate>Tue, 26 Apr 2022 19:08:22 +0800</pubDate><guid>https://wangloo.github.io/posts/compiler-tools/gcc_-m_related/</guid><description>As we all know, there are huge number of parameters for GCC. With them, we can make many things possible. Now we talk about -M and related ones. After reading this article, you will know the meaning of there magic parameters. And I will put some little demos follows. Finally, we will see what can they do in really project. Let&amp;rsquo;s go ahead.
-M Output the dependencies of the input source file.</description></item><item><title>Second Blog</title><link>https://wangloo.github.io/posts/second-blog/second-blog/</link><pubDate>Tue, 26 Apr 2022 15:32:11 +0800</pubDate><guid>https://wangloo.github.io/posts/second-blog/second-blog/</guid><description>This is my second blog.
Wish you have a good life.
happy smile sunset</description></item><item><title>First Blog</title><link>https://wangloo.github.io/posts/first-blog/first-blog/</link><pubDate>Tue, 26 Apr 2022 15:13:07 +0800</pubDate><guid>https://wangloo.github.io/posts/first-blog/first-blog/</guid><description>This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog. This is my first blog.</description></item><item><title/><link>https://wangloo.github.io/posts/os-learning/arm64-linux-qemu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wangloo.github.io/posts/os-learning/arm64-linux-qemu/</guid><description>编译Linux 源码 上海交通大学镜像站
# get linux source code wget http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/ # extract tar xvf linux-4.12.1.tar.gz # enter dir cd linux-4.12.1/ # generate .config make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- defconfig make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- menuconfig # compile make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- Image -j16 构建根文件系统 使用 Busybox 构建, 下载源码时可能比较慢, 暂时没有发现国内镜像站
# Download busybox source code wget https://busybox.net/downloads/busybox-1.35.0.tar.bz2 # menuconfig - generate .config make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- menuconfig # compile make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- -j16 make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- install # create rootfs cd .</description></item><item><title/><link>https://wangloo.github.io/posts/os-learning/trace/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wangloo.github.io/posts/os-learning/trace/</guid><description>名词解释 probe 一个probe是一个位置或者活动, 动态追踪工具可以在probe上绑定一些action. 例如记录栈帧位置, 查看参数等.
probe就像是一个可编程的传感器, 你可以为他设定触发的事件或者指令. 当probe 触发时, 可以执行你提前绑定的函数, 了解此时系统的状态</description></item></channel></rss>