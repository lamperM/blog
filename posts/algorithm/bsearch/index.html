<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/syntax_pastie.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>一道题搞定二分法的细节</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e9%a2%98%e7%9b%ae aria-label=题目>题目</a></li><li><a href=#%e8%a7%a3%e7%ad%94python aria-label=解答(python):>解答(python):</a></li><li><a href=#%e7%bb%86%e8%8a%82 aria-label=细节>细节</a><ul><li><a href=#%e9%97%ae%e9%a2%98%e8%bd%ac%e5%8c%96 aria-label=问题转化>问题转化</a></li><li><a href=#%e5%86%8d%e5%ae%a1%e5%8e%9f%e9%a2%98 aria-label=再审原题>再审原题</a></li></ul></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>一道题搞定二分法的细节</div></header><p>实际上我做过的二分搜索的题目并不少，但是一直以来没有静下心去研究它的
【循环条件】【边界调整】【返回值】的细节，通过这个题目希望自己能完整、
清晰的了解二分搜索。</p><h2 id=题目>题目</h2><p><a href=https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array>https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array</a></p><blockquote><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><blockquote><p>示例 1：</p><p>输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]</p></blockquote></blockquote><h2 id=解答python>解答(python):</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=k>def</span> <span class=nf>searchRange</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>nums</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>],</span> <span class=n>target</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>nums</span> <span class=o>==</span> <span class=p>[]:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 第一次二分，确定右边界</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span><span class=p>,</span> <span class=n>right</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>left</span> <span class=o>&lt;=</span> <span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>left</span> <span class=o>+</span> <span class=n>right</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>nums</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>left</span> <span class=o>=</span> <span class=n>mid</span><span class=o>+</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>right</span> <span class=o>=</span> <span class=n>mid</span><span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>end</span> <span class=o>=</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 第二次二分，确定左边界</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span><span class=p>,</span> <span class=n>right</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>left</span> <span class=o>&lt;=</span> <span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>left</span> <span class=o>+</span> <span class=n>right</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>nums</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>left</span> <span class=o>=</span> <span class=n>mid</span><span class=o>+</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>right</span> <span class=o>=</span> <span class=n>mid</span><span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>sta</span> <span class=o>=</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>sta</span><span class=p>,</span> <span class=n>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>end</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=ow>or</span> <span class=n>sta</span> <span class=o>&gt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span> <span class=ow>or</span> <span class=n>nums</span><span class=p>[</span><span class=n>sta</span><span class=p>]</span> <span class=o>!=</span> <span class=n>target</span> <span class=ow>or</span> <span class=n>nums</span><span class=p>[</span><span class=n>end</span><span class=p>]</span> <span class=o>!=</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=n>sta</span><span class=p>,</span> <span class=n>end</span><span class=p>]</span>
</span></span></code></pre></div><h2 id=细节>细节</h2><p>写好一个二分搜索就是需要确定三件事:</p><ol><li>循环边界条件</li><li>调整边界</li><li>返回值</li></ol><p>这三件事是环环相扣的，先说确定的，调整边界的操作一定是<code>left=mid+1</code> or <code>right=mid-1</code>,
整数的二分不存在<code>left=mid</code>这种操作，仅限于浮点数中。</p><p>再说边界条件，我个人喜欢使用带等号的判断，即<code>while left &lt;= right</code>, 这纯粹是个人习惯.</p><h3 id=问题转化>问题转化</h3><p>以求右侧下标为例, 可以等价为: 搜索&lt;=target的最大值. 这其实是问题的关键, 只是另外加一个判断说如果求得数
不是target, 返回特殊值就行了. 如果你还是不理解这两个问题为什么是等价的, 那么看完下面的解释应该也能清楚.</p><p>先说搜索&lt;=target的最大值的计算方法, 一般的二分搜索, 搜索完成之后, 如果没有找到target,
<code>right=left-1</code>, <strong>且 right 指向比 target 首个小的元素,left 指向首个比 target 大的元素.</strong></p><p>那么代码是不是可以这么写:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>left</span><span class=p>,</span> <span class=n>right</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>n</span><span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=n>left</span> <span class=o>&lt;=</span> <span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>left</span> <span class=o>+</span> <span class=n>right</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>nums</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>mid</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>nums</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>left</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>right</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>right</span>
</span></span></code></pre></div><p>更进一步的说, 如果"把target也看作是小于target", 也就是让循环不停下, 最后平衡的条件也一定是满足
<strong>right 指向比 target 首个小的元素,left 指向首个比 target 大的元素.</strong>, 只不过此时=target
也被算作是小于target, 走小于target的处理流程.
最终的结果就是right指向的就是target(如果存在), 要不就是比target小的那个数.</p><p>于是代码就可以被优化为:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-py data-lang=py><span class=line><span class=cl><span class=n>left</span><span class=p>,</span> <span class=n>right</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>n</span><span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=n>left</span> <span class=o>&lt;=</span> <span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>left</span> <span class=o>+</span> <span class=n>right</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>nums</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>left</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>right</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>right</span>
</span></span></code></pre></div><h3 id=再审原题>再审原题</h3><p>上述这种进一步思考的思想是不是与原题中的要求类似? 我可以有一连串的target, 我要求的是最右边的target在哪,
如果把=target也看作是小于target, 让循环继续跑, 最后right指向的就是最右边的那个target.</p></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2023-08-20T20:30:35, Lastmod: 2023-09-24T18:08:59</p><script src=/js/copy-to-clipboard.js></script></main></div></body></html>