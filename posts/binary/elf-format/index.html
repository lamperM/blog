<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>ELF 文件的链接与加载</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>所有文章</a></div><div class="a-block nav-link-item"><a href=/tags>Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#elf%e6%98%af%e4%bb%80%e4%b9%88 aria-label=ELF是什么>ELF是什么</a><ul><li><a href=#%e5%85%b3%e4%ba%8e%e9%9d%99%e6%80%81%e5%ba%93 aria-label=关于静态库>关于静态库</a></li></ul></li><li><a href=#elf-%e6%96%87%e4%bb%b6%e7%bb%84%e6%88%90%e7%9a%84%e7%bb%93%e6%9e%84 aria-label="ELF 文件组成的结构">ELF 文件组成的结构</a><ul><li><a href=#elf-header aria-label="ELF Header">ELF Header</a></li><li><a href=#program-header-table aria-label="Program Header Table">Program Header Table</a></li><li><a href=#section-header-table aria-label="Section Header Table">Section Header Table</a></li></ul></li><li><a href=#%e5%a6%82%e4%bd%95%e7%94%9f%e6%88%90%e4%b8%80%e4%b8%aaelf%e5%8f%af%e6%89%a7%e8%a1%8c%e6%96%87%e4%bb%b6 aria-label=如何生成一个ELF可执行文件>如何生成一个ELF可执行文件</a><ul><li><a href=#%e9%a2%84%e7%bc%96%e8%af%91 aria-label=预编译>预编译</a></li><li><a href=#%e7%bc%96%e8%af%91 aria-label=编译>编译</a></li><li><a href=#%e6%b1%87%e7%bc%96 aria-label=汇编>汇编</a></li><li><a href=#%e9%93%be%e6%8e%a5 aria-label=链接>链接</a><ul><li><a href=#%e9%9d%99%e6%80%81%e9%93%be%e6%8e%a5 aria-label=静态链接>静态链接</a></li><li><a href=#%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5 aria-label=动态链接>动态链接</a></li></ul></li></ul></li><li><a href=#elf-%e5%8a%a0%e8%bd%bd aria-label="ELF 加载">ELF 加载</a><ul><li><a href=#%e9%9d%99%e6%80%81%e5%8a%a0%e8%bd%bd aria-label=静态加载>静态加载</a></li><li><a href=#%e5%8a%a8%e6%80%81%e5%8a%a0%e8%bd%bd aria-label=动态加载>动态加载</a></li></ul></li><li><a href=#%e5%85%b6%e4%bb%96%e9%97%ae%e9%a2%98%e6%b1%87%e6%80%bb aria-label=其他问题汇总>其他问题汇总</a><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%8c%ba%e5%88%86section%e5%92%8csegment aria-label=为什么要区分section和segment>为什么要区分section和segment</a></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e7%9b%ae%e6%a0%87%e6%96%87%e4%bb%b6%e4%b8%ad%e4%bb%a3%e7%a0%81%e5%92%8c%e6%95%b0%e6%8d%ae%e8%a6%81%e5%88%86%e5%bc%80%e6%94%be aria-label=为什么目标文件中代码和数据要分开放?>为什么目标文件中代码和数据要分开放?</a></li><li><a href=#%e6%ae%b5%e5%9c%b0%e5%9d%80%e5%af%b9%e9%bd%90%e6%8a%80%e6%9c%af aria-label=段地址对齐技术>段地址对齐技术</a><ul><li><a href=#-%e8%bf%99%e4%b8%89%e4%b8%aa%e6%ae%b5%e5%9c%a8elf%e6%96%87%e4%bb%b6%e4%b8%ad%e7%9a%84%e5%b8%83%e5%b1%80%e5%a6%82%e4%bd%95 aria-label="❓ 这三个段在ELF文件中的布局如何?">❓ 这三个段在ELF文件中的布局如何?</a></li><li><a href=#-%e8%bf%99%e4%b8%89%e4%b8%aa%e6%ae%b5%e5%9c%a8%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98%e4%b8%ad%e7%9a%84%e5%b8%83%e5%b1%80 aria-label="❓ 这三个段在物理内存中的布局?">❓ 这三个段在物理内存中的布局?</a></li><li><a href=#-%e8%bf%99%e4%b8%89%e4%b8%aa%e6%ae%b5%e5%9c%a8%e7%94%a8%e6%88%b7virtual-addrspace%e4%b8%8b%e7%9a%84%e5%b8%83%e5%b1%80%e5%a6%82%e4%bd%95 aria-label="❓ 这三个段在用户virtual addrspace下的布局如何?">❓ 这三个段在用户virtual addrspace下的布局如何?</a></li><li><a href=#-%e4%bd%95%e4%b8%ba%e6%ae%b5%e5%9c%b0%e5%9d%80%e5%af%b9%e9%bd%90%e6%8a%80%e6%9c%af aria-label="❓ 何为段地址对齐技术?">❓ 何为段地址对齐技术?</a></li></ul></li></ul></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>ELF 文件的链接与加载</div></header><h1 id=elf是什么>ELF是什么</h1><p>ELF（Executable Linkable Format）可执行文件格式不止是单指“可以被执行的文件”，
动态链接库、静态链接库都按照可执行文件格式来存储。</p><p>ELF标准里把采用ELF格式的文件分为四类：</p><table><thead><tr><th>Type</th><th>description</th><th>实例</th></tr></thead><tbody><tr><td>Relocatable File</td><td>这些文件包含了代码和data, 可以被用来链接成可执行文件或共享目标文件.</td><td><code>.o</code>, <code>.a</code></td></tr><tr><td>Executable File</td><td>直接可执行的文件</td><td><code>/bin/ls</code></td></tr><tr><td>Shared Object File</td><td>Including code and data. 链接器可将其与其他Relocatable File或Shared Object File结合, 生成新的目标文件. 动态链接器可将其与Executable File结合, 作为进程映像的一部分来运行.</td><td><code>.so</code></td></tr><tr><td>Core Dump File</td><td>Restore critical infomation when process is terminated unexpectedly</td><td><code>core dump</code></td></tr></tbody></table><blockquote><p>📌 <code>file</code> command in Linux can output the format of a file.</p></blockquote><h2 id=关于静态库>关于静态库</h2><p>一个静态库可以简单的看作是 a set of object file.<br>这些 object file 可能包括: 输入输出相关的<code>printf.o</code>, <code>scanf.o</code>, 日期时间相关的<code>time.o</code>, <code>date.o</code>等.</p><p>❓ 为什么不直接提供这些<em>目标文件</em>呢?</p><p>这些<strong>零散的</strong>文件若直接提供给使用者, 很大程度上造成文件传输, 管理等方面的不便.<br>于是人们通常使用<code>ar</code>压缩程序将这些目标文件压缩到一起.</p><p>❓ 如何查看一个静态库是由哪些object file压缩到一起的?</p><p>Shell command<code>ar -t libc.a</code> 可以查看<code>libc.a</code>中包含的所有object files.</p><h1 id=elf-文件组成的结构>ELF 文件组成的结构</h1><p>知道了ELF文件是什么，接下来就看看其内部的结构。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span>+---------------------------------+
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>|           ELF Header            |  包含描述整个ELF的基本信息, 如版本, 入口地址...
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>+---------------------------------+
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>|           .text                 |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>+---------------------------------+
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>|           .data                 |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>+---------------------------------+  紧接着是各个段
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>|           .bss                  |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>+---------------------------------+
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>|           ...                   |  
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>|           other sections        |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>+---------------------------------+
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>|                                 |  与section相关最重要的结构
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>|       Section Header table      |  描述了每个section的名称,长度,权限...
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>|                                 |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>+---------------------------------+
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span>|                                 |  与segment相关最重要的结构
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span>|       Program Header table      |  描述了每个segment的位置、属性(RWX)、size...
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>|                                 |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span>+---------------------------------+
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span>|         String tables           |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span>|         Symbol tables           |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span>+---------------------------------+
</span></span></code></pre></div><h2 id=elf-header>ELF Header</h2><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>e_machine</td><td>目标架构</td></tr><tr><td>e_entry</td><td>入口地址</td></tr><tr><td>e_machine</td><td>目标架构</td></tr><tr><td>e_phnum</td><td>number of entries in the <strong>program header table</strong></td></tr><tr><td>e_shnum</td><td>number of entries in the <strong>section header table</strong></td></tr><tr><td>e_shoff</td><td>offset, in bytes, of the section header table</td></tr><tr><td>e_phoff</td><td>offset, in bytes, of the program header table</td></tr><tr><td>e_machine</td><td>目标架构</td></tr><tr><td>e_machine</td><td>目标架构</td></tr></tbody></table><h2 id=program-header-table>Program Header Table</h2><p>每个表项对应一个segment，表明其位置、属性(LOAD?动态链接用?)、memory size和file size，权限(RWX)等。</p><blockquote><p>Memory Size >= Segment Size, 因为有BSS段存在。</p></blockquote><h2 id=section-header-table>Section Header Table</h2><p>相应地，每个表项指定一个section的信息，包括名字、大小、地址等。</p><h1 id=如何生成一个elf可执行文件>如何生成一个ELF可执行文件</h1><p>从一个C文件到一个ELF可执行文件包括<strong>编译、链接</strong>两个步骤，具体来说，共包含4个步骤：</p><figure align role=group aria-describedby=caption-d41d8cd98f00b204e9800998ecf8427e><a href=https://wangloo.github.io/20230924001351_724769684186295240.png class=img-link><img src=https://wangloo.github.io/20230924001351_724769684186295240_hu0e7a12bbb534e3df2aefcda60b1ced18_0_800x0_resize_box_3.png></a><figcaption id=caption-d41d8cd98f00b204e9800998ecf8427e></figcaption></figure><h2 id=预编译>预编译</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>gcc –E hello.c –o hello.i
</span></span></code></pre></div><p>预编译过程主要处理那些源代码文件中的以“#”开始的预编译指令。比如 “#include”、“#define ”等</p><ul><li>将所有的 “#define ”删除，并且展开所有的宏定义。</li><li>处 理 所 有 条 件 预 编 译 指 令， 比
如 “#if”、“#ifdef”、“#elif”、“#else”、“#endif ”。</li><li>处理 “#include ”预编译指令，将被包含的文件插入到该预编译指令的位
置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其
他文件。</li><li>删除所有的注释“//”和“/* */”。</li><li>添加行号和文件名标识，比如#2“hello.c”2，以便于编译时编译器产生调
试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。</li><li>保留所有的 #pragma 编译器指令，因为编译器须要使用它们。</li></ul><h2 id=编译>编译</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>gcc –S hello.i –o hello.s <span style=color:#6272a4># or</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>gcc –S hello.c –o hello.s 
</span></span></code></pre></div><p>编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件</p><h2 id=汇编>汇编</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>as hello.s –o hello.o <span style=color:#6272a4># or</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>gcc –c hello.c –o hello.o 
</span></span></code></pre></div><p>汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都
对应一条机器指令。所以汇编器的汇编过程相对于编译器来讲比较简单，
它没有复杂的语法，也没有语义，也不需要做指令优化，只是根据汇编指
令和机器指令的对照表一一翻译就可以了</p><h2 id=链接>链接</h2><p>一个可执行文件可能需要用到许多个目标文件，例如C库、pthread库、自己写的库等。
链接的过程就是把他们组合在一起，生成最终的可执行文件。</p><p>仅编译过程中，如果对于外部的函数，编译器无法确定实际跳转的地址，
只能先写0，链接过程会对这个值进行修改。</p><p>主要包含两个过程：（1）地址空间分配（2）重定位</p><ul><li>地址空间分配：这么多.o，这么多section，他们结合为可执行文件后地址怎么规划呢？是不是有的
section 可以合并，比如多个代码段。</li><li>重定位：对于外部调用的函数，这些实际的值也需要更正，或者采用别的方法来间接寻址（动态链接）</li></ul><h3 id=静态链接>静态链接</h3><p>重定位</p><p>合并后的每个section都有一个<strong>重定位表</strong><code>.rel.xx</code>， 里面的内容大概是:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>RELOCATION RECORDS FOR [.text]:
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>OFFSET TYPE VALUE
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>0000001c R_386_32 shared
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>00000027 R_386_PC32 swap
</span></span></code></pre></div><p>对于每个需要重定位的指令，都会在这里表里对应到，所以链接时需要遍历它，填充上真正的地址。</p><h3 id=动态链接>动态链接</h3><p>静态链接的做法就决定了，程序A和B不能共享同一份库，浪费内存。库编进了可执行文件中，所以生成的可执行文件就很大，
另外这样如果要修改库的话就需要对所有依赖的A和B都重新编译。</p><p>动态链接是目的是解决上面的问题，也就是说，库不编到ELF里，ELF在运行的时候能找到它就行。
这样一个程序编译链接后其实不能确定库的地址, 而是将这个过程推迟到运行时的某个时间。</p><blockquote><p>详细可见<a href=https://wangloo.github.io/posts/os/dynamic-link/ title=动态链接>动态链接</a></p></blockquote><h1 id=elf-加载>ELF 加载</h1><blockquote><p>废了半天劲编译生成的ELF文件, 想要最终跑起来则包含的instruction and data必须要在内存中.</p></blockquote><p>我们能想到的最简单的办法是: 把整个ELF的<strong>所有指令和数据</strong>在运行之前就全部load到内存中. 这就是<em>静态加载</em>.</p><p>更加高效的做法是: 充分利用<em>局部性原理</em>, 将指令和数据划分为<strong>模块</strong>, 只有当该模块被使用时, 才load进内存,
否则就在外存中老老实实呆着. 这就是<em>动态加载</em>.</p><h2 id=静态加载>静态加载</h2><ol><li>读取ELF header, 校验magic number和架构是否正确</li><li>根据ELF header中指定的 program header table地址去读 segments</li><li>加载segments 中属性为LOAD的segment, 先要分配对应的虚拟空间, 根据ELF的LMA</li><li>加载程序为ELF分配栈空间，并填充argc, argv，env等。<blockquote><p>参数、环境变量怎么填充需要参考体系结构的ABI手册</p></blockquote></li><li>将PC设置为ELF header中entry point, 返回到用户态开始执行</li></ol><h2 id=动态加载>动态加载</h2><blockquote><p>详细可见<a href=https://wangloo.github.io/posts/os/dynamic-link/ title=动态加载>动态加载</a></p></blockquote><h1 id=其他问题汇总>其他问题汇总</h1><h2 id=为什么要区分section和segment>为什么要区分section和segment</h2><p>segment是加载关心的, section是链接过程关心的。</p><ul><li>segment中包含了多个section, 这些section地址相连、属性类似, 加载器只按照segment去加载。</li><li>而链接时, 链接器会对每个section进行重定位, 同时也需要 <code>.rel*</code> section来完成重定位。</li><li>调试信息也是按照section进行存储的，调试器依赖他们得到符号信息。</li></ul><h2 id=为什么目标文件中代码和数据要分开放>为什么目标文件中代码和数据要分开放?</h2><p>一方面, 程序被加载进内存后, 代码段和数据段分别被映射到<strong>两个virtual memory region</strong>.
通过MMU的支持, 可以将代码段的区域设置为只读, 防止恶意篡改.</p><p>另一方面, 当下CPU Cache多划分为<em>Instruction Cache</em>和<em>Data Cache</em>, 再配合互相独立的
地址区域能够提高<strong>局部性原理</strong>的效果.</p><p>最后, 代码段可以被多个进程共享(例如都调用同一外部函数), 节省内存空间.</p><blockquote><p>针对嵌入式设备, 如果内存空间不够大, 只读的代码段可存放在ROM中</p></blockquote><h2 id=段地址对齐技术>段地址对齐技术</h2><blockquote><p>由前面动态加载的步骤可知, ELF文件中的代码和数据被按page划分. 并只有在用到时才被加载到内存,
并建立<code>虚拟内存-物理内存</code>的映射.</p></blockquote><p>假设一个ELF有三个段需要被<code>LOAD</code>, ELF段表如下:</p><table><thead><tr><th>Segment</th><th>Length</th><th>offset</th></tr></thead><tbody><tr><td>SEG 0</td><td>127 B</td><td>34 B</td></tr><tr><td>SEG 1</td><td>9899 B</td><td>164 B</td></tr><tr><td>SEG 2</td><td>1988 B</td><td>0 B</td></tr></tbody></table><h3 id=-这三个段在elf文件中的布局如何>❓ 这三个段在ELF文件中的布局如何?</h3><p>根据前面ELF文件格式的介绍, 这三个段必然是挨着的(简单考虑, ELF中仅有这三个段).</p><h3 id=-这三个段在物理内存中的布局>❓ 这三个段在物理内存中的布局?</h3><p>发生<code>page fault</code>之后, OS会为页面分配合适的物理页面, 如利用<code>buddy system</code>等.</p><p>可以保证<em>段内</em>的连续, 不能保证<em>段与段</em>是连续的.</p><blockquote><p>未使用段对齐技术之前, <code>SEG0</code>的长度不足一页, 但是也给它分配一页的空间. 同理为<code>SEG1</code>分配两页, <code>SEG2</code>分配一页.
总共占用 <code>1+2+1=5</code>个物理页.</p></blockquote><h3 id=-这三个段在用户virtual-addrspace下的布局如何>❓ 这三个段在用户virtual addrspace下的布局如何?</h3><p>todo</p><h3 id=-何为段地址对齐技术>❓ 何为段地址对齐技术?</h3><p>上面说了, 在为这三个段分配物理内存时, 虽然他们的真实大小远小于5个页面, 但由于简单采用: <code>每个段的开头必须是page align</code>,
导致实际上产生了巨大的<strong>内部碎片</strong>.</p><p>段地址对齐实际上就是在为ELF文件中的段分配物理内存时, 不考虑其段的独立性, 强制按照<code>page</code>来划分. 划分的行为如下图所示.
结果就是仅需占用<code>3</code>个物理页面.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span>+---+---------------+
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>| P |     SEG0      |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>| A +---------------+
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>| G |               |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>| E |               |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>+---+               |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>| P |     SEG1      |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>| A |               |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>| G |               |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>| E |               |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>+---+               |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>| P +---------------+
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>| A |               |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>| G |     SEG2      |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>| E |               |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>+---+---------------+
</span></span></code></pre></div><blockquote><p>目前, gcc(更准确是说是GUN ld)默认启用段对齐技术. 各个段的虚拟地址并不是<code>page align</code>.</p></blockquote><blockquote><p>🍀 物理页面到虚拟页面的映射阶段, 那些<em>同时包含</em>两个段的页面会被映射两次, 即一个物理页面对应两个
虚拟页.</p><p>原因是: 在一个页面的不同段可能<strong>权限不同</strong>, 所以不能使用同一映射.</p></blockquote></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2022-06-20T16:21:27, Lastmod: 2023-12-14T14:28:32</p></main></div></body></html>