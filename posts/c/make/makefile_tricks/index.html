<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>Makefile 一些技巧</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#make%e5%91%bd%e4%bb%a4%e5%8f%82%e6%95%b0 aria-label=make命令参数>make命令参数</a></li><li><a href=#%e4%bc%aa%e7%9b%ae%e6%a0%87%e7%9a%84%e4%be%9d%e8%b5%96%e5%85%b3%e7%b3%bb aria-label=伪目标的依赖关系>伪目标的依赖关系</a></li><li><a href=#%e6%81%90%e6%80%96%e7%9a%84%e7%a9%ba%e6%a0%bc aria-label=恐怖的空格>恐怖的空格</a></li><li><a href=#%e8%a7%84%e5%88%99%e7%9a%84%e6%89%a7%e8%a1%8c%e9%a1%ba%e5%ba%8f aria-label=规则的执行顺序>规则的执行顺序</a></li><li><a href=#%e5%87%bd%e6%95%b0%e7%9a%84%e9%ad%94%e6%b3%95 aria-label=函数的魔法>函数的魔法</a><ul><li><a href=#patsubst aria-label=patsubst>patsubst</a></li></ul></li><li><a href=#%e4%bd%bf%e7%94%a8-shell-%e5%8f%98%e9%87%8f aria-label="使用 shell 变量">使用 shell 变量</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e5%8f%a6%e4%b8%80%e4%b8%aa-makefile aria-label="使用另一个 Makefile">使用另一个 Makefile</a></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>Makefile 一些技巧</div></header><h2 id=make命令参数>make命令参数</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#888># 仅输出所有命令，不实际执行，调试用</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>make -nB
</span></span></code></pre></div><h2 id=伪目标的依赖关系>伪目标的依赖关系</h2><p>Makefile 中的依赖关系指的是目标和依赖之间建立的关系，目标对应规则中的语句是否执行取决于依赖的状态。</p><p>最简单的依赖关系可以拿两个文件来举例:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#888># gcc语句执行当前仅当 main.c 新于 main.elf
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#888></span><span style=color:#06b;font-weight:700>main.elf</span>: main.c
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>    gcc main.c -o main.elf
</span></span></code></pre></div><p>make 在执行<code>main.elf</code>的规则时，会先判断依赖关系。拿上面的例子来说，
gcc 语句是否执行取决于<code>main.c</code> 和 <code>main.elf</code>的修改时间，<strong>只有当
依赖新与目标时，规则语句才会执行</strong>。</p><p>然而许多情况下，目标或者依赖并不是一个文件，而是<strong>虚拟目标</strong>。虚拟目标
并不是一个文件，即它没有修改时间这个属性，此时 make 就不能作比较，结果就是
<strong>如果目标是伪目标，那么不管依赖如何都执行规则语句；如果依赖是伪目标，
那么目标的规则语句也永远被执行</strong>。下面是两个例子：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-make data-lang=make><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#888># 伪目标作为目标文件出现
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#888># build finish总是输出， 而gcc语句仅当main.c比main.elf新时才执行
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#888></span><span style=color:#06b;font-weight:700>.PHONY </span>: all
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span><span style=color:#06b;font-weight:700>all</span>: main.elf
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>	@echo <span style=color:#d20;background-color:#fff0f0>&#39;build finish&#39;</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span><span style=color:#06b;font-weight:700>main.elf</span>: main.c
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span>	gcc $&lt; -o <span style=color:#369>$@</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-make data-lang=make><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#888># 伪目标作为依赖文件中出现
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#888># 不管main.c是否比main.elf更新，因为pre-work是伪目标
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#888># 所以gcc语句总是执行
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span><span style=color:#888></span><span style=color:#06b;font-weight:700>.PHONY </span>: pre-work
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span><span style=color:#06b;font-weight:700>main.elf</span>: main.c pre-work
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>	gcc $&lt; -o <span style=color:#369>$@</span>
</span></span></code></pre></div><p>上面的代码的效果是：两条规则中的语句都会执行，即使你并没有对 main.c 做任何修改！</p><h2 id=恐怖的空格>恐怖的空格</h2><p>Makefile 中的变量结合很常见，例如<code>$(FIXDEP)=$(FIXDEP_PATH)/build/fixdep</code>.</p><p>特别是当我们这些语句是从某些地方粘贴过来，要特别注意变量中是否有空格，Makefile 非常重视这个。假如<code>$(FIXDEP_PATH)</code>中有一个空格，那么<code>$(FIXDEP)</code>就变成<strong>两个宏</strong>了（不知道叫宏合不合适）。而且 Make 的执行过程很难检查出来。</p><h2 id=规则的执行顺序>规则的执行顺序</h2><p>如果不从命令行传入目标, Makefile 中定义的规则其实是以<strong>从上而下</strong>的顺序执行的, 但是我习惯把 <code>all</code> 这种默认规则放在最下面, 所以一般我们可以看到很多 Makefile 会在开头写一句规则<code>all:</code>, 作用就是告诉 make 默认(不显式指定)的目标是<code>all</code>.</p><blockquote><p>Busybox 根目录 Makefile 中的做法示例</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#888># That&#39;s our default target when &gt;none is given on the command line
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#888></span><span style=color:#06b;font-weight:700>.PHONY</span>: _all
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#06b;font-weight:700>_all</span>:
</span></span></code></pre></div></blockquote><h2 id=函数的魔法>函数的魔法</h2><h3 id=patsubst>patsubst</h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-make data-lang=make><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#080;font-weight:700>$(</span><span style=color:#369>patsubst</span> &lt;<span style=color:#369>pattern</span>&gt;,&lt;<span style=color:#369>replacement</span>&gt;,&lt;<span style=color:#369>text</span>&gt;<span style=color:#080;font-weight:700>)</span>
</span></span></code></pre></div><p>功能：查找<code>&lt;text></code>中的单词（以空格，tab，回车，换行分割），看其是否符合<code>&lt;pattern></code>,
如果符合，将其使用<code>&lt;replacement></code>替换。可以使用通配符<code>%</code>。</p><p>以下两对是等效的, 明显还是直接使用变量的替换语法操作简单:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-make data-lang=make><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#080;font-weight:700>$(</span><span style=color:#369>patsubst</span> &lt;<span style=color:#369>pattern</span>&gt;,&lt;<span style=color:#369>replacement</span>&gt;,<span style=color:#080;font-weight:700>$(</span><span style=color:#369>var</span><span style=color:#080;font-weight:700>))</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#06b;font-weight:700>$(var</span>:&lt;pattern&gt;=&lt;replacement&gt;;)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span><span style=color:#080;font-weight:700>$(</span><span style=color:#369>patsubst</span> %&lt;<span style=color:#369>suffix</span>&gt;,%&lt;<span style=color:#369>replacement</span>&gt;,<span style=color:#080;font-weight:700>$(</span><span style=color:#369>var</span><span style=color:#080;font-weight:700>))</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span><span style=color:#06b;font-weight:700>$(var</span>:&lt;suffix&gt;=&lt;replacement&gt;)
</span></span></code></pre></div><h2 id=使用-shell-变量>使用 shell 变量</h2><p>Make 将 <code>$$var</code> 转义为<code>$var</code>, 供 shell 处理.</p><p>demo(源自 6.828 根目录<code>GNUmakefile</code>):</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#06b;font-weight:700>handin-check</span>:
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>    @if <span style=color:#038>test</span> -n <span style=color:#d20;background-color:#fff0f0>&#34;`git status -s`&#34;</span>; <span style=color:#080;font-weight:700>then</span> <span style=color:#04d;background-color:#fff0f0>\
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#04d;background-color:#fff0f0></span>        git status -s; <span style=color:#04d;background-color:#fff0f0>\
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span><span style=color:#04d;background-color:#fff0f0></span>        <span style=color:#038>read</span> -p <span style=color:#d20;background-color:#fff0f0>&#34;Untracked files will not be handed in.  Continue? [y/N] &#34;</span> r; <span style=color:#04d;background-color:#fff0f0>\
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span><span style=color:#04d;background-color:#fff0f0></span>        <span style=color:#038>test</span> <span style=color:#d20;background-color:#fff0f0>&#34;</span><span style=color:#369>$$</span><span style=color:#d20;background-color:#fff0f0>r&#34;</span> = y; <span style=color:#04d;background-color:#fff0f0>\
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span><span style=color:#04d;background-color:#fff0f0></span>    <span style=color:#080;font-weight:700>fi</span>
</span></span></code></pre></div><blockquote><p>以上 demo 还使用了 test 命令来终止 make 的执行, 如果用户没有输入<code>y</code>, make 将会终止执行</p></blockquote><h2 id=使用另一个-makefile>使用另一个 Makefile</h2><p>常见的有三种方式， <code>make -C</code>, <code>make -f</code> 和 <code>include</code></p><p><code>make -C &lt;dir></code> 的作用等价与 <code>cd &lt;dir></code>+<code>make</code>, 常见于在一个工程
的主目录下，依次编译生成其他子目录的目标文件。有<code>cd</code>命令的效果，会切换
当前目录。</p><p><code>make -f &lt;file></code> 更像临时使用某个 Makefile 来执行一些操作，在指定的
Makefile 中如果想使用之前的变量，需要<code>export</code>. 目前还没有发现有必要的
应用场景，大部分用<code>include</code>方式替代。</p><p><code>include &lt;file></code> 一般用于引入一些通用规则，就像 C 语言的 include 头文件
一样，变量无需<code>export</code>.</p></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2022-12-03T19:08:22, Lastmod: 2024-04-17T23:52:53</p></main></div></body></html>