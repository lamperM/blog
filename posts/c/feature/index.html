<!doctype html><html><head><title>C语言的特点与难点</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=description content><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><link rel=stylesheet href=/scss/journal.min.ea0f3d3af5cc437a42b1ad2f9b5ebeeaf367c8f8fc3004c55b78f4f503cea3a2.css integrity="sha256-6g89OvXMQ3pCsa0vm16+6vNnyPj8MATFW3j09QPOo6I=" media=screen><link rel=stylesheet href=/scss/dark-mode.min.2509d1ab7a8b17f2ca6b95285afc4f5ef50f8699b8114c954f01351654b5ceba.css integrity="sha256-JQnRq3qLF/LKa5UoWvxPXvUPhpm4EUyVTwE1FlS1zro=" media=screen><script src=/vendor/js/loadCSS.js></script>
<script>loadCSS("https://fonts.googleapis.com/css?family=Fira+Mono|Material+Icons")</script><script src=/js/toc.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script>
<script src=/vendor/js/md5.min.js></script>
<script>var gitalk=new Gitalk({clientID:"12dfb0f809e5e6afde3d",clientSecret:"72aaf5660b3a7b43b0bffb4d683a605a7ea65dad",repo:"blogcomments_gitalk",owner:"wangloo",admin:["wangloo"],id:md5(location.pathname),distractionFreeMode:"false"});window.onload=function(){gitalk.render("gitalk-container")}</script></head><body><div id=app><div id=sideContainer class=side-container><a class="a-block nav-head false" href=https://wangloo.github.io/><div class=nav-title>Wangloo's BLOG</div><div class=nav-subtitle>花有重开日, 人无再少年</div></a><div class=nav-link-list><a class="a-block nav-link-item active" href=/posts>Archive</a>
<a class="a-block nav-link-item false" href=/tags>Tags</a>
<a class="a-block nav-link-item false" href=/categories>Categories</a></div><div class=nav-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://risehere.net/>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
@2019 Notepadium.</div></div><div id=extraContainer class=extra-container><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc-content><center>- CATALOG -</center><ul><li><a href=#%e5%87%bd%e6%95%b0%e6%8c%87%e9%92%88 onclick="onNavClick(`#函数指针-nav`)" id=函数指针-nav>函数指针</a></li><ul><li><a href=#%e6%8c%87%e9%92%88%e7%9a%84%e6%95%b0%e7%bb%84-or-%e6%8c%87%e5%90%91%e6%95%b0%e7%bb%84%e7%9a%84%e6%8c%87%e9%92%88 onclick="onNavClick(`#指针的数组-or-指向数组的指针-nav`)" id=指针的数组-or-指向数组的指针-nav>指针的数组 or 指向数组的指针?</a></li><li><a href=#%e5%9f%ba%e7%a1%80%e6%9e%b6%e6%9e%84 onclick="onNavClick(`#基础架构-nav`)" id=基础架构-nav>基础架构</a></li><li><a href=#typedef%e5%b8%ae%e5%8a%a9%e7%90%86%e8%a7%a3%e5%87%bd%e6%95%b0%e6%8c%87%e9%92%88 onclick="onNavClick(`#typedef帮助理解函数指针-nav`)" id=typedef帮助理解函数指针-nav>typedef帮助理解函数指针</a></li></ul><li><a href=#c%e8%af%ad%e8%a8%80%e6%a0%87%e5%87%86 onclick="onNavClick(`#c语言标准-nav`)" id=c语言标准-nav>C语言标准</a></li><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afkr-c onclick="onNavClick(`#什么是kr-c-nav`)" id=什么是kr-c-nav>什么是K&R C？</a></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afansi-ciso-cc89c90%e6%a0%87%e5%87%86 onclick="onNavClick(`#什么是ansi-ciso-cc89c90标准-nav`)" id=什么是ansi-ciso-cc89c90标准-nav>什么是ANSI C、ISO C、C89、C90标准？</a></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afc99%e6%a0%87%e5%87%86 onclick="onNavClick(`#什么是c99标准-nav`)" id=什么是c99标准-nav>什么是C99标准？</a></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afc11%e6%a0%87%e5%87%86 onclick="onNavClick(`#什么是c11标准-nav`)" id=什么是c11标准-nav>什么是C11标准？</a></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afc18%e6%a0%87%e5%87%86 onclick="onNavClick(`#什么是c18标准-nav`)" id=什么是c18标准-nav>什么是C18标准？</a></li><li><a href=#%e5%a6%82%e4%bd%95%e6%9f%a5%e7%9c%8b%e8%87%aa%e5%b7%b1%e7%a8%8b%e5%ba%8f%e7%9a%84c%e6%a0%87%e5%87%86%e7%89%88%e6%9c%ac onclick="onNavClick(`#如何查看自己程序的c标准版本-nav`)" id=如何查看自己程序的c标准版本-nav>如何查看自己程序的C标准版本？</a></li><li><a href=#%e5%a6%82%e4%bd%95%e6%8c%87%e5%ae%9a%e6%8c%89%e7%85%a7%e6%9f%90%e4%b8%aa%e6%a0%87%e5%87%86%e6%89%a7%e8%a1%8c%e7%bc%96%e8%af%91 onclick="onNavClick(`#如何指定按照某个标准执行编译-nav`)" id=如何指定按照某个标准执行编译-nav>如何指定按照某个标准执行编译？</a></li><li><a href=#%e5%8f%82%e8%80%83%e7%9b%ae%e5%bd%95 onclick="onNavClick(`#参考目录-nav`)" id=参考目录-nav>参考目录</a></li></ul><li><a href=#%e5%90%ab%e7%b3%8a%e4%b8%8d%e6%b8%85%e7%9a%84%e7%ac%a6%e5%8f%b7%e6%89%a9%e5%b1%95 onclick="onNavClick(`#含糊不清的符号扩展-nav`)" id=含糊不清的符号扩展-nav>含糊不清的符号扩展</a></li><ul><li><a href=#%e9%97%ae%e9%a2%98%e5%87%ba%e5%9c%a8%e5%93%aa onclick="onNavClick(`#问题出在哪-nav`)" id=问题出在哪-nav>问题出在哪？</a></li><li><a href=#%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d onclick="onNavClick(`#如何避免-nav`)" id=如何避免-nav>如何避免？</a></li></ul><li><a href=#%e5%8f%b3%e7%a7%bb%e5%92%8c%e9%99%a4%e6%b3%95 onclick="onNavClick(`#右移和除法-nav`)" id=右移和除法-nav>右移和除法</a></li><ul><li><a href=#logical-shift-vs-arithmetic-shift onclick="onNavClick(`#logical-shift-vs-arithmetic-shift-nav`)" id=logical-shift-vs-arithmetic-shift-nav>Logical Shift .vs. Arithmetic Shift</a></li><li><a href=#%e5%ae%9e%e8%b7%b5%e5%87%ba%e7%9c%9f%e7%9f%a5 onclick="onNavClick(`#实践出真知-nav`)" id=实践出真知-nav>实践出真知</a></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e7%bb%93%e6%9e%9c%e4%b8%8d%e5%90%8c onclick="onNavClick(`#为什么结果不同-nav`)" id=为什么结果不同-nav>为什么结果不同</a></li><li><a href=#%e6%88%91%e4%bb%ac%e5%ba%94%e8%af%a5%e5%a6%82%e4%bd%95%e5%81%9a onclick="onNavClick(`#我们应该如何做-nav`)" id=我们应该如何做-nav>我们应该如何做</a></li></ul></div></div><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a>
<a type=button class=pagination-action id=darkModeToggleButton><span class="material-icons pagination-action-icon" id=darkModeToggleIcon>dark_mode</span></a></div></div><div class=single-column-drawer-container id=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item active" href=/posts>Archive</a>
<a class="a-block drawer-menu-item false" href=/tags>Tags</a>
<a class="a-block drawer-menu-item false" href=/categories>Categories</a><div class=toc><div class=toc-content><center>- CATALOG -</center><ul><li><a href=#%e5%87%bd%e6%95%b0%e6%8c%87%e9%92%88 onclick="onNavClick(`#函数指针-nav`)" id=函数指针-nav>函数指针</a></li><ul><li><a href=#%e6%8c%87%e9%92%88%e7%9a%84%e6%95%b0%e7%bb%84-or-%e6%8c%87%e5%90%91%e6%95%b0%e7%bb%84%e7%9a%84%e6%8c%87%e9%92%88 onclick="onNavClick(`#指针的数组-or-指向数组的指针-nav`)" id=指针的数组-or-指向数组的指针-nav>指针的数组 or 指向数组的指针?</a></li><li><a href=#%e5%9f%ba%e7%a1%80%e6%9e%b6%e6%9e%84 onclick="onNavClick(`#基础架构-nav`)" id=基础架构-nav>基础架构</a></li><li><a href=#typedef%e5%b8%ae%e5%8a%a9%e7%90%86%e8%a7%a3%e5%87%bd%e6%95%b0%e6%8c%87%e9%92%88 onclick="onNavClick(`#typedef帮助理解函数指针-nav`)" id=typedef帮助理解函数指针-nav>typedef帮助理解函数指针</a></li></ul><li><a href=#c%e8%af%ad%e8%a8%80%e6%a0%87%e5%87%86 onclick="onNavClick(`#c语言标准-nav`)" id=c语言标准-nav>C语言标准</a></li><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afkr-c onclick="onNavClick(`#什么是kr-c-nav`)" id=什么是kr-c-nav>什么是K&R C？</a></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afansi-ciso-cc89c90%e6%a0%87%e5%87%86 onclick="onNavClick(`#什么是ansi-ciso-cc89c90标准-nav`)" id=什么是ansi-ciso-cc89c90标准-nav>什么是ANSI C、ISO C、C89、C90标准？</a></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afc99%e6%a0%87%e5%87%86 onclick="onNavClick(`#什么是c99标准-nav`)" id=什么是c99标准-nav>什么是C99标准？</a></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afc11%e6%a0%87%e5%87%86 onclick="onNavClick(`#什么是c11标准-nav`)" id=什么是c11标准-nav>什么是C11标准？</a></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afc18%e6%a0%87%e5%87%86 onclick="onNavClick(`#什么是c18标准-nav`)" id=什么是c18标准-nav>什么是C18标准？</a></li><li><a href=#%e5%a6%82%e4%bd%95%e6%9f%a5%e7%9c%8b%e8%87%aa%e5%b7%b1%e7%a8%8b%e5%ba%8f%e7%9a%84c%e6%a0%87%e5%87%86%e7%89%88%e6%9c%ac onclick="onNavClick(`#如何查看自己程序的c标准版本-nav`)" id=如何查看自己程序的c标准版本-nav>如何查看自己程序的C标准版本？</a></li><li><a href=#%e5%a6%82%e4%bd%95%e6%8c%87%e5%ae%9a%e6%8c%89%e7%85%a7%e6%9f%90%e4%b8%aa%e6%a0%87%e5%87%86%e6%89%a7%e8%a1%8c%e7%bc%96%e8%af%91 onclick="onNavClick(`#如何指定按照某个标准执行编译-nav`)" id=如何指定按照某个标准执行编译-nav>如何指定按照某个标准执行编译？</a></li><li><a href=#%e5%8f%82%e8%80%83%e7%9b%ae%e5%bd%95 onclick="onNavClick(`#参考目录-nav`)" id=参考目录-nav>参考目录</a></li></ul><li><a href=#%e5%90%ab%e7%b3%8a%e4%b8%8d%e6%b8%85%e7%9a%84%e7%ac%a6%e5%8f%b7%e6%89%a9%e5%b1%95 onclick="onNavClick(`#含糊不清的符号扩展-nav`)" id=含糊不清的符号扩展-nav>含糊不清的符号扩展</a></li><ul><li><a href=#%e9%97%ae%e9%a2%98%e5%87%ba%e5%9c%a8%e5%93%aa onclick="onNavClick(`#问题出在哪-nav`)" id=问题出在哪-nav>问题出在哪？</a></li><li><a href=#%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d onclick="onNavClick(`#如何避免-nav`)" id=如何避免-nav>如何避免？</a></li></ul><li><a href=#%e5%8f%b3%e7%a7%bb%e5%92%8c%e9%99%a4%e6%b3%95 onclick="onNavClick(`#右移和除法-nav`)" id=右移和除法-nav>右移和除法</a></li><ul><li><a href=#logical-shift-vs-arithmetic-shift onclick="onNavClick(`#logical-shift-vs-arithmetic-shift-nav`)" id=logical-shift-vs-arithmetic-shift-nav>Logical Shift .vs. Arithmetic Shift</a></li><li><a href=#%e5%ae%9e%e8%b7%b5%e5%87%ba%e7%9c%9f%e7%9f%a5 onclick="onNavClick(`#实践出真知-nav`)" id=实践出真知-nav>实践出真知</a></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e7%bb%93%e6%9e%9c%e4%b8%8d%e5%90%8c onclick="onNavClick(`#为什么结果不同-nav`)" id=为什么结果不同-nav>为什么结果不同</a></li><li><a href=#%e6%88%91%e4%bb%ac%e5%ba%94%e8%af%a5%e5%a6%82%e4%bd%95%e5%81%9a onclick="onNavClick(`#我们应该如何做-nav`)" id=我们应该如何做-nav>我们应该如何做</a></li></ul></div></div></div></div></div><transition name=fade><div id=drawer-mask v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav id=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div id=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu</i></button>
<a id=navTitle class=navbar-brand href=https://wangloo.github.io/>Wangloo's BLOG</a>
<button type=button class=nav-darkmode-toggle id=darkModeToggleButton2>
<i class=material-icons id=darkModeToggleIcon2>dark_mode</i></button></div></nav><div class=single-column-header-container id=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=https://wangloo.github.io/><div class=single-column-header-title>Wangloo's BLOG</div><div class=single-column-header-subtitle>花有重开日, 人无再少年</div></a></div><div id=content><div id=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only><div class=post-title>C语言的特点与难点<div class=post-meta><time itemprop=datePublished>2023-03-09 17:18</time>
<i class=material-icons>label</i>
<a href=/tags/c>c</a>
&nbsp;
<i class=material-icons>schedule</i>
19 min
59 s.</div></div></div><div class=post-body-wrapper><div class=post-body v-pre><h1 id=函数指针>函数指针</h1><h2 id=指针的数组-or-指向数组的指针>指针的数组 or 指向数组的指针?</h2><pre tabindex=0><code>&gt;&gt; int (*p)[10]   p是指针, 指向长度为10的数组. 加括号是为了强调p是一个指针, 区别包含10个指针的array.
&gt;&gt; int *(p[10])   p是数组, 它的元素类型是int *, 加括号是为了强调p是数组.
&gt;&gt; int *p[10]     等效于int *(p[10])
</code></pre><h2 id=基础架构>基础架构</h2><pre tabindex=0><code>// 函数指针
&gt;&gt; int (*f)(int)  说明f是一个指向函数的指针, 加括号为了区别返回值为int*的函数
&gt;&gt; f = function;  函数指针的赋值
&gt;&gt; (*f)(x)        函数指针指向函数的调用, 可简化为f(x). 但是容易将f误认为是函数.
    
// 函数指针的数组
&gt;&gt; int (*(f[10])) (int)  f是数组,元素为10个函数指针. 内层括号说明f是数组,外层括号说明元素类型是函数指针
&gt;&gt; int (*f[10]) (int)    与上面等效. 但外层括号不能省略
&gt;&gt; f[0] = function()     赋值
&gt;&gt; (*f[0])()             指向函数的调用, 可简化为f[0]()
    
// 返回函数指针的函数
&gt;&gt; void (*signal(int sig, ...))(int);  signal是一个函数, 参数有sig.... 它的返回值是一个函数指针, 指向任意返回值为void, 参数为int的函数.
</code></pre><h2 id=typedef帮助理解函数指针><code>typedef</code>帮助理解函数指针</h2><p><code>signal()</code>是一个系统调用, 用于告诉系统, 当某种特定"软件中断"发生时调用<em>特定的程序</em>. 它的真正名称应当是: <em>Call that routine when the interrupt comes in</em>.</p><p>看<code>signal()</code>的原型, 非常复杂. 根据上面基础架构的铺垫, 可以看出<code>signal()</code>的返回值是函数指针, 同时它的参数也是一个函数指针. 且这两个函数指针所指向函数的返回值和参数相同.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8be9fd>void</span> (<span style=color:#ff79c6>*</span>signal(<span style=color:#8be9fd>int</span> sig, <span style=color:#8be9fd>void</span>(<span style=color:#ff79c6>*</span>func)(<span style=color:#8be9fd>int</span>)))(<span style=color:#8be9fd>int</span>);
</span></span></code></pre></div><p>可以借用<code>typedef</code>表示通用部分.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>typedef</span> <span style=color:#50fa7b>void</span> (<span style=color:#ff79c6>*</span>sighandler_t)(<span style=color:#8be9fd>int</span>);
</span></span></code></pre></div><p>而后<code>signal</code>的声明就是人能看懂的了:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>sighandler_t <span style=color:#50fa7b>signal</span>(<span style=color:#8be9fd>int</span> signum, sighandler_t handler);
</span></span></code></pre></div><h1 id=c语言标准>C语言标准</h1><p>我们在使用C语言编程时很少有人告诉我们C语言各个标准的情况，于是我们在看见一些函数标定支持的C标准（例如仅支持C99及以后），内心不会有什么波澜。</p><p>我们常见这些C标准：K&R C、ANSI C、ISO C、C89、C99、C11、C18。让我们补充点可能很少使用的知识吧。</p><h2 id=什么是kr-c>什么是K&R C？</h2><p>1978年，丹尼斯•里奇（Dennis Ritchie）和布莱恩•柯林汉（Brian ernighan）合作出版了《C程序设计语言》的第一版。书中介绍的C语言标准也被称作“K&R C”。</p><p>最初的C标准与我们现在用的有较大差别，例如它竟然还不支持void类型！</p><h2 id=什么是ansi-ciso-cc89c90标准>什么是ANSI C、ISO C、C89、C90标准？</h2><p>随着C语言使用得越来越广泛，出现了许多新问题，人们日益强烈地要求对C语言进行标准化。1983年，美国国家标准协会（ANSI）组成了一个委员会，X3J11，为了创立 C 的一套标准。经过漫长而艰苦的过程，该标准于1989年完成，这个版本的语言经常被称作ANSI C，或有时称为C89（为了区别C99）。在1990年，ANSI C标准（带有一些小改动）被美国国家标准协会（ANSI）采纳为ISO/IEC 9899:1990。这个版本有时候称为C90或者ISO C。综上，ANSI C、ISO C、C89、C90其实是同一种标准。</p><p>这一版本的C就更接近我们平常使用的C了，大部分特性都引入了。</p><h2 id=什么是c99标准>什么是C99标准？</h2><p>2000年3月，ANSI 采纳了 ISO/IEC 9899:1999 标准。这个标准通常指C99。</p><p>C99我们最常使用的新特性是：在源代码的中间位置声明变量。</p><h2 id=什么是c11标准>什么是C11标准？</h2><p>C11标准是C语言标准的第三版（2011年由ISO/IEC发布），前一个标准版本是C99标准。与C99相比，C11有哪些变化呢？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#bd93f9>1</span>、 对齐处理：alignof(T)返回T的对齐方式，aligned_alloc()以指定字节和对齐方式分配内存，头文件<span style=color:#ff79c6>&lt;</span>stdalign.h<span style=color:#ff79c6>&gt;</span>定义了这些内容。
</span></span><span style=display:flex><span><span style=color:#bd93f9>2</span>、 _Noreturn：_Noreturn 是个函数修饰符，位置在函数返回类型的前面，声明函数无返回值，有点类似于gcc的__attribute__((noreturn))，后者在声明语句尾部。
</span></span><span style=display:flex><span><span style=color:#bd93f9>3</span>、 _Generic：_Generic支持轻量级范型编程，可以把一组具有不同类型而却有相同功能的函数抽象为一个接口。
</span></span><span style=display:flex><span><span style=color:#bd93f9>4</span>、 _Static_assert()：_Static_assert()，静态断言，在编译时刻进行，断言表达式必须是在编译时期可以计算的表达式，而普通的assert()在运行时刻断言。
</span></span><span style=display:flex><span><span style=color:#bd93f9>5</span>、安全版本的几个函数：gets_s()取代了gets()，原因是后者这个I<span style=color:#ff79c6>/</span>O函数的实际缓冲区大小不确定，以至于发生常见的缓冲区溢出攻击，类似的函数还有其它的。
</span></span><span style=display:flex><span><span style=color:#bd93f9>6</span>、 fopen()新模式：fopen()增加了新的创建、打开模式“x”，在文件锁中比较常用。
</span></span><span style=display:flex><span><span style=color:#bd93f9>7</span>、 匿名结构体、联合体。
</span></span><span style=display:flex><span><span style=color:#bd93f9>8</span>、 多线程：头文件<span style=color:#ff79c6>&lt;</span>threads.h<span style=color:#ff79c6>&gt;</span>定义了创建和管理线程的函数，新的存储类修饰符_Thread_local限定了变量不能在多线程之间共享。
</span></span><span style=display:flex><span><span style=color:#bd93f9>9</span>、 _Atomic类型修饰符和头文件<span style=color:#ff79c6>&lt;</span>stdatomic.h<span style=color:#ff79c6>&gt;</span>。
</span></span><span style=display:flex><span><span style=color:#bd93f9>10</span>、改进的Unicode支持和头文件<span style=color:#ff79c6>&lt;</span>uchar.h<span style=color:#ff79c6>&gt;</span>。
</span></span><span style=display:flex><span><span style=color:#bd93f9>11</span>、quick_exit()：又一种终止程序的方式，当exit()失败时用以终止程序。
</span></span><span style=display:flex><span><span style=color:#bd93f9>12</span>、复数宏，浮点数宏。
</span></span><span style=display:flex><span><span style=color:#bd93f9>13</span>、time.h新增timespec结构体，时间单位为纳秒，原来的timeval结构体时间单位为毫秒。
</span></span></code></pre></div><h2 id=什么是c18标准>什么是C18标准？</h2><p>C18也称C17是于2018年6月发布的 ISO/IEC 9899:2018 的非正式名称，也是目前（截止到2020年6月）为止最新的 C语言编程标准，被用来替代 C11 标准。</p><p>C17 没有引入新的语言特性，只对 C11 进行了补充和修正。</p><p>​</p><h2 id=如何查看自己程序的c标准版本>如何查看自己程序的C标准版本？</h2><p>使用宏__STDC_VERSION__可以输出当前使用的C标准版本，是一个长整型：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>printf(<span style=color:#f1fa8c>&#34;C std version:%ld</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>, __STDC_VERSION__);
</span></span></code></pre></div><p>值与标准的对应关系：</p><table><thead><tr><th>标准</th><th>宏</th></tr></thead><tbody><tr><td>C94</td><td>_<em>STDC_VERSION</em>_= 199409L</td></tr><tr><td>C99</td><td>_<em>STDC_VERSION</em>_= 199901L</td></tr><tr><td>C11</td><td>_<em>STDC_VERSION</em>_= 201112L</td></tr><tr><td>C18</td><td>_<em>STDC_VERSION</em>_= 201710L</td></tr></tbody></table><p>​</p><h2 id=如何指定按照某个标准执行编译>如何指定按照某个标准执行编译？</h2><p>以下的介绍只针对GCC，我没有用过别的编译器。</p><p>GCC中可以添加<code>--std=xxx</code>来指定C标准版本，常用的情况如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>-</span>std<span style=color:#ff79c6>=</span>c11             Conform to the ISO <span style=color:#bd93f9>2011</span> C standard
</span></span><span style=display:flex><span><span style=color:#ff79c6>-</span>std<span style=color:#ff79c6>=</span>c89             Conform to the ISO <span style=color:#bd93f9>1990</span> C standard
</span></span><span style=display:flex><span><span style=color:#ff79c6>-</span>std<span style=color:#ff79c6>=</span>c90             Conform to the ISO <span style=color:#bd93f9>1990</span> C standard
</span></span><span style=display:flex><span><span style=color:#ff79c6>-</span>std<span style=color:#ff79c6>=</span>c99             Conform to the ISO <span style=color:#bd93f9>1999</span> C stand
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#ff79c6>-</span>std<span style=color:#ff79c6>=</span>gnu11           Conform to the ISO <span style=color:#bd93f9>2011</span> C standard with GNU extensions
</span></span><span style=display:flex><span><span style=color:#ff79c6>-</span>std<span style=color:#ff79c6>=</span>gnu89           Conform to the ISO <span style=color:#bd93f9>1990</span> C standard with GNU extensions
</span></span><span style=display:flex><span><span style=color:#ff79c6>-</span>std<span style=color:#ff79c6>=</span>gnu90           Conform to the ISO <span style=color:#bd93f9>1990</span> C standard with GNU extensions
</span></span><span style=display:flex><span><span style=color:#ff79c6>-</span>std<span style=color:#ff79c6>=</span>gnu99           Conform to the ISO <span style=color:#bd93f9>1999</span> C standard with GNU extensions
</span></span></code></pre></div><blockquote><p>默认情况下，我电脑上的<code>gcc 5.4.0</code>使用<code>-std-gnu11</code></p></blockquote><h2 id=参考目录>参考目录</h2><p><a href=https://blog.csdn.net/zhengnianli/article/details/87387268>https://blog.csdn.net/zhengnianli/article/details/87387268</a></p><p><a href=https://gcc.gnu.org/onlinedocs/gcc/C-Dialect-Options.html#C-Dialect-Options>C Dialect Options (Using the GNU Compiler Collection (GCC))</a></p><h1 id=含糊不清的符号扩展>含糊不清的符号扩展</h1><h2 id=问题出在哪>问题出在哪？</h2><p>下面一段代码会输出什么呢？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8be9fd>char</span> c <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0xff</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> (c <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0xff</span>)
</span></span><span style=display:flex><span>    printf(<span style=color:#f1fa8c>&#34;successful</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#ff79c6>else</span>
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>printf</span>(<span style=color:#f1fa8c>&#34;failed</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>);
</span></span></code></pre></div><p>答案是取决于不同的编译器设定：</p><ul><li>当编译器将char识别为signed char时，该判断会失败。因为常数0xff被识别为int类型，所以编译器首先要对c进行符号扩展，判断语句<code>c == 0xff</code>此时等价于<code>(int)c == 0xff</code>。而对于signed char类型是扩展其最高位，即<code>(int)c=0xffffffff</code>，if判断失败。</li><li>当编译器将char识别为unsigned char时，判断成功。对于unsigned char类型总是扩展0。</li></ul><blockquote><p>注：gcc可通过添加编译参数 -fsigned-char/ -funsigned-char来指定编译器如何识别char</p></blockquote><p>同样的问题也存在与位域(bitfiled)中，详见-fsigned-bitfields/-funsigned-bitfields参数。</p><h2 id=如何避免>如何避免？</h2><p>在使用char类型时，根据情况写清楚unsigned/signed char就ok</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>char</span> c <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0xff</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> (c <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0xff</span>)
</span></span><span style=display:flex><span>    printf(<span style=color:#f1fa8c>&#34;successful</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#ff79c6>else</span>
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>printf</span>(<span style=color:#f1fa8c>&#34;failed</span><span style=color:#f1fa8c>\n</span><span style=color:#f1fa8c>&#34;</span>);
</span></span></code></pre></div><h1 id=右移和除法>右移和除法</h1><p>你是否有听说过有符号数不能使用右移操作(<code>>></code>)来代替除法？ 这篇短文会向你证明它，并尝试向你解释为什么。</p><h2 id=logical-shift-vs-arithmetic-shift>Logical Shift .vs. Arithmetic Shift</h2><p>若你现在有二进制数<code>x=1110B</code>，对其施加右移操作，请问高位填0还是填1？</p><p><strong>逻辑移位</strong>不管造成的影响，总是用0来填充移位操作产生的空缺。但是这样简单的想法在一些情况总会出错。例如若上述x是有符号数，那么简单的填0就会造成错误，起码正负号出错了。</p><p><strong>算数移位</strong>支持有符号数的移位操作，在移位后使用符号位进行填充，结合补码的表示方法，就能实现正确的负数移位操作。</p><p>总结来说：在有符号的场景下，使用算数位移；如果你能保证移位操作是无符号的，那么用逻辑位移也无妨.</p><p>x86汇编代码中，<code>shr</code>代表逻辑右移指令，<code>sar</code>代表算数右移指令，我们可以通过以下C代码及其反汇编的结果来更好的理解逻辑移位和算数移位：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;stdlib.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;stdio.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>    
</span></span><span style=display:flex><span><span style=color:#8be9fd>signed</span> <span style=color:#8be9fd>int</span> x <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>-</span><span style=color:#bd93f9>3</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd>unsigned</span> <span style=color:#8be9fd>int</span> y <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>3</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    x <span style=color:#ff79c6>&gt;&gt;=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>    y <span style=color:#ff79c6>&gt;&gt;=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code class=language-assembly data-lang=assembly>x:
        .long   -3
y:
        .long   3
main:
        push    rbp
        mov     rbp, rsp
        mov     eax, DWORD PTR x[rip]
        sar     eax
        mov     DWORD PTR x[rip], eax
        mov     eax, DWORD PTR y[rip]
        shr     eax
        mov     DWORD PTR y[rip], eax
        mov     eax, 0
        pop     rbp
        ret
</code></pre><p><a href=https://godbolt.org/z/K4M4Ko4c7>https://godbolt.org/z/K4M4Ko4c7</a></p><h2 id=实践出真知>实践出真知</h2><p>在我作为一个初级程序员的认知中，<code>/2</code>和<code>>>1</code>是等价的，甚至一起还听说过后者能够优化代码的效率。但是今天我要告诉你， Definitely wrong!</p><p>或许在遥远的古代，我们使用位移操作真的能够对代码进行加速，但是当下编译器已经足够聪明，如果你真的动手反汇编"<code>/2</code>&ldquo;的代码，那么你就会知道编译器已经替你优化为了位移操作。</p><p>更糟糕的是，我们要避免使用移位操作来实现除法或者乘法，不仅仅是因为这两者等价，实际上，他们并不是等价的！并且会造成错误！</p><p>考虑如下的C语言代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;stdlib.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#include</span> <span style=color:#ff79c6>&lt;stdio.h&gt;</span><span style=color:#ff79c6>
</span></span></span><span style=display:flex><span><span style=color:#ff79c6></span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>signed</span> <span style=color:#8be9fd>int</span> x <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>-</span><span style=color:#bd93f9>3</span>;
</span></span><span style=display:flex><span><span style=color:#8be9fd>signed</span> <span style=color:#8be9fd>int</span> y <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>-</span><span style=color:#bd93f9>3</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    x <span style=color:#ff79c6>&gt;&gt;=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>    y <span style=color:#ff79c6>/=</span> <span style=color:#bd93f9>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>他们的汇编代码是相同的吗？这里还是拿X86汇编举例：</p><pre tabindex=0><code class=language-assembly data-lang=assembly>; Following is ‘x &gt;&gt;= 1’
mov     eax, #-3  ;x
sar     eax
mov     x, eax
; Following is ‘y/= 2’
mov     eax, #-3  ;y
mov     edx, eax
shr     edx, 31
add     eax, edx
sar     eax
mov     y, eax
</code></pre><p>注意：以上的汇编代码省去了一些我认为无关紧要的操作，并不是完全正确的，但是足够表达他们的差别了。</p><p>可以看出，除法比移位多了一步<code>shr edx, 31</code>过程，下面会探讨这个。</p><p>还有一件使你震惊的事件，<code>x</code>, <code>y</code>的值最终是<strong>不同</strong>的！是的，正是因为那条看似“多余”的<code>shr</code>指令。</p><h2 id=为什么结果不同>为什么结果不同</h2><p>首先，我们可以确定的一件事是：编译器真的帮我们将除法操作优化为移位。所以，再也不要说你的代码中使用<code>>></code>来替代除法是为了增加执行效率了。</p><p>让我们来解释下为什么两者的结果是不同的。</p><p>首先，<code>sar</code>指令在x86指令集中表示算数右移，这个是我们熟悉的，那么<code>-3</code>进行算数右移后的结果就是<code>-2</code>. 意味着<code>>></code>是向负无穷舍入的.</p><p>那么除法操作又是在干什么呢? 它是将原值加上其符号位.Demo中使用的数据类型是32位<code>int</code>.</p><pre tabindex=0><code class=language-assembly data-lang=assembly>shr     edx, 31
add     eax, edx
</code></pre><p>这样做必然改变了原值啊，动手算一下就会知道，<code>-3/2</code>的结果为<code>-1</code>. 并且只有负奇数会受影响，对于正数，其符号为0；对于负偶数，其补码的最低位必为0，刚加上的1会被下一步的算数右移丢弃，不对高位产生影响。</p><p>Aha, 差别就是向负无穷舍弃还是向0舍弃，一时间竟然不知道哪个是正确的了。</p><h2 id=我们应该如何做>我们应该如何做</h2><p>根据最新的[C语言标准草案](<a href=http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1336.pdf>ISO/IEC 9899:201x (open-std.org)</a>) 6.5.7章节，负数的右移操作是implementation-defined，即取决于具体的实现：</p><blockquote><p>The result of E1 &#187; E2 is E1 right-shifted E2 bit positions. If E1 has an unsigned type or if E1 has a signed type and a nonnegative value, the value of the result is the integral part of the quotient of E1 / 2E2. If E1 has a signed type and a negative value, the resulting value is implementation-defined.</p></blockquote><p>因此，理论上它依赖于实现。所以我们在实际应用中为了程序的可移植性，应当避免对有符号数使用移位操作。除非你能确定它的值一定是非负数，在此情况下，请将它用无符号类型来声明。</p><p>对于除法操作，标准中的6.5.5章节规定了，除法操作总是向0舍入. 非常好！</p><blockquote><p>When integers are divided, the result of the / operator is the algebraic quotient with any fractional part discarded.</p></blockquote><p>检查你的代码，恢复所有的“优化”乘除法的行为吧！</p><hr width=100% id=EOF><p style=color:#777>Last modified on 2023-06-24</p></div></div><nav class=post-pagination><a class=newer-posts href=/posts/c/enum/>Next<br>C语言enum的使用</a>
<a class=older-posts href=/posts/c/experience/>Previous<br>C语言程序设计的一些经验</a></nav><div class=post-comment-wrapper><div id=gitalk-container></div></div></div></div></div></div><div id=single-column-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://risehere.net/>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
@2019 Notepadium.</div></div><script src=/js/journal.js></script></body></html>