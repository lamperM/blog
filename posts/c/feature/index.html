<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>C语言的特点与难点</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>所有文章</a></div><div class="a-block nav-link-item"><a href=/tags>Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%87%bd%e6%95%b0%e6%8c%87%e9%92%88 aria-label=函数指针>函数指针</a><ul><li><a href=#%e6%8c%87%e9%92%88%e7%9a%84%e6%95%b0%e7%bb%84-or-%e6%8c%87%e5%90%91%e6%95%b0%e7%bb%84%e7%9a%84%e6%8c%87%e9%92%88 aria-label="指针的数组 or 指向数组的指针?">指针的数组 or 指向数组的指针?</a></li><li><a href=#%e5%9f%ba%e7%a1%80%e6%9e%b6%e6%9e%84 aria-label=基础架构>基础架构</a></li><li><a href=#typedef%e5%b8%ae%e5%8a%a9%e7%90%86%e8%a7%a3%e5%87%bd%e6%95%b0%e6%8c%87%e9%92%88 aria-label=typedef帮助理解函数指针><code>typedef</code>帮助理解函数指针</a></li></ul></li><li><a href=#c%e8%af%ad%e8%a8%80%e6%a0%87%e5%87%86 aria-label=C语言标准>C语言标准</a><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afkr-c aria-label="什么是K&amp;amp;R C？">什么是K&R C？</a></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afansi-ciso-cc89c90%e6%a0%87%e5%87%86 aria-label="什么是ANSI C、ISO C、C89、C90标准？">什么是ANSI C、ISO C、C89、C90标准？</a></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afc99%e6%a0%87%e5%87%86 aria-label=什么是C99标准？>什么是C99标准？</a></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afc11%e6%a0%87%e5%87%86 aria-label=什么是C11标准？>什么是C11标准？</a></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afc18%e6%a0%87%e5%87%86 aria-label=什么是C18标准？>什么是C18标准？</a></li><li><a href=#%e5%a6%82%e4%bd%95%e6%9f%a5%e7%9c%8b%e8%87%aa%e5%b7%b1%e7%a8%8b%e5%ba%8f%e7%9a%84c%e6%a0%87%e5%87%86%e7%89%88%e6%9c%ac aria-label=如何查看自己程序的C标准版本？>如何查看自己程序的C标准版本？</a></li><li><a href=#%e5%a6%82%e4%bd%95%e6%8c%87%e5%ae%9a%e6%8c%89%e7%85%a7%e6%9f%90%e4%b8%aa%e6%a0%87%e5%87%86%e6%89%a7%e8%a1%8c%e7%bc%96%e8%af%91 aria-label=如何指定按照某个标准执行编译？>如何指定按照某个标准执行编译？</a></li><li><a href=#%e5%8f%82%e8%80%83%e7%9b%ae%e5%bd%95 aria-label=参考目录>参考目录</a></li></ul></li><li><a href=#%e5%90%ab%e7%b3%8a%e4%b8%8d%e6%b8%85%e7%9a%84%e7%ac%a6%e5%8f%b7%e6%89%a9%e5%b1%95 aria-label=含糊不清的符号扩展>含糊不清的符号扩展</a><ul><li><a href=#%e9%97%ae%e9%a2%98%e5%87%ba%e5%9c%a8%e5%93%aa aria-label=问题出在哪？>问题出在哪？</a></li><li><a href=#%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d aria-label=如何避免？>如何避免？</a></li></ul></li><li><a href=#%e5%8f%b3%e7%a7%bb%e5%92%8c%e9%99%a4%e6%b3%95 aria-label=右移和除法>右移和除法</a><ul><li><a href=#logical-shift-vs-arithmetic-shift aria-label="Logical Shift .vs. Arithmetic Shift">Logical Shift .vs. Arithmetic Shift</a></li><li><a href=#%e5%ae%9e%e8%b7%b5%e5%87%ba%e7%9c%9f%e7%9f%a5 aria-label=实践出真知>实践出真知</a></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e7%bb%93%e6%9e%9c%e4%b8%8d%e5%90%8c aria-label=为什么结果不同>为什么结果不同</a></li><li><a href=#%e6%88%91%e4%bb%ac%e5%ba%94%e8%af%a5%e5%a6%82%e4%bd%95%e5%81%9a aria-label=我们应该如何做>我们应该如何做</a></li></ul></li></ul></div></details></div></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>C语言的特点与难点</div></header><h1 id=函数指针>函数指针</h1><h2 id=指针的数组-or-指向数组的指针>指针的数组 or 指向数组的指针?</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>&gt;&gt; int (*p)[10]   p是指针, 指向长度为10的数组. 加括号是为了强调p是一个指针, 区别包含10个指针的array.
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>&gt;&gt; int *(p[10])   p是数组, 它的元素类型是int *, 加括号是为了强调p是数组.
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>&gt;&gt; int *p[10]     等效于int *(p[10])
</span></span></code></pre></div><h2 id=基础架构>基础架构</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span>// 函数指针
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>&gt;&gt; int (*f)(int)  说明f是一个指向函数的指针, 加括号为了区别返回值为int*的函数
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>&gt;&gt; f = function;  函数指针的赋值
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>&gt;&gt; (*f)(x)        函数指针指向函数的调用, 可简化为f(x). 但是容易将f误认为是函数.
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>    
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>// 函数指针的数组
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>&gt;&gt; int (*(f[10])) (int)  f是数组,元素为10个函数指针. 内层括号说明f是数组,外层括号说明元素类型是函数指针
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>&gt;&gt; int (*f[10]) (int)    与上面等效. 但外层括号不能省略
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>&gt;&gt; f[0] = function()     赋值
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>&gt;&gt; (*f[0])()             指向函数的调用, 可简化为f[0]()
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>    
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>// 返回函数指针的函数
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>&gt;&gt; void (*signal(int sig, ...))(int);  signal是一个函数, 参数有sig.... 它的返回值是一个函数指针, 指向任意返回值为void, 参数为int的函数.
</span></span></code></pre></div><h2 id=typedef帮助理解函数指针><code>typedef</code>帮助理解函数指针</h2><p><code>signal()</code>是一个系统调用, 用于告诉系统, 当某种特定"软件中断"发生时调用<em>特定的程序</em>. 它的真正名称应当是: <em>Call that routine when the interrupt comes in</em>.</p><p>看<code>signal()</code>的原型, 非常复杂. 根据上面基础架构的铺垫, 可以看出<code>signal()</code>的返回值是函数指针, 同时它的参数也是一个函数指针. 且这两个函数指针所指向函数的返回值和参数相同.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#2b91af>void</span> (*signal(<span style=color:#2b91af>int</span> sig, <span style=color:#2b91af>void</span>(*func)(<span style=color:#2b91af>int</span>)))(<span style=color:#2b91af>int</span>);
</span></span></code></pre></div><p>可以借用<code>typedef</code>表示通用部分.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#00f>typedef</span> void (*sighandler_t)(<span style=color:#2b91af>int</span>);
</span></span></code></pre></div><p>而后<code>signal</code>的声明就是人能看懂的了:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>sighandler_t signal(<span style=color:#2b91af>int</span> signum, sighandler_t handler);
</span></span></code></pre></div><h1 id=c语言标准>C语言标准</h1><p>我们在使用C语言编程时很少有人告诉我们C语言各个标准的情况，于是我们在看见一些函数标定支持的C标准（例如仅支持C99及以后），内心不会有什么波澜。</p><p>我们常见这些C标准：K&R C、ANSI C、ISO C、C89、C99、C11、C18。让我们补充点可能很少使用的知识吧。</p><h2 id=什么是kr-c>什么是K&R C？</h2><p>1978年，丹尼斯•里奇（Dennis Ritchie）和布莱恩•柯林汉（Brian ernighan）合作出版了《C程序设计语言》的第一版。书中介绍的C语言标准也被称作“K&R C”。</p><p>最初的C标准与我们现在用的有较大差别，例如它竟然还不支持void类型！</p><h2 id=什么是ansi-ciso-cc89c90标准>什么是ANSI C、ISO C、C89、C90标准？</h2><p>随着C语言使用得越来越广泛，出现了许多新问题，人们日益强烈地要求对C语言进行标准化。1983年，美国国家标准协会（ANSI）组成了一个委员会，X3J11，为了创立 C 的一套标准。经过漫长而艰苦的过程，该标准于1989年完成，这个版本的语言经常被称作ANSI C，或有时称为C89（为了区别C99）。在1990年，ANSI C标准（带有一些小改动）被美国国家标准协会（ANSI）采纳为ISO/IEC 9899:1990。这个版本有时候称为C90或者ISO C。综上，ANSI C、ISO C、C89、C90其实是同一种标准。</p><p>这一版本的C就更接近我们平常使用的C了，大部分特性都引入了。</p><h2 id=什么是c99标准>什么是C99标准？</h2><p>2000年3月，ANSI 采纳了 ISO/IEC 9899:1999 标准。这个标准通常指C99。</p><p>C99我们最常使用的新特性是：在源代码的中间位置声明变量。</p><h2 id=什么是c11标准>什么是C11标准？</h2><p>C11标准是C语言标准的第三版（2011年由ISO/IEC发布），前一个标准版本是C99标准。与C99相比，C11有哪些变化呢？</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span>1<span>、</span> <span>对齐处理：</span>alignof(T)<span>返回</span>T的对齐方式<span>，</span>aligned_alloc()<span>以指定字节和对齐方式分配内存，头文件</span>&lt;stdalign.h&gt;<span>定义了这些内容。</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>2<span>、</span> _Noreturn<span>：</span>_Noreturn <span>是个函数修饰符，位置在函数返回类型的前面，声明函数无返回值，有点类似于</span>gcc的__attribute__((noreturn))<span>，后者在声明语句尾部。</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>3<span>、</span> _Generic<span>：</span>_Generic支持轻量级范型编程<span>，可以把一组具有不同类型而却有相同功能的函数抽象为一个接口。</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>4<span>、</span> _Static_assert()<span>：</span>_Static_assert()<span>，静态断言，在编译时刻进行，断言表达式必须是在编译时期可以计算的表达式，而普通的</span>assert()<span>在运行时刻断言。</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>5<span>、安全版本的几个函数：</span>gets_s()<span>取代了</span>gets()<span>，原因是后者这个</span>I/O函数的实际缓冲区大小不确定<span>，以至于发生常见的缓冲区溢出攻击，类似的函数还有其它的。</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>6<span>、</span> fopen()<span>新模式：</span>fopen()<span>增加了新的创建、打开模式“</span>x<span>”，在文件锁中比较常用。</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>7<span>、</span> <span>匿名结构体、联合体。</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>8<span>、</span> <span>多线程：头文件</span>&lt;threads.h&gt;<span>定义了创建和管理线程的函数，新的存储类修饰符</span>_Thread_local限定了变量不能在多线程之间共享<span>。</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>9<span>、</span> _Atomic类型修饰符和头文件&lt;stdatomic.h&gt;<span>。</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>10<span>、改进的</span>Unicode支持和头文件&lt;uchar.h&gt;<span>。</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>11<span>、</span>quick_exit()<span>：又一种终止程序的方式，当</span>exit()<span>失败时用以终止程序。</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>12<span>、复数宏，浮点数宏。</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>13<span>、</span>time.h新增timespec结构体<span>，时间单位为纳秒，原来的</span>timeval结构体时间单位为毫秒<span>。</span>
</span></span></code></pre></div><h2 id=什么是c18标准>什么是C18标准？</h2><p>C18也称C17是于2018年6月发布的 ISO/IEC 9899:2018 的非正式名称，也是目前（截止到2020年6月）为止最新的 C语言编程标准，被用来替代 C11 标准。</p><p>C17 没有引入新的语言特性，只对 C11 进行了补充和修正。</p><p>​</p><h2 id=如何查看自己程序的c标准版本>如何查看自己程序的C标准版本？</h2><p>使用宏__STDC_VERSION__可以输出当前使用的C标准版本，是一个长整型：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>printf(<span style=color:#a31515>&#34;C std version:%ld</span><span style=color:#a31515>\n</span><span style=color:#a31515>&#34;</span>, __STDC_VERSION__);
</span></span></code></pre></div><p>值与标准的对应关系：</p><table><thead><tr><th>标准</th><th>宏</th></tr></thead><tbody><tr><td>C94</td><td>_<em>STDC_VERSION</em>_= 199409L</td></tr><tr><td>C99</td><td>_<em>STDC_VERSION</em>_= 199901L</td></tr><tr><td>C11</td><td>_<em>STDC_VERSION</em>_= 201112L</td></tr><tr><td>C18</td><td>_<em>STDC_VERSION</em>_= 201710L</td></tr></tbody></table><p>​</p><h2 id=如何指定按照某个标准执行编译>如何指定按照某个标准执行编译？</h2><p>以下的介绍只针对GCC，我没有用过别的编译器。</p><p>GCC中可以添加<code>--std=xxx</code>来指定C标准版本，常用的情况如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span>-std=c11             Conform to the ISO 2011 C standard
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>-std=c89             Conform to the ISO 1990 C standard
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>-std=c90             Conform to the ISO 1990 C standard
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>-std=c99             Conform to the ISO 1999 C stand
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>    
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>    
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>-std=gnu11           Conform to the ISO 2011 C standard with GNU extensions
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>-std=gnu89           Conform to the ISO 1990 C standard with GNU extensions
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>-std=gnu90           Conform to the ISO 1990 C standard with GNU extensions
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>-std=gnu99           Conform to the ISO 1999 C standard with GNU extensions
</span></span></code></pre></div><blockquote><p>默认情况下，我电脑上的<code>gcc 5.4.0</code>使用<code>-std-gnu11</code></p></blockquote><h2 id=参考目录>参考目录</h2><p><a href=https://blog.csdn.net/zhengnianli/article/details/87387268>https://blog.csdn.net/zhengnianli/article/details/87387268</a></p><p><a href=https://gcc.gnu.org/onlinedocs/gcc/C-Dialect-Options.html#C-Dialect-Options>C Dialect Options (Using the GNU Compiler Collection (GCC))</a></p><h1 id=含糊不清的符号扩展>含糊不清的符号扩展</h1><h2 id=问题出在哪>问题出在哪？</h2><p>下面一段代码会输出什么呢？</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#2b91af>char</span> c = 0xff;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#00f>if</span> (c == 0xff)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>    printf(<span style=color:#a31515>&#34;successful</span><span style=color:#a31515>\n</span><span style=color:#a31515>&#34;</span>);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span><span style=color:#00f>else</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>    printf(<span style=color:#a31515>&#34;failed</span><span style=color:#a31515>\n</span><span style=color:#a31515>&#34;</span>);
</span></span></code></pre></div><p>答案是取决于不同的编译器设定：</p><ul><li>当编译器将char识别为signed char时，该判断会失败。因为常数0xff被识别为int类型，所以编译器首先要对c进行符号扩展，判断语句<code>c == 0xff</code>此时等价于<code>(int)c == 0xff</code>。而对于signed char类型是扩展其最高位，即<code>(int)c=0xffffffff</code>，if判断失败。</li><li>当编译器将char识别为unsigned char时，判断成功。对于unsigned char类型总是扩展0。</li></ul><blockquote><p>注：gcc可通过添加编译参数 -fsigned-char/ -funsigned-char来指定编译器如何识别char</p></blockquote><p>同样的问题也存在与位域(bitfiled)中，详见-fsigned-bitfields/-funsigned-bitfields参数。</p><h2 id=如何避免>如何避免？</h2><p>在使用char类型时，根据情况写清楚unsigned/signed char就ok</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#2b91af>unsigned</span> <span style=color:#2b91af>char</span> c = 0xff
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#00f>if</span> (c == 0xff)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>    printf(<span style=color:#a31515>&#34;successful</span><span style=color:#a31515>\n</span><span style=color:#a31515>&#34;</span>);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span><span style=color:#00f>else</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>    printf(<span style=color:#a31515>&#34;failed</span><span style=color:#a31515>\n</span><span style=color:#a31515>&#34;</span>);
</span></span></code></pre></div><h1 id=右移和除法>右移和除法</h1><p>你是否有听说过有符号数不能使用右移操作(<code>>></code>)来代替除法？ 这篇短文会向你证明它，并尝试向你解释为什么。</p><h2 id=logical-shift-vs-arithmetic-shift>Logical Shift .vs. Arithmetic Shift</h2><p>若你现在有二进制数<code>x=1110B</code>，对其施加右移操作，请问高位填0还是填1？</p><p><strong>逻辑移位</strong>不管造成的影响，总是用0来填充移位操作产生的空缺。但是这样简单的想法在一些情况总会出错。例如若上述x是有符号数，那么简单的填0就会造成错误，起码正负号出错了。</p><p><strong>算数移位</strong>支持有符号数的移位操作，在移位后使用符号位进行填充，结合补码的表示方法，就能实现正确的负数移位操作。</p><p>总结来说：在有符号的场景下，使用算数位移；如果你能保证移位操作是无符号的，那么用逻辑位移也无妨.</p><p>x86汇编代码中，<code>shr</code>代表逻辑右移指令，<code>sar</code>代表算数右移指令，我们可以通过以下C代码及其反汇编的结果来更好的理解逻辑移位和算数移位：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#00f>#include</span> <span style=color:#00f>&lt;stdlib.h&gt;</span><span style=color:#00f>
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#00f>#include</span> <span style=color:#00f>&lt;stdio.h&gt;</span><span style=color:#00f>
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span><span style=color:#00f></span>    
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span><span style=color:#2b91af>signed</span> <span style=color:#2b91af>int</span> x = -3;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span><span style=color:#2b91af>unsigned</span> <span style=color:#2b91af>int</span> y = 3;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span><span style=color:#2b91af>int</span> main()
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    x &gt;&gt;= 1;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>    y &gt;&gt;= 1;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>    <span style=color:#00f>return</span> 0;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span>x:
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>        .long   -3
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>y:
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>        .long   3
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>main:
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>        push    rbp
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>        mov     rbp, rsp
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>        mov     eax, DWORD PTR x[rip]
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>        sar     eax
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>        mov     DWORD PTR x[rip], eax
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>        mov     eax, DWORD PTR y[rip]
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>        shr     eax
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>        mov     DWORD PTR y[rip], eax
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>        mov     eax, 0
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>        pop     rbp
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>        ret
</span></span></code></pre></div><p><a href=https://godbolt.org/z/K4M4Ko4c7>https://godbolt.org/z/K4M4Ko4c7</a></p><h2 id=实践出真知>实践出真知</h2><p>在我作为一个初级程序员的认知中，<code>/2</code>和<code>>>1</code>是等价的，甚至一起还听说过后者能够优化代码的效率。但是今天我要告诉你， Definitely wrong!</p><p>或许在遥远的古代，我们使用位移操作真的能够对代码进行加速，但是当下编译器已经足够聪明，如果你真的动手反汇编"<code>/2</code>&ldquo;的代码，那么你就会知道编译器已经替你优化为了位移操作。</p><p>更糟糕的是，我们要避免使用移位操作来实现除法或者乘法，不仅仅是因为这两者等价，实际上，他们并不是等价的！并且会造成错误！</p><p>考虑如下的C语言代码：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#00f>#include</span> <span style=color:#00f>&lt;stdlib.h&gt;</span><span style=color:#00f>
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#00f>#include</span> <span style=color:#00f>&lt;stdio.h&gt;</span><span style=color:#00f>
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span><span style=color:#00f></span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span><span style=color:#2b91af>signed</span> <span style=color:#2b91af>int</span> x = -3;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span><span style=color:#2b91af>signed</span> <span style=color:#2b91af>int</span> y = -3;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span><span style=color:#2b91af>int</span> main()
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    x &gt;&gt;= 1;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>    y /= 2;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>    <span style=color:#00f>return</span> 0;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>}
</span></span></code></pre></div><p>他们的汇编代码是相同的吗？这里还是拿X86汇编举例：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span>; Following is ‘x &gt;&gt;= 1’
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>mov     eax, #-3  ;x
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>sar     eax
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>mov     x, eax
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>; Following is ‘y/= 2’
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>mov     eax, #-3  ;y
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>mov     edx, eax
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>shr     edx, 31
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>add     eax, edx
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>sar     eax
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>mov     y, eax
</span></span></code></pre></div><p>注意：以上的汇编代码省去了一些我认为无关紧要的操作，并不是完全正确的，但是足够表达他们的差别了。</p><p>可以看出，除法比移位多了一步<code>shr edx, 31</code>过程，下面会探讨这个。</p><p>还有一件使你震惊的事件，<code>x</code>, <code>y</code>的值最终是<strong>不同</strong>的！是的，正是因为那条看似“多余”的<code>shr</code>指令。</p><h2 id=为什么结果不同>为什么结果不同</h2><p>首先，我们可以确定的一件事是：编译器真的帮我们将除法操作优化为移位。所以，再也不要说你的代码中使用<code>>></code>来替代除法是为了增加执行效率了。</p><p>让我们来解释下为什么两者的结果是不同的。</p><p>首先，<code>sar</code>指令在x86指令集中表示算数右移，这个是我们熟悉的，那么<code>-3</code>进行算数右移后的结果就是<code>-2</code>. 意味着<code>>></code>是向负无穷舍入的.</p><p>那么除法操作又是在干什么呢? 它是将原值加上其符号位.Demo中使用的数据类型是32位<code>int</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>shr     edx, 31
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>add     eax, edx
</span></span></code></pre></div><p>这样做必然改变了原值啊，动手算一下就会知道，<code>-3/2</code>的结果为<code>-1</code>. 并且只有负奇数会受影响，对于正数，其符号为0；对于负偶数，其补码的最低位必为0，刚加上的1会被下一步的算数右移丢弃，不对高位产生影响。</p><p>Aha, 差别就是向负无穷舍弃还是向0舍弃，一时间竟然不知道哪个是正确的了。</p><h2 id=我们应该如何做>我们应该如何做</h2><p>根据最新的[C语言标准草案](<a href=http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1336.pdf>ISO/IEC 9899:201x (open-std.org)</a>) 6.5.7章节，负数的右移操作是implementation-defined，即取决于具体的实现：</p><blockquote><p>The result of E1 &#187; E2 is E1 right-shifted E2 bit positions. If E1 has an unsigned type or if E1 has a signed type and a nonnegative value, the value of the result is the integral part of the quotient of E1 / 2E2. If E1 has a signed type and a negative value, the resulting value is implementation-defined.</p></blockquote><p>因此，理论上它依赖于实现。所以我们在实际应用中为了程序的可移植性，应当避免对有符号数使用移位操作。除非你能确定它的值一定是非负数，在此情况下，请将它用无符号类型来声明。</p><p>对于除法操作，标准中的6.5.5章节规定了，除法操作总是向0舍入. 非常好！</p><blockquote><p>When integers are divided, the result of the / operator is the algebraic quotient with any fractional part discarded.</p></blockquote><p>检查你的代码，恢复所有的“优化”乘除法的行为吧！</p></article></body></main></div></body></html>