<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/syntax_pastie.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>Good Design: 抽象消息参数</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>Good Design: 抽象消息参数</div></header><p>在设计一个消息传递类似的子系统时，消息经常需要各种参数，
通常消息的个数和类型是根据<strong>消息自身的类型</strong>决定的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>handle_open</span><span class=p>(...,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>,</span> <span class=kt>int</span> <span class=n>mode</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>handle_read</span><span class=p>(...,</span> <span class=n>size_t</span> <span class=n>len</span><span class=p>,</span> <span class=kt>int</span> <span class=n>offset</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span></code></pre></div><p>有的消息/命令参数比较多，不想写这么长的参数那就把这些参数封装到struct里</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>arg_open</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>flag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>mode</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>arg_read</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 这里用结构体还是结构体指针都可以，不是重点!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>handle_open</span><span class=p>(...,</span> <span class=k>struct</span> <span class=n>arg_open</span> <span class=o>*</span><span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>handle_read</span><span class=p>(...,</span> <span class=k>struct</span> <span class=n>arg_read</span> <span class=o>*</span><span class=n>arg</span><span class=p>);</span>
</span></span></code></pre></div><p>这种方法有什么缺点呢?</p><ol><li>不具有通用性；无法用函数指针来实现进一步抽象，即跳表。</li><li>&mldr;（暂时没想到）</li></ol><p>所以说，<strong>一个更好的抽象方式来了</strong>，将所有的参数利用union放到一个结构体中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>proto_open</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>flag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>mode</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>proto_read</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>size_t</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// GOOD DESIGN
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>proto</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ... 可能有公共的参数, 例如ID
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>union</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>proto_open</span> <span class=n>open</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>proto_read</span> <span class=n>read</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 因为每个类型的消息/命令都有自己的处理函数
</span></span></span><span class=line><span class=cl><span class=c1>// 所以各个函数知道自己应该从那个union成员里取
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>handle_open</span><span class=p>(...,</span> <span class=k>struct</span> <span class=n>proto</span> <span class=o>*</span><span class=n>proto</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>flag</span><span class=p>,</span> <span class=n>mode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>flag</span> <span class=o>=</span> <span class=n>proto</span><span class=o>-&gt;</span><span class=n>open</span><span class=p>.</span><span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>mode</span> <span class=o>=</span> <span class=n>proto</span><span class=o>-&gt;</span><span class=n>open</span><span class=p>.</span><span class=n>mode</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>handle_read</span><span class=p>(...,</span> <span class=k>struct</span> <span class=n>proto</span> <span class=o>*</span><span class=n>proto</span><span class=p>)</span> <span class=p>{...}</span>
</span></span></code></pre></div><p>这样做的最大好处<strong>就是可以用跳表来设计了</strong>，减少了代码量，增加了易读性！！</p></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2023-11-26T16:21:27, Lastmod: 2023-11-30T17:56:18</p><script src=/js/copy-to-clipboard.js></script></main></div></body></html>