<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>C 语言位操作技巧</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e8%bf%9e%e7%bb%ad%e5%86%85%e5%ad%98%e5%8f%96n-bit aria-label="连续内存取n bit">连续内存取n bit</a></li><li><a href=#%e4%b8%80%e4%b8%aa%e6%95%b0%e5%8f%96%e8%bf%9e%e7%bb%adn-bit aria-label="一个数取连续n bit">一个数取连续n bit</a></li><li><a href=#%e5%88%a4%e6%96%ad%e4%b8%80%e4%b8%aa%e6%95%b0%e6%98%af%e5%90%a6%e4%b8%ba2%e7%9a%84%e5%b9%82 aria-label=判断一个数是否为2的幂>判断一个数是否为2的幂</a></li><li><a href=#%e7%bb%9f%e8%ae%a1%e4%b8%80%e4%b8%aa%e6%95%b0%e7%9a%84%e4%ba%8c%e8%bf%9b%e5%88%b6%e4%b8%ad1%e7%9a%84%e6%95%b0%e9%87%8f aria-label=统计一个数的二进制中1的数量>统计一个数的二进制中1的数量</a></li><li><a href=#%e5%b0%86%e4%b8%80%e4%b8%aa%e6%95%b0%e5%90%91%e4%b8%8a%e5%8f%96%e6%95%b4%e4%b8%ba2%e7%9a%84%e5%b9%82 aria-label=将一个数向上取整为2的幂>将一个数向上取整为2的幂</a></li><li><a href=#%e5%90%91%e4%b8%8a%e5%90%91%e4%b8%8b%e5%af%b9%e9%bd%90-%e6%a3%80%e6%9f%a5%e6%98%af%e5%90%a6%e5%af%b9%e9%bd%90 aria-label="向上/向下对齐, 检查是否对齐">向上/向下对齐, 检查是否对齐</a></li><li><a href=#%e6%a3%80%e6%9f%a5%e4%b8%a4%e4%b8%aa%e6%9c%89%e7%ac%a6%e5%8f%b7%e6%95%b0%e6%98%af%e5%90%a6%e5%bc%82%e5%8f%b7 aria-label=检查两个有符号数是否异号>检查两个有符号数是否异号</a></li><li><a href=#%e5%a4%a7%e5%b0%8f%e7%ab%af%e8%bd%ac%e6%8d%a2 aria-label=大小端转换>大小端转换</a></li><li><a href=#%e5%af%b9%e6%9f%90%e4%b8%aa%e4%bd%8d%e7%9a%84getsetclear%e6%93%8d%e4%bd%9c aria-label=对某个位的get/set/clear操作>对某个位的get/set/clear操作</a></li><li><a href=#sign-extending-from-a-varaiable-bit-width aria-label="Sign extending from a varaiable bit-width">Sign extending from a varaiable bit-width</a></li><li><a href=#%e5%ad%97%e7%ac%a6%e5%ad%97%e7%ac%a6%e6%95%b0%e7%bb%84%e7%9a%84%e5%a4%a7%e5%b0%8f%e5%86%99%e8%bd%ac%e6%8d%a2 aria-label=字符/字符数组的大小写转换>字符/字符数组的大小写转换</a></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>C 语言位操作技巧</div></header><h2 id=连续内存取n-bit>连续内存取n bit</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#c00;font-weight:700>#include</span> <span style=color:#c00;font-weight:700>&lt;stdio.h&gt;</span><span style=color:#c00;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#c00;font-weight:700>#include</span> <span style=color:#c00;font-weight:700>&lt;stdint.h&gt;</span><span style=color:#c00;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#c00;font-weight:700>#include</span> <span style=color:#c00;font-weight:700>&lt;assert.h&gt;</span><span style=color:#c00;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#c00;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#c00;font-weight:700>#define bitmask(n) ((1ul &lt;&lt; (n)) - 1)
</span></span></span><span style=display:flex><span><span style=color:#c00;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#888>/* 
</span></span></span><span style=display:flex><span><span style=color:#888> * 从ptr指向的内存开始，抽取第start个bit开始的连续n个bit
</span></span></span><span style=display:flex><span><span style=color:#888> * 限制: n &lt; 32
</span></span></span><span style=display:flex><span><span style=color:#888> */</span>
</span></span><span style=display:flex><span><span style=color:#888;font-weight:700>uint32_t</span> <span style=color:#06b;font-weight:700>extract_bits</span>(<span style=color:#888;font-weight:700>uint8_t</span> *ptr, <span style=color:#888;font-weight:700>uint32_t</span> start, <span style=color:#888;font-weight:700>uint32_t</span> n)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#888;font-weight:700>uint32_t</span> start_byte = start / <span style=color:#00d;font-weight:700>8</span>;
</span></span><span style=display:flex><span>  <span style=color:#888;font-weight:700>uint32_t</span> start_offset = start % <span style=color:#00d;font-weight:700>8</span>;
</span></span><span style=display:flex><span>  <span style=color:#888;font-weight:700>uint32_t</span> *pstart = (<span style=color:#888;font-weight:700>uint32_t</span> *)(ptr + start_byte);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#888;font-weight:700>uint32_t</span> end = start + n - <span style=color:#00d;font-weight:700>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#888;font-weight:700>uint32_t</span> end_byte = end / <span style=color:#00d;font-weight:700>8</span>;
</span></span><span style=display:flex><span>  <span style=color:#888;font-weight:700>uint32_t</span> end_offset = end % <span style=color:#00d;font-weight:700>8</span>;
</span></span><span style=display:flex><span>  <span style=color:#888;font-weight:700>uint32_t</span> *pend = (<span style=color:#888;font-weight:700>uint32_t</span> *)(ptr + end_byte);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#888;font-weight:700>uint32_t</span> data = *pstart &gt;&gt; start_offset;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>if</span> (n &gt; <span style=color:#00d;font-weight:700>32</span> - start_offset) {
</span></span><span style=display:flex><span>    <span style=color:#888>/* 由于n &lt; 32, 所以补齐*pend一定就够了，
</span></span></span><span style=display:flex><span><span style=color:#888>     * end_offset对齐到最后一位(n-1).
</span></span></span><span style=display:flex><span><span style=color:#888>     * 
</span></span></span><span style=display:flex><span><span style=color:#888>     * 严谨性证明: n 一定&gt; end_offset + 1
</span></span></span><span style=display:flex><span><span style=color:#888>     * 因为n &gt; 32-start_offset ==&gt; n &gt; 25, 
</span></span></span><span style=display:flex><span><span style=color:#888>     * 且end_offset + 1 &lt; 9, 故得证
</span></span></span><span style=display:flex><span><span style=color:#888>     */</span>
</span></span><span style=display:flex><span>    data |= *pend &lt;&lt; (n - end_offset - <span style=color:#00d;font-weight:700>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>return</span> data &amp; bitmask(n);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-weight:700>void</span> <span style=color:#06b;font-weight:700>test_val</span>(<span style=color:#888;font-weight:700>uint32_t</span> val, <span style=color:#888;font-weight:700>uint32_t</span> expect)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>if</span> (val != expect) {
</span></span><span style=display:flex><span>    printf(<span style=color:#d20;background-color:#fff0f0>&#34;error: val: 0x%x, expect: 0x%x</span><span style=color:#04d;background-color:#fff0f0>\n</span><span style=color:#d20;background-color:#fff0f0>&#34;</span>, val, expect);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  assert(val == expect);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-weight:700>int</span> <span style=color:#06b;font-weight:700>main</span>(<span style=color:#888;font-weight:700>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#888;font-weight:700>uint32_t</span> vals[] = {<span style=color:#00d;font-weight:700>0x11223344</span>, <span style=color:#00d;font-weight:700>0x11223344</span>};
</span></span><span style=display:flex><span>  <span style=color:#888;font-weight:700>uint32_t</span> ret;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  ret = extract_bits((<span style=color:#888;font-weight:700>uint8_t</span> *)vals, <span style=color:#00d;font-weight:700>31</span>, <span style=color:#00d;font-weight:700>30</span>);
</span></span><span style=display:flex><span>  test_val(ret, <span style=color:#00d;font-weight:700>0x22446688</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  printf(<span style=color:#d20;background-color:#fff0f0>&#34;Test Passed!</span><span style=color:#04d;background-color:#fff0f0>\n</span><span style=color:#d20;background-color:#fff0f0>&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>return</span> <span style=color:#00d;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=一个数取连续n-bit>一个数取连续n bit</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#888>/*
</span></span></span><span style=display:flex><span><span style=color:#888> * 从一个数中取第start个bit开始的连续n个bit
</span></span></span><span style=display:flex><span><span style=color:#888> */</span>
</span></span><span style=display:flex><span><span style=color:#888;font-weight:700>uint32_t</span> <span style=color:#06b;font-weight:700>extract_bits</span> (<span style=color:#888;font-weight:700>uint32_t</span> val, <span style=color:#888;font-weight:700>uint32_t</span> start, <span style=color:#888;font-weight:700>uint32_t</span> n)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>return</span> (val &gt;&gt; start) &amp; bitmask(n);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=判断一个数是否为2的幂>判断一个数是否为2的幂</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#888;font-weight:700>unsigned</span> <span style=color:#888;font-weight:700>int</span> v;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>if</span> ((v &amp; (v - <span style=color:#00d;font-weight:700>1</span>)) == <span style=color:#00d;font-weight:700>0</span>) 
</span></span><span style=display:flex><span>    printf(<span style=color:#d20;background-color:#fff0f0>&#34;v is a power of 2</span><span style=color:#04d;background-color:#fff0f0>\n</span><span style=color:#d20;background-color:#fff0f0>&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>else</span> 
</span></span><span style=display:flex><span>    <span style=color:#06b;font-weight:700>printf</span>(<span style=color:#d20;background-color:#fff0f0>&#34;v is not a power of 2</span><span style=color:#04d;background-color:#fff0f0>\n</span><span style=color:#d20;background-color:#fff0f0>&#34;</span>);
</span></span></code></pre></div><p> </p><h2 id=统计一个数的二进制中1的数量>统计一个数的二进制中1的数量</h2><p>依然是利用<code>v & (v -1)</code>的运算结果会将v的最低位的<code>1</code>(如果有的话)置<code>0</code>.</p><p>循环执行此操作就可统计v中<code>1</code>的数量.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#888;font-weight:700>int</span> <span style=color:#06b;font-weight:700>numberof1</span>(<span style=color:#888;font-weight:700>int</span> v) {
</span></span><span style=display:flex><span>    <span style=color:#888;font-weight:700>int</span> count = <span style=color:#00d;font-weight:700>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>while</span>(v) {
</span></span><span style=display:flex><span>        count++;
</span></span><span style=display:flex><span>        v = v &amp; (v -<span style=color:#00d;font-weight:700>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>return</span> count;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p> </p><h2 id=将一个数向上取整为2的幂>将一个数向上取整为2的幂</h2><p>用一个<code>1</code>一直左移, 直到比这个数大为止.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#888;font-weight:700>uint32_t</span> <span style=color:#06b;font-weight:700>roundup_pow_of_two</span>(<span style=color:#080;font-weight:700>const</span> <span style=color:#888;font-weight:700>uint32_t</span> x) {
</span></span><span style=display:flex><span>    <span style=color:#888;font-weight:700>uint32_t</span> ret = <span style=color:#00d;font-weight:700>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>while</span> (ret &lt; x) {
</span></span><span style=display:flex><span>        ret = ret &lt;&lt; <span style=color:#00d;font-weight:700>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Linux内核中使用了一种更快的方案, amazing!!!</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-weight:700>static</span> __inline__ <span style=color:#888;font-weight:700>int</span> <span style=color:#06b;font-weight:700>generic_fls</span>(<span style=color:#888;font-weight:700>int</span> x)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#888;font-weight:700>int</span> r = <span style=color:#00d;font-weight:700>32</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#080;font-weight:700>if</span> (!x)
</span></span><span style=display:flex><span>		<span style=color:#080;font-weight:700>return</span> <span style=color:#00d;font-weight:700>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#080;font-weight:700>if</span> (!(x &amp; <span style=color:#00d;font-weight:700>0xffff0000u</span>)) { 
</span></span><span style=display:flex><span>		x &lt;&lt;= <span style=color:#00d;font-weight:700>16</span>;
</span></span><span style=display:flex><span>		r -= <span style=color:#00d;font-weight:700>16</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#080;font-weight:700>if</span> (!(x &amp; <span style=color:#00d;font-weight:700>0xff000000u</span>)) {
</span></span><span style=display:flex><span>		x &lt;&lt;= <span style=color:#00d;font-weight:700>8</span>;
</span></span><span style=display:flex><span>		r -= <span style=color:#00d;font-weight:700>8</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#080;font-weight:700>if</span> (!(x &amp; <span style=color:#00d;font-weight:700>0xf0000000u</span>)) {
</span></span><span style=display:flex><span>		x &lt;&lt;= <span style=color:#00d;font-weight:700>4</span>;
</span></span><span style=display:flex><span>		r -= <span style=color:#00d;font-weight:700>4</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#080;font-weight:700>if</span> (!(x &amp; <span style=color:#00d;font-weight:700>0xc0000000u</span>)) {
</span></span><span style=display:flex><span>		x &lt;&lt;= <span style=color:#00d;font-weight:700>2</span>;
</span></span><span style=display:flex><span>		r -= <span style=color:#00d;font-weight:700>2</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#080;font-weight:700>if</span> (!(x &amp; <span style=color:#00d;font-weight:700>0x80000000u</span>)) {
</span></span><span style=display:flex><span>		x &lt;&lt;= <span style=color:#00d;font-weight:700>1</span>;
</span></span><span style=display:flex><span>		r -= <span style=color:#00d;font-weight:700>1</span>;<span style=color:#00d;font-weight:700>1</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#080;font-weight:700>return</span> r;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>static</span> <span style=color:#080;font-weight:700>inline</span> <span style=color:#888;font-weight:700>unsigned</span> <span style=color:#888;font-weight:700>long</span> __attribute_const__ <span style=color:#06b;font-weight:700>roundup_pow_of_two</span>(<span style=color:#888;font-weight:700>unsigned</span> <span style=color:#888;font-weight:700>long</span> x)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#080;font-weight:700>return</span> (<span style=color:#00d;font-weight:700>1UL</span> &lt;&lt; generic_fls(x - <span style=color:#00d;font-weight:700>1</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p> </p><h2 id=向上向下对齐-检查是否对齐>向上/向下对齐, 检查是否对齐</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#888>/* uintptr_t 代表指针的位数
</span></span></span><span style=display:flex><span><span style=color:#888> * 加uintptr_t转换的原因是: (void *)不能进行运算
</span></span></span><span style=display:flex><span><span style=color:#888> */</span>
</span></span><span style=display:flex><span><span style=color:#c00;font-weight:700>#define IS_ALIGNED(X, align)  (((uintptr_t)(const void *)(X)) % (align) == 0)
</span></span></span><span style=display:flex><span><span style=color:#c00;font-weight:700>#define ALIGN_UP(X, align)   (((X) + ((align) - 1)) &amp; ~((align) - 1))
</span></span></span><span style=display:flex><span><span style=color:#c00;font-weight:700>#define ALIGN_DOWN(x, align) ((X) &amp; ~((align) - 1))
</span></span></span><span style=display:flex><span><span style=color:#c00;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#c00;font-weight:700>#define X      (0x12345675)
</span></span></span><span style=display:flex><span><span style=color:#c00;font-weight:700>#define align  (1 &lt;&lt; 2)
</span></span></span><span style=display:flex><span><span style=color:#c00;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#888;font-weight:700>int</span> <span style=color:#06b;font-weight:700>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#888;font-weight:700>int</span> v = IS_ALIGNED(X, align);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>if</span> (<span style=color:#00d;font-weight:700>0</span> == v) {
</span></span><span style=display:flex><span>        printf(<span style=color:#d20;background-color:#fff0f0>&#34;Given X(0x%x) is not align to 0x%08x</span><span style=color:#04d;background-color:#fff0f0>\n</span><span style=color:#d20;background-color:#fff0f0>&#34;</span>, X, align);
</span></span><span style=display:flex><span>        printf(<span style=color:#d20;background-color:#fff0f0>&#34;After align up,   new X = 0x%x</span><span style=color:#04d;background-color:#fff0f0>\n</span><span style=color:#d20;background-color:#fff0f0>&#34;</span>, ALIGN_UP(X, align));
</span></span><span style=display:flex><span>        printf(<span style=color:#d20;background-color:#fff0f0>&#34;After align down, new X = 0x%x</span><span style=color:#04d;background-color:#fff0f0>\n</span><span style=color:#d20;background-color:#fff0f0>&#34;</span>, ALIGN_DOWN(X, align));
</span></span><span style=display:flex><span>    } <span style=color:#080;font-weight:700>else</span> {
</span></span><span style=display:flex><span>        printf(<span style=color:#d20;background-color:#fff0f0>&#34;Give X(0x%x) is aligned to 0x%08x</span><span style=color:#04d;background-color:#fff0f0>\n</span><span style=color:#d20;background-color:#fff0f0>&#34;</span>, X, align);
</span></span><span style=display:flex><span>        printf(<span style=color:#d20;background-color:#fff0f0>&#34;After align up,   new X = 0x%x</span><span style=color:#04d;background-color:#fff0f0>\n</span><span style=color:#d20;background-color:#fff0f0>&#34;</span>, ALIGN_UP(X, align));
</span></span><span style=display:flex><span>        printf(<span style=color:#d20;background-color:#fff0f0>&#34;After align down, new X = 0x%x</span><span style=color:#04d;background-color:#fff0f0>\n</span><span style=color:#d20;background-color:#fff0f0>&#34;</span>, ALIGN_DOWN(X, align));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>return</span> <span style=color:#00d;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p> </p><h2 id=检查两个有符号数是否异号>检查两个有符号数是否异号</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#888;font-weight:700>int</span> x,y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>if</span> ((x ^ y) &lt; <span style=color:#00d;font-weight:700>0</span>) 
</span></span><span style=display:flex><span>    printf(<span style=color:#d20;background-color:#fff0f0>&#34;They have opposite signs</span><span style=color:#04d;background-color:#fff0f0>\n</span><span style=color:#d20;background-color:#fff0f0>&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>else</span>
</span></span><span style=display:flex><span>    <span style=color:#06b;font-weight:700>printf</span>(<span style=color:#d20;background-color:#fff0f0>&#34;They have same signs</span><span style=color:#04d;background-color:#fff0f0>\n</span><span style=color:#d20;background-color:#fff0f0>&#34;</span>);
</span></span></code></pre></div><p> </p><h2 id=大小端转换>大小端转换</h2><p> </p><h2 id=对某个位的getsetclear操作>对某个位的get/set/clear操作</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#c00;font-weight:700>#define GET_BIT(x, bit)     ( ((x) &amp; (1ULL &lt;&lt; (bit))) &gt;&gt; (bit) )
</span></span></span><span style=display:flex><span><span style=color:#c00;font-weight:700>#define SET_BIT(x, bit)     ( (x) |= (1ULL &lt;&lt; (bit)) )
</span></span></span><span style=display:flex><span><span style=color:#c00;font-weight:700>#define CLEAR_BIT(x, bit)   ( (x) &amp;= ~(1ULL &lt;&lt; (bit)) )
</span></span></span></code></pre></div><blockquote><p>Release note:</p><ol><li>添加对<code>unsigned long long</code>长度的支持</li></ol></blockquote><p> </p><h2 id=sign-extending-from-a-varaiable-bit-width>Sign extending from a varaiable bit-width</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>    <span style=color:#888;font-weight:700>int</span> bits = <span style=color:#00d;font-weight:700>2</span> * <span style=color:#00d;font-weight:700>8</span>; <span style=color:#888>// number of bits representing the number in x
</span></span></span><span style=display:flex><span><span style=color:#888></span>    <span style=color:#888;font-weight:700>int</span> x = <span style=color:#00d;font-weight:700>0xFFC1</span>;   <span style=color:#888>// ready to get sign-extended
</span></span></span><span style=display:flex><span><span style=color:#888></span>    <span style=color:#888;font-weight:700>int</span> rst;          <span style=color:#888>// resulting sign-extended number
</span></span></span><span style=display:flex><span><span style=color:#888></span>    <span style=color:#888;font-weight:700>int</span> <span style=color:#080;font-weight:700>const</span> mask = <span style=color:#00d;font-weight:700>1U</span> &lt;&lt; (bits - <span style=color:#00d;font-weight:700>1</span>); <span style=color:#888>// mask can be  pre-computed if bits if fixed.
</span></span></span><span style=display:flex><span><span style=color:#888></span>
</span></span><span style=display:flex><span>    x = x &amp; ((<span style=color:#00d;font-weight:700>1U</span> &lt;&lt; bits) - <span style=color:#00d;font-weight:700>1</span>); <span style=color:#888>// cut x if it holds more bits
</span></span></span><span style=display:flex><span><span style=color:#888></span>    rst = (x ^ mask) - mask;    <span style=color:#888>// excellent trick!
</span></span></span><span style=display:flex><span><span style=color:#888></span>
</span></span><span style=display:flex><span>    printf(<span style=color:#d20;background-color:#fff0f0>&#34;INPUT: 0x%x, RESULT: 0x%x</span><span style=color:#04d;background-color:#fff0f0>\n</span><span style=color:#d20;background-color:#fff0f0>&#34;</span>, x, rst);
</span></span></code></pre></div><p> </p><h2 id=字符字符数组的大小写转换>字符/字符数组的大小写转换</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#c00;font-weight:700>#define TO_LOWER(c) (unsigned char)((c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) ? (c | 0x20) : c)
</span></span></span><span style=display:flex><span><span style=color:#c00;font-weight:700>#define TO_UPPER(c) (unsigned char)((c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) ? (c &amp; ~0x20) : c)
</span></span></span><span style=display:flex><span><span style=color:#c00;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#c00;font-weight:700>#define TO_LOWER_STR(s, len) { \
</span></span></span><span style=display:flex><span><span style=color:#c00;font-weight:700>    for (int i = 0; i &lt; len &amp;&amp; s[i] != &#39;\0&#39;; i++) { \
</span></span></span><span style=display:flex><span><span style=color:#c00;font-weight:700>        s[i] = TO_LOWER(s[i]); \
</span></span></span><span style=display:flex><span><span style=color:#c00;font-weight:700>    } \
</span></span></span><span style=display:flex><span><span style=color:#c00;font-weight:700>}
</span></span></span><span style=display:flex><span><span style=color:#c00;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#c00;font-weight:700>#define TO_UPPER_STR(s, len) {\
</span></span></span><span style=display:flex><span><span style=color:#c00;font-weight:700>    for (int i = 0; i &lt; len &amp;&amp; s[i] != &#39;\0&#39;; i++) { \
</span></span></span><span style=display:flex><span><span style=color:#c00;font-weight:700>        s[i] = TO_UPPER(s[i]); \
</span></span></span><span style=display:flex><span><span style=color:#c00;font-weight:700>    } \
</span></span></span><span style=display:flex><span><span style=color:#c00;font-weight:700>}
</span></span></span></code></pre></div></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2022-07-03T09:44:13, Lastmod: 2023-09-24T18:08:59</p><script src=/js/copy-to-clipboard.js></script></main></div></body></html>