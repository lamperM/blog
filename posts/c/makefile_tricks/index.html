<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>Makefile 一些技巧</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>所有文章</a></div><div class="a-block nav-link-item"><a href=/tags>Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput><ul id=searchResults></ul></div></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><h1>Makefile 一些技巧</h1></header><h2 id=伪目标的依赖关系>伪目标的依赖关系</h2><p>Makefile 中的依赖关系指的是目标和依赖之间建立的关系，目标对应规则中的语句是否执行取决于依赖的状态。</p><p>最简单的依赖关系可以拿两个文件来举例:</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span><span style=color:green># gcc语句执行当前仅当 main.c 新于 main.elf
</span></span></span><span style=display:flex><span><span style=color:green></span>main.elf: main.c
</span></span><span style=display:flex><span>    gcc main.c -o main.elf
</span></span></code></pre></td></tr></table></div></div><p>make 在执行<code>main.elf</code>的规则时，会先判断依赖关系。拿上面的例子来说，
gcc 语句是否执行取决于<code>main.c</code> 和 <code>main.elf</code>的修改时间，<strong>只有当
依赖新与目标时，规则语句才会执行</strong>。</p><p>然而许多情况下，目标或者依赖并不是一个文件，而是<strong>虚拟目标</strong>。虚拟目标
并不是一个文件，即它没有修改时间这个属性，此时 make 就不能作比较，结果就是
<strong>如果目标是伪目标，那么不管依赖如何都执行规则语句；如果依赖是伪目标，
那么目标的规则语句也永远被执行</strong>。下面是两个例子：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-make data-lang=make><span style=display:flex><span><span style=color:green># 伪目标作为目标文件出现
</span></span></span><span style=display:flex><span><span style=color:green># build finish总是输出， 而gcc语句仅当main.c比main.elf新时才执行
</span></span></span><span style=display:flex><span><span style=color:green></span>.PHONY : all
</span></span><span style=display:flex><span>all: main.elf
</span></span><span style=display:flex><span>	@echo <span style=color:#a31515>&#39;build finish&#39;</span>
</span></span><span style=display:flex><span>main.elf: main.c
</span></span><span style=display:flex><span>	gcc $&lt; -o $@
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-make data-lang=make><span style=display:flex><span><span style=color:green># 伪目标作为依赖文件中出现
</span></span></span><span style=display:flex><span><span style=color:green># 不管main.c是否比main.elf更新，因为pre-work是伪目标
</span></span></span><span style=display:flex><span><span style=color:green># 所以gcc语句总是执行
</span></span></span><span style=display:flex><span><span style=color:green></span>.PHONY : pre-work
</span></span><span style=display:flex><span>main.elf: main.c pre-work
</span></span><span style=display:flex><span>	gcc $&lt; -o $@
</span></span></code></pre></td></tr></table></div></div><p>上面的代码的效果是：两条规则中的语句都会执行，即使你并没有对 main.c 做任何修改！</p><h2 id=恐怖的空格>恐怖的空格</h2><p>Makefile 中的变量结合很常见，例如<code>$(FIXDEP)=$(FIXDEP_PATH)/build/fixdep</code>.</p><p>特别是当我们这些语句是从某些地方粘贴过来，要特别注意变量中是否有空格，Makefile 非常重视这个。假如<code>$(FIXDEP_PATH)</code>中有一个空格，那么<code>$(FIXDEP)</code>就变成<strong>两个宏</strong>了（不知道叫宏合不合适）。而且 Make 的执行过程很难检查出来。</p><h2 id=规则的执行顺序>规则的执行顺序</h2><p>如果不从命令行传入目标, Makefile 中定义的规则其实是以<strong>从上而下</strong>的顺序执行的, 但是我习惯把 <code>all</code> 这种默认规则放在最下面, 所以一般我们可以看到很多 Makefile 会在开头写一句规则<code>all:</code>, 作用就是告诉 make 默认(不显式指定)的目标是<code>all</code>.</p><blockquote><p>Busybox 根目录 Makefile 中的做法示例</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span><span style=color:green># That&#39;s our default target when &gt;none is given on the command line
</span></span></span><span style=display:flex><span><span style=color:green></span>.PHONY: _all
</span></span><span style=display:flex><span>_all:
</span></span></code></pre></td></tr></table></div></div></blockquote><h2 id=函数的魔法>函数的魔法</h2><h3 id=patsubst>patsubst</h3><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-make data-lang=make><span style=display:flex><span><span style=color:#00f>$(</span>patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;<span style=color:#00f>)</span>
</span></span></code></pre></td></tr></table></div></div><p>功能：查找<code>&lt;text></code>中的单词（以空格，tab，回车，换行分割），看其是否符合<code>&lt;pattern></code>,
如果符合，将其使用<code>&lt;replacement></code>替换。可以使用通配符<code>%</code>。</p><p>以下两对是等效的, 明显还是直接使用变量的替换语法操作简单:</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-make data-lang=make><span style=display:flex><span><span style=color:#00f>$(</span>patsubst &lt;pattern&gt;,&lt;replacement&gt;,<span style=color:#00f>$(</span>var<span style=color:#00f>))</span>
</span></span><span style=display:flex><span>$(var:&lt;pattern&gt;=&lt;replacement&gt;;)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>$(</span>patsubst %&lt;suffix&gt;,%&lt;replacement&gt;,<span style=color:#00f>$(</span>var<span style=color:#00f>))</span>
</span></span><span style=display:flex><span>$(var:&lt;suffix&gt;=&lt;replacement&gt;)
</span></span></code></pre></td></tr></table></div></div><h2 id=使用-shell-变量>使用 shell 变量</h2><p>Make 将 <code>$$var</code> 转义为<code>$var</code>, 供 shell 处理.</p><p>demo(源自 6.828 根目录<code>GNUmakefile</code>):</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span>handin-check:
</span></span><span style=display:flex><span>    @if test -n <span style=color:#a31515>&#34;`git status -s`&#34;</span>; <span style=color:#00f>then</span> <span style=color:#a31515>\
</span></span></span><span style=display:flex><span><span style=color:#a31515></span>        git status -s; <span style=color:#a31515>\
</span></span></span><span style=display:flex><span><span style=color:#a31515></span>        read -p <span style=color:#a31515>&#34;Untracked files will not be handed in.  Continue? [y/N] &#34;</span> r; <span style=color:#a31515>\
</span></span></span><span style=display:flex><span><span style=color:#a31515></span>        test <span style=color:#a31515>&#34;</span>$$<span style=color:#a31515>r&#34;</span> = y; <span style=color:#a31515>\
</span></span></span><span style=display:flex><span><span style=color:#a31515></span>    <span style=color:#00f>fi</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>以上 demo 还使用了 test 命令来终止 make 的执行, 如果用户没有输入<code>y</code>, make 将会终止执行</p></blockquote></article></body></main></div></body></html>