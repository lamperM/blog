<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>写高质量的C语言工程的规范</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%b7%bb%e5%8a%a0%e6%9b%b4%e5%a4%9a%e7%9a%84%e7%bc%96%e8%af%91%e9%80%89%e9%a1%b9comiler-options%e6%9d%a5%e9%98%b2%e6%ad%a2bug aria-label="添加更多的编译选项(comiler options)来防止bug">添加更多的编译选项(comiler options)来防止bug</a></li><li><a href=#%e5%8a%a8%e6%80%81%e7%94%b3%e8%af%b7%e7%9a%84%e7%a9%ba%e9%97%b4%e5%88%b0%e5%ba%95%e8%a6%81%e4%b8%8d%e8%a6%81%e9%87%8a%e6%94%be aria-label=动态申请的空间到底要不要释放>动态申请的空间到底要不要释放</a></li><li><a href=#%e5%b0%bd%e5%8f%af%e8%83%bd%e5%9c%a8%e5%88%9b%e5%bb%ba%e5%8f%98%e9%87%8f%e6%97%b6%e8%b5%8b%e5%88%9d%e5%80%bc aria-label=尽可能在创建变量时赋初值>尽可能在创建变量时赋初值</a></li><li><a href=#%e4%bd%bf%e7%94%a8define-enum aria-label="使用#define, enum">使用<code>#define</code>, <code>enum</code></a><ul><li><a href=#%e4%bd%bf%e7%94%a8typedef%e4%bc%98%e5%8c%96function-pointer aria-label="使用typedef优化function pointer">使用<code>typedef</code>优化function pointer</a></li></ul></li><li><a href=#%e9%87%8d%e5%ae%9a%e4%b9%89%e4%b8%80%e5%a5%97%e8%87%aa%e5%b7%b1%e7%9a%84%e7%b1%bb%e5%9e%8b aria-label=重定义一套自己的类型>重定义一套自己的类型</a></li><li><a href=#%e5%96%84%e7%94%a80 aria-label=善用~0>善用<code>~0</code></a></li><li><a href=#%e5%90%88%e7%90%86%e7%9a%84%e4%bd%bf%e7%94%a8goto%e8%af%ad%e5%8f%a5 aria-label=合理的使用goto语句>合理的使用<code>goto</code>语句</a></li><li><a href=#%e5%ae%9a%e4%b9%89%e5%90%88%e7%90%86-%e6%ad%a3%e7%a1%ae%e7%9a%84%e7%bb%93%e6%9e%84%e4%bd%93 aria-label="定义合理, 正确的结构体">定义合理, 正确的结构体</a><ul><li><a href=#1-flexible-array-member aria-label="#1 Flexible Array Member">#1 Flexible Array Member</a></li><li><a href=#-2-padding-and-packed aria-label="# 2 Padding and Packed"># 2 Padding and Packed</a></li></ul></li><li><a href=#%e6%b0%b8%e8%bf%9c%e4%b8%ba%e4%bd%a0%e7%9a%84%e5%87%bd%e6%95%b0%e8%ae%be%e7%bd%aeerror-return-value aria-label="永远为你的函数设置error return value">永远为你的函数设置error return value</a></li><li><a href=#%e5%8f%98%e9%87%8f%e7%b1%bb%e5%9e%8b%e7%9a%84%e9%80%89%e6%8b%a9 aria-label=变量类型的选择>变量类型的选择</a></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>写高质量的C语言工程的规范</div></header><h2 id=添加更多的编译选项comiler-options来防止bug>添加更多的编译选项(comiler options)来防止bug</h2><p>对于我常用的<code>GCC</code>, 推荐开启一下的compiler options:</p><ul><li><p><code>-Wall</code>: enable a lot of common warnings</p></li><li><p><code>-Wno-format-truncation</code>: warns about the snprintf output buffer not being
large enough for a corresponding “%s” in the format string.</p></li><li><p><code>-Werror</code>: turn warnings into errors.</p></li></ul><p> </p><h2 id=动态申请的空间到底要不要释放>动态申请的空间到底要不要释放</h2><p>When using a barebones embedded OS, you absolutely need to tightly manage your memory.</p><p>但是, 如果你是写应用业务的代码, 特别是在内存足够的场景下. 最好不要手动释放内存,
因为当线程/进程退出时, 操作系统会自动帮我们释放. <strong>某些情况下, 释放内存的操作会很大程度上增加逻辑的复杂度</strong>.</p><blockquote><p>如果你是一个内核程序员, 则必须手动的释放. 不用怀疑.</p></blockquote><p> </p><h2 id=尽可能在创建变量时赋初值>尽可能在创建变量时赋初值</h2><p>放置某些变量创建后是 <code>magic value</code>. 而使用这些变量可能不会立马导致错误, 但是这是一个隐患.</p><p>但这会产生一个问题, 有时我们定义变量之后的不久之后就会对其赋予正确的值, 这时候初值就是
多余的. 而且维护者可能认为这个值是meaningful, 这就要求我们如果要赋初值, 就要说明这个值
仅仅是<strong>无意义的</strong>初值.</p><p> </p><h2 id=使用define-enum>使用<code>#define</code>, <code>enum</code></h2><p>对于代码在不同地方使用的同一个值, 应使用<code>#define</code>来声明使得代码<strong>maintainable</strong>.</p><p>如果这些值有多个且能规划为同一类别, 则还可将<code>#define</code>的方式换为<code>enum</code>. 这会使代码更加<strong>meaningful</strong></p><blockquote><p>使用<code>enum</code>使还要注意其所占内存空间在不同架构中可能不同的问题, see <a href=https://www.cnblogs.com/bluettt/p/16041867.html>enum的优势和漏洞</a></p></blockquote><p> </p><h3 id=使用typedef优化function-pointer>使用<code>typedef</code>优化function pointer</h3><p> </p><h2 id=重定义一套自己的类型>重定义一套自己的类型</h2><p>在开发<em>大项目</em>时, 需要考虑可移植性的情况下, 最好利用<code>typedef</code>对类型进行重定义.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>#if SYSTEM1
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#ff79c6></span>    <span style=color:#ff79c6>typedef</span>  <span style=color:#8be9fd>int</span>  INT32;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>    ...
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span><span style=color:#ff79c6>#else
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span><span style=color:#ff79c6></span>    <span style=color:#ff79c6>typedef</span>  <span style=color:#8be9fd>long</span> INT32;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>    ...
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span><span style=color:#ff79c6>#endif
</span></span></span></code></pre></div><p>如上, 对于某些架构<code>int</code>类型可能不是32bit, 此时就要使用<code>long</code>. 这种定义的方式会保证我们的系统
在任何架构中都不会出现类型的bug. 而且也增加了代码的<strong>readability</strong>.</p><p> </p><h2 id=善用0>善用<code>~0</code></h2><p>在做嵌入式编程时, 有时在设置掩码(mask)或者其他情况会要用到<strong>全1</strong>的变量值, 你是否经常这样声明?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#8be9fd>int</span> mask <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0xffff</span>;
</span></span></code></pre></div><p>暂且不谈<code>int</code>类型到底占多少字节的问题. 就像上面一样, 我们程序员经常忘记某个类型的大小,
而少添加了<code>f</code>. 会导致变量<code>mask</code>的值不是全1(32位情况下).</p><p>这是要变换一下思维, 使用<code>~0</code>的定义方法就可轻松化解, 无需管变量的类型是什么.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#8be9fd>int</span> mask <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>~</span><span style=color:#bd93f9>0</span>;
</span></span></code></pre></div><p> </p><h2 id=合理的使用goto语句>合理的使用<code>goto</code>语句</h2><p>在大学课堂中, 我们老师说过禁止使用<code>goto</code>语句, 但却没有给出明确的原因.</p><p>实际上, <strong>合理的</strong>使用<code>goto</code>能够极大的减少程序的冗余度.</p><p><code>goto</code>语句常用于程序出现错误要退出时, 可能有多个情况会使用重复的代码处理,
例如释放一些allocated memory. 相较于使用<code>flag</code>, 使用<code>goto</code>显然更加clearly and readability.</p><p>所以, 在面对重复的错误处理代码时, 想想能不能用<code>goto</code>进行优化. 当然, <strong>避免过早优化</strong>.</p><blockquote><p>注意, <code>goto</code>出现的场景其实很受限. Never use a backward <code>goto</code> or jump into control statements.</p></blockquote><p> </p><h2 id=定义合理-正确的结构体>定义合理, 正确的结构体</h2><p>结构体是C语言编程应用中常用的数据结构, 关于结构体也有许多要注意的点.</p><h3 id=1-flexible-array-member>#1 Flexible Array Member</h3><p>C99开始支持<em>Flexible Array Member</em>. 且看我<a href>lstring</a>库的结构体定义:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>struct</span> str {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>    <span style=color:#8be9fd>int</span> length;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>    <span style=color:#8be9fd>int</span> size;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>    <span style=color:#8be9fd>char</span> data[];   <span style=color:#6272a4>// Flexible array member - C99 only
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span><span style=color:#6272a4></span>};
</span></span></code></pre></div><p>对于这种不定长的数组元素, 我之前都是定义一个指针, 占用一个<code>sizeof(char *)</code>的空间. 而Flexible Array Member本身不占用空间. 需要在malloc时为他单独声明空间.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#8be9fd>int</span> n <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>100</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#ff79c6>struct</span> str <span style=color:#ff79c6>*</span>s <span style=color:#ff79c6>=</span> malloc(<span style=color:#ff79c6>sizeof</span>(<span style=color:#ff79c6>struct</span> str) <span style=color:#ff79c6>+</span> <span style=color:#ff79c6>sizeof</span>(<span style=color:#8be9fd>char</span>[n]));
</span></span></code></pre></div><blockquote><p>这里也有一个小trick, 使用<code>sizeof(char[n])</code> 比 <code>sizeof(char) * n</code> 更简洁!</p></blockquote><h3 id=-2-padding-and-packed># 2 Padding and Packed</h3><p>有关结构体的大小, 和地址对齐的问题. 假设我有一个结构体如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>struct</span> mystruct_A
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>   <span style=color:#8be9fd>char</span> a; <span style=color:#8be9fd>int</span> b; <span style=color:#8be9fd>char</span> c;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>} x;
</span></span></code></pre></div><p>Padding是编译器对结构体<strong>默认</strong>做的事情. 它会在成员之间插入一些 gap 来保证地址对齐:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>struct</span> mystruct_A {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>    <span style=color:#8be9fd>char</span> a;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>    <span style=color:#8be9fd>char</span> gap_0[<span style=color:#bd93f9>3</span>]; <span style=color:#6272a4>/* inserted by compiler: for alignment of b */</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>    <span style=color:#8be9fd>int</span> b;         <span style=color:#6272a4>/* int 在32位上其地址是4字节对齐的 */</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>    <span style=color:#8be9fd>char</span> c;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>    <span style=color:#8be9fd>char</span> gap_1[<span style=color:#bd93f9>3</span>]; <span style=color:#6272a4>/* -&#34;-: for alignment of the whole struct in an array */</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span>} x;
</span></span></code></pre></div><blockquote><p>除了保证每个成员的地址是对齐的, <strong>整个结构体</strong>的地址也是按照其最大的成员类型来对齐, 即对齐到<code>int</code>(4字节).</p></blockquote><p>如果你<strong>不想要这些 gap</strong>, 那么可以对结构体声明使用 <code>__attribute__((__packed__))</code>关键字. 整个结构体大小仅为6个字节.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>struct</span> <span style=color:#50fa7b>__attribute__</span>((__packed__)) mystruct_A {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>    <span style=color:#8be9fd>char</span> a;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>    <span style=color:#8be9fd>int</span> b;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>    <span style=color:#8be9fd>char</span> c;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>};
</span></span></code></pre></div><p> </p><h2 id=永远为你的函数设置error-return-value>永远为你的函数设置error return value</h2><p>一旦你的函数可能被其他人调用, 那么养成设置return value的习惯. 即便你现在的实现
并不会产生任何错误, 也请返回<code>success</code>.</p><p>这样做的原因是, caller可以根据你的定义做错误判断, 即便以后你的实现加上了出错情况,
上层的代码也不需要修改.</p><p> </p><h2 id=变量类型的选择>变量类型的选择</h2><ul><li>名字, 特定不变的字符串使用<code>const char *</code>, 甚至<code>const char const*</code></li><li>长度使用<code>size_t</code></li><li>表示类型的参数尽可能使用<code>enum</code></li><li>循环变量i使用<code>signed</code>, 避免溢出后出错</li></ul><p> </p><h2 id=reference>Reference</h2><p><a href=https://www.msweet.org/blog/2020-12-31-how-i-improve-my-c-code-quality.html>How I Improve My (C) Code Quality</a></p><p><a href=https://www.codeproject.com/Articles/357065/Ten-Fallacies-of-Good-C-Code>Ten Fallacies of Good C Code</a></p></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2022-06-14T17:59:22, Lastmod: 2023-09-24T18:08:59</p></main></div></body></html>