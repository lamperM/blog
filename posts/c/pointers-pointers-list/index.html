<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>二级指针操作链表技巧</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>所有文章</a></div><div class="a-block nav-link-item"><a href=/tags>Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="search posts..."><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>二级指针操作链表技巧</div></header><p>问题源于我在知乎刷到的一个回答: <a href=https://www.zhihu.com/question/477832027/answer/2044206446>能分享你C指针用得最灵活（飘）的一次吗?</a></p><p>文中提到了Linus关于<strong>无头节点单项链表的删除操作</strong>给出的一种新的思路, 我觉得对理解指针非常有帮助, 所以在这里详细描述一下这件事.</p><p>从我学习数据结构起, 对不含头节点的单向链表的删除操作, 做法常是: 借用<strong>pre指针</strong>搜索. 这种情况下避免不了对于链表中第一个节点的特判(第一个节点没有pre).</p><p>Linus提到了一种借助<strong>二级指针避免该分支</strong>的方法.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#2b91af>void</span> remove_if(node ** head, remove_fn rm)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>    <span style=color:#00f>for</span> (node** curr = head; *curr; )
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>    {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>        node * entry = *curr;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>        <span style=color:#00f>if</span> (rm(entry))
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>        {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>            *curr = entry-&gt;next;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>            free(entry);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>        }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>        <span style=color:#00f>else</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>            curr = &amp;entry-&gt;next;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>}
</span></span></code></pre></div><p>指针的内容就是地址, <code>int *p = a</code> 也就意味着变量<code>p</code> 中保存着变量<code>a</code>的地址. 所以参数<code>head</code>在内存中的含义为:</p><p><img src=./mem.png alt=list的内存布局></p><p>假如要删除node2, 那么改变<code>*curr</code>实际上就是<strong>改了node1的<code>next</code>成员</strong>.</p></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2022-11-20T23:40:30, Lastmod: 2023-09-24T18:08:59</p></main></div></body></html>