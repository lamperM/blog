<!doctype html><html><head><title>C语言的内存对齐</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=description content><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><link rel=stylesheet href=/scss/journal.min.ea0f3d3af5cc437a42b1ad2f9b5ebeeaf367c8f8fc3004c55b78f4f503cea3a2.css integrity="sha256-6g89OvXMQ3pCsa0vm16+6vNnyPj8MATFW3j09QPOo6I=" media=screen><link rel=stylesheet href=/scss/dark-mode.min.2509d1ab7a8b17f2ca6b95285afc4f5ef50f8699b8114c954f01351654b5ceba.css integrity="sha256-JQnRq3qLF/LKa5UoWvxPXvUPhpm4EUyVTwE1FlS1zro=" media=screen><script src=/vendor/js/loadCSS.js></script>
<script>loadCSS("https://fonts.googleapis.com/css?family=Fira+Mono|Material+Icons")</script><script src=/js/toc.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script>
<script src=/vendor/js/md5.min.js></script>
<script>var gitalk=new Gitalk({clientID:"12dfb0f809e5e6afde3d",clientSecret:"72aaf5660b3a7b43b0bffb4d683a605a7ea65dad",repo:"blogcomments_gitalk",owner:"wangloo",admin:["wangloo"],id:md5(location.pathname),distractionFreeMode:"false"});window.onload=function(){gitalk.render("gitalk-container")}</script></head><body><div id=app><div id=sideContainer class=side-container><a class="a-block nav-head false" href=https://wangloo.github.io/><div class=nav-title>Wangloo's BLOG</div><div class=nav-subtitle>花有重开日, 人无再少年</div></a><div class=nav-link-list><a class="a-block nav-link-item active" href=/posts>Archive</a>
<a class="a-block nav-link-item false" href=/tags>Tags</a>
<a class="a-block nav-link-item false" href=/categories>Categories</a></div><div class=nav-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://risehere.net/>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
@2019 Notepadium.</div></div><div id=extraContainer class=extra-container><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc-content><center>- CATALOG -</center><ul><ul><li><a href=#%e5%86%85%e5%ad%98%e5%af%b9%e9%bd%90%e4%b8%ba%e4%bd%95%e8%a2%ab%e9%9c%80%e8%a6%81 onclick="onNavClick(`#内存对齐为何被需要-nav`)" id=内存对齐为何被需要-nav>内存对齐为何被需要</a></li><ul><li><a href=#%e4%b8%80%e8%88%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%af%b9%e9%bd%90%e8%a6%81%e6%b1%82 onclick="onNavClick(`#一般数据类型的对齐要求-nav`)" id=一般数据类型的对齐要求-nav>一般数据类型的对齐要求</a></li><li><a href=#%e7%bb%93%e6%9e%84%e4%bd%93%e7%9a%84%e5%af%b9%e9%bd%90%e8%a6%81%e6%b1%82 onclick="onNavClick(`#结构体的对齐要求-nav`)" id=结构体的对齐要求-nav>结构体的对齐要求</a></li></ul><li><a href=#%e5%a6%82%e4%bd%95%e5%81%9a%e5%88%b0%e5%86%85%e5%ad%98%e5%af%b9%e9%bd%90 onclick="onNavClick(`#如何做到内存对齐-nav`)" id=如何做到内存对齐-nav>如何做到内存对齐</a></li><li><a href=#aarch64-%e5%af%b9%e9%9d%9e%e5%af%b9%e9%bd%90%e8%ae%bf%e9%97%ae%e7%9a%84%e6%94%af%e6%8c%81 onclick="onNavClick(`#aarch64-对非对齐访问的支持-nav`)" id=aarch64-对非对齐访问的支持-nav>AArch64 对非对齐访问的支持</a></li></ul></div></div><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a>
<a type=button class=pagination-action id=darkModeToggleButton><span class="material-icons pagination-action-icon" id=darkModeToggleIcon>dark_mode</span></a></div></div><div class=single-column-drawer-container id=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item active" href=/posts>Archive</a>
<a class="a-block drawer-menu-item false" href=/tags>Tags</a>
<a class="a-block drawer-menu-item false" href=/categories>Categories</a><div class=toc><div class=toc-content><center>- CATALOG -</center><ul><ul><li><a href=#%e5%86%85%e5%ad%98%e5%af%b9%e9%bd%90%e4%b8%ba%e4%bd%95%e8%a2%ab%e9%9c%80%e8%a6%81 onclick="onNavClick(`#内存对齐为何被需要-nav`)" id=内存对齐为何被需要-nav>内存对齐为何被需要</a></li><ul><li><a href=#%e4%b8%80%e8%88%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%af%b9%e9%bd%90%e8%a6%81%e6%b1%82 onclick="onNavClick(`#一般数据类型的对齐要求-nav`)" id=一般数据类型的对齐要求-nav>一般数据类型的对齐要求</a></li><li><a href=#%e7%bb%93%e6%9e%84%e4%bd%93%e7%9a%84%e5%af%b9%e9%bd%90%e8%a6%81%e6%b1%82 onclick="onNavClick(`#结构体的对齐要求-nav`)" id=结构体的对齐要求-nav>结构体的对齐要求</a></li></ul><li><a href=#%e5%a6%82%e4%bd%95%e5%81%9a%e5%88%b0%e5%86%85%e5%ad%98%e5%af%b9%e9%bd%90 onclick="onNavClick(`#如何做到内存对齐-nav`)" id=如何做到内存对齐-nav>如何做到内存对齐</a></li><li><a href=#aarch64-%e5%af%b9%e9%9d%9e%e5%af%b9%e9%bd%90%e8%ae%bf%e9%97%ae%e7%9a%84%e6%94%af%e6%8c%81 onclick="onNavClick(`#aarch64-对非对齐访问的支持-nav`)" id=aarch64-对非对齐访问的支持-nav>AArch64 对非对齐访问的支持</a></li></ul></div></div></div></div></div><transition name=fade><div id=drawer-mask v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav id=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div id=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu</i></button>
<a id=navTitle class=navbar-brand href=https://wangloo.github.io/>Wangloo's BLOG</a>
<button type=button class=nav-darkmode-toggle id=darkModeToggleButton2>
<i class=material-icons id=darkModeToggleIcon2>dark_mode</i></button></div></nav><div class=single-column-header-container id=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=https://wangloo.github.io/><div class=single-column-header-title>Wangloo's BLOG</div><div class=single-column-header-subtitle>花有重开日, 人无再少年</div></a></div><div id=content><div id=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only><div class=post-title>C语言的内存对齐<div class=post-meta><time itemprop=datePublished>2023-05-08 17:19</time>
<i class=material-icons>label</i>
<a href=/tags/arm64>arm64</a>
&nbsp;
<a href=/tags/c>c</a>
&nbsp;
<a href=/tags/operating-system>Operating System</a>
&nbsp;
<i class=material-icons>schedule</i>
5 min
46 s.</div></div></div><div class=post-body-wrapper><div class=post-body v-pre><h2 id=内存对齐为何被需要>内存对齐为何被需要</h2><p>架构规定了数据类型大小的同时，也规定了对这些类型的变量合法访问的对齐要求。
也就是说，变量不能随便的放在内存的任意位置，起始地址必须满足特定的对齐要求，
对不满足要求的变量强行访问就叫做<strong>非对齐访问</strong>， 非对齐访问通常会触发异常。</p><h3 id=一般数据类型的对齐要求>一般数据类型的对齐要求</h3><p>对于一般的数据类型，比如 int, long, char 这些，要求其变量地址对齐到自身大小，
比如 ARM64 中，int 变量的地址必须对齐到 4 字节，long 变量地址必须对齐到 8 字节等等。</p><p>那么对于<code>*(int *)0x1001 = 1234;</code>, 这类的内存访问就叫非对齐的内存访问。</p><blockquote><p>即 （变量 addr % 变量 size) ！= 0, 就称为非对齐内存访问。</p></blockquote><h3 id=结构体的对齐要求>结构体的对齐要求</h3><p>上面说的还都是一般的数据类型，对于结构体这种复杂的类型，对齐的要求也复杂些。</p><ul><li>首先是结构体成员，每个成员都必须满足其自身的对齐要求</li><li>然后是结构体变量自身的起始地址的对齐要求是<strong>其所有成员的最大对齐要求</strong>。</li></ul><p>然而两个要求均满足有时候根本不可能，比如一个结构体声明为:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>struct</span> foo {
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>char</span>  mem1;
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>int</span>   mem2;
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>short</span> mem3;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>不可能同时做到 foo 变量和其成员 mem2 同时满足对齐到 4 字节，所以<strong>编译器会依据
上面的两条要求在成员之间添加 padding</strong>。</p><p>除了变量中间添加 padding 外，在末尾也会添加，<strong>使得结构体数组容易满足对齐需求</strong>。</p><p>最后 foo 变量在内存中的样子可能是:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>struct</span> foo {
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>char</span>  mem1;
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>char</span>  _pad1[<span style=color:#bd93f9>3</span>];  <span style=color:#6272a4>// 保证结构体和成员均对齐正确
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#8be9fd>int</span>   mem2;
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>short</span> mem3;
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>char</span>  _pad2[<span style=color:#bd93f9>2</span>];  <span style=color:#6272a4>// 保证【结构体数组】对齐正确
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>};
</span></span></code></pre></div><blockquote><p>若结构体的成员还是一个结构体，嵌套操作就可以了，编译器可以 handle。</p></blockquote><blockquote><p>对于结构体的定义来说，若不想添加 padding，可以使用<code>__attribute((packed))</code>
来声明。 常用于一些数据包的声明，除非你清楚自己为什么要这么做，要不别用。</p></blockquote><h2 id=如何做到内存对齐>如何做到内存对齐</h2><p>上面一节说明了各个类型的变量对于内存对齐的需求，只要是各个类型变量的地址满足要求了，
对所有变量的访问也就 OK 了。那么<em>如何保证每个变量地址都满足需求呢？</em></p><p>对于静态分配的变量，即在编译链接时期就能确定地址，由编译器完成这项工作。编译器保证
分配给这些变量的地址是满足对齐要求的，这个完全不用担心。</p><p>对于运行时动态分配的变量，例如<code>malloc()</code>接口返回的，其实 malloc 本身不知道要申请
空间的对齐规则，因为它只接受一个 size 作为参数。 所以一般来说，为了保证满足所有的
对齐要求，<code>malloc()</code> 返回的地址<strong>总是满足最大的对齐请求，即指针的大小 8 字节。</strong></p><blockquote><p><code>malloc()</code> 的实际效果与运行库的实现有关，并不是规定死的。不过我还没有见过不是
按照最大对齐要求分配的实现方法:)</p></blockquote><h2 id=aarch64-对非对齐访问的支持>AArch64 对非对齐访问的支持</h2><p>非对齐访问的结果是<strong>架构定义的</strong>， 不同的架构可能造成的结果不同：</p><ul><li>架构可能支持非对齐访问，成功读取数据</li><li>架构不支持非对齐访问，产生异常</li></ul><p>AArch64 架构支持 16、32、64 和 128 位的非对齐访问，但是有几个前提条件:</p><ul><li>关闭系统的对齐检查: <code>SCTLR_ELx.A</code> bit 来控制</li><li>exclusive load/store 和 load-acuqire/store-release 两类指令必须是对齐访问的
。这就表示构建信号量和其他锁机制时必须是对齐访问的</li><li>非对齐访问仅“普通内存”可用，"<strong>Device memory</strong>&ldquo;必须是对齐访问的</li></ul><blockquote><p>AArch64 非对齐访问的原理是<strong>分解为多次的访存</strong>，所以<strong>不能保证原子性</strong>，且性能是较差的。</p></blockquote><blockquote><p>虽然 AArch64 支持非对齐访问， 但编译器默认还是会生成满足对齐要求的代码。</p></blockquote><hr width=100% id=EOF><p style=color:#777>Last modified on 2023-05-28</p></div></div><nav class=post-pagination><a class=newer-posts href=/posts/os/linux/data_struct/hlist/>Next<br>Linux 内核数据结构 hlist</a>
<a class=older-posts href=/posts/armv8/memory_attr/>Previous<br>AArch64 内存属性与内存类型</a></nav><div class=post-comment-wrapper><div id=gitalk-container></div></div></div></div></div></div><div id=single-column-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://risehere.net/>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
@2019 Notepadium.</div></div><script src=/js/journal.js></script></body></html>