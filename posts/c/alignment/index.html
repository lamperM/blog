<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>C 语言的内存对齐要求</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%86%85%e5%ad%98%e5%af%b9%e9%bd%90%e4%b8%ba%e4%bd%95%e8%a2%ab%e9%9c%80%e8%a6%81 aria-label=内存对齐为何被需要>内存对齐为何被需要</a><ul><li><a href=#%e4%b8%80%e8%88%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%af%b9%e9%bd%90%e8%a6%81%e6%b1%82 aria-label=一般数据类型的对齐要求>一般数据类型的对齐要求</a></li><li><a href=#%e7%bb%93%e6%9e%84%e4%bd%93%e7%9a%84%e5%af%b9%e9%bd%90%e8%a6%81%e6%b1%82 aria-label=结构体的对齐要求>结构体的对齐要求</a></li></ul></li><li><a href=#%e5%a6%82%e4%bd%95%e5%81%9a%e5%88%b0%e5%86%85%e5%ad%98%e5%af%b9%e9%bd%90 aria-label=如何做到内存对齐>如何做到内存对齐</a></li><li><a href=#aarch64-%e5%af%b9%e9%9d%9e%e5%af%b9%e9%bd%90%e8%ae%bf%e9%97%ae%e7%9a%84%e6%94%af%e6%8c%81 aria-label="AArch64 对非对齐访问的支持">AArch64 对非对齐访问的支持</a></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>C 语言的内存对齐要求</div></header><h2 id=内存对齐为何被需要>内存对齐为何被需要</h2><p>架构规定了数据类型大小的同时，也规定了对这些类型的变量合法访问的对齐要求。
也就是说，变量不能随便的放在内存的任意位置，起始地址必须满足特定的对齐要求，
对不满足要求的变量强行访问就叫做<strong>非对齐访问</strong>， 非对齐访问通常会触发异常。</p><h3 id=一般数据类型的对齐要求>一般数据类型的对齐要求</h3><p>对于一般的数据类型，比如 int, long, char 这些，要求其变量地址对齐到自身大小，
比如 ARM64 中，int 变量的地址必须对齐到 4 字节，long 变量地址必须对齐到 8 字节等等。</p><p>那么对于<code>*(int *)0x1001 = 1234;</code>, 这类的内存访问就叫非对齐的内存访问。</p><blockquote><p>即 （变量 addr % 变量 size) ！= 0, 就称为非对齐内存访问。</p></blockquote><h3 id=结构体的对齐要求>结构体的对齐要求</h3><p>上面说的还都是一般的数据类型，对于结构体这种复杂的类型，对齐的要求也复杂些。</p><ul><li>首先是结构体成员，每个成员都必须满足其自身的对齐要求</li><li>然后是结构体变量自身的起始地址的对齐要求是<strong>其所有成员的最大对齐要求</strong>。</li></ul><p>然而两个要求均满足有时候根本不可能，比如一个结构体声明为:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-weight:700>struct</span> foo {
</span></span><span style=display:flex><span>  <span style=color:#888;font-weight:700>char</span>  mem1;
</span></span><span style=display:flex><span>  <span style=color:#888;font-weight:700>int</span>   mem2;
</span></span><span style=display:flex><span>  <span style=color:#888;font-weight:700>short</span> mem3;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>不可能同时做到 foo 变量和其成员 mem2 同时满足对齐到 4 字节，所以<strong>编译器会依据
上面的两条要求在成员之间添加 padding</strong>。</p><p>除了变量中间添加 padding 外，在末尾也会添加，<strong>使得结构体数组容易满足对齐需求</strong>。</p><p>最后 foo 变量在内存中的样子可能是:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#080;font-weight:700>struct</span> foo {
</span></span><span style=display:flex><span>  <span style=color:#888;font-weight:700>char</span>  mem1;
</span></span><span style=display:flex><span>  <span style=color:#888;font-weight:700>char</span>  _pad1[<span style=color:#00d;font-weight:700>3</span>];  <span style=color:#888>// 保证结构体和成员均对齐正确
</span></span></span><span style=display:flex><span><span style=color:#888></span>  <span style=color:#888;font-weight:700>int</span>   mem2;
</span></span><span style=display:flex><span>  <span style=color:#888;font-weight:700>short</span> mem3;
</span></span><span style=display:flex><span>  <span style=color:#888;font-weight:700>char</span>  _pad2[<span style=color:#00d;font-weight:700>2</span>];  <span style=color:#888>// 保证【结构体数组】对齐正确
</span></span></span><span style=display:flex><span><span style=color:#888></span>};
</span></span></code></pre></div><blockquote><p>若结构体的成员还是一个结构体，嵌套操作就可以了，编译器可以 handle。</p></blockquote><blockquote><p>对于结构体的定义来说，若不想添加 padding，可以使用<code>__attribute((packed))</code>
来声明。 常用于一些数据包的声明，除非你清楚自己为什么要这么做，要不别用。</p></blockquote><h2 id=如何做到内存对齐>如何做到内存对齐</h2><p>上面一节说明了各个类型的变量对于内存对齐的需求，只要是各个类型变量的地址满足要求了，
对所有变量的访问也就 OK 了。那么<em>如何保证每个变量地址都满足需求呢？</em></p><p>对于静态分配的变量，即在编译链接时期就能确定地址，由编译器完成这项工作。编译器保证
分配给这些变量的地址是满足对齐要求的，这个完全不用担心。</p><p>对于运行时动态分配的变量，例如<code>malloc()</code>接口返回的，其实 malloc 本身不知道要申请
空间的对齐规则，因为它只接受一个 size 作为参数。 所以一般来说，为了保证满足所有的
对齐要求，<code>malloc()</code> 返回的地址<strong>总是满足最大的对齐请求，即指针的大小 8 字节。</strong></p><blockquote><p><code>malloc()</code> 的实际效果与运行库的实现有关，并不是规定死的。不过我还没有见过不是
按照最大对齐要求分配的实现方法:)</p></blockquote><h2 id=aarch64-对非对齐访问的支持>AArch64 对非对齐访问的支持</h2><p>非对齐访问的结果是<strong>架构定义的</strong>， 不同的架构可能造成的结果不同：</p><ul><li>架构可能支持非对齐访问，成功读取数据</li><li>架构不支持非对齐访问，产生异常</li></ul><p>AArch64 架构支持 16、32、64 和 128 位的非对齐访问，但是有几个前提条件:</p><ul><li>关闭系统的对齐检查: <code>SCTLR_ELx.A</code> bit 来控制</li><li>exclusive load/store 和 load-acuqire/store-release 两类指令必须是对齐访问的
。这就表示构建信号量和其他锁机制时必须是对齐访问的</li><li>非对齐访问仅“普通内存”可用，"<strong>Device memory</strong>&ldquo;必须是对齐访问的</li></ul><blockquote><p>AArch64 非对齐访问的原理是<strong>分解为多次的访存</strong>，所以<strong>不能保证原子性</strong>，且性能是较差的。</p></blockquote><blockquote><p>虽然 AArch64 支持非对齐访问， 但编译器默认还是会生成满足对齐要求的代码。</p></blockquote></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2023-05-08T17:19:44, Lastmod: 2023-09-24T18:08:59</p><script src=/js/copy-to-clipboard.js></script></main></div></body></html>