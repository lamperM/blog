<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>杂乱的开发日记</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>所有文章</a></div><div class="a-block nav-link-item"><a href=/tags>Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#spring-os aria-label="spring OS">spring OS</a><ul><li><a href=#2023-07-01 aria-label=2023-07-01>2023-07-01</a></li><li><a href=#2023-07-02 aria-label=2023-07-02>2023-07-02</a></li></ul></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>杂乱的开发日记</div></header><p>零零碎碎的开发笔记，如果思考比较多应该写成单独的博文。</p><h2 id=spring-os>spring OS</h2><h3 id=2023-07-01>2023-07-01</h3><p>如果kernel也用低地址， 其实是不行的，因为这样在切换到用户
进程的时候，需要切页表对吧。 但是切换之后用户进程的ttbr是
没有内核的页面映射的。 它们又都用了用一个页表。</p><p>所以说看来是还是需要用两个页表实现起来比较方便些，
让内核用ttbr1，即映射在高地址。 做法是：</p><ol><li>首先boot阶段的代码是要在低地址的，因为此时没有开mmu（用uboot+PIC就没有这个顾虑）。</li><li>在boot代码中，mmu开启前需要建立映射，除了映射内核的代码段、数据段之外。
还有一个很重要的是恒等映射ttbr0，需要将boot代码建立恒等映射。</li><li>等到mmu启动后，访问的还是boot的代码，这时恒等映射生效。</li><li>但是当跳转到内核的代码时， 因为VMA是高地址， 所以用ttbr1，之前就映射好了。可以直接访问的。</li></ol><h3 id=2023-07-02>2023-07-02</h3><p>task_init():</p><p>task->affinity = -1</p><p>如果不是内核任务, 默认情况下task->state = TASK_STATE_WAIT_EVENT, 在create hook中进行的
内核任务的话, task->state = TASK_STATE_SUSPEND, 在task_init()中进行的</p><p>除了idle外, 其他task的task->cpu = -1, 在task_init()中进行的</p><p>wakeup_common():
task->task = TASK_STATE_WAKING
task->pend_stat = pend_state</p><p>task_ready():</p><ol><li>更新task->cpu, 如果初始值是-1, 更新为NR_CPUS-1, 这是TBD, 否则是affinity</li><li>然后根据当前cpu是否为task->cpu, 做出判断:<ol><li>如果是, 那么直接调用add_task_to_ready_list() 将任务加到readylist中</li><li>否则,将任务加到new_list, 而不是readylist, 然后发送核间中断通知task->cpu</li></ol></li></ol><p>sched_tick_handler():</p><ol><li>当前的task->ti.flags | __TIF_TICK_EXHAUST</li><li>当前的task->ti.flags | __TIF_NEED_RESCHED</li></ol><p>irqwork_handler():</p><ol><li>遍历当前pcpu->next_list:<ol><li>将task->state = TASK_STATE_READY</li><li>task加入pcpu的readylist</li></ol></li></ol></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2023-12-17T17:19:44, Lastmod: 2024-01-04T21:41:57</p></main></div></body></html>