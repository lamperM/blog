<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>git 宝典</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>所有文章</a></div><div class="a-block nav-link-item"><a href=/tags>Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput><ul id=searchResults></ul></div></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><h1>git 宝典</h1></header><h2 id=合并操作-git-merge>合并操作: git merge</h2><p>merge 有两种方式:</p><ul><li>fast-forward</li><li>three-way merger</li></ul><h3 id=fast-forward-merge>Fast-forward Merge</h3><p>假设合并的双方为<code>main</code>为<code>dev</code>, 如果其中一个是另一个的祖先, 此时直接移动 HEAD 到前方即可, 称为 fast-forward.</p><p>例如, 当前在 main, 执行<code>git merge dev</code>的过程如下:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>     main                              main
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>       |                                |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>M1 --- M2          ===&gt;    M1 --- M2 -- F1
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>       \                                |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>        \--- F1                        dev
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>             |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span>           dev
</span></span></code></pre></div><h3 id=three-way-merge>three-way Merge</h3><p>合并的两者不构成直接的祖先-孩子关系, 产生了分叉. 此时进行合并就需要有个基准(参考), 对于两边相较于基准的每个 diff 来说:</p><ul><li>合并的两者都在基准上进行了改动, 且改动不一致, <strong>标记为冲突</strong></li><li>如果该 diff<strong>仅在其中一方</strong>有改动, 那么就保留此次改动</li></ul><p>合并时使用的参考就是<strong>两个合并 commit 的最近公共祖先</strong>, 这种借助三个 commit(main, dev, 公共祖先)才能完成的合并操作就叫做 three-way merge.</p><p>例如, 当前在 main, 执行<code>git merge dev</code>的过程如下:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>             main                                main
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>              |                                   |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>M1 --- M2 --- M3    ===&gt;     M1 --- M2 --- M3 --- M4
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>       \                            \            /
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>        \--- F1                      \--- F1 ---
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>              |                           |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span>             dev                         dev
</span></span></code></pre></div><blockquote><p>three-way 的合并方式如果发生了冲突, 会产生一次额外的 merge commit, 下面介绍它</p></blockquote><h3 id=什么情况下-merge-commit-没有任何-diff>什么情况下 merge commit 没有任何 diff?</h3><p>按照上面的例子, three-way merge 发生冲突后会产生一次额外的 merge commit, 即 M4. 如果这是去查看 M4 相较前一次 commit 的 diff, 有时是没有的, 有时又会产生 diff.</p><p>如果在解决冲突的过程中, 我们仅仅是接收了 M2,M3 或者 F1 的修改, 那么此时 merge commit 就不会有 diff.</p><p>然而, 在解决冲突时, 我们也可以不采用来自两条路径的修改, 做一次新的修改(可以说, 同时接收两条 diff 就是这种情况), 此时查看 merge commit 的 diff 就是有内容的.</p><h2 id=变基-rebase>变基: rebase</h2><p>rebase 命令需要指定一个<strong>基准分支</strong>，<code>git rebase &lt;base-branch></code>，
rebase 会将当前所处分支整体移动到<code>base-branch</code>之后，即改变了当前分支的历史。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>// before rebase
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>[A]---[B]---[C]---[D]&lt;-dev
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>  \
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>   \--[E]&lt;-master
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>// after rebase
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span>[A]---[E]---[B]---[C]---[D]&lt;-dev
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8</span><span>       |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9</span><span>       master
</span></span></code></pre></div><h3 id=交互式-rebase>交互式 rebase</h3><p>交互式 rebase 是一种更高级的用法。基础的 rebase 上面说了是将当前分支的所有提交移动到 base-branch 之后。而交互式 rebase 提供一个方法，在移动之前"挑选"当前分支的 commit。</p><p>实际工程中，通常来说，我们将开发分支移动到 master 之前，可以经过交互 rebase 来整理开发分支中混乱的 commit 记录。</p><p>具体的使用方法是，为<code>git rebase</code>指令提供<code>-i</code>参数:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>git checkout dev
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>git rebase -i master
</span></span></code></pre></div><p>这个命令会打开一个文本编辑器，列出当前 feature 分支的所有提交:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>pick 33d5b7a Message for commit #1
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>pick 9480b3d Message for commit #2
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>pick 5c67e61 Message for commit #3
</span></span></code></pre></div><p>列出的内容就能完整的表示 dev 分支的所有提交，按照顺序。而我们不仅可以任意的重排这些 commit，而且修改<code>pick</code>关键字就能对这些 commit 做改动。举个例子，我们可能发现 commit2 只是对于 commit1 做了一个很小的改动，它们完全可以合并为一个 commit，那么直接 commit2 的<code>pick</code>修改为<code>fixup</code>，整个内容变为:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>pick 33d5b7a Message for commit #1
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>fixup 9480b3d Message for commit #2
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>pick 5c67e61 Message for commit #3
</span></span></code></pre></div><p>当你保存并退出这个文件时，改动就会生效，不仅将 dev 整体移动到了 master 后，并且合并了前两个 commit。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>// after rebase interactive
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>[A]---[E]---[B]---[D]&lt;-dev
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>       |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>       master
</span></span></code></pre></div><h3 id=rebase-整理多个-commit>rebase 整理多个 commit</h3><p>如上面交互式 rebase 所述，当你开发完 dev 分支，需要<code>merge</code>到 main 分支时，可以先利用交互式 rebase"整理"一下 dev 分支的 commit。</p><p>这里其实要用到一个小 trick，上面说过 rebase 命令需要指定一个 base-branch，实际上是一个 base-commit，这种场景下我们不是要合并其他分支，所以<strong>base-branch</strong>可以选择当前 dev 分支的前面某一次 commit。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>git checkout dev
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>git rebase -i HEAD~3
</span></span></code></pre></div><p>以上指令实现的功能就是给你整理最后 3 次提交的机会，但<strong>不会合并其他分支的东西</strong>。</p><p>那如果我想整理整个 dev 分支呢？是向上找到 dev 的第一次 commit 吗？ Git 提供了一个方便找到 dev 分叉出来的那次 commit，将其输出传递给<code>git rebase -i</code>即可实现整理整个 dev 的所有 commit。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>git merger-base dev main
</span></span></code></pre></div><h2 id=git-merege-vs-git-rebase><code>git merege</code> vs <code>git rebase</code></h2><h3 id=准则>准则</h3><ul><li><p>如果分支已经被提交到远程仓库，就不能再改变他的历史了，即不能使用 rebase。
git 也会阻止你这么做，因为分支的历史已经被修改，除非 force-push。</p></li><li><p>你能进行 rebase 的分支是本地的”私人分支”，私人表示为: 只有你自己在使用，别人不会基于你的分支做东西。</p></li></ul><h3 id=dev-同步主分支的改动-rebase>dev 同步主分支的改动: rebase</h3><p>假设我们正在本地的 dev 分支开发一个特性，此时你的同事在 main(也可以是其他的远程分支)上提交了一个重要的 commit，以至于你需要它来继续你的开发任务。</p><p>这种情况我们使用 rebase 和 merge 都能完成目标，但是 rebase 是更好的选择。</p><ul><li>首先满足 rebase 的使用条件，我们仅仅是破坏了本地 dev 分支的历史，并没有动到其他的远程分支，所以就不存在干涉别人</li><li>其次，在 dev 上 merge 其他分支会产生一次不必要的<em>merge commit</em>，其不代表任何实际意义，没必要存在的</li></ul><h3 id=合并-dev-到主分支-merge>合并 dev 到主分支: merge</h3><p>很简单的逻辑，主分支或者其他合作开发的分支并不是你一个人在用，并且需要最后同步到远程仓库，不符合使用 rebase 的准则</p><h1 id=git-log>git log</h1><h2 id=参数>参数:</h2><table><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody><tr><td>non-param</td><td>列出所有历史提交的 SHA、作者、提交日期和 commit</td></tr><tr><td>-p</td><td>按补丁显示每次更新，比&ndash;stat 更全</td></tr><tr><td>&ndash;stat</td><td>显示每次更新修改文件的名称及添加（删除）的行数。比&ndash;name-only 更全</td></tr><tr><td>&ndash;name-only</td><td>显示文件清单</td></tr><tr><td>&ndash;name-status</td><td>显示文件清单及改动方式(新增、删除、修改)</td></tr><tr><td>&ndash;oneline</td><td>只显示前 6 位 SHA 值和 commit</td></tr><tr><td>-n</td><td>显示前 n 条 log</td></tr><tr><td>&lt;branch></td><td>查看某个分支的历史提交。<strong>该参数只能 log 命令之后</strong></td></tr><tr><td>&lt;branch1>..&lt;branch2></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><p>参考网站：https://www.cnblogs.com/bellkosmos/p/5923439.html</p><h2 id=example-1-彩色显示重要信息>Example 1: 彩色显示重要信息</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>git log --graph --pretty=format:<span style=color:#a31515>&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39;</span> --abbrev-commit
</span></span></code></pre></div><p><img src=gitlog_1.png alt></p><h2 id=example-2-查看本地分支和对应远程分支的-commit-差异>Example 2: 查看本地分支和对应远程分支的 commit 差异</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>git log --oneline main..origin/main
</span></span></code></pre></div><h1 id=子模块-submodule>子模块: submodule</h1><h2 id=新增一个子模块>新增一个子模块</h2><ol start=0><li><p>将子模块上传到远端仓库上</p></li><li><p>执行<code>git submodule add [url] [path]</code></p></li><li><p>此时执行<code>git status</code> 会有两个changes，分别是：</p><ul><li><code>.gitmodules</code>: 记录子模块的path和url</li><li><code>[子模块同名的文件]</code>: 记录主项目追踪的是子模块的哪个commit.</li></ul><blockquote><p>也就是说主项目中惠济路自己跟踪子模块的commit，并不一定总是最新的。</p></blockquote></li><li><p><code>git add</code>这两处改动，<code>git commit -m "add submodule xxx"</code></p></li></ol><h2 id=clone一个使用子模块的项目>clone一个使用子模块的项目</h2><ol><li>用常规的<code>git clone</code>命令将主项目拿下，此时子模块不会自动下载，只是一个空的目录</li><li><code>git submodule init</code>，<strong>这个命令其实是带参数的</strong>，指定你想更新哪些子模块，
缺省代表所有子模块。该命令实际的行为是将<code>.gitmodule</code>中的内容写入<code>.git/config</code></li><li><code>git submodule update</code>, 按照<code>.git/config</code>指定的子模块去下载，<strong>注意下载的
commit不一定是最新的，上面讲过</strong></li></ol><blockquote><p>:question: <code>git submodule init</code>命令是否有意义？</p><p>有时我们并不想同步所有的子模块，而是其中的某几个，因为可能想自己重写一些，这时可以添加参数
指定想要同步的那些子模块。</p></blockquote><blockquote><p>:two::three:可以合并为一条命令： <code>git submodule update --init</code>， 同步所有子模块。</p></blockquote><h2 id=修改更新子模块>修改更新子模块</h2><p>如果仅仅是使用子模块，并不做修改，那不用关注这个。但如果你同时参与submodule的开发，那就需要注意。</p><ol><li>修改子模块并提交；这一步很常规，<code>cd</code>到子模块中，做完修改commit即可</li><li>此时会发现在主项目中也多了一个额外的change，是刚才修改子模块的同名文件，
查看diff会发现改动为commit id改为了刚才提交的那次子模块修改</li></ol><p>Q1: 这次改动代表什么含义？</p><p>我们知道，子模块同名文件中记录主项目跟踪此子模块的commit，也是<code>git commit update</code> 会达到的
commit。含义是<strong>主项目配合子模块的这个commit是ok的</strong>。而这次改动也就代表跟踪的commit想要
发生变化，由于你刚才对子模块修改造成的，git自动猜测你想同时改动主项目的追踪。</p><p>Q2: 对这个改动应该做什么操作？</p><p>分两种场景: (1)如果子项目的这些更新有意义同步到主项目中，那么就add并commit这个同名文件的改动，
message为"更新submodule"。 (2)如若只是更新子项目而已，或许是为了其他依赖的项目所改的，并不
想涉及到本主项目，那么就restore此次更新，或者重新执行<code>submodule update</code>即可(前提是对子模块
的修改已经push)。</p><p>所以说，同意主项目中的这次change的人必须是更新这次子模块的人，由他决定是否同步到主项目。
其他人<strong>甚至在使用期间都不需要<code>cd</code>进入子模块做<code>git pull</code>的</strong>，这样也就不会有决策产生，即便
子项目在远端更新了，你要做的就是关注那个同名文件就行，当同名文件更新了，在主项目中
<code>submodule update</code>即可，</p><h2 id=子模块的优缺点>子模块的优缺点</h2><p>TODO</p></article></body></main></div></body></html>