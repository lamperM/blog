<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>git 宝典</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%90%88%e5%b9%b6%e6%93%8d%e4%bd%9c-git-merge aria-label="合并操作: git merge">合并操作: git merge</a><ul><li><a href=#fast-forward-merge aria-label="Fast-forward Merge">Fast-forward Merge</a></li><li><a href=#three-way-merge aria-label="three-way Merge">three-way Merge</a></li></ul></li><li><a href=#%e5%8f%98%e5%9f%ba-rebase aria-label="变基: rebase">变基: rebase</a><ul><li><a href=#%e4%ba%a4%e4%ba%92%e5%bc%8f-rebase aria-label="交互式 rebase">交互式 rebase</a></li><li><a href=#rebase-%e6%95%b4%e7%90%86%e5%a4%9a%e4%b8%aa-commit aria-label="rebase 整理多个 commit">rebase 整理多个 commit</a></li></ul></li><li><a href=#git-merege-vs-git-rebase aria-label="git merege vs git rebase"><code>git merege</code> vs <code>git rebase</code></a><ul><li><a href=#%e5%87%86%e5%88%99 aria-label=准则>准则</a></li><li><a href=#dev-%e5%90%8c%e6%ad%a5%e4%b8%bb%e5%88%86%e6%94%af%e7%9a%84%e6%94%b9%e5%8a%a8-rebase aria-label="dev 同步主分支的改动: rebase">dev 同步主分支的改动: rebase</a></li><li><a href=#%e5%90%88%e5%b9%b6-dev-%e5%88%b0%e4%b8%bb%e5%88%86%e6%94%af-merge aria-label="合并 dev 到主分支: merge">合并 dev 到主分支: merge</a></li></ul></li><li><a href=#git-log aria-label="git log">git log</a><ul><li><a href=#%e5%8f%82%e6%95%b0 aria-label=参数:>参数:</a></li><li><a href=#example-1-%e5%bd%a9%e8%89%b2%e6%98%be%e7%a4%ba%e9%87%8d%e8%a6%81%e4%bf%a1%e6%81%af aria-label="Example 1: 彩色显示重要信息">Example 1: 彩色显示重要信息</a></li><li><a href=#example-2-%e6%9f%a5%e7%9c%8b%e6%9c%ac%e5%9c%b0%e5%88%86%e6%94%af%e5%92%8c%e5%af%b9%e5%ba%94%e8%bf%9c%e7%a8%8b%e5%88%86%e6%94%af%e7%9a%84-commit-%e5%b7%ae%e5%bc%82 aria-label="Example 2: 查看本地分支和对应远程分支的 commit 差异">Example 2: 查看本地分支和对应远程分支的 commit 差异</a></li></ul></li><li><a href=#%e8%bf%9c%e7%a8%8b%e4%bb%93%e5%ba%93 aria-label=远程仓库>远程仓库</a><ul><li><a href=#%e5%85%8b%e9%9a%86%e8%bf%9c%e7%a8%8b%e4%bb%93%e5%ba%93 aria-label=克隆远程仓库>克隆远程仓库</a></li></ul></li><li><a href=#%e5%ad%90%e6%a8%a1%e5%9d%97-submodule aria-label="子模块: submodule">子模块: submodule</a><ul><li><a href=#%e6%96%b0%e5%a2%9e%e4%b8%80%e4%b8%aa%e5%ad%90%e6%a8%a1%e5%9d%97 aria-label=新增一个子模块>新增一个子模块</a></li><li><a href=#submodule-command aria-label="Submodule Command">Submodule Command</a><ul><li><a href=#git-submodule-init aria-label="git submodule init"><code>git submodule init</code></a></li><li><a href=#git-submodule-update aria-label="git submodule update"><code>git submodule update</code></a><ul><li><a href=#--init aria-label=&amp;ndash;init>&ndash;init</a></li><li><a href=#--remote aria-label=&amp;ndash;remote>&ndash;remote</a></li></ul></li><li><a href=#git-submoudle-set-x aria-label="git submoudle set-x"><code>git submoudle set-x</code></a></li></ul></li><li><a href=#%e4%bd%bf%e7%94%a8submodule%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9 aria-label=使用Submodule注意事项>使用Submodule注意事项</a><ul><li><a href=#1submodule%e5%88%b0%e5%ba%95%e6%98%af%e8%bf%bd%e8%b8%aa%e5%88%86%e6%94%af%e8%bf%98%e6%98%afcommit aria-label=1.Submodule到底是追踪分支还是commit>1.Submodule到底是追踪分支还是commit</a></li><li><a href=#2-%e5%90%8c%e5%90%8d%e6%96%87%e4%bb%b6%e5%8f%91%e7%94%9f%e4%ba%86%e4%bf%ae%e6%94%b9%e5%ba%94%e4%b8%8d%e5%ba%94%e8%af%a5stage aria-label="2. 同名文件发生了修改，应不应该stage？">2. 同名文件发生了修改，应不应该stage？</a></li></ul></li><li><a href=#%e5%ad%90%e6%a8%a1%e5%9d%97%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9 aria-label=子模块的优缺点>子模块的优缺点</a></li></ul></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>git 宝典</div></header><h2 id=合并操作-git-merge>合并操作: git merge</h2><p>merge行为的语义是将其他分支的修改合并到当前分支。由此就产生了两种内部的实现原理，
以下均假设当前分支为main，其他分支为dev：</p><ul><li>fast-forward：</li><li>three-way merger：</li></ul><h3 id=fast-forward-merge>Fast-forward Merge</h3><p>main是dev的某个直接祖先，或者说他们之间是一条线的关系。此时将dev的修改合并进来相当于移动main指针指向dev的最新commit(F1)。此时merge称为 fast-forward.</p><p>例如, 当前在 main, 执行<code>git merge dev</code>的过程如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>     main                              main
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>       |                                |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>M1 --- M2          ===&gt;    M1 --- M2 -- F1
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>       \                                |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>        \--- F1                        dev
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>             |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span>           dev
</span></span></code></pre></div><h3 id=three-way-merge>three-way Merge</h3><p>合并的两者不构成直接的祖先-孩子关系，也就意味着main和dev分别位于两个分叉上（见下图左）。此时merge的步骤就相对复杂：</p><ol><li>找到main和dev的公共祖先M2</li><li>列出main和dev分别基于公共祖先来说做了哪些修改<ol><li>如果两条分叉的修改不冲突，完美合并</li><li>经常出现的是，两个分叉难免对同一片段做了不同修改，此时<strong>标记为冲突</strong>，等待用户解决</li></ol></li><li>因为main和dev位于两个分叉，合并会新建一个节点（M4），commit的信息是“Merge dev into main”。如果步骤2中产生冲突了，那么解决冲突的行为就被记录到M4的diff。没有冲突时diff是空的。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>             main                                main
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>              |                                   |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>M1 --- M2 --- M3    ===&gt;     M1 --- M2 --- M3 --- M4
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>       \                            \            /
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>        \--- F1                      \--- F1 ---
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>              |                           |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span>             dev                         dev
</span></span></code></pre></div><p>因为此时merge需要借助三个 commit(main, dev, 公共祖先)，这种操作就叫做 three-way merge。</p><h2 id=变基-rebase>变基: rebase</h2><p>rebase 命令需要指定一个<strong>基准分支</strong>，<code>git rebase &lt;base-branch></code>，
rebase 会将当前所处分支整体移动到<code>base-branch</code>之后，即改变了当前分支的历史。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>// before rebase
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>[A]---[B]---[C]---[D]&lt;-dev
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>  \
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>   \--[E]&lt;-master
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>// after rebase
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span>[A]---[E]---[B]---[C]---[D]&lt;-dev
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8</span><span>       |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">9</span><span>       master
</span></span></code></pre></div><h3 id=交互式-rebase>交互式 rebase</h3><p>交互式 rebase 是一种更高级的用法。基础的 rebase 上面说了是将当前分支的所有提交移动到 base-branch 之后。而交互式 rebase 提供一个方法，在移动之前"挑选"当前分支的 commit。</p><p>实际工程中，通常来说，我们将开发分支移动到 master 之前，可以经过交互 rebase 来整理开发分支中混乱的 commit 记录。</p><p>具体的使用方法是，为<code>git rebase</code>指令提供<code>-i</code>参数:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>git checkout dev
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>git rebase -i master
</span></span></code></pre></div><p>这个命令会打开一个文本编辑器，列出当前 feature 分支的所有提交:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>pick 33d5b7a Message for commit #1
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>pick 9480b3d Message for commit #2
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>pick 5c67e61 Message for commit #3
</span></span></code></pre></div><p>列出的内容就能完整的表示 dev 分支的所有提交，按照顺序。而我们不仅可以任意的重排这些 commit，而且修改<code>pick</code>关键字就能对这些 commit 做改动。举个例子，我们可能发现 commit2 只是对于 commit1 做了一个很小的改动，它们完全可以合并为一个 commit，那么直接 commit2 的<code>pick</code>修改为<code>fixup</code>，整个内容变为:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>pick 33d5b7a Message for commit #1
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>fixup 9480b3d Message for commit #2
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>pick 5c67e61 Message for commit #3
</span></span></code></pre></div><p>当你保存并退出这个文件时，改动就会生效，不仅将 dev 整体移动到了 master 后，并且合并了前两个 commit。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>// after rebase interactive
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>[A]---[E]---[B]---[D]&lt;-dev
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>       |
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>       master
</span></span></code></pre></div><h3 id=rebase-整理多个-commit>rebase 整理多个 commit</h3><p>如上面交互式 rebase 所述，当你开发完 dev 分支，需要<code>merge</code>到 main 分支时，可以先利用交互式 rebase"整理"一下 dev 分支的 commit。</p><p>这里其实要用到一个小 trick，上面说过 rebase 命令需要指定一个 base-branch，实际上是一个 base-commit，这种场景下我们不是要合并其他分支，所以<strong>base-branch</strong>可以选择当前 dev 分支的前面某一次 commit。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>git checkout dev
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>git rebase -i HEAD~3
</span></span></code></pre></div><p>以上指令实现的功能就是给你整理最后 3 次提交的机会，但<strong>不会合并其他分支的东西</strong>。</p><p>那如果我想整理整个 dev 分支呢？是向上找到 dev 的第一次 commit 吗？ Git 提供了一个方便找到 dev 分叉出来的那次 commit，将其输出传递给<code>git rebase -i</code>即可实现整理整个 dev 的所有 commit。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>git merger-base dev main
</span></span></code></pre></div><h2 id=git-merege-vs-git-rebase><code>git merege</code> vs <code>git rebase</code></h2><h3 id=准则>准则</h3><ul><li><p>如果分支已经被提交到远程仓库，就不能再改变他的历史了，即不能使用 rebase。
git 也会阻止你这么做，因为分支的历史已经被修改，除非 force-push。</p></li><li><p>你能进行 rebase 的分支是本地的”私人分支”，私人表示为: 只有你自己在使用，别人不会基于你的分支做东西。</p></li></ul><h3 id=dev-同步主分支的改动-rebase>dev 同步主分支的改动: rebase</h3><p>假设我们正在本地的 dev 分支开发一个特性，此时你的同事在 main(也可以是其他的远程分支)上提交了一个重要的 commit，以至于你需要它来继续你的开发任务。</p><p>这种情况我们使用 rebase 和 merge 都能完成目标，但是 rebase 是更好的选择。</p><ul><li>首先满足 rebase 的使用条件，我们仅仅是破坏了本地 dev 分支的历史，并没有动到其他的远程分支，所以就不存在干涉别人</li><li>其次，在 dev 上 merge 其他分支会产生一次不必要的<em>merge commit</em>，其不代表任何实际意义，没必要存在的</li></ul><h3 id=合并-dev-到主分支-merge>合并 dev 到主分支: merge</h3><p>很简单的逻辑，主分支或者其他合作开发的分支并不是你一个人在用，并且需要最后同步到远程仓库，不符合使用 rebase 的准则</p><h2 id=git-log>git log</h2><h3 id=参数>参数:</h3><table><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody><tr><td>non-param</td><td>列出所有历史提交的 SHA、作者、提交日期和 commit</td></tr><tr><td>-p</td><td>按补丁显示每次更新，比&ndash;stat 更全</td></tr><tr><td>&ndash;stat</td><td>显示每次更新修改文件的名称及添加（删除）的行数。比&ndash;name-only 更全</td></tr><tr><td>&ndash;name-only</td><td>显示文件清单</td></tr><tr><td>&ndash;name-status</td><td>显示文件清单及改动方式(新增、删除、修改)</td></tr><tr><td>&ndash;oneline</td><td>只显示前 6 位 SHA 值和 commit</td></tr><tr><td>-n</td><td>显示前 n 条 log</td></tr><tr><td>&lt;branch></td><td>查看某个分支的历史提交。<strong>该参数只能 log 命令之后</strong></td></tr><tr><td>&lt;branch1>..&lt;branch2></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><p>参考网站：https://www.cnblogs.com/bellkosmos/p/5923439.html</p><h3 id=example-1-彩色显示重要信息>Example 1: 彩色显示重要信息</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>git log --graph --pretty<span style=color:#ff79c6>=</span>format:<span style=color:#f1fa8c>&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39;</span> --abbrev-commit
</span></span></code></pre></div><p><img src=gitlog_1.png alt></p><h3 id=example-2-查看本地分支和对应远程分支的-commit-差异>Example 2: 查看本地分支和对应远程分支的 commit 差异</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>git log --oneline main..origin/main
</span></span></code></pre></div><h2 id=远程仓库>远程仓库</h2><h3 id=克隆远程仓库>克隆远程仓库</h3><p>默认克隆master分支</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>git clone &lt;shortname&gt; &lt;url&gt;
</span></span></code></pre></div><p>需要克隆指定的分支</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>git clone -b &lt;branch&gt; &lt;shortname&gt; &lt;url&gt;
</span></span></code></pre></div><p>克隆并指定文件名</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>git clone &lt;shortname&gt; &lt;url&gt; &lt;dirname&gt;
</span></span></code></pre></div><style type=text/css>.notice{--root-color:#444;--root-background:#eff;--title-color:#fff;--title-background:#7bd;--warning-title:#c33;--warning-content:#fee;--info-title:#fb7;--info-content:#fec;--note-title:#6be;--note-content:#e7f2fa;--tip-title:#5a5;--tip-content:#efe}@media(prefers-color-scheme:dark){.notice{--root-color:#ddd;--root-background:#eff;--title-color:#fff;--title-background:#7bd;--warning-title:#800;--warning-content:#400;--info-title:#a50;--info-content:#420;--note-title:#069;--note-content:#023;--tip-title:#363;--tip-content:#121}}body.dark .notice{--root-color:#ddd;--root-background:#eff;--title-color:#fff;--title-background:#7bd;--warning-title:#800;--warning-content:#400;--info-title:#a50;--info-content:#420;--note-title:#069;--note-content:#023;--tip-title:#363;--tip-content:#121}.notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:var(--root-color);background:var(--root-background)}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:var(--title-color);background:var(--title-background)}.notice.warning .notice-title{background:var(--warning-title)}.notice.warning{background:var(--warning-content)}.notice.info .notice-title{background:var(--info-title)}.notice.info{background:var(--info-content)}.notice.note .notice-title{background:var(--note-title)}.notice.note{background:var(--note-content)}.notice.tip .notice-title{background:var(--tip-title)}.notice.tip{background:var(--tip-content)}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:.125em;position:relative}</style><div><svg width="0" height="0" display="none" xmlns="http://www.w3.org/2000/svg"><symbol id="tip-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379.0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628.0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628.0l-22.627 22.627c-6.248 6.248-6.248 16.379.0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"/></symbol><symbol id="note-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405.0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346 7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373.0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884.0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="warning-notice" viewBox="0 0 576 512" preserveAspectRatio="xMidYMid meet"><path d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937.0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154.0l239.94 416.028zM288 354c-25.405.0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346 7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373.0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884.0-12.356 5.78-11.981 12.654z"/></symbol><symbol id="info-notice" viewBox="0 0 512 512" preserveAspectRatio="xMidYMid meet"><path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196.0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627.0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627.0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627.0 12 5.373 12 12v1e2h12c6.627.0 12 5.373 12 12v24z"/></symbol></svg></div><div class="notice note"><p class="first notice-title"><span class="icon-notice baseline"><svg><use href="#note-notice"/></svg></span>Note</p><p>clone或者fetch会将历史都下载到本地，内容可能很大。
<strong>使用<code>--depth</code>参数只克隆最近几次commit的内容</strong>，减少下载的时间。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>git clone &lt;url&gt; --depth<span style=color:#ff79c6>=</span><span style=color:#bd93f9>1</span> <span style=color:#6272a4># Clone最近一次提交only</span>
</span></span></code></pre></div><p>以后如果需要下载历史，执行<code>git fetch --unshallow</code>即可下载完整内容。</p></div><h2 id=子模块-submodule>子模块: submodule</h2><h3 id=新增一个子模块>新增一个子模块</h3><p>(1) 将子模块上传到远端仓库上，或者使用已有的第三方项目</p><p>(2) 执行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>git submodule add <span style=color:#ff79c6>[</span>url<span style=color:#ff79c6>]</span> <span style=color:#ff79c6>[</span>path<span style=color:#ff79c6>]</span>
</span></span></code></pre></div><p>(3) 此时看<code>git status</code> 会有两个changes，分别是：</p><ol><li><code>.gitmodules</code>中会增加一条项目, 记录子模块的名称和地址<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>[submodule &#34;SubmoduleTestRepo&#34;]
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>    path = SubmoduleTestRepo
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>    url = https://github.com/jzaccone/SubmoduleTestRepo.git   
</span></span></code></pre></div></li><li><code>[子模块同名的文件]</code>: 记录主项目追踪的是子模块的哪个commit</li></ol><blockquote><p>.gitmodule和子模块同名文件的作用</p><ul><li><p>先说比较简单的.gitmodule，<strong>记录主项目中用到的所有子模块</strong>。
一般来说仅仅记录子模块的路径和url，但有时还会有指定的分支名。
这个我们在下面会介绍。</p></li><li><p>然后是和子模块同名的文件，我们想一下，上面的.gitmodules仅仅告诉了从哪来，
但是一个仓库是有多个分支，对应多个commit的，那么需要有一种方式去指定使用绑定哪个commit，
这就是同名文件的作用。在同名文件中会记录一下commitid，表明主项目依赖这个commitid下的子模块，
他们之间具有绑定关系。</p></li></ul></blockquote><p>(4) <code>git add</code>这两处改动，<code>git commit -m "add submodule xxx"</code></p><h3 id=submodule-command>Submodule Command</h3><p>Execute <code>git submodule --help</code> to get more info.</p><h4 id=git-submodule-init><code>git submodule init</code></h4><p>此命令clone新项目的时候会用到, 完整的命令是</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>git submodule init [path]
</span></span></code></pre></div><blockquote><p><strong>在详细介绍前需要说明两个文件的差别: .gitmodule和.git/config</strong>:</p><ul><li>.gitmoudles在上面已经介绍过一些，这里主要想说<strong>它是跟随主项目一起提交的</strong>，
而.git/config是后面生成的本地文件。</li><li>.gitmodules会给出列出所有子模块，但是不一定每次都全部使用。
**具体会启用哪些由.git/config文件规定。</li></ul></blockquote><p><code>git submodule init</code>指令会指定生成.git/config文件的内容。
选择某几个子模块启用即写入<code>.git/config</code>。</p><ul><li>在缺省参数下的含义是添加所有在.gitmodules中的子模块。</li><li>未来<code>update</code>指令只会更新<code>.git/config</code>中的项目。</li></ul><h4 id=git-submodule-update><code>git submodule update</code></h4><p>刚才说了，因为.gitmodules中的所有子模块并不一定都使用，
所以新clone下来的项目并不会同时下载所有的子模块。
在上面的init阶段生成了.git/config来指定需要哪些之后，
update命令就是用于下载指定的子模块。</p><h5 id=--init>&ndash;init</h5><p>由于此命令配合init命令使用，两者通常连续操作，所以可以合并为:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>git submodule update --init
</span></span></code></pre></div><h5 id=--remote>&ndash;remote</h5><p>一般情况下，下载子模块都是checkout到.git/config指定的commit。
<code>--remote</code>则会checkout到<strong>追踪分支的最新commit</strong>，下面会说到如何设置追踪分支，
默认是master。</p><p>如果最新的commit不等于.git/config指定的，那么执行完该指令后会产生一次同名文件的改动。</p><h4 id=git-submoudle-set-x><code>git submoudle set-x</code></h4><p>修改的是哪个文件？</p><p>&ldquo;x"可以是url，修改子模块的地址。</p><p>这里我主要想着重介绍<code>set-branch</code>命令，<strong>将原来追踪自模块的方式由commit更改为(branch+commit)。</strong> 想要修改追踪子模块的commit到某个分支的最新，有两种方法:</p><ol><li>传统方案<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#8be9fd;font-style:italic>cd</span> lib1/
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>git checkout &lt;branch&gt;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#8be9fd;font-style:italic>cd</span> ..
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>git add lib1
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>git commit -m <span style=color:#f1fa8c>&#34;change lib1&#39;s tracked commit&#34;</span>
</span></span></code></pre></div></li><li>使用set-branch参数<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>git submodule set-branch -b &lt;branch&gt; lib1/ 
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#6272a4># 改变设置之后，子模块不会立即变化</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#6272a4># 必须指定带remote参数的update命令，才会用更新到显式指定的分支最新，</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span><span style=color:#6272a4># 而不是同名文件中规定的commitid</span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>git submodule update --remote
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>git add lib1 .gitmodules
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span>git commit -m <span style=color:#f1fa8c>&#34;change lib1&#39;s tracked commit&#34;</span>
</span></span></code></pre></div></li></ol><blockquote><p><code>set-branch</code>修改了.gitmodules, 也同步到了.git/config中。如果你想手动修改.gitmodules来设置分支，不要忘了<code>submodule init</code>来同步到.git/config</p></blockquote><h3 id=使用submodule注意事项>使用Submodule注意事项</h3><h4 id=1submodule到底是追踪分支还是commit>1.Submodule到底是追踪分支还是commit</h4><p>事实证明子模块默认追踪的不是分支，容易验证。
我们将子模块基于当前分支（假设master）新建一个子分支，并做一些修改，
可以看到主项目中的子模块同名文件也发生了改动。
所以说，它默认并不是跟踪分支。</p><p>我感觉可以证明<strong>它默认跟踪的是HEAD</strong>。还是用上面的例子，
此时主项目中同名文件发生了改动。但是如果将子模块的分支切换回原来的master，
子模块同名文件的改动就消失了。以我目前的见解我暂且这么认为。</p><h4 id=2-同名文件发生了修改应不应该stage>2. 同名文件发生了修改，应不应该stage？</h4><p>分两种场景: (1)如果子项目的这些更新有意义同步到主项目中，那么就add并commit这个同名文件的改动，
message为"更新submodule&rdquo;。 (2)如若只是更新子项目而已，或许是为了其他依赖的项目所改的，并不
想涉及到本主项目，那么就restore此次更新，或者重新执行<code>submodule update</code>即可(前提是对子模块
的修改已经push)。</p><p>所以说，同意主项目中的这次change的人必须是更新这次子模块的人，由他决定是否同步到主项目。
其他人<strong>甚至在使用期间都不需要<code>cd</code>进入子模块做<code>git pull</code>的</strong>，这样也就不会有决策产生，即便
子项目在远端更新了，你要做的就是关注那个同名文件就行，当同名文件更新了，在主项目中
<code>submodule update</code>即可，</p><h3 id=子模块的优缺点>子模块的优缺点</h3><p>TODO</p></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2022-12-13T17:39:42, Lastmod: 2024-04-09T21:38:28</p></main></div></body></html>