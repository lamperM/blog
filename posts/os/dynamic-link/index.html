<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>动态链接</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>所有文章</a></div><div class="a-block nav-link-item"><a href=/tags>Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e9%9d%99%e6%80%81%e9%93%be%e6%8e%a5%e5%b8%a6%e6%9d%a5%e7%9a%84%e9%97%ae%e9%a2%98 aria-label=静态链接带来的问题>静态链接带来的问题</a></li><li><a href=#%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5%e7%9a%84%e8%bf%87%e7%a8%8b aria-label=动态链接的过程>动态链接的过程</a></li><li><a href=#%e5%9c%b0%e5%9d%80%e6%97%a0%e5%85%b3%e4%bb%a3%e7%a0%81-pic aria-label="地址无关代码 PIC">地址无关代码 PIC</a></li></ul></div></details></div></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>动态链接</div></header><h2 id=静态链接带来的问题>静态链接带来的问题</h2><ol><li><p>像是<code>libc</code>这种几乎每个程序都要用到的库, 如果是静态的, 那么不仅意外着每个程序的
可执行文件很大, 浪费磁盘空间. 并且当程序加载到内存时, 可能许多程序都会用到<code>printf</code>
, 使得内存中会存在好多份的<code>printf</code>源码.</p></li><li><p>维护和更新难. 一旦静态链接的其中一个目标文件更新, 所有的可执行程序都要重新链接.</p></li><li><p>不满足局部性原理. 上面提到, 内存中同时存在多份的<code>printf</code>源码会破坏<em>局部性原理</em>的.
显然如果所有的程序共享一份<code>printf</code>源码的想法更好. 即动态加载.</p></li><li><p>可移植性差. 静态链接, 只要有一个依赖目标文件的实现不同, 软件厂商就得专门发布一个
版本. 而动态链接则信赖客户电脑上的<em>动态库</em>, 相当于一个中间层.</p></li></ol><p> </p><h2 id=动态链接的过程>动态链接的过程</h2><p>对比静态链接使用<code>ld</code>链接器在编译后即执行链接, 动态链接则是将链接过程推迟到<strong>运行时</strong>,
即装载到内存时.</p><p>这样, 链接器在链接产生可执行文件时就有两种做法:</p><ul><li>对于静态符号, 按照静态链接的规则进行<em>地址引用重定位</em></li><li>对于动态符号, 链接器则仅标记其为动态链接中的符号, 不进行处理. 而是等到装载时由
专门的<em>动态链接器</em>来完成动态符号的链接工作.</li></ul><p>:interrobang: 链接器如何确定一个符号是静态的or动态的?</p><p>在动态共享对象(<em>.so)中保存了完整的</em>动态符号表*, 表中存在的符号即为动态的, 否则为静态.</p><blockquote><p>Linux的C语言运行库<code>glib</code>的动态链接版本叫<code>libc.so</code>. 它在外存上只保存一份, 所有的程序
都可以在运行时使用它. 所以千万不要删掉它.</p></blockquote><blockquote><p>动态链接有一定的性能损失, 因为每次运行程序时都要重新链接, 并不像静态链接是一劳永逸的.
也有例如<code>延迟绑定</code>对性能进行优化的方法, 大概仅有5%的损耗, 与带来的便利相比可以忽略不计.</p></blockquote><p> </p><h2 id=地址无关代码-pic>地址无关代码 PIC</h2><p>GCC生成动态库时需要添加参数<code>-fPIC</code>, 含义就是生成地址无关码</p><p>地址无关码的含义是代码中<strong>不包含任何的绝对地址引用</strong>, 全都是<strong>相对地址</strong>.</p><ul><li>对于<strong>模块内</strong>的跳转/数据引用, 使用相对的跳转/加载指令. 例如ARM指令集中的<code>B</code>, <code>ADR</code>, 经过汇编器之后, 目标的地址都会转为相对于该指令(PC)的偏移.</li><li>对于<strong>模块间</strong>的跳转/数据引用, 借用<em>GOT表</em>来间接实现地址无关.</li></ul><p>而如果该动态库中全部使用相对地址, 那么加载时也就不需要进行重定位, 即所有的程序都可以
共享这些地址无关代码.</p><blockquote><p>上面说PIC的动态库不需要重定位其实是错误的, 只不过它的重定位过程不需要修改代码段,
而是设置了一个放置在数据段的<em>GOT</em>表来实现代码段部分的地址无关特性.</p></blockquote><blockquote><p>现在貌似GCC ARM版本在编译动态库时强制使用-fPIC选项, 否则会报错. 对此我不是
非常确定!</p></blockquote><blockquote><p>一般来说, 不将主程序编译为地址无关码. 因为主程序不需要共享, 而且地址无关码的调用
需要两个指令: <code>计算地址</code> + <code>跳转</code>. 多了一步根据偏移得到绝对地址.</p></blockquote></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2022-06-26T19:50:45, Lastmod: 2023-09-02T15:27:14</p></main></div></body></html>