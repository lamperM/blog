<!doctype html><html><head><title>ELF 文件的链接与加载</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=description content><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><link rel=stylesheet href=/scss/journal.min.a4a96c4dc87303b81206f86623ab533a5c6cc7fe9ac433fcdd808d2089bae63b.css integrity="sha256-pKlsTchzA7gSBvhmI6tTOlxsx/6axDP83YCNIIm65js=" media=screen><link rel=stylesheet href=/scss/dark-mode.min.8d11714119bdb3c376b7eab64344dcd1f183f83f58c906bbe5d8b770bccf9c03.css integrity="sha256-jRFxQRm9s8N2t+q2Q0Tc0fGD+D9YyQa75di3cLzPnAM=" media=screen><script src=/vendor/js/loadCSS.js></script>
<script>loadCSS("https://fonts.googleapis.com/css?family=Fira+Mono|Material+Icons")</script><script src=/js/toc.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script>
<script src=/vendor/js/md5.min.js></script>
<script>var gitalk=new Gitalk({clientID:"12dfb0f809e5e6afde3d",clientSecret:"72aaf5660b3a7b43b0bffb4d683a605a7ea65dad",repo:"blogcomments_gitalk",owner:"wangloo",admin:["wangloo"],id:md5(location.pathname),distractionFreeMode:"false"});window.onload=function(){gitalk.render("gitalk-container")}</script></head><body><div id=app><div id=sideContainer class=side-container><a class="a-block nav-head false" href=https://wangloo.github.io/><div class=nav-title>Soben's Secret Base</div><div class=nav-subtitle>花有重开日, 人无再少年</div></a><div class=nav-link-list><a class="a-block nav-link-item active" href=/posts>Archive</a>
<a class="a-block nav-link-item false" href=/tags>Tags</a>
<a class="a-block nav-link-item false" href=/categories>Categories</a></div><div class=nav-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://risehere.net/>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
@2019 Notepadium.</div></div><div id=extraContainer class=extra-container><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc-content><center>- CATALOG -</center><ul><ul><li><a href=#elf-is-a-file-format onclick="onNavClick(`#elf-is-a-file-format-nav`)" id=elf-is-a-file-format-nav>ELF is a file format</a></li><li><a href=#elf-%e6%96%87%e4%bb%b6%e7%bb%84%e6%88%90%e7%9a%84%e7%bb%93%e6%9e%84 onclick="onNavClick(`#elf-文件组成的结构-nav`)" id=elf-文件组成的结构-nav>ELF 文件组成的结构</a></li><ul><li><a href=#%e6%ae%b5%e8%a1%a8 onclick="onNavClick(`#段表-nav`)" id=段表-nav>段表</a></li><li><a href=#%e7%a8%8b%e5%ba%8f%e5%a4%b4%e8%a1%a8 onclick="onNavClick(`#程序头表-nav`)" id=程序头表-nav>程序头表</a></li></ul><li><a href=#%e5%88%86%e6%9e%90elf%e6%96%87%e4%bb%b6%e7%9a%84%e5%b7%a5%e5%85%b7 onclick="onNavClick(`#分析elf文件的工具-nav`)" id=分析elf文件的工具-nav>分析ELF文件的工具</a></li><ul><li><a href=#1-objdump onclick="onNavClick(`#1-objdump-nav`)" id=1-objdump-nav>1. objdump</a></li><li><a href=#2-readelf onclick="onNavClick(`#2-readelf-nav`)" id=2-readelf-nav>2. readelf</a></li></ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e7%9b%ae%e6%a0%87%e6%96%87%e4%bb%b6%e4%b8%ad%e4%bb%a3%e7%a0%81%e5%92%8c%e6%95%b0%e6%8d%ae%e8%a6%81%e5%88%86%e5%bc%80%e6%94%be onclick="onNavClick(`#为什么目标文件中代码和数据要分开放-nav`)" id=为什么目标文件中代码和数据要分开放-nav>为什么目标文件中代码和数据要分开放?</a></li><li><a href=#%e5%85%b3%e4%ba%8e%e9%9d%99%e6%80%81%e5%ba%93 onclick="onNavClick(`#关于静态库-nav`)" id=关于静态库-nav>关于静态库</a></li><li><a href=#elf%e6%96%87%e4%bb%b6%e5%8a%a0%e8%bd%bd-%e8%bf%90%e8%a1%8c%e6%b5%81%e7%a8%8b onclick="onNavClick(`#elf文件加载-运行流程-nav`)" id=elf文件加载-运行流程-nav>ELF文件加载-运行流程</a></li><ul><li><a href=#%e9%9d%99%e6%80%81%e5%8a%a0%e8%bd%bd%e4%b8%8e%e5%8a%a8%e6%80%81%e5%8a%a0%e8%bd%bd onclick="onNavClick(`#静态加载与动态加载-nav`)" id=静态加载与动态加载-nav>静态加载与动态加载</a></li><li><a href=#%e5%8a%a8%e6%80%81%e5%8a%a0%e8%bd%bd%e7%9a%84%e6%ad%a5%e9%aa%a4 onclick="onNavClick(`#动态加载的步骤-nav`)" id=动态加载的步骤-nav>动态加载的步骤</a></li></ul><li><a href=#%e6%ae%b5%e5%9c%b0%e5%9d%80%e5%af%b9%e9%bd%90%e6%8a%80%e6%9c%af onclick="onNavClick(`#段地址对齐技术-nav`)" id=段地址对齐技术-nav>段地址对齐技术</a></li><ul><li><a href=#-%e8%bf%99%e4%b8%89%e4%b8%aa%e6%ae%b5%e5%9c%a8elf%e6%96%87%e4%bb%b6%e4%b8%ad%e7%9a%84%e5%b8%83%e5%b1%80%e5%a6%82%e4%bd%95 onclick="onNavClick(`#-这三个段在elf文件中的布局如何-nav`)" id=-这三个段在elf文件中的布局如何-nav>❓ 这三个段在ELF文件中的布局如何?</a></li><li><a href=#-%e8%bf%99%e4%b8%89%e4%b8%aa%e6%ae%b5%e5%9c%a8%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98%e4%b8%ad%e7%9a%84%e5%b8%83%e5%b1%80 onclick="onNavClick(`#-这三个段在物理内存中的布局-nav`)" id=-这三个段在物理内存中的布局-nav>❓ 这三个段在物理内存中的布局?</a></li><li><a href=#-%e8%bf%99%e4%b8%89%e4%b8%aa%e6%ae%b5%e5%9c%a8%e7%94%a8%e6%88%b7virtual-addrspace%e4%b8%8b%e7%9a%84%e5%b8%83%e5%b1%80%e5%a6%82%e4%bd%95 onclick="onNavClick(`#-这三个段在用户virtual-addrspace下的布局如何-nav`)" id=-这三个段在用户virtual-addrspace下的布局如何-nav>❓ 这三个段在用户virtual addrspace下的布局如何?</a></li><li><a href=#-%e4%bd%95%e4%b8%ba%e6%ae%b5%e5%9c%b0%e5%9d%80%e5%af%b9%e9%bd%90%e6%8a%80%e6%9c%af onclick="onNavClick(`#-何为段地址对齐技术-nav`)" id=-何为段地址对齐技术-nav>❓ 何为段地址对齐技术?</a></li></ul></div></div><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a>
<a type=button class=pagination-action id=darkModeToggleButton><span class="material-icons pagination-action-icon" id=darkModeToggleIcon>dark_mode</span></a></div></div><div class=single-column-drawer-container id=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item active" href=/posts>Archive</a>
<a class="a-block drawer-menu-item false" href=/tags>Tags</a>
<a class="a-block drawer-menu-item false" href=/categories>Categories</a><div class=toc><div class=toc-content><center>- CATALOG -</center><ul><ul><li><a href=#elf-is-a-file-format onclick="onNavClick(`#elf-is-a-file-format-nav`)" id=elf-is-a-file-format-nav>ELF is a file format</a></li><li><a href=#elf-%e6%96%87%e4%bb%b6%e7%bb%84%e6%88%90%e7%9a%84%e7%bb%93%e6%9e%84 onclick="onNavClick(`#elf-文件组成的结构-nav`)" id=elf-文件组成的结构-nav>ELF 文件组成的结构</a></li><ul><li><a href=#%e6%ae%b5%e8%a1%a8 onclick="onNavClick(`#段表-nav`)" id=段表-nav>段表</a></li><li><a href=#%e7%a8%8b%e5%ba%8f%e5%a4%b4%e8%a1%a8 onclick="onNavClick(`#程序头表-nav`)" id=程序头表-nav>程序头表</a></li></ul><li><a href=#%e5%88%86%e6%9e%90elf%e6%96%87%e4%bb%b6%e7%9a%84%e5%b7%a5%e5%85%b7 onclick="onNavClick(`#分析elf文件的工具-nav`)" id=分析elf文件的工具-nav>分析ELF文件的工具</a></li><ul><li><a href=#1-objdump onclick="onNavClick(`#1-objdump-nav`)" id=1-objdump-nav>1. objdump</a></li><li><a href=#2-readelf onclick="onNavClick(`#2-readelf-nav`)" id=2-readelf-nav>2. readelf</a></li></ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e7%9b%ae%e6%a0%87%e6%96%87%e4%bb%b6%e4%b8%ad%e4%bb%a3%e7%a0%81%e5%92%8c%e6%95%b0%e6%8d%ae%e8%a6%81%e5%88%86%e5%bc%80%e6%94%be onclick="onNavClick(`#为什么目标文件中代码和数据要分开放-nav`)" id=为什么目标文件中代码和数据要分开放-nav>为什么目标文件中代码和数据要分开放?</a></li><li><a href=#%e5%85%b3%e4%ba%8e%e9%9d%99%e6%80%81%e5%ba%93 onclick="onNavClick(`#关于静态库-nav`)" id=关于静态库-nav>关于静态库</a></li><li><a href=#elf%e6%96%87%e4%bb%b6%e5%8a%a0%e8%bd%bd-%e8%bf%90%e8%a1%8c%e6%b5%81%e7%a8%8b onclick="onNavClick(`#elf文件加载-运行流程-nav`)" id=elf文件加载-运行流程-nav>ELF文件加载-运行流程</a></li><ul><li><a href=#%e9%9d%99%e6%80%81%e5%8a%a0%e8%bd%bd%e4%b8%8e%e5%8a%a8%e6%80%81%e5%8a%a0%e8%bd%bd onclick="onNavClick(`#静态加载与动态加载-nav`)" id=静态加载与动态加载-nav>静态加载与动态加载</a></li><li><a href=#%e5%8a%a8%e6%80%81%e5%8a%a0%e8%bd%bd%e7%9a%84%e6%ad%a5%e9%aa%a4 onclick="onNavClick(`#动态加载的步骤-nav`)" id=动态加载的步骤-nav>动态加载的步骤</a></li></ul><li><a href=#%e6%ae%b5%e5%9c%b0%e5%9d%80%e5%af%b9%e9%bd%90%e6%8a%80%e6%9c%af onclick="onNavClick(`#段地址对齐技术-nav`)" id=段地址对齐技术-nav>段地址对齐技术</a></li><ul><li><a href=#-%e8%bf%99%e4%b8%89%e4%b8%aa%e6%ae%b5%e5%9c%a8elf%e6%96%87%e4%bb%b6%e4%b8%ad%e7%9a%84%e5%b8%83%e5%b1%80%e5%a6%82%e4%bd%95 onclick="onNavClick(`#-这三个段在elf文件中的布局如何-nav`)" id=-这三个段在elf文件中的布局如何-nav>❓ 这三个段在ELF文件中的布局如何?</a></li><li><a href=#-%e8%bf%99%e4%b8%89%e4%b8%aa%e6%ae%b5%e5%9c%a8%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98%e4%b8%ad%e7%9a%84%e5%b8%83%e5%b1%80 onclick="onNavClick(`#-这三个段在物理内存中的布局-nav`)" id=-这三个段在物理内存中的布局-nav>❓ 这三个段在物理内存中的布局?</a></li><li><a href=#-%e8%bf%99%e4%b8%89%e4%b8%aa%e6%ae%b5%e5%9c%a8%e7%94%a8%e6%88%b7virtual-addrspace%e4%b8%8b%e7%9a%84%e5%b8%83%e5%b1%80%e5%a6%82%e4%bd%95 onclick="onNavClick(`#-这三个段在用户virtual-addrspace下的布局如何-nav`)" id=-这三个段在用户virtual-addrspace下的布局如何-nav>❓ 这三个段在用户virtual addrspace下的布局如何?</a></li><li><a href=#-%e4%bd%95%e4%b8%ba%e6%ae%b5%e5%9c%b0%e5%9d%80%e5%af%b9%e9%bd%90%e6%8a%80%e6%9c%af onclick="onNavClick(`#-何为段地址对齐技术-nav`)" id=-何为段地址对齐技术-nav>❓ 何为段地址对齐技术?</a></li></ul></div></div></div></div></div><transition name=fade><div id=drawer-mask v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav id=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div id=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu</i></button>
<a id=navTitle class=navbar-brand href=https://wangloo.github.io/>Soben's Secret Base</a>
<button type=button class=nav-darkmode-toggle id=darkModeToggleButton2>
<i class=material-icons id=darkModeToggleIcon2>dark_mode</i></button></div></nav><div class=single-column-header-container id=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=https://wangloo.github.io/><div class=single-column-header-title>Soben's Secret Base</div><div class=single-column-header-subtitle>花有重开日, 人无再少年</div></a></div><div id=content><div id=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only><div class=post-title>ELF 文件的链接与加载<div class=post-meta><time itemprop=datePublished>2022-06-20 16:21</time>
<i class=material-icons>label</i>
<a href=/tags/operating-system>Operating System</a>
&nbsp;
<i class=material-icons>schedule</i>
10 min
29 s.</div></div></div><div class=post-body-wrapper><div class=post-body v-pre><h2 id=elf-is-a-file-format><code>ELF</code> is a file format</h2><p>Files in <code>ELF</code> format includes:</p><table><thead><tr><th>Type</th><th>description</th><th>实例</th></tr></thead><tbody><tr><td>Relocatable File</td><td>这些文件包含了代码和data, 可以被用来链接成可执行文件或共享目标文件.</td><td><code>.o</code>, <code>.a</code></td></tr><tr><td>Executable File</td><td>直接可执行的文件</td><td><code>/bin/ls</code></td></tr><tr><td>Shared Object File</td><td>Including code and data. 链接器可将其与其他Relocatable File或Shared Object File结合, 生成新的目标文件. 动态链接器可将其与Executable File结合, 作为进程映像的一部分来运行.</td><td><code>.so</code></td></tr><tr><td>Core Dump File</td><td>Restore critical infomation when process is terminated unexpectedly</td><td><code>core dump</code></td></tr></tbody></table><blockquote><p>📌 <code>file</code> command in Linux can output the format of a file.</p></blockquote><p> </p><h2 id=elf-文件组成的结构>ELF 文件组成的结构</h2><pre tabindex=0><code>+---------------------------------+
|           ELF Header            |  包含描述整个ELF的基本信息, 如版本, 入口地址...
+---------------------------------+
|           .text                 |
+---------------------------------+
|           .data                 |
+---------------------------------+  紧接着是各个段
|           .bss                  |
+---------------------------------+
|           ...                   |  
|           other sections        |
+---------------------------------+
|                                 |  段表: 与段相关最重要的结构
|       Section Header table      |  描述了每个段的name, length, authority...
|                                 |
+---------------------------------+
|         String tables           |
|         Symbol tables           |
+---------------------------------+
</code></pre><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>e_machine</td><td>目标架构</td></tr><tr><td>e_entry</td><td>入口地址</td></tr><tr><td>e_machine</td><td>目标架构</td></tr><tr><td>e_phnum</td><td>number of entries in the <strong>program header table</strong></td></tr><tr><td>e_shnum</td><td>number of entries in the <strong>section header table</strong></td></tr><tr><td>e_shoff</td><td>offset, in bytes, of the section header table</td></tr><tr><td>e_phoff</td><td>offset, in bytes, of the program header table</td></tr><tr><td>e_machine</td><td>目标架构</td></tr><tr><td>e_machine</td><td>目标架构</td></tr></tbody></table><h3 id=段表>段表</h3><p>ELF文件中的各个段的基本属性就是保存在<strong>段表</strong>中，是分析ELF文件最重要的字段。存放了每个段的信息，例如，段名，段的长度，在文件中的偏移，读写权限以及其他属性。</p><p>编译器、链接器都是依靠段表来定位和访问各个段的属性的。</p><p>如何找到段表？ <strong><code>e_shoff</code>字段</strong></p><blockquote><p>使用<code>readelf -S &lt;elfname></code> 就能查看ELF文件的段表</p></blockquote><h3 id=程序头表>程序头表</h3><p> </p><h2 id=分析elf文件的工具>分析ELF文件的工具</h2><h3 id=1-objdump>1. objdump</h3><h3 id=2-readelf>2. readelf</h3><p> </p><h2 id=为什么目标文件中代码和数据要分开放>为什么目标文件中代码和数据要分开放?</h2><p>一方面, 程序被加载进内存后, 代码段和数据段分别被映射到<strong>两个virtual memory region</strong>.
通过MMU的支持, 可以将代码段的区域设置为只读, 防止恶意篡改.</p><p>另一方面, 当下CPU Cache多划分为<em>Instruction Cache</em>和<em>Data Cache</em>, 再配合互相独立的
地址区域能够提高<strong>局部性原理</strong>的效果.</p><p>最后, 代码段可以被多个进程共享(例如都调用同一外部函数), 节省内存空间.</p><blockquote><p>针对嵌入式设备, 如果内存空间不够大, 只读的代码段可存放在ROM中</p></blockquote><p> </p><h2 id=关于静态库>关于静态库</h2><p>一个静态库可以简单的看作是 a set of object file.<br>这些 object file 可能包括: 输入输出相关的<code>printf.o</code>, <code>scanf.o</code>, 日期时间相关的<code>time.o</code>, <code>date.o</code>等.</p><p>❓ 为什么不直接提供这些<em>目标文件</em>呢?</p><p>这些<strong>零散的</strong>文件若直接提供给使用者, 很大程度上造成文件传输, 管理等方面的不便.<br>于是人们通常使用<code>ar</code>压缩程序将这些目标文件压缩到一起.</p><p>❓ 如何查看一个静态库是由哪些object file压缩到一起的?</p><p>Shell command<code>ar -t libc.a</code> 可以查看<code>libc.a</code>中包含的所有object files.</p><p> </p><h2 id=elf文件加载-运行流程>ELF文件加载-运行流程</h2><blockquote><p>废了半天劲编译生成的ELF文件, 想要最终跑起来则包含的instruction and data必须要在内存中.</p></blockquote><h3 id=静态加载与动态加载>静态加载与动态加载</h3><p>我们能想到的最简单的办法是: 把整个ELF的<strong>所有指令和数据</strong>在运行之前就全部load到内存中. 这就是<em>静态加载</em>.</p><p>更加高效的做法是: 充分利用<em>局部性原理</em>, 将指令和数据划分为<strong>模块</strong>, 只有当该模块被使用时, 才load进内存,
否则就在外存中老老实实呆着. 这就是<em>动态加载</em>.</p><h3 id=动态加载的步骤>动态加载的步骤</h3><p>借助<em>虚拟内存</em>技术, 上面提到的<strong>模块</strong>的概念可以自然的被<strong>页</strong>(page)代替.
我们将所有的指令和数据按照page为单位划分.</p><ol><li><p>运行该ELF的线程被创建时, 其virtual space范围被划定, 但其页表是空的, 没有任何映射.</p></li><li><p>OS读取ELF Header, 建立virtual space与<strong>ELF文件</strong>的映射关系. 这个映射关系的表达方式是一个特殊的<strong>数据结构</strong>.
建立该映射关系的原因是: 当程序运行到某个地址发现该页表项是空的(例如 <code>call 0x1234</code>), 那么必然触发<code>page fault</code>.
由OS负责到<em>特定的外存地址</em>将页面加载到physical memory中.</p></li></ol><pre tabindex=0><code>OS要想知道缺失的内容在ELF文件的哪个位置, 就是利用该映射, 即某个数据结构
</code></pre><ol start=3><li>physical memory中有了所需的指令或数据后, 还需建立visual memory到physical memory的映射, 即在<em>页表项</em>中写入.
随着程序的运行, 会继续触发<code>page fault</code>, 从ELF中不断load page到physical memory, 建立缺页visual addr处的页表映射,
最终填补成一个完整的pagetable.</li></ol><p> </p><h2 id=段地址对齐技术>段地址对齐技术</h2><blockquote><p>由前面动态加载的步骤可知, ELF文件中的代码和数据被按page划分. 并只有在用到时才被加载到内存,
并建立<code>虚拟内存-物理内存</code>的映射.</p></blockquote><p>假设一个ELF有三个段需要被<code>LOAD</code>, ELF段表如下:</p><table><thead><tr><th>Segment</th><th>Length</th><th>offset</th></tr></thead><tbody><tr><td>SEG 0</td><td>127 B</td><td>34 B</td></tr><tr><td>SEG 1</td><td>9899 B</td><td>164 B</td></tr><tr><td>SEG 2</td><td>1988 B</td><td>0 B</td></tr></tbody></table><h3 id=-这三个段在elf文件中的布局如何>❓ 这三个段在ELF文件中的布局如何?</h3><p>根据前面ELF文件格式的介绍, 这三个段必然是挨着的(简单考虑, ELF中仅有这三个段).</p><h3 id=-这三个段在物理内存中的布局>❓ 这三个段在物理内存中的布局?</h3><p>发生<code>page fault</code>之后, OS会为页面分配合适的物理页面, 如利用<code>buddy system</code>等.</p><p>可以保证<em>段内</em>的连续, 不能保证<em>段与段</em>是连续的.</p><blockquote><p>未使用段对齐技术之前, <code>SEG0</code>的长度不足一页, 但是也给它分配一页的空间. 同理为<code>SEG1</code>分配两页, <code>SEG2</code>分配一页.
总共占用 <code>1+2+1=5</code>个物理页.</p></blockquote><h3 id=-这三个段在用户virtual-addrspace下的布局如何>❓ 这三个段在用户virtual addrspace下的布局如何?</h3><p>todo</p><h3 id=-何为段地址对齐技术>❓ 何为段地址对齐技术?</h3><p>上面说了, 在为这三个段分配物理内存时, 虽然他们的真实大小远小于5个页面, 但由于简单采用: <code>每个段的开头必须是page align</code>,
导致实际上产生了巨大的<strong>内部碎片</strong>.</p><p>段地址对齐实际上就是在为ELF文件中的段分配物理内存时, 不考虑其段的独立性, 强制按照<code>page</code>来划分. 划分的行为如下图所示.
结果就是仅需占用<code>3</code>个物理页面.</p><pre tabindex=0><code>+---+---------------+
| P |     SEG0      |
| A +---------------+
| G |               |
| E |               |
+---+               |
| P |     SEG1      |
| A |               |
| G |               |
| E |               |
+---+               |
| P +---------------+
| A |               |
| G |     SEG2      |
| E |               |
+---+---------------+
</code></pre><blockquote><p>目前, gcc(更准确是说是GUN ld)默认启用段对齐技术. 各个段的虚拟地址并不是<code>page align</code>.</p></blockquote><blockquote><p>🍀 物理页面到虚拟页面的映射阶段, 那些<em>同时包含</em>两个段的页面会被映射两次, 即一个物理页面对应两个
虚拟页.</p><p>原因是: 在一个页面的不同段可能<strong>权限不同</strong>, 所以不能使用同一映射.</p></blockquote><hr width=100% id=EOF><p style=color:#777>Last modified on 2023-02-27</p></div></div><nav class=post-pagination><a class=newer-posts href=/posts/os/dynamic-link/>Next<br>动态链接</a>
<a class=older-posts href=/posts/codestyle/improve_quality/>Previous<br>Improving the quality of C code</a></nav><div class=post-comment-wrapper><div id=gitalk-container></div></div></div></div></div></div><div id=single-column-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://risehere.net/>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
@2019 Notepadium.</div></div><script src=/js/journal.js></script></body></html>