<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/syntax_pastie.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>虚拟化：Virtio</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#virtio-%e6%98%af%e5%b9%b2%e5%95%a5%e7%9a%84 aria-label="Virtio 是干啥的">Virtio 是干啥的</a></li><li><a href=#%e4%bb%a5%e5%89%8d%e7%9a%84%e8%ae%be%e5%a4%87%e8%99%9a%e6%8b%9f%e5%8c%96%e4%b8%ba%e4%bb%80%e4%b9%88%e6%80%a7%e8%83%bd%e4%bd%8e aria-label=以前的设备虚拟化为什么性能低>以前的设备虚拟化为什么性能低</a></li><li><a href=#virtio-%e5%a6%82%e4%bd%95%e6%8f%90%e9%ab%98%e6%80%a7%e8%83%bd aria-label="Virtio 如何提高性能">Virtio 如何提高性能</a></li><li><a href=#%e5%87%a0%e7%a7%8d-virtio-%e7%9a%84%e7%bb%8f%e5%85%b8%e5%ae%9e%e7%8e%b0 aria-label="几种 Virtio 的经典实现">几种 Virtio 的经典实现</a><ul><li><a href=#%e5%90%8e%e7%ab%af%e5%9c%a8-hypervisor aria-label="后端在 Hypervisor">后端在 Hypervisor</a></li><li><a href=#%e5%90%8e%e7%ab%af%e5%9c%a8-hostvm aria-label="后端在 HostVM">后端在 HostVM</a></li></ul></li><li><a href=#%e8%bf%9b%e4%b8%80%e6%ad%a5%e6%8f%90%e5%8d%87%e6%80%a7%e8%83%bdvhost aria-label=进一步提升性能：Vhost>进一步提升性能：Vhost</a></li><li><a href=#virtio-qemu-%e8%bf%9b%e4%b8%80%e6%ad%a5%e6%8f%90%e5%8d%87%e6%80%a7%e8%83%bdvhe aria-label="Virtio QEMU 进一步提升性能：VHE">Virtio QEMU 进一步提升性能：VHE</a></li><li><a href=#%e6%88%91%e6%98%af%e4%b8%80%e4%b8%aa-vmm-%e5%bc%80%e5%8f%91%e8%80%85%e5%a6%82%e4%bd%95%e6%94%af%e6%8c%81-virtio aria-label="我是一个 VMM 开发者，如何支持 Virtio">我是一个 VMM 开发者，如何支持 Virtio</a></li><li><a href=#%e6%88%91%e6%98%af%e4%b8%80%e4%b8%aa-linux-%e9%a9%b1%e5%8a%a8%e5%bc%80%e5%8f%91%e8%80%85%e5%a6%82%e4%bd%95%e6%94%af%e6%8c%81-virtio aria-label="我是一个 Linux 驱动开发者，如何支持 Virtio">我是一个 Linux 驱动开发者，如何支持 Virtio</a></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>虚拟化：Virtio</div></header><p>从最近开始接触虚拟化的基础知识，一直不太理解设备虚拟化的理念。然而通过最近对 Virtio 的了解，可能稍微有一些见解，在这里记录下。</p><h2 id=virtio-是干啥的>Virtio 是干啥的</h2><p>虚拟化中，设备的虚拟化是很复杂、很关键的一点，Linux 代码中大量的设备驱动，<strong>如何对这些驱动的行为进行模拟成为了一个很难解决的问题</strong>。
Virtio 提供了一种高性能的设备虚拟化方案。</p><h2 id=以前的设备虚拟化为什么性能低>以前的设备虚拟化为什么性能低</h2><p>最早，虚拟化技术刚刚提出的时候，实现虚拟化的是的方案是&ndash;<strong>设备“全虚拟化”</strong>。关键的点是：<strong>VM 不必知道自己运行在 Hypervisor 之上，也不用修改任何的代码</strong>，直接就能实现设备的访问。</p><p>实现这种方案的关键是：对所有的设备访问都要 Trap 到 Hypervisor 处理。OS 和设备交互的方式是 MMIO 和中断，以串口举例，我们要发送一个字符到串口中，就需要不断的读 busy 寄存器，直到空闲然后写 data 寄存器。</p><ul><li>不能直接把设备 MMIO 地址给 VM 操作，因为 hypervisor 之上运行着多个 VM，他们不知道其他人是否在占用设备，会造成冲突。</li><li>所以唯一的方法就是：<strong>每一次 MMIO 的访问，都 Trap 到 Hypervisor</strong>，它能看到所有 VM 的状态，在合适的时候将这个请求转发给物理设备。中断也是如此，Hypervisor 拦截所有的中断。</li></ul><p><strong>这种做法显然造成了频繁的 Trap</strong>，性能很差！！</p><figure><img src=/virtio_1.jpg width=60%></figure><h2 id=virtio-如何提高性能>Virtio 如何提高性能</h2><p>Virtio 的设计原则是：放弃一部分设备全虚拟化的优势，VM 得知道自己运行在 Hypervisor 之上。然后，在 VM 上运行“改良过的”设备驱动，来提高性能。</p><p>这个改良做的是什么呢？</p><ul><li>Virtio 分为前后端，前端在 VM 中，替换原来的设备驱动。</li><li>后端在 Hypervisor/HostVM 中，相当于是原来对物理设备实际操作的代码。</li></ul><p>原来的全虚拟化，不是每次寄存器操作都要 Trap 吗？现在的方案是，</p><ul><li>在前后端之间（不论后段在 Hypervisor 还是 HostVM），有一个 ringbuf，两个端口可以分别将数据放到 ringbuf 中，甚至是两个分离的 ringbuf。</li><li>加以合适的通知机制，在数据准备好后通知后段进行处理，或者后段通知前端，原理是相同的。</li></ul><p>这种方案能提高性能主要在于：</p><ol><li>GuestVM 和直接驱动硬件设备的代理方（可能是 Hypervisor/HostVM）通信不需要每次都 Trap，直接等到某个条件下通过中断告之，去 ringbuf 取就可以了。你可能会问，全虚拟化中，也可以做缓存啊？但问题是，因为 VM 不知道自己运行在虚拟机上，所以缓存不能做成共享内存的形式（或者难做、不通用），而 VirtIO 中的 ringbuf 是完全的共享内存的形式，零拷贝，速度快。</li></ol><p>另外，Virtio 前后端分离的设计，也解决了一部分通用性问题。前后端在设备初始化时会握手，只要满足某种约束就行相互配合，可以独立设计实现。</p><ul><li>站在 Hypervisor/HostVM 的角度，不用对所有的设备驱动都分别做代理判断了，而是划分为了几种类别（Virtio-blk、Virtio-console 等）。不管你是什么设备，只要 VM 有 virtio 驱动，Hypervisor/HostVM 就不用更改，直接支持。</li></ul><h2 id=几种-virtio-的经典实现>几种 Virtio 的经典实现</h2><h3 id=后端在-hypervisor>后端在 Hypervisor</h3><ul><li>VM 驱动通过 hvc 调用来通知 hyperv</li><li>Hypervisor 通过中断注入来通知 VM</li></ul><figure><img src=/virtio_hyp.jpg width=60%></figure><h3 id=后端在-hostvm>后端在 HostVM</h3><ul><li>VM 后端是 HostVM 里的一个<strong>用户线程</strong>，专门处理前端请求</li><li>VM 如何通知 HostVM，我理解只有 Host 能主动发起通知，难道还是 hvc 吗？</li><li>VM 和 HostVM 之间的 virtqueue 通过共享内存来实现，可以承载于 uio 设备</li><li>HostVM 专门用于处理请求的，所以它可以直接操作硬件，Hypervisor 不需要 Trap 吧</li></ul><p>TODO： 展示一个完整的数据流程，假设 GusetVM 要操作硬件，比如说写入数据</p><ol><li>首先 GuestVM 用户程序调用驱动 write()，</li><li>驱动将数据写入到 virtqueue 里，hvc 通知 virtio 后端？</li><li>hypervisor 负责通知 Hostvm 处理 virtio 请求，中断注入到 Hostvm</li><li>HostVM 在收到 virtio 请求中断时，调度 EL0 的后端线程，在此之前后端线程已经打开了/dev 下的 virtio 设备，所以要做的就是判断 guestVM 此次是写哪个设备，做一下代理转换。</li><li>目的地（设备）决定好后，向 virtio device 写入数据即可。</li><li>写完之后，怎么通知 hypervisor，再最终通知到 guestVM？</li></ol><figure><img src=/virtio_host.jpg width=60%></figure><h2 id=进一步提升性能vhost>进一步提升性能：Vhost</h2><p>在 HostVM 作为后端的模式下，因为 virtio 后端原本是用户线程，在准备处理请求时还得先陷入到 HostVM Kernel 中，请求完毕还得返回 HostVM EL0.</p><p>Vhost 就是把后端放在 HostVM 的内核中，避免 HostVM 处理请求时多次的内核陷入。</p><p><a href=https://www.cnblogs.com/bakari/p/8341133.html>vhost：一种 virtio 高性能的后端驱动实现 - bakari - 博客园</a></p><h2 id=virtio-qemu-进一步提升性能vhe>Virtio QEMU 进一步提升性能：VHE</h2><p>VHE 适用于 QEMU KVM 吧。</p><p>启用 ARM VHE 特性，VM Kernel 运行在 EL2</p><h2 id=我是一个-vmm-开发者如何支持-virtio>我是一个 VMM 开发者，如何支持 Virtio</h2><h2 id=我是一个-linux-驱动开发者如何支持-virtio>我是一个 Linux 驱动开发者，如何支持 Virtio</h2></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2024-04-19T19:28:12, Lastmod: 2024-08-22T23:53:01</p></main></div></body></html>