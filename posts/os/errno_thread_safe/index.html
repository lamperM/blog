<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>操作系统：浅谈 errno 的线程安全问题</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%ad%a3%e6%96%87 aria-label=正文>正文</a></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>操作系统：浅谈 errno 的线程安全问题</div></header><p>我始终以为，C库中常用的 <code>errno</code> 仅是一个全局变量，使用了全局变量就无法保证线程安全了，因为全局变量在所有线程中都是共享的。</p><p>要实现线程安全的<code>errno</code> 就必须将其设置为<strong>线程私有的变量</strong>，下面就来看看GCC是如何巧妙的实现的。</p><h2 id=正文>正文</h2><p>现在的<code>errno</code>定义并非一个全局变量, 而是一个<strong>宏定义</strong>, 以下是在<code>usr/include/errno</code>中的声明:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#080;font-weight:700>extern</span> <span style=color:#888;font-weight:700>int</span> *<span style=color:#06b;font-weight:700>__errno_location</span> (<span style=color:#888;font-weight:700>void</span>);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#c00;font-weight:700># define errno (*__errno_location ())
</span></span></span></code></pre></div><p>这种方式下其实现原理大概是: <code>__errno_location</code> 函数返回一个<code>int</code>指针, 而这个函数的实现中, 返回的就恰好是<strong>实际的</strong><code>errno</code> 变量(与宏同名)的地址, 所以对其<strong>解引用</strong>就相当于对其值进行操作. 所以, 这种定义规则下, 左值和右值表达式均成立.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>errno = <span style=color:#00d;font-weight:700>10</span>;    <span style=color:#888>// *__errno_location () = 10
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#888></span><span style=color:#888;font-weight:700>int</span> x = errno; <span style=color:#888>// x = *__errno_location ();
</span></span></span></code></pre></div><p><code>__errno_location</code> 的实现就至关重要, 因为如果其返回的变量地址不包含任何技巧的话, 就和原先直接定义全局变量的方式没差了, <strong>说到底能否实现线程安全, 还得看实际保存errno的变量是否为线程独有的</strong>. 目前还没有发掘到其精髓, 只是套壳而已.</p><p>以下给出<code>/csu/errno-loc.c</code>中<code>__errno_location</code> 的实现, 与我们预期一致, 返回变量的地址. 而同名变量<code>errno</code>则定义在<code>/csu/errno.c</code>中, <strong>决定了能够实现errno的线程安全</strong>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#888;font-weight:700>int</span> *
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#06b;font-weight:700>__errno_location</span> (<span style=color:#888;font-weight:700>void</span>)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>  <span style=color:#080;font-weight:700>return</span> &amp;errno;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>__thread <span style=color:#888;font-weight:700>int</span> errno;
</span></span></code></pre></div><p>&ldquo;<code>__thread</code>&rdquo; 是GCC提供的扩展前缀, 表示该变量将被库处理为线程私有的, 注意这一步是C库完成的, 对程序员透明. 相关的理论叫 <em>Thread-local Storage</em>, AArch64 架构实现的原理是利用<code>TPIDR_EL0</code> 寄存器, 其他架构可以参考<a href=https://akkadia.org/drepper/tls.pdf>此PDF</a></p><blockquote><p>❓ 以上源文件中有注释为 <em>non-threaded</em>版本的实现, 是代表什么含义呢?</p></blockquote><p>​</p><p>虽然我暂时没有查阅到errno的其他线程安全的实现原理, 但起码GCC下该方式这是可行的. 依靠的是"<code>__thread</code>&ldquo;的支持, <strong>与换成宏定义的方式无关</strong>, 不排除可能为了考虑兼容其他实现方式的可能性.</p><h2 id=参考>参考</h2><p><a href=https://stackoverflow.com/questions/18025995/how-is-thread-safe-errno-initialized-if-define-substitutes-errno-symbol>c - How is thread-safe errno initialized if #define substitutes errno symbol? - Stack Overflow</a></p></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2022-12-21T19:08:22, Lastmod: 2023-09-24T18:08:59</p></main></div></body></html>