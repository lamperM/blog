<!doctype html><html><head><title>浅谈 errno 的线程安全问题</title><meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=description content><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><link rel=stylesheet href=/scss/journal.min.ea0f3d3af5cc437a42b1ad2f9b5ebeeaf367c8f8fc3004c55b78f4f503cea3a2.css integrity="sha256-6g89OvXMQ3pCsa0vm16+6vNnyPj8MATFW3j09QPOo6I=" media=screen><link rel=stylesheet href=/scss/dark-mode.min.2509d1ab7a8b17f2ca6b95285afc4f5ef50f8699b8114c954f01351654b5ceba.css integrity="sha256-JQnRq3qLF/LKa5UoWvxPXvUPhpm4EUyVTwE1FlS1zro=" media=screen><script src=/vendor/js/loadCSS.js></script>
<script>loadCSS("https://fonts.googleapis.com/css?family=Fira+Mono|Material+Icons")</script><script src=/js/toc.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script>
<script src=/vendor/js/md5.min.js></script>
<script>var gitalk=new Gitalk({clientID:"12dfb0f809e5e6afde3d",clientSecret:"72aaf5660b3a7b43b0bffb4d683a605a7ea65dad",repo:"blogcomments_gitalk",owner:"wangloo",admin:["wangloo"],id:md5(location.pathname),distractionFreeMode:"false"});window.onload=function(){gitalk.render("gitalk-container")}</script></head><body><div id=app><div id=sideContainer class=side-container><a class="a-block nav-head false" href=https://wangloo.github.io/><div class=nav-title>Wangloo's BLOG</div><div class=nav-subtitle>花有重开日, 人无再少年</div></a><div class=nav-link-list><a class="a-block nav-link-item active" href=/posts>Archive</a>
<a class="a-block nav-link-item false" href=/tags>Tags</a>
<a class="a-block nav-link-item false" href=/categories>Categories</a></div><div class=nav-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://risehere.net/>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
@2019 Notepadium.</div></div><div id=extraContainer class=extra-container><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc-content><center>- CATALOG -</center><ul><ul><li><a href=#%e6%ad%a3%e6%96%87 onclick="onNavClick(`#正文-nav`)" id=正文-nav>正文</a></li><li><a href=#%e5%8f%82%e8%80%83 onclick="onNavClick(`#参考-nav`)" id=参考-nav>参考</a></li></ul></div></div><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a>
<a type=button class=pagination-action id=darkModeToggleButton><span class="material-icons pagination-action-icon" id=darkModeToggleIcon>dark_mode</span></a></div></div><div class=single-column-drawer-container id=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item active" href=/posts>Archive</a>
<a class="a-block drawer-menu-item false" href=/tags>Tags</a>
<a class="a-block drawer-menu-item false" href=/categories>Categories</a><div class=toc><div class=toc-content><center>- CATALOG -</center><ul><ul><li><a href=#%e6%ad%a3%e6%96%87 onclick="onNavClick(`#正文-nav`)" id=正文-nav>正文</a></li><li><a href=#%e5%8f%82%e8%80%83 onclick="onNavClick(`#参考-nav`)" id=参考-nav>参考</a></li></ul></div></div></div></div></div><transition name=fade><div id=drawer-mask v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav id=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div id=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu</i></button>
<a id=navTitle class=navbar-brand href=https://wangloo.github.io/>Wangloo's BLOG</a>
<button type=button class=nav-darkmode-toggle id=darkModeToggleButton2>
<i class=material-icons id=darkModeToggleIcon2>dark_mode</i></button></div></nav><div class=single-column-header-container id=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=https://wangloo.github.io/><div class=single-column-header-title>Wangloo's BLOG</div><div class=single-column-header-subtitle>花有重开日, 人无再少年</div></a></div><div id=content><div id=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only><div class=post-title>浅谈 errno 的线程安全问题<div class=post-meta><time itemprop=datePublished>2022-12-21 19:08</time>
<i class=material-icons>label</i>
<a href=/tags/operating-system>Operating System</a>
&nbsp;
<i class=material-icons>schedule</i>
3 min
29 s.</div></div></div><div class=post-body-wrapper><div class=post-body v-pre><p>我始终以为，C库中常用的 <code>errno</code> 仅是一个全局变量，使用了全局变量就无法保证线程安全了，因为全局变量在所有线程中都是共享的。</p><p>要实现线程安全的<code>errno</code> 就必须将其设置为<strong>线程私有的变量</strong>，下面就来看看GCC是如何巧妙的实现的。</p><h2 id=正文>正文</h2><p>现在的<code>errno</code>定义并非一个全局变量, 而是一个<strong>宏定义</strong>, 以下是在<code>usr/include/errno</code>中的声明:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>extern</span> <span style=color:#8be9fd>int</span> <span style=color:#ff79c6>*</span><span style=color:#50fa7b>__errno_location</span> (<span style=color:#8be9fd>void</span>);
</span></span><span style=display:flex><span><span style=color:#ff79c6># define errno (*__errno_location ())
</span></span></span></code></pre></div><p>这种方式下其实现原理大概是: <code>__errno_location</code> 函数返回一个<code>int</code>指针, 而这个函数的实现中, 返回的就恰好是<strong>实际的</strong><code>errno</code> 变量(与宏同名)的地址, 所以对其<strong>解引用</strong>就相当于对其值进行操作. 所以, 这种定义规则下, 左值和右值表达式均成立.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>errno <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>10</span>;    <span style=color:#6272a4>// *__errno_location () = 10
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#8be9fd>int</span> x <span style=color:#ff79c6>=</span> errno; <span style=color:#6272a4>// x = *__errno_location ();
</span></span></span></code></pre></div><p><code>__errno_location</code> 的实现就至关重要, 因为如果其返回的变量地址不包含任何技巧的话, 就和原先直接定义全局变量的方式没差了, <strong>说到底能否实现线程安全, 还得看实际保存errno的变量是否为线程独有的</strong>. 目前还没有发掘到其精髓, 只是套壳而已.</p><p>以下给出<code>/csu/errno-loc.c</code>中<code>__errno_location</code> 的实现, 与我们预期一致, 返回变量的地址. 而同名变量<code>errno</code>则定义在<code>/csu/errno.c</code>中, <strong>决定了能够实现errno的线程安全</strong>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#ff79c6>*</span>
</span></span><span style=display:flex><span><span style=color:#50fa7b>__errno_location</span> (<span style=color:#8be9fd>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>&amp;</span>errno;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>__thread <span style=color:#8be9fd>int</span> errno;
</span></span></code></pre></div><p>&ldquo;<code>__thread</code>&rdquo; 是GCC提供的扩展前缀, 表示该变量将被库处理为线程私有的, 注意这一步是C库完成的, 对程序员透明. 相关的理论叫 <em>Thread-local Storage</em>, AArch64 架构实现的原理是利用<code>TPIDR_EL0</code> 寄存器, 其他架构可以参考<a href=https://akkadia.org/drepper/tls.pdf>此PDF</a></p><blockquote><p>❓ 以上源文件中有注释为 <em>non-threaded</em>版本的实现, 是代表什么含义呢?</p></blockquote><p>​</p><p>虽然我暂时没有查阅到errno的其他线程安全的实现原理, 但起码GCC下该方式这是可行的. 依靠的是"<code>__thread</code>&ldquo;的支持, <strong>与换成宏定义的方式无关</strong>, 不排除可能为了考虑兼容其他实现方式的可能性.</p><h2 id=参考>参考</h2><p><a href=https://stackoverflow.com/questions/18025995/how-is-thread-safe-errno-initialized-if-define-substitutes-errno-symbol>c - How is thread-safe errno initialized if #define substitutes errno symbol? - Stack Overflow</a></p><hr width=100% id=EOF><p style=color:#777>Last modified on 2023-02-27</p></div></div><nav class=post-pagination><a class=newer-posts href=/posts/c/end-of-line/>Next<br>行结束符在windows和linux的区别</a>
<a class=older-posts href=/posts/tools/git/git/>Previous<br>git 宝典</a></nav><div class=post-comment-wrapper><div id=gitalk-container></div></div></div></div></div></div><div id=single-column-footer>Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://risehere.net/>Rise</a><br>Ported from <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
@2019 Notepadium.</div></div><script src=/js/journal.js></script></body></html>