<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/syntax_pastie.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>ATF 解读：中断</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#gic-%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label="GIC 初始化">GIC 初始化</a></li><li><a href=#smc-calling-convention-smccc aria-label="SMC Calling Convention (SMCCC)">SMC Calling Convention (SMCCC)</a></li><li><a href=#ehf aria-label=EHF>EHF</a></li><li><a href=#sdei aria-label=SDEI>SDEI</a><ul><li><a href=#sdei-%e5%92%8c-ehf-%e7%9a%84%e5%85%b3%e7%b3%bb aria-label="SDEI 和 EHF 的关系">SDEI 和 EHF 的关系</a></li><li><a href=#sdei-%e7%9a%84%e5%ba%94%e7%94%a8 aria-label="SDEI 的应用">SDEI 的应用</a><ul><li><a href=#hypervisor aria-label=Hypervisor>Hypervisor</a></li><li><a href=#nmi aria-label=NMI>NMI</a></li></ul></li></ul></li><li><a href=#%e8%bf%90%e8%a1%8c%e6%97%b6%e6%9c%8d%e5%8a%a1 aria-label=运行时服务>运行时服务</a><ul><li><a href=#power-state-coordination-interface-psci aria-label="Power State Coordination Interface (PSCI)">Power State Coordination Interface (PSCI)</a></li><li><a href=#software-delegated-exceptions-interface-sdei aria-label="Software Delegated Exceptions Interface (SDEI)">Software Delegated Exceptions Interface (SDEI)</a></li></ul></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>ATF 解读：中断</div></header><p>BL31 位于 EL3 安全世界， 提供运行时服务，并不像 BL1 和 BL2 一样 boot 后就释放空间，其他的子系统通过 SMC 调用向 BL31 发送请求，包括安全世界的切换。</p><p>BL31 不是必须得，如果实际没有实现 EL3，或者不需要 Secure Monitor，则可以不用 BL31.</p><h2 id=gic-初始化>GIC 初始化</h2><p>默认配置 GIC，其中 GIC 有一些配置在 secure state 才能配置，所以在这里配一下。</p><p>BL31 中，每个 platform 都有一个分配中断分组的全局变量<code>qemu_interrupt_props</code>（以 QEMU 为例），在 BL31 中可以将一些中断划分为 G1S 或 G0。当然，我猜测 BL32 也可以重设，毕竟 BL32 也要设定一些特殊中断，比如说安全 uart。</p><h2 id=smc-calling-convention-smccc>SMC Calling Convention (SMCCC)</h2><p>在非安全状态和低于EL3运行的软件要请求EL3的服务，使用smc调用。这些请求需要遵循的是SMCCC，它为每个SMC请求分配函数标识符，并描述了如何传递和返回参数。</p><h2 id=ehf>EHF</h2><p>配置完 GIC 后，紧接着就是可选的 EHF 功能。</p><p>GICv3将中断分为三种类型：Group0，secure Group1，non-secure Group1。EHF 就是支持Group0中断的，Group0总是以FIQ的形式触发。开启EHF的情况下需要通过SCR_EL3的配置来使得FIQ路由到EL3。在应用中，我们会将一些需要陷入EL3的中断配置成Group0，同时开启ATF，就能完成这种场景所需的功能。</p><p>关于中断，我们的目标肯定是配置某些中断在某个服务中处理，可能是Linux内核、Hypervisor、TEEOS、EL3。这个功能的输入是每个中断，也就是INTID，目的就是让每个中断路由到特定的运行时。在GICv3中，实现这个过程需要两步：</p><ol><li>配置INTID到某个中断分组，Group0、Secure Group1，Non-secure Group1</li><li>每个中断分组运行在特定的安全状态下触发的中断类型是确定的，也是不用的。参考这个表格。所以说，需要通过SCR_ELx寄存器来设置FIQ和IRQ的路由到哪个EL。</li></ol><p>因为设置中断路由目标的单位是【中断组】，所以需要做以上两种设置。</p><p>默认 ATF 中关中断，这个我们可以想想，EL31 负责安全世界的切换，有点像处于异常处理上下文中，也没有什么中断需要触发，所以关中断也是合理的。</p><p>EHF 通过编译选项 <code>EL3_EXCEPTION_HANDLING</code> 控制开关，EHF 的功能就是让 EL3 能处理其他中断（除了原本的 SMC），原本的情况是直接返回，让上面的 EL 处理。开启 EHF 后，其他的应用可以注册一些中断处理函数到 EL3，并设置 <code>SCR_EL3.IRQ/FIQ</code>，置 1 之后，IRQ/FIQ 会被路由到 EL3，调用之前注册好的 handler。</p><p>EHF 的全称是 Exception Handling Framework，既然是 Framework，一个框架，就是提供注册的接口。
其他的子模块填充一个 <code>intr_type_descs</code> 成员，它是一个数组</p><ul><li>下标 type 代表想要运行在哪个状态的中断 Trap 到 EL3？是 SEL1？EL3？还是 Non-secure</li><li>我们知道，每种 type 下，都有三种类型的中断（G0、G1S、G1NS），有时我们只想让 EL3 handle 其一，或者都。</li><li>EHF 提供的粒度是 IRQ 和 FIQ。知道当前运行的 type，和你想要 trap EL3 的中断分组，就能唯一得到中断是 IRQ/FIQ。</li><li>所以你可以单独设计这个 IRQ/FIQ 是否 Trap，来达到你想要只 trap 一种分组的目的。当然这不是一一对应的，IRQ 可能对应多个中断分组，这是没办法的事情。只能人为做更加严格的中断分组。</li><li>配置完成后，框架会将 IRQ 和 FIQ 置位的情况（成员 <code>scr_el3[2]</code>) 汇总，存到上下文中，返回时到该 type 时恢复。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>intr_type_desc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>interrupt_type_handler_t</span> <span class=n>handler</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>u_register_t</span> <span class=n>scr_el3</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>  <span class=c1>// 2 =&gt; 两种安全状态下的scr_el3
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>flags</span><span class=p>;</span> <span class=c1>// bit[0]: routing model for interrupt from not EL3 but secure state
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=c1>// bit[1]: routing modul for interrupt from not EL3 but non-secure state
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=c1>// &#39;1&#39; =&gt; this interrupt will be routed to EL3
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=c1>// &#39;0&#39; =&gt; this interrupt will be routed to current EL
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>intr_type_desc_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define INTR_TYPE_S_EL1			U(0)
</span></span></span><span class=line><span class=cl><span class=cp>#define INTR_TYPE_EL3			U(1)
</span></span></span><span class=line><span class=cl><span class=cp>#define INTR_TYPE_NS			U(2)
</span></span></span><span class=line><span class=cl><span class=cp>#define MAX_INTR_TYPES			U(3)
</span></span></span><span class=line><span class=cl><span class=cp>#define INTR_TYPE_INVAL			MAX_INTR_TYPES
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>intr_type_desc_t</span> <span class=n>intr_type_descs</span><span class=p>[</span><span class=n>MAX_INTR_TYPES</span><span class=p>];</span>
</span></span></code></pre></div><p>ATF 中中断的注册(这三种类型的 handler 程序的注册)，以 INTR_TYPE_S_EL1 为例：</p><p>在开机 bl32_main 调用 opteed_setup()时，将 opteed_sel1_interrupt_handler()函数注册成了 INTR_TYPE_S_EL1 类型中断，同时也会将 REE(Linux)使用的 SCR_EL3.FIQ 配置成 1,也意味着当 CPU 运行在 REE 时，来了一个 secure group1 的中断，此中断在 REE 中被标记 FIQ 后将被 target 到 EL3，进入 EL3(ATF)的中断处理函数，也就是刚才注册的 opteed_sel1_interrupt_handler()函数，在该函数中，会将 cpu 切换到 TEE 中，去处理这个中断。这就是 REE 切换到 TEE 的一种方式。</p><figure><img src=/interrupt_grp.jpg width=70%></figure><p>由此我们再看 EHF 的实现原理。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>    The ``flags`` field stores the routing model for the interrupt type in
</span></span></span><span class=line><span class=cl><span class=cm>    bits[1:0]. Bit[0] stores the routing model when execution is in the secure
</span></span></span><span class=line><span class=cl><span class=cm>    state. Bit[1] stores the routing model when execution is in the non-secure
</span></span></span><span class=line><span class=cl><span class=cm>    state. As mentioned in Section `Routing model`_, a value of ``0`` implies that
</span></span></span><span class=line><span class=cl><span class=cm>    the interrupt should be targeted to the FEL. A value of ``1`` implies that it
</span></span></span><span class=line><span class=cl><span class=cm>    should be targeted to EL3. The remaining bits are reserved and SBZ. The helper
</span></span></span><span class=line><span class=cl><span class=cm>    macro ``set_interrupt_rm_flag()`` should be used to set the bits in the
</span></span></span><span class=line><span class=cl><span class=cm>    ``flags`` parameter.
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=c1>// EL3 不是要处理中断吗，当SCR_EL3.IRQ/FIQ打开时，会进入EL3的异常处理函数，
</span></span></span><span class=line><span class=cl><span class=c1>// ehf_init()做的就是初始化好这个框架，使得EL3在接收到FIQ、IRQ后不会直接返回，
</span></span></span><span class=line><span class=cl><span class=c1>// 为其注册了一个大的 handler，在里面根据情况调用其他type的处理函数。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ehf_init</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>=&gt;</span> <span class=n>set_interrupt_rm_flag</span><span class=p>(</span><span class=n>flags</span><span class=p>,</span> <span class=n>NON_SECURE</span><span class=p>);</span>  <span class=c1>// flag | (1 &lt;&lt; 1)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>=&gt;</span> <span class=k>if</span> <span class=n>SPMC</span> <span class=n>is</span> <span class=n>not</span> <span class=n>present</span> <span class=n>in</span> <span class=n>S</span><span class=o>-</span><span class=n>EL2</span>
</span></span><span class=line><span class=cl>        <span class=o>=&gt;</span> <span class=n>set_interrupt_rm_flag</span><span class=p>(</span><span class=n>flags</span><span class=p>,</span> <span class=n>SECURE</span><span class=p>);</span> <span class=c1>// flag | (1 &lt;&lt; 0)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>=&gt;</span> <span class=n>register_interrupt_type_handler</span><span class=p>(</span><span class=n>type</span><span class=o>=</span><span class=n>INTR_TYPE_EL3</span><span class=p>,,</span><span class=n>flags</span><span class=o>=</span><span class=n>flags</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>register_interrupt_type_handler</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>=&gt;</span> <span class=n>set_routing_model</span><span class=p>(</span><span class=n>INTR_TYPE_EL3</span><span class=p>,</span> <span class=n>flags</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>set_routing_model</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>=&gt;</span> <span class=n>intr_type_descs</span><span class=p>[</span><span class=n>INTR_TYPE_EL3</span><span class=p>].</span><span class=n>flags</span> <span class=o>=</span> <span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 两次调用分别将FIQ和IRQ的情况汇总到最终上下文中的SCR寄存器
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>=&gt;</span> <span class=n>set_scr_el3_from_rm</span><span class=p>(</span><span class=n>type</span><span class=o>=</span><span class=n>INTR_TYPE_EL3</span><span class=p>,</span> <span class=n>flags</span><span class=p>,</span> <span class=n>SECURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>=&gt;</span> <span class=n>set_scr_el3_from_rm</span><span class=p>(</span><span class=n>type</span><span class=o>=</span><span class=n>INTR_TYPE_EL3</span><span class=p>,</span> <span class=n>flags</span><span class=p>,</span> <span class=n>NON_SECURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>set_scr_el3_from_rm</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 看传入secure state在flag中对应的bit是1还是0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>=&gt;</span> <span class=n>flag</span> <span class=o>=</span> <span class=n>get_interrupt_rm_flag</span><span class=p>(</span><span class=n>flags</span><span class=p>,</span> <span class=n>security_state</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 计算SCR_ELx中对应secure state（FIQ/IRQ）的控制 bit
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>=&gt;</span> <span class=n>bit_ops</span> <span class=o>=</span> <span class=n>plat_interrupt_type_to_line</span><span class=p>(</span><span class=n>INTR_TYPE_EL3</span><span class=p>,</span> <span class=n>security_state</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>=&gt;</span> <span class=n>intr_type_descs</span><span class=p>[</span><span class=n>type</span><span class=p>].</span><span class=n>scr_el3</span><span class=p>[</span><span class=n>security_state</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>u_register_t</span><span class=p>)</span><span class=n>flag</span> <span class=o>&lt;&lt;</span> <span class=n>bit_pos</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * Update scr_el3 only if there is a context available. If not, it
</span></span></span><span class=line><span class=cl><span class=cm>     * will be updated later during context initialization which will obtain
</span></span></span><span class=line><span class=cl><span class=cm>     * the scr_el3 value to be used via get_scr_el3_from_routing_model()
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=o>=&gt;</span>  <span class=n>cm_write_scr_el3_bit</span><span class=p>(</span><span class=n>security_state</span><span class=p>,</span> <span class=n>bit_pos</span><span class=p>,</span> <span class=n>flag</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*******************************************************************************
</span></span></span><span class=line><span class=cl><span class=cm> * This function updates a single bit in the SCR_EL3 member of the &#39;cpu_context&#39;
</span></span></span><span class=line><span class=cl><span class=cm> * pertaining to the given security state using the value and bit position
</span></span></span><span class=line><span class=cl><span class=cm> * specified in the parameters. It preserves all other bits.
</span></span></span><span class=line><span class=cl><span class=cm> ******************************************************************************/</span>
</span></span><span class=line><span class=cl> <span class=n>cm_write_scr_el3_bit</span><span class=p>()</span>
</span></span><span class=line><span class=cl>     <span class=o>=&gt;</span> <span class=n>ctx</span> <span class=o>=</span> <span class=n>cm_get_context</span><span class=p>(</span><span class=n>security_state</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>scr_el3</span> <span class=o>=</span> <span class=n>read_ctx_reg</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>CTX_SCR_EL3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>scr_el3</span> <span class=o>&amp;=</span> <span class=o>~</span><span class=p>(</span><span class=mi>1UL</span> <span class=o>&lt;&lt;</span> <span class=n>bit_pos</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>scr_el3</span> <span class=o>|=</span> <span class=p>(</span><span class=n>u_register_t</span><span class=p>)</span><span class=n>value</span> <span class=o>&lt;&lt;</span> <span class=n>bit_pos</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>write_ctx_reg</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>CTX_SCR_EL3</span><span class=p>,</span> <span class=n>scr_el3</span><span class=p>);</span>
</span></span></code></pre></div><h2 id=sdei>SDEI</h2><p>SDEI: Software Delegated Exception Interface，软件委派异常接口。</p><p>其实就是在 EL1(或 EL2)能够注册 SDEI 中断，其实就是切换到 EL3 中将该中断注册成 group0 中断，然后当事件到来时，中断将直接 target 到 EL3，在 EL3 的处理程序中会 dispatcher 到 EL1(EL2)中再处理。</p><figure><img src=/bl31_sdei.jpg width=80%></figure><figure><img src=/bl31_sdei2.png width=60%></figure><p>用图来表示就是上述的过程，大概分为以下几步：</p><ol><li>Linux/hyperv 注册一个中断为 SDEI 中断，调用 SDEI API</li><li>SDEI API 准备好参数，调用 smc 指令陷入 EL3，EL3 将这个中断号配置为<strong>Group0</strong>分组，并设置好 SCR_EL3.IRQ/FIQ</li><li>当运行在 EL1/2 时，来了一个注册为 SDEI 的中断，因为是 Group0 且 SCR_EL3.FIQ 被置位，所以直接路由到 EL3 处理。</li><li>EL3 fiq handler 识别到这是一个注册为 SDEI 的中断，则返回上层注册的 hangler 去执行，处理完后再返回。</li></ol><h3 id=sdei-和-ehf-的关系>SDEI 和 EHF 的关系</h3><p>结论：SDEI 依赖 EHF。</p><p>没有开 EHF 的情况下，BL31 是不处理 FIQ、IRQ 的，没有 dispatch 的行为。</p><p>当某个Group0的中断触发FIQ，进入EL3，对SDEI来说，也可以当作是一个event signal动作。所以说，这个中断可以在EL3直接处理，也可以作为SDEI的事件触发源，SDEI会进行dispatch行为，委托注册的handler进行处理。</p><h3 id=sdei-的应用>SDEI 的应用</h3><h4 id=hypervisor>Hypervisor</h4><p>引入 Hypervisor 后，如果开启了中断直通，那么 hostVM 就不能控制 guestVM 了，这里的”控制“的含义是将其拉到 EL2 hypervisor。为什么呢？</p><ul><li>因为没有中断直通的情况下，hostVM 发送 IPI 给 guestVM，Hypervisor 会拦截 IPI，识别到这是一个控制 guestVM 的行为，就会停在 Hypervisor 完成相应的服务。</li><li>但是，如果开启了中断直通，这个 IPI 不会被 Hypervisor 拦截，而是直接到了 GuestVM 里，GuestVM 并不一定会选择陷入 Hypervisor，这取决于 guestVM 的实现，所以说不能保证。</li></ul><p>此时可以通过把某个 IPI 注册为 SDEI 中断，使得发送 IPI 首先被 EL3 拦截，通过注册 Hypervisor 对应的处理函数，就使得 guestVM 一定进入 EL2。</p><h4 id=nmi>NMI</h4><p>NMI 的含义是不可屏蔽中断，如果某个中断我们想让其快速触发，通过注册为 SDEI 中断，即便是在 EL1/2 是屏蔽中断的环境下，这个中断也能直接到达 EL3，dispatch 到 EL1/2 完成处理，不受中断屏蔽上下文的影响。</p><h2 id=运行时服务>运行时服务</h2><h3 id=power-state-coordination-interface-psci>Power State Coordination Interface (PSCI)</h3><h3 id=software-delegated-exceptions-interface-sdei>Software Delegated Exceptions Interface (SDEI)</h3></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2024-07-22T19:28:12, Lastmod: 2025-01-09T23:30:54</p><script src=/js/copy-to-clipboard.js></script></main></div></body></html>