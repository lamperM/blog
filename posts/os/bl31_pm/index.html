<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/syntax_pastie.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>ATF 解读：电源管理</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#psci aria-label=PSCI>PSCI</a><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e6%9c%89-psci-%e5%8d%8f%e8%ae%ae aria-label="为什么要有 PSCI 协议？">为什么要有 PSCI 协议？</a></li></ul></li><li><a href=#scp aria-label=SCP>SCP</a></li><li><a href=#scmi aria-label=SCMI>SCMI</a></li><li><a href=#%e7%83%ad%e6%8f%92%e6%8b%94-hotplug aria-label="热插拔 Hotplug">热插拔 Hotplug</a><ul><li><a href=#cpu-down aria-label="CPU Down">CPU Down</a><ul><li><a href=#linux-%e4%be%a7%e8%a1%8c%e4%b8%ba aria-label="Linux 侧行为">Linux 侧行为</a></li><li><a href=#bl31-%e4%be%a7%e8%a1%8c%e4%b8%ba aria-label="BL31 侧行为">BL31 侧行为</a></li></ul></li><li><a href=#cpu-up aria-label="CPU UP">CPU UP</a></li></ul></li><li><a href=#%e7%b3%bb%e7%bb%9f%e4%bc%91%e7%9c%a0%e5%94%a4%e9%86%92 aria-label=系统休眠唤醒>系统休眠唤醒</a></li><li><a href=#%e5%85%b3%e6%9c%ba%e9%87%8d%e5%90%af aria-label=关机重启>关机重启</a></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>ATF 解读：电源管理</div></header><h2 id=psci>PSCI</h2><p>PSCI, Power State Coordination Interface，由 ARM 定义的电源管理接口规范。
目前 PSCI 最新规格为 v1.1，《POWER STATE COORDINATION INTERFACE (PSCI) System Software on ARM® Systems》。</p><h3 id=为什么要有-psci-协议>为什么要有 PSCI 协议？</h3><p>以前，ARM 中设备的电源管理由 OS 内核负责，随着多 OS、虚拟化技术的发展，电源管理需要有一个单独统一的组件去完成。ARMv8 引入 PSCI 协议，OS 内核里的所有电源管理行为通过 <code>smc/hvc</code> 下陷到 hypervisor/EL3 完成，通常在 EL3。ATF 里那就是 BL31 去做这件事。</p><p>PSCI 规定了 OS 内核发送 smc 指令的标准电源管理请求格式，BL31 会按照这个格式去实现具体的方案。所以，只要 OS 是遵循 PSCI 协议的，就能使得 OS 和 BL31 解绑，通用性更好。</p><h2 id=scp>SCP</h2><p>BL31 接收到 PSCI SMC 消息，然后呢？这一块又是解耦的设计，电源管理具体是要一个单独的硬件控制器去做，BL31 的任务就是将 PSCI SMC 请求转化为具体电源控制器的控制指令。</p><p>SCP, System Control Processor，是一个控制电源的硬件，里面运行的固件叫 SCP Firmware。BL31 需要想办法和 SCP 通信。</p><h2 id=scmi>SCMI</h2><p>SCMI（System Control and Management Interface），是 BL31 和 SCP 的通信接口。当然，有了 SCMI 标准接口，SOC 中的其他 IP 也可以通过 SCMI 接口与 SCP 通信控制电源。</p><h2 id=热插拔-hotplug>热插拔 Hotplug</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>echo</span> <span class=mi>0</span> <span class=o>&gt;</span> <span class=o>/</span><span class=n>sys</span><span class=o>/</span><span class=n>devices</span><span class=o>/</span><span class=n>system</span><span class=o>/</span><span class=n>cpu</span><span class=o>/</span><span class=n>cpu1</span><span class=o>/</span><span class=n>online</span> <span class=c1>//拔核操作
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>echo</span> <span class=mi>1</span> <span class=o>&gt;</span> <span class=o>/</span><span class=n>sys</span><span class=o>/</span><span class=n>devices</span><span class=o>/</span><span class=n>system</span><span class=o>/</span><span class=n>cpu</span><span class=o>/</span><span class=n>cpu1</span><span class=o>/</span><span class=n>online</span> <span class=c1>//插核操作
</span></span></span></code></pre></div><p>CPU 热插拔是在不关闭系统电源的情况下，根据需求动态“关闭”任意 non-boot CPU，可避免因为 CPU 空转造成的能源浪费。</p><ul><li>AP：将要被拔掉的 cpu。</li><li>BP：处理拔核流程的 cpu。</li></ul><h3 id=cpu-down>CPU Down</h3><h4 id=linux-侧行为>Linux 侧行为</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 如果config中启用了hotplug功能，则定义回调函数 cpu_subsys_online/cpu_subsys_offline
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>bus_type</span> <span class=n>cpu_subsys</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;cpu&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>dev_name</span> <span class=o>=</span> <span class=s>&#34;cpu&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>match</span> <span class=o>=</span> <span class=n>cpu_subsys_match</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef CONFIG_HOTPLUG_CPU
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=p>.</span><span class=n>online</span> <span class=o>=</span> <span class=n>cpu_subsys_online</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>offline</span> <span class=o>=</span> <span class=n>cpu_subsys_offline</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 如果config中启用了hotplug功能
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=k>struct</span> <span class=n>cpu_operations</span> <span class=n>cpu_psci_ops</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>name</span>		<span class=o>=</span> <span class=s>&#34;psci&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>cpu_init</span>	<span class=o>=</span> <span class=n>cpu_psci_cpu_init</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>cpu_prepare</span>	<span class=o>=</span> <span class=n>cpu_psci_cpu_prepare</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>cpu_boot</span>	<span class=o>=</span> <span class=n>cpu_psci_cpu_boot</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef CONFIG_HOTPLUG_CPU
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=p>.</span><span class=n>cpu_can_disable</span> <span class=o>=</span> <span class=n>cpu_psci_cpu_can_disable</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>cpu_disable</span>	<span class=o>=</span> <span class=n>cpu_psci_cpu_disable</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>cpu_die</span>	<span class=o>=</span> <span class=n>cpu_psci_cpu_die</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>.</span><span class=n>cpu_kill</span>	<span class=o>=</span> <span class=n>cpu_psci_cpu_kill</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>cpu_subsys_offline</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>=&gt;</span> <span class=n>cpu_down</span><span class=p>(</span><span class=n>cpu</span> <span class=o>=</span> <span class=n>dev</span><span class=o>-&gt;</span><span class=n>id</span><span class=p>,</span> <span class=n>CPUHP_OFFLINE</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>cpu_down</span><span class=p>(</span><span class=n>cpu</span><span class=p>,</span> <span class=n>target</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>=&gt;</span> <span class=n>cpuhp_kick_ap_work</span><span class=p>(</span><span class=n>cpu</span><span class=p>)</span> <span class=c1>// 使AP放弃手头工作，进入CPUHP_TEARDOWN_CPU状态
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>=&gt;</span>  <span class=n>wake_up_process</span><span class=p>(</span><span class=n>ap</span><span class=o>-&gt;</span><span class=kr>thread</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	    <span class=o>=&gt;</span>  <span class=n>wait_for_ap_thread</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=o>=&gt;</span> <span class=n>cpuhp_down_callbacks</span><span class=p>()</span> <span class=c1>// 进一步 clean AP
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>=&gt;</span>  <span class=n>takedown_cpu</span><span class=p>(</span><span class=n>cpu</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>takedown_cpu</span><span class=p>(</span><span class=n>cpu</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>=&gt;</span> <span class=n>stop_cpus</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=o>=&gt;</span> <span class=n>queue_stop_cpus_work</span><span class=p>()</span> <span class=c1>// !! 将die自己的线程加入AP的运行队列，
</span></span></span><span class=line><span class=cl><span class=c1></span>                                  <span class=c1>// 等待AP自己die，而不是BP完全帮他
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>=&gt;</span> <span class=n>__cpu_die</span><span class=p>()</span> <span class=c1>// 见下
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// ====== 切换到 AP 的执行视角
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>take_cpu_down</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>=&gt;</span> <span class=n>__cpu_disable</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 设置CPU状态为OFFLINE，一旦如此，IDLE线程里就会 call idle_dead()
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>=&gt;</span> <span class=n>set_cpu_online</span><span class=p>(</span><span class=n>cpu</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=o>=&gt;</span> <span class=n>irq_migrate_all_off_this_cpu</span><span class=p>()</span><span class=c1>// 中断迁移
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>=&gt;</span> <span class=c1>// 任务迁移
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>idle_dead</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1>// PSCI 接口，切换到BL31执行实际电源管理。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>=&gt;</span> <span class=n>cpu_die</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ====== 返回 BP 的执行视角
</span></span></span><span class=line><span class=cl><span class=c1>// 等待 BP 完成自己的die
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>=&gt;</span> <span class=n>__cpu_die</span><span class=p>(</span><span class=n>cpu</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>=&gt;</span> <span class=n>cpu_wait_death</span><span class=p>(</span><span class=n>cpu</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>=&gt;</span> <span class=n>op_cpu_kill</span><span class=p>(</span><span class=n>cpu</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>=&gt;</span> <span class=n>cpu_kill</span><span class=p>(</span><span class=n>cpu</span><span class=p>)</span> <span class=c1>// cpu_psci_cpu_kill()
</span></span></span></code></pre></div><p>总结来看：</p><ol><li>用户输入<code>echo 0 > /sys/devices/system/cpu/cpu1/online</code></li><li>唤醒 AP per_cpu 线程，完成手头的工作</li><li>设置 AP cpu 的状态为 OFFLINE，AP 的 idle 线程会自己调用 psci 接口 die</li><li>做 AP 上的任务迁移和中断迁移</li><li>BP 会等到 AP 自杀完成</li></ol><h4 id=bl31-侧行为>BL31 侧行为</h4><h3 id=cpu-up>CPU UP</h3><p>唤醒后执行哪里的代码？是 warm boot 还是 cold boot？</p><h2 id=系统休眠唤醒>系统休眠唤醒</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>echo</span> <span class=n>mem</span> <span class=o>&gt;</span> <span class=o>/</span><span class=n>sys</span><span class=o>/</span><span class=n>power</span><span class=o>/</span><span class=n>state</span>
</span></span></code></pre></div><h2 id=关机重启>关机重启</h2></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2024-08-02T19:28:12, Lastmod: 2024-08-22T23:53:01</p><script src=/js/copy-to-clipboard.js></script></main></div></body></html>