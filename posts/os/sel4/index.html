<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/syntax_pastie.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>Êìç‰ΩúÁ≥ªÁªüÔºöSeL4 Âü∫Á°ÄÊ¶ÇÂøµ</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>ÊúÄËøë‰øÆÊîπ</a></div><div class="a-block nav-link-item"><a href=/categories>ÂàÜÁ±ª Categories</a></div><div class="a-block nav-link-item"><a href=/tags>Ê†áÁ≠æ Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#sel4-capabilities aria-label="seL4 Capabilities">seL4 Capabilities</a><ul><li><a href=#capability-derivation aria-label="Capability Derivation">Capability Derivation</a><ul><li><a href=#mint-operation aria-label="MINT OPERATION">MINT OPERATION</a></li><li><a href=#copy-operation aria-label="COPY OPERATION">COPY OPERATION</a></li></ul></li></ul></li><li><a href=#sel4-kernel-objects aria-label="seL4 Kernel Objects">seL4 Kernel Objects</a></li><li><a href=#sel4-system-calls aria-label="seL4 System Calls">seL4 System Calls</a><ul><li><a href=#different-object-support-different-operations aria-label="Different object support different operations">Different object support different operations</a><ul><li><a href=#endpoints aria-label=ENDPOINTS>ENDPOINTS</a></li><li><a href=#notifications aria-label=NOTIFICATIONS>NOTIFICATIONS</a></li><li><a href=#other-objects aria-label="OTHER OBJECTS">OTHER OBJECTS</a></li></ul></li></ul></li><li><a href=#sel4-ipc aria-label="seL4 IPC">seL4 IPC</a></li><li><a href=#sel4-threads aria-label="seL4 Threads">seL4 Threads</a><ul><li><a href=#creating-a-thread aria-label="Creating a thread">Creating a thread</a></li><li><a href=#threads-and-stacks aria-label="Threads and Stacks">Threads and Stacks</a></li></ul></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>Êìç‰ΩúÁ≥ªÁªüÔºöSeL4 Âü∫Á°ÄÊ¶ÇÂøµ</div></header><h2 id=sel4-capabilities>seL4 Capabilities</h2><p>In seL4, capabilities are stored in <strong>C-space</strong>. C-space is a hierarchical data structure very similar to <strong>page table</strong>.</p><ul><li>page table is a mapping from virtual address to physical address.</li><li>C-space is a mapping from <strong>object ID</strong> to <strong>capability</strong>.</li><li>Kernel object is made up of several <strong>C-nodes</strong>, just like a page table made up of individual page tables.</li><li>Each C-nodes is an array of cap <em>slots</em>, which contain capability.</li></ul><p>Inaccessible to userland, you can never hold an <strong>actual capability</strong></p><ul><li>You can only hold a reference to capability, which pointers into C-space(slot addresses)</li><li>These C-space addresses are called <strong>CPTRs</strong></li></ul><blockquote><p>You don&rsquo;t need to do the transform, because this is typically extracted in some libs.</p></blockquote><p>Capabilities convey specific privilege (acces rights)</p><ul><li>Read, Write, Execute, GrantReply(<code>call</code>), Grant(<code>cap transfer</code>)</li></ul><p>Main operations on capabilities:</p><ul><li><code>Invoke</code>perform operation on object referred to by cap.<ul><li>For example, map some frame into memory. You need to have capabilities to both the frame and address space.</li></ul></li><li><code>Copy</code>|<code>Mint</code>|<code>Grant</code>: create copy of cap with <strong>same/lesser</strong> privilege.</li><li><code>Move</code>|<code>Mutate</code>: transfer to different address with <strong>same/lesser</strong> privilege.<ul><li>Between C-space or within C-space.</li></ul></li><li><code>Delete</code>: invalidate slot(cleans up object if this is the only cap to it)</li><li><code>Revoke</code>: delete any derived(eg. copied or minted) caps</li></ul><h3 id=capability-derivation>Capability Derivation</h3><h4 id=mint-operation>MINT OPERATION</h4><p>The <strong>Mint</strong> operation creates a new, less powerful cap</p><ul><li>Can add badge</li><li>Can strip access rights, eg <code>RW->RO</code></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>mint</span><span class=p>(</span><span class=n>dest</span><span class=p>,</span> <span class=n>src</span><span class=p>,</span> <span class=n>rights</span><span class=p>,</span> <span class=n>badge</span><span class=p>)</span>
</span></span></code></pre></div><ul><li>The first two arguement are <strong>capability pointers(CPTR)</strong> to a C-space(represented by C-node), which are references inside C-node.</li><li>The <strong>destination C-node cap</strong> must allow modification</li><li>Then you have the rights and the <em>batch</em> of the new cap.</li></ul><p>üìå This is an alternative of sending addressed capabilities by <strong>IPC operation</strong>.
That is what operating system do to set up protection domains for <strong>user level process</strong>.</p><h4 id=copy-operation>COPY OPERATION</h4><blockquote><p>Copy as a version of <em>Mint</em>.</p></blockquote><p>¬†</p><h2 id=sel4-kernel-objects>seL4 Kernel Objects</h2><p>In file <code>libsel4\include\sel4\objecttype.h</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>enum</span> <span class=n>api_object</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>seL4_UntypedObject</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>seL4_TCBObject</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>seL4_EndpointObject</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>seL4_NotificationObject</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>seL4_CapTableObject</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef CONFIG_KERNEL_MCS
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=n>seL4_SchedContextObject</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>seL4_ReplyObject</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=n>seL4_NonArchObjectTypeCount</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>seL4_ObjectType</span><span class=p>;</span>
</span></span></code></pre></div><p>¬†</p><h2 id=sel4-system-calls>seL4 System Calls</h2><p>seL4 has <code>11</code> syscalls:</p><p><code>Yield()</code>: invokes scheduler</p><ul><li>does NOT require a capability!</li></ul><p><code>Send()</code>,<code>Recv()</code> and variants/combinations thereof: IPC operations</p><ul><li><code>Call()</code>,<code>ReplyRecv()</code>: usually invokes by client/server</li><li><code>Send()</code>, <code>NBSend()</code>: send-only and non-blocking version of it.</li><li><code>Recv()</code>, <code>NBRecv()</code>, <code>NBSendRecv()</code></li><li><code>Wait()</code>, <code>NBWait()</code>, <code>NBSendWait()</code></li></ul><blockquote><p>We just use <code>Call()</code> normally, the others are only for bootstrapping protocols and exception handling.</p></blockquote><p>Call() is atomic Send() + reply-object setup + Wait()</p><ul><li>cannot be simulated with one-way operations!</li></ul><p>ReplyRecv() is NBSend() + Recv()</p><h3 id=different-object-support-different-operations>Different object support different operations</h3><h4 id=endpoints>ENDPOINTS</h4><p>Endpoints support all 10 IPC variants.</p><h4 id=notifications>NOTIFICATIONS</h4><p>Notifications support:</p><ul><li>NBSend() - aliased as Signal()</li><li>Wait()</li><li>NBWait() - aliased as Poll()</li></ul><h4 id=other-objects>OTHER OBJECTS</h4><p>Other objects only supports <code>Call()</code> operation.</p><ul><li>Appear as (kernel-implemented) servers. If you invoking a method on an object, this is done by treating the object as a kernel-implemented server. And you invoke it with a <code>call()</code> operation just as you do a normal server invocation.</li><li>Each of these kernel objects has a different kernel-defined protocol<ul><li>operations encoded in message tag</li><li>parameters passed in message words</li></ul></li><li>Mostly hidden behind <strong>syscall</strong> wrappers, user do not need to know this details.</li></ul><p>¬†</p><h2 id=sel4-ipc>seL4 IPC</h2><blockquote><p>IPC in seL4 is a way to realize <strong>cross-domain</strong> invocation.</p></blockquote><p>seL4 IPC is not a mechanism for shipping data. Transfering data is axillary but not the primary purpose.</p><p>seL4 IPC is a protected procedure call, a user-controlled context switch(from clients context into server context).</p><p>¬†</p><h2 id=sel4-threads>seL4 Threads</h2><h3 id=creating-a-thread>Creating a thread</h3><ol><li>Obtain a TCB object</li><li>Set attributes: V-space, C-space, fault endpoint, IPC buffer</li><li>Set Scheduling parameters:<ul><li>priority, scheduling context, timeout endpoint(maybe MCP)</li></ul></li><li>Set architecture-related registers</li></ol><h3 id=threads-and-stacks>Threads and Stacks</h3><p>Stacks are completely user-managed, kernel doesn&rsquo;t care!</p><blockquote><p>Kernel only preserves SP.. on context switch</p></blockquote><p>Stack location, allocation, size must be managed by <strong>userland</strong>.</p><p>Kernel beware of stack overflow</p></article></body><hr width=100% id=EOF><p style=color:#777>ÂàõÂª∫‰∫é: 2022-06-04T11:52:51, Lastmod: 2023-09-24T18:08:59</p><script src=/js/copy-to-clipboard.js></script></main></div></body></html>