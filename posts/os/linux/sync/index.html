<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>操作系统：同步互斥机制</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>所有文章</a></div><div class="a-block nav-link-item"><a href=/tags>Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="search posts..."><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%b8%ba%e4%bd%95%e9%9c%80%e8%a6%81%e5%90%8c%e6%ad%a5%e4%ba%92%e6%96%a5%e6%9c%ba%e5%88%b6 aria-label=为何需要同步互斥机制>为何需要同步互斥机制</a></li><li><a href=#%e5%90%8c%e6%ad%a5%e4%ba%92%e6%96%a5%e7%9a%84%e5%b8%b8%e8%a7%81%e6%96%b9%e6%a1%88 aria-label=同步互斥的常见方案>同步互斥的常见方案</a><ul><li><a href=#per-cpu-%e5%8f%98%e9%87%8f aria-label="per-cpu 变量">per-cpu 变量</a></li><li><a href=#%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c aria-label=原子操作>原子操作</a></li><li><a href=#%e9%94%81%e5%92%8c%e4%bf%a1%e5%8f%b7%e9%87%8f aria-label=锁和信号量>锁和信号量</a></li></ul></li><li><a href=#%e9%80%89%e6%8b%a9%e5%90%88%e9%80%82%e7%9a%84%e5%90%8c%e6%ad%a5%e4%ba%92%e6%96%a5%e6%9c%ba%e5%88%b6 aria-label=选择合适的同步互斥机制>选择合适的同步互斥机制</a></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>操作系统：同步互斥机制</div></header><h1 id=为何需要同步互斥机制>为何需要同步互斥机制</h1><p>同步互斥存在的意义只针对<strong>多个任务都会修改同一块内存的场景</strong>。这块内存也叫<strong>临界区</strong>，
要求是必须各个任务独占访问的。比如说许多线程都会往 ringbuffer 中填数据，
必须使用同步互斥机制才能保证数据的正确性。</p><p>所以说，在以下的场景中，无需考虑同步互斥：</p><ul><li>如果你只有1个CPU，该CPU上只运行1一个线程</li><li>如果会存在多个线程（可能是多个core或者一个core上的多线程环境），但是他们不会涉及同一块内存</li><li>即便是多个线程访问了同一块内存，但是都是<strong>读操作</strong></li></ul><blockquote><p>需要同步互斥的场景在OS内核和用户态程序中都很常见：</p><ul><li>内核中常见的临界资源包括：对内存区域的<strong>引用计数</strong>操作，或者对调度队列的修改操作等。</li><li>用户态那就更不用说了，同步互斥的场景很多，比如典型的读者写者问题(Buffer)</li></ul><p>因为OS内核和用户态程序的权限不同，所以实现同步互斥的方案也不太相同。</p></blockquote><h1 id=同步互斥的常见方案>同步互斥的常见方案</h1><h2 id=per-cpu-变量>per-cpu 变量</h2><p>OS 内核里有些数据结构如果不需要CPU之间共享，可以定义成per-cpu形式。</p><blockquote><p>比如说调度队列，每个CPU只关心自己核上队列的情况，如果想要访问其他CPU的，
比如进程迁移请通过核间通信IPI来做，并不能直接访问。</p></blockquote><blockquote><p>per-cpu 变量通常被安排在不同的 cache line，避免 cache 的频繁刷新</p></blockquote><ul><li>优点：多 CPU 之间互不干扰</li><li>缺点：<ul><li>要求逻辑独立， 极少数临界资源可以实现为 per-CPU 形式</li><li>需要考虑内核抢占的影响，如果OS内核修改percpu变量时被调度，新的进程也可能修改这个变量。
如果在中断服务函数中可能修改，还需要另外关闭内核中断。</li></ul></li></ul><h2 id=原子操作>原子操作</h2><p>如果临界资源只是一个基础类型变量，比如说一个Flag或者引用计数。那么实现同步互斥的逻辑就比较简单。</p><p>我们知道，如果多个CPU同时对一个变量做修改(<code>flag++</code>)，结果是不可知的。这是因为一次修改其实在处理器来看分为三步:</p><ol><li>load mem => register</li><li>update register</li><li>store register => mem</li></ol><p>ISA 会提供一些原子操作的指令，将这三步绑定在一起，一旦有一个core执行了写动作，会对该内存总线独占，
只有此次写入完成后，其他core才能发起写入请求。</p><blockquote><p>这就行了？并不是</p><p>原子操作只能排除上面描述的问题出现，但是多CPU情况下的同步互斥还很复杂。比如说，一个Core修改了
这个变量，至于其他core能不能看到这次写操作，就和 memory consistency 和 cache coherence 相关，
<strong>实际应用中还需要考虑这些来保证逻辑的正确性</strong>。</p></blockquote><p>原子操作指令的特权级别是用户级的，也就是说OS内核和用户态程序都可以用，比如说C++就提供了相应的原子操作库函数。</p><ul><li>缺点：仅适用于临界资源是简单的基础数据类型的情况。当然，<strong>复杂操作的同步互斥实现底层也是在原子操作上做封装</strong></li></ul><h2 id=锁和信号量>锁和信号量</h2><p>锁的实现底层就是利用了原子操作，锁应用的场景包含OS内核和用户态:</p><ul><li>OS内核:<ul><li>自旋锁 Spinlock</li><li>互斥锁 Mutex</li><li>读写锁以及其改进版 RCU</li></ul></li><li>用户态:<ul><li>Futex（Fast Userspace mutex)</li></ul></li></ul><blockquote><p>关于信号量</p><p>信号量和锁的本质是相同的，书籍会写信号量是解决同步问题，锁是解决互斥问题。二值信号量就是互斥锁。</p></blockquote><h1 id=选择合适的同步互斥机制>选择合适的同步互斥机制</h1><p>(1) 内核中<strong>避免使用自旋锁</strong>: 获取不到锁的 CPU 会一直死等，浪费 CPU 资源</p><p>(2) 若临界区仅仅是一个共享的整数变量操作，那么用<strong>原子操作</strong>即可完成，不需要复杂的锁。
例如各类数据结构的引用计数通常声明为 <code>atomic_t</code>。</p><h1 id=references>References</h1><ul><li><a href="https://www.youtube.com/watch?v=7OpCf6f_BAM&t=83s">Let&rsquo;s Talk Locks!</a></li></ul></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2023-05-04T20:51:49, Lastmod: 2023-09-24T18:08:59</p></main></div></body></html>