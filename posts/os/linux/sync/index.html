<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>OS内核同步互斥机制 概述</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>所有文章</a></div><div class="a-block nav-link-item"><a href=/tags>Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%86%85%e6%a0%b8%e4%b8%ba%e4%bd%95%e9%9c%80%e8%a6%81%e5%90%8c%e6%ad%a5%e4%ba%92%e6%96%a5%e6%9c%ba%e5%88%b6 aria-label=操作系统内核为何需要同步互斥机制>操作系统内核为何需要同步互斥机制</a></li><li><a href=#%e5%b8%b8%e8%a7%81%e7%9a%84%e5%90%8c%e6%ad%a5%e4%ba%92%e6%96%a5%e6%9c%ba%e5%88%b6 aria-label=常见的同步互斥机制>常见的同步互斥机制</a><ul><li><a href=#per-cpu-%e5%8f%98%e9%87%8f aria-label="per-cpu 变量">per-cpu 变量</a></li><li><a href=#%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c aria-label=原子操作>原子操作</a></li><li><a href=#%e5%b1%8f%e9%9a%9c aria-label=屏障>屏障</a><ul><li><a href=#%e4%bc%98%e5%8c%96%e5%b1%8f%e9%9a%9c aria-label=优化屏障>优化屏障</a></li><li><a href=#%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c aria-label=内存屏障>内存屏障</a></li></ul></li><li><a href=#%e5%8a%a0%e9%94%81 aria-label=加锁>加锁</a></li><li><a href=#%e4%bf%a1%e5%8f%b7%e9%87%8f aria-label=信号量>信号量</a></li></ul></li><li><a href=#%e5%a6%82%e4%bd%95%e9%80%89%e6%8b%a9%e5%90%88%e9%80%82%e7%9a%84%e5%90%8c%e6%ad%a5%e4%ba%92%e6%96%a5%e6%9c%ba%e5%88%b6 aria-label=如何选择合适的同步互斥机制>如何选择合适的同步互斥机制</a></li></ul></div></details></div></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>OS内核同步互斥机制 概述</div></header><h2 id=操作系统内核为何需要同步互斥机制>操作系统内核为何需要同步互斥机制</h2><p>内核代码存在临界区，例如某个对内存区域的<strong>引用计数</strong>操作，或者对
调度队列的修改操作。</p><p>操作系统 必须保证当一个进程（内核进程）在临界区时不会有其他人（或者自己，
当被中断时）再去操作临界资源。</p><p>对于单 CPU 系统来说，保证上述行为的方式很简单: 关中断+关内核抢占</p><ul><li>关中断能够保证，不会发生当一个内核进程正在操作调度队列时，发生中断
，恰好中断服务函数也会访问调度队列。</li><li>关内核抢占能够保证，不会发生当一个内核进程正在操作调度队列时，发生
中断，中断返回时切换到了别的进程，这个进程的内核态也去操作了调度队列。</li></ul><p>多 CPU 情况下，问题就变得负责，就需要配合各种同步互斥机制来实现上述行为要求。</p><h2 id=常见的同步互斥机制>常见的同步互斥机制</h2><h3 id=per-cpu-变量>per-cpu 变量</h3><ul><li>优点：多 CPU 之间互不干扰</li><li>缺点：<ul><li>要求逻辑独立， 极少数临界资源可以实现为 per-CPU 形式</li><li>开内核抢占时仍有危险，因为不同进程可能在一个 CPU 上，
使用同一个 per-cpu 变量</li></ul></li></ul><blockquote><p>per-cpu 变量通常被安排在不同的 cache line，避免 cache 的频繁刷新</p></blockquote><h3 id=原子操作>原子操作</h3><p>解决多个 CPU 同时修改一个内存值时出现覆盖的问题，当然，单 CPU 没必要用原子操作。</p><p>使用原子操作能够保证: 同时执行读操作总会有一个 CPU 先占据总线，此时将总线上锁，其他
CPU 的读写只能等待占领的 CPU 写入彻底完成后。</p><blockquote><p><a href>AArch64 实现原子操作</a></p></blockquote><h3 id=屏障>屏障</h3><p>仅使用屏障不能直接保证同步，但是需要同步互斥机制都要用到屏障。
比如实现原子操作需要<code>ldrx</code>和<code>strx</code>组合（虽然有新的 CAS 指令, 暂不考虑）
，但 ARM 架构中编译器会 reorder 指令，CPU 会乱序执行。如果 <code>strx</code>在<code>ldrx</code>
之前执行了， 那么原子操作就必然不能实现。</p><p>架构支持的各类屏障用于解决这些问题。</p><h4 id=优化屏障>优化屏障</h4><p>优化屏障是指在使用内敛汇编时的，<code>volatile</code>和<code>"memory"</code>关键字，如下示例:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#00f>asm</span> volatile(<span style=color:#a31515>&#34;&#34;</span>:::<span style=color:#a31515>&#34;memory&#34;</span>);
</span></span></code></pre></div><ul><li><code>volatile</code> 向<strong>编译器</strong>说明禁止内敛的语句与其他语句 reorder。但不能保证内部 reorder，
那是下面<em>内存屏障</em>的任务</li><li><code>"memory"</code> 向<strong>编译器</strong>说明对于所有内存访问操作，不能使用 asm 之前预加载到寄存器中的值
，而必须在 asm 内部重新加载。保证其内部访问内存值具有可见性和正确性。</li></ul><h4 id=内存屏障>内存屏障</h4><p>类似于防火墙，保证：屏障之后的指令开始执行前，屏障之前的指令都已执行完毕！</p><p>在 ARMv8 架构中，还将内存屏障进行细分:</p><ul><li>ISB: 之后的指令重新 <strong>fetch</strong>, 常用于例如权限修改后，某些寄存器的读取指令就
可能是非法的</li><li>DMB: 防止<strong>数据相关</strong>的指令 reorder 越过 barrier 先执行</li><li>DSB: DMB 的升级版，不只是数据相关指令，而是防止任何指令 reorder 越过 barrier 先执行</li></ul><h3 id=加锁>加锁</h3><p>进入临界区时，加锁。 常使用的锁包括：</p><ol><li>自旋锁</li><li>读写锁</li><li>顺序锁</li><li>RCU</li></ol><h3 id=信号量>信号量</h3><p>与锁类似且相对应:</p><ol><li>二值信号量 - 自旋锁</li><li>读写信号量 - 读写锁</li><li>&mldr;</li></ol><p>区别是：进程若获取不到信号量，不会死等，而是被睡眠。</p><h2 id=如何选择合适的同步互斥机制>如何选择合适的同步互斥机制</h2><p>(1) <strong>避免使用自旋锁</strong>: 获取不到锁的 CPU 会一直死等，浪费 CPU 资源</p><p>(2) 若临界区仅仅是一个共享的整数变量操作，那么用<strong>原子操作</strong>即可完成，不需要复杂的锁。
例如各类数据结构的引用计数通常声明为 <code>atomic_t</code>。</p></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2023-05-04T20:51:49, Lastmod: 2023-08-30T21:17:50</p></main></div></body></html>