<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>linux SLAB 内存分配器(2): 算法</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>所有文章</a></div><div class="a-block nav-link-item"><a href=/tags>Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%9c%80%e5%a4%96%e5%b1%82%e6%8e%a5%e5%8f%a3-kmallockfree aria-label="最外层接口: kmalloc()/kfree()">最外层接口: <code>kmalloc()</code>/<code>kfree()</code></a></li><li><a href=#%e4%b8%93%e7%94%a8%e7%9a%84cache aria-label=专用的&amp;quot;cache&amp;quot;>专用的"cache"</a></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>linux SLAB 内存分配器(2): 算法</div></header><p>上一篇介绍了数据结构，这一篇主要介绍 slab 分配器的分配和释放算法。</p><h2 id=最外层接口-kmallockfree>最外层接口: <code>kmalloc()</code>/<code>kfree()</code></h2><p>最上层的接口是<code>kmalloc(size, flag)</code>。</p><p>slab 分配器维护了多个不同大小的 kmem_cache，放在数组<code>kmem_caches[]</code>中,
其对应的 object 大小和该 kmem_cache 的 name 在另一个数组<code>kmalloc_info[]</code>
中，它们的下标是对应的。使得我们能根据请求分配的大小来找到对应的<code>struct kmem_cache</code>结构。
【代码】</p><h2 id=专用的cache>专用的"cache"</h2><p>上面的结构，会遍历系统初始化创建的一些内存池，来寻找一个大小满足要求的 object，
但是通常不能找到大小相等的，如果系统中存在的固定 cache 中 object 的大小太稀疏，
就容易发生空间浪费的问题。</p><p>因此，我们可以为某个特定大小的内存请求再创建一个单独的 cache，仅仅用于满足这一类
结构体的申请，也是符合 slab 分配器关于面向对象的设计思想。</p><p>slab 分配器提供的相关接口是:</p><ul><li><code>kmem_cache_create()</code>: 创建一个专用 cache</li><li><code>kmem_cache_alloc()</code>： 从指定的 cache 里分配 object</li><li><code>kmem_cache_free()</code>: 释放对象到指定的 cache</li><li><code>kmem_cache_destory()</code>: 销毁某个 cache</li></ul><h2 id=reference>Reference</h2><p><a href="https://blog.csdn.net/u010923083/article/details/116518646?spm=1001.2014.3001.5502">https://blog.csdn.net/u010923083/article/details/116518646?spm=1001.2014.3001.5502</a></p></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2023-05-20T18:51:49, Lastmod: 2023-08-30T21:17:50</p></main></div></body></html>