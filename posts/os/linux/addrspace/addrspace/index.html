<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>Linux 进程地址空间 概述</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>所有文章</a></div><div class="a-block nav-link-item"><a href=/tags>Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%bd%95%e4%b8%ba%e8%bf%9b%e7%a8%8b%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4 aria-label=何为进程地址空间?>何为进程地址空间?</a></li><li><a href=#linux-%e6%8f%8f%e8%bf%b0%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label="Linux 描述地址空间的数据结构">Linux 描述地址空间的数据结构</a></li><li><a href=#linux-%e6%8f%8f%e8%bf%b0%e7%ba%bf%e6%80%a7%e5%8c%ba%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label="Linux 描述线性区的数据结构">Linux 描述线性区的数据结构</a></li><li><a href=#%e8%bf%9b%e7%a8%8b%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e6%89%80%e6%9c%89%e7%ba%bf%e6%80%a7%e5%8c%ba%e7%9a%84%e7%bb%84%e7%bb%87 aria-label=进程地址空间所有线性区的组织>进程地址空间所有线性区的组织</a><ul><li><a href=#%e7%ba%a2%e9%bb%91%e6%a0%91%e4%bc%98%e5%8c%96%e6%9f%a5%e6%89%be aria-label=红黑树优化查找>红黑树优化查找</a></li><li><a href=#%e5%88%86%e9%85%8d%e4%b8%80%e4%b8%aa%e7%ba%bf%e6%80%a7%e5%8c%ba aria-label=分配一个线性区>分配一个线性区</a></li><li><a href=#%e9%87%8a%e6%94%be%e4%b8%80%e4%b8%aa%e7%ba%bf%e6%80%a7%e5%8c%ba aria-label=释放一个线性区>释放一个线性区</a></li></ul></li></ul></div></details></div></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>Linux 进程地址空间 概述</div></header><h2 id=何为进程地址空间>何为进程地址空间?</h2><p>进程地址空间由允许进程使用的若干<strong>线性地址区域</strong>(也称"虚拟内存区域")构成。</p><p>每个线性区域由起始地址、长度和属性来描述。</p><p>在进程刚创建时，其地址空间仅包含 3 个线性区，分别是：代码段、数据段和堆区，其中
堆区的初始大小为 0。</p><blockquote><p>栈区虽然也属于进程使用的内存区域，但这个区域对用户是透明的，所以我们一般将其
归于内核管理，并非进程本身。</p></blockquote><p><strong>线性区增加的典型情况:</strong></p><ol><li>使用<code>mmap()</code>为一个文件映射内存空间</li><li>创建一个 IPC 共享线性区与其他进程协作</li><li>调用<code>malloc()</code>扩张自己的堆区</li></ol><h2 id=linux-描述地址空间的数据结构>Linux 描述地址空间的数据结构</h2><p>在进程的 tcb 中，描述地址空间相关的结构都保存在成员<code>mm</code>中，其类型为<code>struct mm_struct</code>,
其中重要的成员有：</p><ul><li><code>mmap(struct vm_area_struct*)</code>: 指向所有线性区的链表头</li><li><code>mm_rb(struct rb_root)</code>: 指向所有线性区对象红黑树的根</li><li><code>pgd(pgd_t *)</code>: 指向进程的页表</li><li><code>mmlist(struct list_head)</code>: 指向下一个地址空间描述符(所有进程的地址空间描述符
被链接起来)</li></ul><h2 id=linux-描述线性区的数据结构>Linux 描述线性区的数据结构</h2><p>用<code>struct vm_area_struct</code>描述一个线性去，其中重要的成员有:</p><ul><li><code>vm_mm(struct mm_struct *)</code>: 指向所属的地址空间描述符</li><li><code>vm_start(unsigned long)</code>: 此线性区的开始</li><li><code>vm_end(unsigned long)</code>: 下一个线性区的开始(此线性区结束地址+1）</li><li><code>vm_next(struct vm_area_struct *)</code>: 指向进程线性区的 next</li><li><code>vm_rb(struct rb_node)</code>: 此线性区对应红黑树中的节点</li></ul><p>此线性区的大小就可以表示为: <code>vm_end - vm_start</code>.</p><h2 id=进程地址空间所有线性区的组织>进程地址空间所有线性区的组织</h2><p>进程拥有的所有线性区通过单链表串联（按地址排序），第一个区在<code>mm_struct->mmap</code>, 下一次
通过<code>vm_area_struct->vm_next</code>找到，依次类推。并且，<code>mmstruct->map_count</code>成员
记录了进程所有线性区的数量。</p><h3 id=红黑树优化查找>红黑树优化查找</h3><p>正常来说，想要查找某个地址是否存在于进程的地址空间，遍历上述链表的效率是 O(n).</p><p>因此，Linux2.6 引入红黑树来优化查找速度， 所有线性区同时组织成一个红黑树，
首部通过<code>mm_struct.mm_rb</code>指向。 然后每个线性区的<code>vm_area_struct.vm_rb</code>
存储节点的颜色和双亲信息。</p><p>现在，当需要插入/删除一个线性区描述符时，用红黑树查找前后元素，再操作链表进行插入。</p><h3 id=分配一个线性区>分配一个线性区</h3><p>接口是<code>do_mmap()</code>, 参数为:</p><ul><li>file, offset; 如果有文件映射</li><li>addr, len</li><li>prot; 该线性区的权限</li></ul><p>步骤大致包含:</p><ol><li>用红黑树确定新线性区的前后， 对应<code>find_vma_prepare()</code></li><li>slab 分配一个<code>struct vma_area_struct</code>，并初始化</li><li>操作链表插入，对应<code>vma_link()</code></li></ol><h3 id=释放一个线性区>释放一个线性区</h3><p>接口是<code>do_munmap()</code></p><p>步骤大致包含:</p><ol><li>红黑树确定要删除线性区的位置，以及做分割（必要时）</li><li>调用<code>detach_vmas_to_unmapped()</code>将其从链表中删除</li><li><code>unmap_region()</code>删除页表项</li><li>释放 <code>vma_area_struct</code> 的空间</li></ol></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2023-05-07T14:51:49, Lastmod: 2023-09-02T15:27:14</p></main></div></body></html>