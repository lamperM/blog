<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>Linux 进程地址空间 堆的管理</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>所有文章</a></div><div class="a-block nav-link-item"><a href=/tags>Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%bf%ae%e6%94%b9%e5%a0%86%e7%a9%ba%e9%97%b4%e7%9a%84%e6%8e%a5%e5%8f%a3 aria-label=修改堆空间的接口>修改堆空间的接口</a></li><li><a href=#malloc%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label=malloc()的实现><code>malloc()</code>的实现</a></li></ul></div></details></div></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>Linux 进程地址空间 堆的管理</div></header><p>当进程被创建时，就预留了一块特殊的线性区，其开始地址和结束地址单独保存在
<code>mm_struct.start_brk</code>和<code>mm_strcut.brk</code>成员中，并不由<code>vm_area_struct</code>
链接，这块特殊的线性区就叫堆。</p><p>进程使用的<code>malloc()</code>和<code>free()</code>等相关 API 都是操纵的堆空间。</p><h2 id=修改堆空间的接口>修改堆空间的接口</h2><p>对用户态进程来说，提供<code>brk()</code>系统调用来修改自身的堆空间。</p><p><code>brk()</code>: 参数<code>addr</code>, 效果是修改<code>mm_struct.brk</code>到 addr，即修改一个堆的结束地址。</p><p><code>brk()</code> 系统调用的实现，在内核态是调用<code>do_mmap()</code>扩充堆，或者<code>do_unmap()</code>缩小堆。
并且移动<code>mm_struct.brk</code>的值而已，这是 <code>brk()</code>的实现。</p><blockquote><p>用户态进程还有一个接口: <code>sbrk()</code>, 参数是字节，代表扩充的字节数。
其下层还是调用的 <code>brk()</code>。</p></blockquote><h2 id=malloc的实现><code>malloc()</code>的实现</h2><p>进程刚创建时，堆空间的大小为 0， 即<code>bkr</code>==<code>start_brk</code>。</p><p>调用<code>malloc()</code>，即对堆空间扩充，上面介绍了修改堆空间的接口，
所以我们可以使用<code>brk()</code>来实现<code>malloc()</code>.</p><p>对于进程本身来说，只能通过<code>brk()</code>简单的增加/减少堆的总大小，这样做的效率是比较低的。
比如连续执行了三次<code>malloc()</code>, 如果要将中间的地址 free 掉，其实是无法实现的。</p><p>而且这种最简单的情况下，每次<code>malloc()</code>都要使用<code>brk()</code>系统调用，效率也是很低的。</p><p>所以，通常在 C 库则一层，即<code>malloc()</code>和<code>brk()</code>之间，会有一层对堆内存的管理，
包含碎片回收，内存池等算法来避免频繁的使用系统调用。</p></article></body></main></div></body></html>