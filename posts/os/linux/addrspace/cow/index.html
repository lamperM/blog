<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>Linux 进程地址空间 写时复制</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%bd%93%e5%89%8d%e5%ad%98%e5%9c%a8%e7%9a%84%e9%97%ae%e9%a2%98 aria-label=当前存在的问题>当前存在的问题</a></li><li><a href=#%e5%86%99%e6%97%b6%e5%a4%8d%e5%88%b6%e7%9a%84%e4%bc%98%e5%8c%96 aria-label=写时复制的优化>写时复制的优化</a></li><li><a href=#%e8%bf%99%e6%a0%b7%e5%b0%b1%e5%ae%8c%e7%be%8e%e4%ba%86%e5%90%97 aria-label=这样就完美了吗>这样就完美了吗</a></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>Linux 进程地址空间 写时复制</div></header><h2 id=当前存在的问题>当前存在的问题</h2><p>未启用写时复制时，<code>fork()</code>创建子进程地址空间的流程如下:</p><ol><li>动态申请子进程的页表</li><li>动态申请子进程的物理页面，大小和父进程的相同</li><li>创建<code>父进程虚拟地址-新物理页</code>的映射到子进程页表</li><li><code>memcpy()</code>将父进程所有页面拷贝到子进程地址空间下</li></ol><p>这样做有什么问题呢？ 在<code>fork()</code>的常规调用环境下，<code>fork()</code>之后
接的一般是<code>exec()</code>类函数，即载入一个新的可执行文件，继续用父进程
的情况不多。</p><p>这样的话，上述过程中<code>memcpy()</code>父进程的页面就是多余的，而且如果
父进程比较大，会非常耗时。</p><h2 id=写时复制的优化>写时复制的优化</h2><p>执行 <code>fork()</code> 时，不给子进程分配新的物理页，而是将父进程的页表项
完全的拷贝到子进程中，结果就是<strong>父子进程的虚拟地址指向同一个物理地址</strong>。</p><p>换句话说，这样做就不需要<code>memcpy()</code>父进程所有的页面，仅仅是<code>memcpy()</code>一份
父进程的页表，给子进程用。</p><blockquote><p>那么是否连新页表都不申请，直接用父进程的页表？</p><p>显然是不行的，因为本质上父子进程拥有不同的地址空间，
最后都要分隔开（无论是否执行<code>exec()</code>），所以没必要
推迟页表的申请，本身不怎么耗时。</p><p>但是创建<strong>线程</strong>时，确实使用同一张页表。</p></blockquote><p>当然，仅设计到这步是不行的，因为按理来说父子进程是独立的，对子进程的
修改不应该影响父进程的地址空间。</p><p>所有，在 copy 完页表后，会将父子进程的所有地址空间（实际是页表项）设置
为<strong>只读属性</strong>，当父/子进程尝试修改地址空间时，触发异常，配合特定的
异常处理机制，为其创建一个新的屋里也，拷贝原来的+执行修改。</p><p>下图是对上述情况的描述，仅给出一个页面的示例，可以推广到整个地址空间：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span>            VMA                                                              VMA
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>          ┌───────┐                                  │                     ┌───────┐
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>Parent    │       │                                  │           Parent    │       │
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>          │       │                                  │                     │       │
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>          ├───────┤                                  │                     ├───────┤
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>          │       ├────┐                             │                     │       ├────┐
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>          ├───────┤    │       PMA            Write  │                     ├───────┤    │       PMA
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>          │       │    │     ┌───────┐           ────┼───►                 │       │    │     ┌───────┐
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>          │       │    │     │       │               │                     │       │    │     │       │
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>          │       │    │     │       │               │                     │       │    │     │       │
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>          └───────┘    │     ├───────┤               │                     └───────┘    │     ├───────┤
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>                       ├────►│       │ Read          │                                  └────►│       │ RW
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>          ┌───────┐    │     ├───────┤ only          │                     ┌───────┐          ├───────┤
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>Child     │       │    │     │       │               │           Child     │       │          │       │
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>          │       │    │     │       │               │                     │       │          ├───────┤
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>          ├───────┤    │     │       │               │                     ├───────┤       ┌─►│       │ RW
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span>          │       ├────┘     └───────┘               │                     │       ├───────┘  ├───────┤
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span>          ├───────┤                                  │                     ├───────┤          │       │
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>          │       │                                  │                     │       │          └───────┘
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span>          │       │                                  │                     │       │
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span>          │       │                                  │                     │       │
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span>          └───────┘                                  │                     └───────┘
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span>                                                     │
</span></span></code></pre></div><h2 id=这样就完美了吗>这样就完美了吗</h2><p>实际上不是的，拷贝父进程的页表和<code>vm_area_struct</code>就不占内存了吗？</p><p>当页表是稀疏的，<code>vm_area_struct</code>的数量过多时，其本身的数据结构
就会占用很大的空间。</p><p>就 AArch64 来说，针对页表过大的问题，提供了 2M 和 1G 的巨型页(Huge Page)
可供选择，能在申请大而稀疏的页面时显著的减少页表的大小，同时也增加了 TLB 的
命中率，因为同样大小的内存大页只需要一个 TLB 表项即可。</p><p>然而，还有一种情况更加严重，若<code>fork()</code>后父进程写了地址空间的内容，
如上所说就要拷贝这些物理页面，此时如果写的页面过多可能发生<code>fork()</code>到<code>exec()</code>
那一段间隔时间里的物理内存占用极高。虽然这种情况极少发生，前提必须是内存
分配稀疏+父进程修改的内存也是稀疏的，但是并不能完全忽略这种情况。</p><p>当然，这个问题不能归根于 COW，而是<code>fork()</code>带来的，<code>fork()</code>应该提供参数
给那些子进程立马调用<code>exec()</code>的场景，就不用拷贝父进程的这些数据结构了。</p></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2023-05-08T09:51:49, Lastmod: 2023-09-24T18:08:59</p></main></div></body></html>