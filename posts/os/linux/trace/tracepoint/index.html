<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>Linux追踪系统学习(1): tracepoint</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>所有文章</a></div><div class="a-block nav-link-item"><a href=/tags>Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#tracepoint-%e7%9a%84%e7%bb%84%e6%88%90 aria-label="tracepoint 的组成">tracepoint 的组成</a></li><li><a href=#tracepoint-%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86 aria-label="tracepoint 工作原理">tracepoint 工作原理</a></li><li><a href=#%e5%b0%8f%e7%bb%93 aria-label=小结>小结</a></li></ul></div></details></div></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>Linux追踪系统学习(1): tracepoint</div></header><p>tracepoint 是 Linux trace system 中 data source 之一，
其 trace 的对象是 kernel，属于一种静态的插桩方法。</p><ul><li>添加和删除需要手动修改内核源码</li><li>可以向上提供接口，可以通过 frontend 来开启或者关闭，也可以自定义数据处理方式</li><li>在 disable 时， 仅有一次 if 判断的损耗，所以效率还算高。但缺点是不够灵活。</li></ul><h2 id=tracepoint-的组成>tracepoint 的组成</h2><p>看其源码<code>struct tracepoint</code>就能知道它的组成结构：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#00f>struct</span> tracepoint {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>    <span style=color:#00f>const</span> <span style=color:#2b91af>char</span> *name;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span><span style=color:#00f>#define TP_STATE_DISABLE 0
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span><span style=color:#00f>#define TP_STATE_ENABLE  1
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span><span style=color:#00f></span>    <span style=color:#2b91af>int</span> state;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>    <span style=color:green>// 并非用于注册hook的函数，而是注册hook时的hook
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span><span style=color:green></span>    <span style=color:#2b91af>int</span> (*reghook)(<span style=color:#2b91af>void</span>);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    <span style=color:#2b91af>void</span> (*unreghook)(<span style=color:#2b91af>void</span>);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>    <span style=color:green>// 在tracepoint触发时将调用的hook
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span><span style=color:green></span>    <span style=color:#00f>struct</span> tracepoint_hook *hooks;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>};
</span></span></code></pre></div><ul><li>name: 是该 tracepoint 的名称</li><li>state: 用于控制其开关状态</li><li>hooks: 是一系列的函数指针，当 tracepoint hit 时，这些函数会被依次调用</li><li>reghook/unreghook: 在注册/注销 hook 时将被调用，可以用来输出一些提示信息</li></ul><p>为了提供对 tracepoint 操作的接口，定义一个 tracepoint 时，会同时定义一系列功能函数,
包括：</p><ol><li>放在内核代码之中的插桩函数；其被调用说明 tracepoint hit， 如果 enable 状态，
则依次执行其 hook</li><li>用于注册 hook 的接口；为该 tracepoint 添加新的 hook</li><li>注销某个 hook 的接口；</li></ol><h2 id=tracepoint-工作原理>tracepoint 工作原理</h2><p>类似于一般的日志记录函数， 在合适的位置放置<code>trace_##event()</code>作为“插桩”，运行到
此处代表该做一些事了，至于做什么事不是 tracepoint 该管的。它只能负责提供给你一些接口
，让你能把“做事”的函数与 tracepoint 联系起来，到时候触发时调用它们。</p><p>这就是上面说的，tracepoint 仅负责 data source 这一部分。</p><h2 id=小结>小结</h2><p>下一节将介绍如何 Linux trace system 中的<strong>数据记录</strong>组件，毕竟每次触发都输出到控制台还是
太乱了，而且不是 trace 这个系统的工作内容（log 系统应该是干这个的）。</p></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2023-04-23T23:51:49, Lastmod: 2023-08-30T21:17:50</p></main></div></body></html>