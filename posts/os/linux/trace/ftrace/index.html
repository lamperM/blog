<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/syntax_pastie.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title></title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#reference aria-label=Reference>Reference</a></li><li><a href=#%e4%bb%8b%e7%bb%8d aria-label=介绍>介绍</a><ul><li><a href=#debugfs%e6%8f%90%e4%be%9b%e7%94%a8%e6%88%b7%e5%b1%82%e6%8e%a7%e5%88%b6%e6%8e%a5%e5%8f%a3 aria-label=Debugfs提供用户层控制接口>Debugfs提供用户层控制接口</a></li></ul></li><li><a href=#%e5%ae%9e%e9%aa%8c aria-label=实验>实验</a><ul><li><a href=#%e5%86%85%e6%a0%b8%e5%87%bd%e6%95%b0%e8%b7%9f%e8%b8%aa aria-label=内核函数跟踪>内核函数跟踪</a></li><li><a href=#%e4%ba%8b%e4%bb%b6 aria-label=事件>事件</a></li></ul></li><li><a href=#perf%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90 aria-label=Perf性能分析>Perf性能分析</a><ul><li><a href=#wsl2%e7%bc%96%e8%af%91%e5%ae%89%e8%a3%85perf aria-label=Wsl2编译安装Perf>Wsl2编译安装Perf</a></li></ul></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title></div></header><h2 id=reference>Reference</h2><ol><li><a href="https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=f48e8682c14355df15567be2c95307485edb1587#page=47">Measuring Function Duration with Ftrace</a></li><li><a href=https://static.lwn.net/lwn/lwn/images/conf/rtlws11/papers/proc/p02.pdf>Finding Origins of Latencies Using Ftrace</a></li><li><a href=https://events.static.linuxfound.org/slides/2010/linuxcon_japan/linuxcon_jp2010_rostedt.pdf>Slides: Ftrace</a></li><li><a href=https://blog.linuxplumbersconf.org/2014/ocw/system/presentations/1773/original/ftrace-kernel-hooks-2014.pdf>Slides: Ftrace Kernel Hooks:More than just tracing</a></li></ol><h2 id=介绍>介绍</h2><p>ftrace功能 ：帮助了解Linux内核的运行时行为，可以查看系统调用情况，以及某个函数的调用流程。
2.6内核之后引入内核的。以便进行故障调试或性能分析。</p><p>Ftrace 跟踪工具由性能分析器（profiler）和跟踪器（tracer）两部分组成，</p><p>性能分析器：用来提供追踪数据的解析和图形化作战时（需要 CONFIG_FUNCTION_PROFILER=y）</p><ul><li>函数性能分析</li><li>直方图</li></ul><p>跟踪器：负责不同追踪事件的实现，数据的来源</p><ul><li>函数跟踪（function）</li><li>点跟踪（tracepoint）</li><li>kprobe</li><li>uprobe</li><li>函数调用关系（function_graph）</li><li>hwlat等</li></ul><h3 id=debugfs提供用户层控制接口>Debugfs提供用户层控制接口</h3><p>ftrace的目录：/sys/kernel/debug/tracing/ ，常用文件介绍：</p><ul><li>dynamic tracing，动态trace进行过滤的接口，是需要在编译时支持该功能，需要打开对应的宏开关：</li><li>available_events</li><li>available_filter_functions: 可追对函数的完整列表</li><li>available_tracers，当前内核中可用的插件追踪器。</li><li>buffer_size_kb，以KB为单位指定各个CPU追踪缓冲区的大小。系统追踪缓冲区的总大小就是这个值乘以CPU的数量。设置buffer_size_kb时，必须设置current_tracer为nop追踪器。</li><li>buffer_total_size_kb</li><li>current_tracer，通过该接口指定当前ftrace要使用的tracer，也就是要追踪的函数/时间。</li><li>dyn_ftrace_total_info:</li><li>enabled_functions:</li><li>max_graph_depth:</li><li>printk_formats:</li><li>saved_cmdlines:</li><li>saved_cmdlines_size:</li><li>set_event:</li><li>set_event_pid:</li><li>set_ftrace_filter，指定要追踪的函数名称，函数名称仅可以包含一个通配符。</li><li>set_ftrace_notrace，指定不要追踪的函数名称。</li><li>set_ftrace_pid，指定作为追踪对象的进程的PID号。</li><li>set_graph_function:</li><li>set_graph_notrace:</li><li>trace，以文本格式输出内核中追踪缓冲区的内容，是查看trace日志的接口。</li><li>trace_clock:</li><li>trace_marker:</li><li>trace_marker_raw:</li><li>trace_options:</li><li>trace_pipe，与trace相同，但是运行时像管道一样，可以在每次事件发生时读出追踪信息，但是读出的内容不能再次读出</li><li>tracing_cpumask，以十六进制的位掩码指定要作为追踪对象的处理器，例如，指定0xb时仅在处理器0、1、3上进行追踪。</li><li>tracing_on，启用/禁用向追踪缓冲区写入功能。1为启用，0为禁用。</li><li>tracing_thresh:</li><li>uprobe_events:</li><li>uprobe_profile:</li><li></li></ul><p>支持的tracer包括:</p><ul><li>nop，不执行任何操作。不使用插件追踪器时指定。</li><li>function，函数调用追踪器，可以看出哪个函数何时调用。</li><li>function_graph，函数调用图表追踪器，可以看出哪个函数被哪个函数调用，何时返回。</li><li>mmiotrace，MMIO( Memory MappedI/O)追踪器，用于Nouveau驱动程序等逆向工程。</li><li>blk，block I/O追踪器。</li><li>wakeup，进程调度延迟追踪器。</li><li>wakeup_rt，与wakeup相同，但以实时进程为对象。</li><li>irqsoff，当中断被禁止时，系统无法响应外部事件，造成系统响应延迟，irqsoff跟踪并记录内核中哪些函数禁止了中断，对于其中禁止中断时间最长的，irqsoff将在log文件的第一行标示出来，从而可以迅速定位造成系统响应延迟的原因。</li><li>preemptoff，追踪并记录禁止内核抢占的函数，并清晰显示出禁止内核抢占时间最长的函数。</li><li>preemptirqsoff，追踪并记录禁止内核抢占和中断时间最长的函数</li><li>sched_switch，进行上下文切换的追踪，可以得知从哪个进程切换到了哪个进程。</li></ul><p>ftrace有两种主要跟踪机制可以往缓冲区中写数据，一种是函数，一种是事件。前者比较酷，很多教程都会先讲前者。但对我来说，后者才比较可靠实用，所以我先讲后者。</p><p>事件是固定插入到内核中的跟踪点，我们看Linux代码的时候，经常看到这种trace_开头的函数调用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>likely</span><span class=p>(</span><span class=n>prev</span> <span class=o>!=</span> <span class=n>next</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>rq</span><span class=o>-&gt;</span><span class=n>nr_switches</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=n>rq</span><span class=o>-&gt;</span><span class=n>curr</span> <span class=o>=</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=o>++*</span><span class=n>switch_count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          <span class=n>trace_sched_switch</span><span class=p>(</span><span class=n>preempt</span><span class=p>,</span> <span class=n>prev</span><span class=p>,</span> <span class=n>next</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=n>rq</span> <span class=o>=</span> <span class=n>context_switch</span><span class=p>(</span><span class=n>rq</span><span class=p>,</span> <span class=n>prev</span><span class=p>,</span> <span class=n>next</span><span class=p>,</span> <span class=n>cookie</span><span class=p>);</span> <span class=cm>/* unlocks the rq */</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=n>lockdep_unpin_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rq</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>,</span> <span class=n>cookie</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=n>raw_spin_unlock_irq</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rq</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></div><h2 id=实验>实验</h2><p>使用ftrace：分为三步</p><ul><li>设置tracer类型</li><li>设置tracer参数</li><li>使能tracer</li></ul><h3 id=内核函数跟踪>内核函数跟踪</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>cd</span> /sys/kernel/debug/tracing
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Set tracer </span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=k>function</span> &gt; current_tracer
</span></span><span class=line><span class=cl><span class=c1># Set function filter</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> vma_link &gt; set_ftrace_filter
</span></span><span class=line><span class=cl><span class=c1># Enable selected tracer</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=m>1</span> &gt; tracing_on
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># See trace result</span>
</span></span><span class=line><span class=cl>cat trace
</span></span></code></pre></div><p>应用的场景不多，只限于想看某几类函数的调用事件。
但是有些场景我们更可能希望获取调用该内核函数的流程（即该函数是在何处被调用），
这需要通过设置 options/func_stack_trace 选项实现。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1>#先关闭跟踪</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=m>0</span> &gt; tracing_on
</span></span><span class=line><span class=cl><span class=c1># Set tracer </span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=k>function</span> &gt; current_tracer
</span></span><span class=line><span class=cl><span class=c1># Set function filter</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> vma_link &gt; set_ftrace_filter
</span></span><span class=line><span class=cl><span class=c1>#开启跟踪函数的调用栈</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=m>1</span> &gt; options/func_stack_trace
</span></span><span class=line><span class=cl><span class=c1># Enable selected tracer</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=m>1</span> &gt; tracing_on
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># See trace result</span>
</span></span><span class=line><span class=cl>cat trace
</span></span></code></pre></div><p>如果想要分析内核函数调用的子流程（即本函数调用了哪些子函数，处理的流程如何），
这时需要用到 function_graph 跟踪器，从字面意思就可看出这是函数调用关系跟踪。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nb>echo</span> function_graph &gt; current_tracer
</span></span><span class=line><span class=cl><span class=nb>echo</span> *vfs* &gt; set_ftrace_filter
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=m>1</span> &gt; tracing_on
</span></span><span class=line><span class=cl>cat trace
</span></span></code></pre></div><h3 id=事件>事件</h3><p>可基于 ftrace 跟踪内核静态跟踪点，可跟踪的完整列表可通过 available_events 查看。</p><p><a href=https://zhuanlan.zhihu.com/p/659390893>1小时掌握ftrace内核跟踪技术 - 知乎</a></p><p><a href=https://zhuanlan.zhihu.com/p/661794875>高效调试与分析：利用ftrace进行Linux内核追踪 - 知乎</a></p><h2 id=perf性能分析>Perf性能分析</h2><h3 id=wsl2编译安装perf>Wsl2编译安装Perf</h3><p>apt工具总是提示找不到，所以就手动编译安装。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git clone https://github.com/microsoft/WSL2-Linux-Kernel --depth <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=nb>cd</span> WSL2-Linux-Kernel/tools/perf
</span></span><span class=line><span class=cl>make -j8
</span></span><span class=line><span class=cl>sudo cp perf /usr/local/bin
</span></span></code></pre></div></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 0001-01-01T00:00:00, Lastmod: 2024-01-17T16:29:05</p><script src=/js/copy-to-clipboard.js></script></main></div></body></html>