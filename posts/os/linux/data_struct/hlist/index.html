<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>Linux 内核数据结构 hlist</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%ba%8c%e8%b1%a1%e6%80%a7 aria-label=二象性>二象性</a></li><li><a href=#%e6%9b%b4%e5%a5%bd%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88-prev aria-label="更好的解决方案: **prev">更好的解决方案: <code>**prev</code></a></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>Linux 内核数据结构 hlist</div></header><p>linux 内核为创建【用单链表解决冲突的哈希表】设计了专门的数据结构 hlist。</p><p>hlist 整体来说是带头结点的双向链表，头结点的类型为<code>hlist_head</code>, 普通节点
的类型为<code>hlist_node</code>. <strong>为什么要区别两种类型？节约空间</strong>， 因为哈希表的
表项类型可以是<code>hlist_head</code>, 它其实不需要<code>prev</code>指针, 比起一般的结点，一个
哈希表能节约一半的空间。</p><p>所以一个哈希表和头结点的结构可表示为:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#080;font-weight:700>struct</span> hlist_head {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>    <span style=color:#080;font-weight:700>struct</span> hlist_node *first;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>};
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span><span style=color:#080;font-weight:700>struct</span> hlist_head table[TALBE_SZ];
</span></span></code></pre></div><h2 id=二象性>二象性</h2><p>任何事物都具有二象性，区分两种类型节约空间的空间，也带了一个问题：
<strong>首个<code>hlist_node</code>结点的<code>prev</code>指向哪呢？</strong></p><p>正常情况下肯定毫不犹豫的指向头结点，即<code>hlist_head</code>，但注意此时类型是
不同的，<code>prev</code>不能同时是<code>struct hlist_head*</code>和<code>struct hlist_node *</code>。</p><p>解决方案有两个，首先可以使首个结点的<code>prev=NULL</code>, 这样虽然避免了类型引发的
问题，也能保证功能正确，但是却破坏了一致性，使得操作的复杂度上升，增加了许多
判断分支。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#888>// delelt a node
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#888></span><span style=color:#888;font-weight:700>void</span> <span style=color:#06b;font-weight:700>del_node</span>(<span style=color:#080;font-weight:700>struct</span> hlist_head *head, <span style=color:#080;font-weight:700>struct</span> hlist_node *node)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>    <span style=color:#888>// 这个if 本来是不需要的，甚至参数的head 也不需要传，
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span><span style=color:#888></span>    <span style=color:#888>// 更好的处理方式见解决方案2
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span><span style=color:#888></span>    <span style=color:#080;font-weight:700>if</span> (node == head-&gt;first) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>        head-&gt;first = node-&gt;next;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    <span style=color:#080;font-weight:700>else</span> {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>        node-&gt;prev-&gt;next = node-&gt;next;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>    <span style=color:#080;font-weight:700>if</span> (node-&gt;next) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>        node-&gt;next-&gt;prev = node-&gt;prev;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>}
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span><span style=color:#888>// insert a node
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span><span style=color:#888></span><span style=color:#888;font-weight:700>void</span> <span style=color:#06b;font-weight:700>add_node_before</span>(<span style=color:#080;font-weight:700>struct</span> hlist_head *head, <span style=color:#080;font-weight:700>struct</span> hlist_node *new
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>                        <span style=color:#080;font-weight:700>struct</span> hlist_node *next)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span>    <span style=color:#888>// 这个if 本来是不需要的，参数head也是不需要传递的
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span><span style=color:#888></span>    <span style=color:#080;font-weight:700>if</span> (next == head-&gt;first) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span>        new-&gt;prev = <span style=color:#038>NULL</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24</span><span>        head-&gt;first = new;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26</span><span>    <span style=color:#080;font-weight:700>else</span> {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27</span><span>        new-&gt;prev = next-&gt;prev;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28</span><span>        new-&gt;prev-&gt;next = new;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30</span><span>    new-&gt;next = next;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31</span><span>    next-&gt;prev = new;
</span></span></code></pre></div><h2 id=更好的解决方案-prev>更好的解决方案: <code>**prev</code></h2><p>改变<code>struct hlist_node</code>的构成，使用二级指针:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#080;font-weight:700>struct</span> hlist_node {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>    <span style=color:#080;font-weight:700>struct</span> hlist_node *next;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>    <span style=color:#080;font-weight:700>struct</span> hlist_node **pprev;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>};
</span></span></code></pre></div><p>使得每个结点的<code>pprev = &(prev_node->next)</code>, 首先类型是统一的，其次删除和添加
都无需额外的分支了。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#888;font-weight:700>void</span> <span style=color:#06b;font-weight:700>del_node</span>(<span style=color:#080;font-weight:700>struct</span> hlist_node *node)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>    *(node-&gt;pprev) = node-&gt;next;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>    <span style=color:#080;font-weight:700>if</span> (node-&gt;next)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>        node-&gt;next-&gt;pprev = node-&gt;pprev;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>}
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span><span style=color:#888;font-weight:700>void</span> <span style=color:#06b;font-weight:700>add_node</span>(<span style=color:#080;font-weight:700>struct</span> hlist_node *new, <span style=color:#080;font-weight:700>struct</span> hlist_node *next)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    new-&gt;pprev = next-&gt;pprev;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>    *(new-&gt;pprev) = new;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>    new-&gt;next = next;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>    next-&gt;pprev = &amp;(new-&gt;next);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>}
</span></span></code></pre></div><p>Ref:</p><ul><li><a href=https://zhuanlan.zhihu.com/p/360217911><code>**prev</code> 可以提高删除的效率</a></li><li>stackoverflow</li></ul></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2023-05-11T20:51:49, Lastmod: 2023-09-24T18:08:59</p></main></div></body></html>