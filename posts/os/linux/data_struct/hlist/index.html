<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>Linux 内核数据结构 hlist</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%ba%8c%e8%b1%a1%e6%80%a7 aria-label=二象性>二象性</a></li><li><a href=#%e6%9b%b4%e5%a5%bd%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88-prev aria-label="更好的解决方案: **prev">更好的解决方案: <code>**prev</code></a></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>Linux 内核数据结构 hlist</div></header><p>linux 内核为创建【用单链表解决冲突的哈希表】设计了专门的数据结构 hlist。</p><p>hlist 整体来说是带头结点的双向链表，头结点的类型为<code>hlist_head</code>, 普通节点
的类型为<code>hlist_node</code>. <strong>为什么要区别两种类型？节约空间</strong>， 因为哈希表的
表项类型可以是<code>hlist_head</code>, 它其实不需要<code>prev</code>指针, 比起一般的结点，一个
哈希表能节约一半的空间。</p><p>所以一个哈希表和头结点的结构可表示为:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>struct</span> hlist_head {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>    <span style=color:#ff79c6>struct</span> hlist_node <span style=color:#ff79c6>*</span>first;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>};
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span><span style=color:#ff79c6>struct</span> hlist_head table[TALBE_SZ];
</span></span></code></pre></div><h2 id=二象性>二象性</h2><p>任何事物都具有二象性，区分两种类型节约空间的空间，也带了一个问题：
<strong>首个<code>hlist_node</code>结点的<code>prev</code>指向哪呢？</strong></p><p>正常情况下肯定毫不犹豫的指向头结点，即<code>hlist_head</code>，但注意此时类型是
不同的，<code>prev</code>不能同时是<code>struct hlist_head*</code>和<code>struct hlist_node *</code>。</p><p>解决方案有两个，首先可以使首个结点的<code>prev=NULL</code>, 这样虽然避免了类型引发的
问题，也能保证功能正确，但是却破坏了一致性，使得操作的复杂度上升，增加了许多
判断分支。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#6272a4>// delelt a node
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#6272a4></span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>del_node</span>(<span style=color:#ff79c6>struct</span> hlist_head <span style=color:#ff79c6>*</span>head, <span style=color:#ff79c6>struct</span> hlist_node <span style=color:#ff79c6>*</span>node)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>    <span style=color:#6272a4>// 这个if 本来是不需要的，甚至参数的head 也不需要传，
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// 更好的处理方式见解决方案2
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> (node <span style=color:#ff79c6>==</span> head<span style=color:#ff79c6>-&gt;</span>first) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>        head<span style=color:#ff79c6>-&gt;</span>first <span style=color:#ff79c6>=</span> node<span style=color:#ff79c6>-&gt;</span>next;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>        node<span style=color:#ff79c6>-&gt;</span>prev<span style=color:#ff79c6>-&gt;</span>next <span style=color:#ff79c6>=</span> node<span style=color:#ff79c6>-&gt;</span>next;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>    <span style=color:#ff79c6>if</span> (node<span style=color:#ff79c6>-&gt;</span>next) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>        node<span style=color:#ff79c6>-&gt;</span>next<span style=color:#ff79c6>-&gt;</span>prev <span style=color:#ff79c6>=</span> node<span style=color:#ff79c6>-&gt;</span>prev;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>}
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span><span style=color:#6272a4>// insert a node
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span><span style=color:#6272a4></span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>add_node_before</span>(<span style=color:#ff79c6>struct</span> hlist_head <span style=color:#ff79c6>*</span>head, <span style=color:#ff79c6>struct</span> hlist_node <span style=color:#ff79c6>*</span>new
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>                        <span style=color:#ff79c6>struct</span> hlist_node <span style=color:#ff79c6>*</span>next)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span>    <span style=color:#6272a4>// 这个if 本来是不需要的，参数head也是不需要传递的
</span></span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> (next <span style=color:#ff79c6>==</span> head<span style=color:#ff79c6>-&gt;</span>first) {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span>        new<span style=color:#ff79c6>-&gt;</span>prev <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>NULL</span>;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24</span><span>        head<span style=color:#ff79c6>-&gt;</span>first <span style=color:#ff79c6>=</span> new;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26</span><span>    <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27</span><span>        new<span style=color:#ff79c6>-&gt;</span>prev <span style=color:#ff79c6>=</span> next<span style=color:#ff79c6>-&gt;</span>prev;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28</span><span>        new<span style=color:#ff79c6>-&gt;</span>prev<span style=color:#ff79c6>-&gt;</span>next <span style=color:#ff79c6>=</span> new;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30</span><span>    new<span style=color:#ff79c6>-&gt;</span>next <span style=color:#ff79c6>=</span> next;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31</span><span>    next<span style=color:#ff79c6>-&gt;</span>prev <span style=color:#ff79c6>=</span> new;
</span></span></code></pre></div><h2 id=更好的解决方案-prev>更好的解决方案: <code>**prev</code></h2><p>改变<code>struct hlist_node</code>的构成，使用二级指针:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#ff79c6>struct</span> hlist_node {
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>    <span style=color:#ff79c6>struct</span> hlist_node <span style=color:#ff79c6>*</span>next;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>    <span style=color:#ff79c6>struct</span> hlist_node <span style=color:#ff79c6>**</span>pprev;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>};
</span></span></code></pre></div><p>使得每个结点的<code>pprev = &(prev_node->next)</code>, 首先类型是统一的，其次删除和添加
都无需额外的分支了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>del_node</span>(<span style=color:#ff79c6>struct</span> hlist_node <span style=color:#ff79c6>*</span>node)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>    <span style=color:#ff79c6>*</span>(node<span style=color:#ff79c6>-&gt;</span>pprev) <span style=color:#ff79c6>=</span> node<span style=color:#ff79c6>-&gt;</span>next;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>    <span style=color:#ff79c6>if</span> (node<span style=color:#ff79c6>-&gt;</span>next)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>        node<span style=color:#ff79c6>-&gt;</span>next<span style=color:#ff79c6>-&gt;</span>pprev <span style=color:#ff79c6>=</span> node<span style=color:#ff79c6>-&gt;</span>pprev;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>}
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>add_node</span>(<span style=color:#ff79c6>struct</span> hlist_node <span style=color:#ff79c6>*</span>new, <span style=color:#ff79c6>struct</span> hlist_node <span style=color:#ff79c6>*</span>next)
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>{
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    new<span style=color:#ff79c6>-&gt;</span>pprev <span style=color:#ff79c6>=</span> next<span style=color:#ff79c6>-&gt;</span>pprev;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>    <span style=color:#ff79c6>*</span>(new<span style=color:#ff79c6>-&gt;</span>pprev) <span style=color:#ff79c6>=</span> new;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>    new<span style=color:#ff79c6>-&gt;</span>next <span style=color:#ff79c6>=</span> next;
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>    next<span style=color:#ff79c6>-&gt;</span>pprev <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>&amp;</span>(new<span style=color:#ff79c6>-&gt;</span>next);
</span></span><span style=display:flex><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>}
</span></span></code></pre></div><p>Ref:</p><ul><li><a href=https://zhuanlan.zhihu.com/p/360217911><code>**prev</code> 可以提高删除的效率</a></li><li>stackoverflow</li></ul></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2023-05-11T20:51:49, Lastmod: 2023-09-24T18:08:59</p></main></div></body></html>