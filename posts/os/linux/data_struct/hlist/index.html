<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/syntax_pastie.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>Linux 内核数据结构 hlist</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item" href>BACK</div><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%ba%8c%e8%b1%a1%e6%80%a7 aria-label=二象性>二象性</a></li><li><a href=#%e6%9b%b4%e5%a5%bd%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88-prev aria-label="更好的解决方案: **prev">更好的解决方案: <code>**prev</code></a></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>Linux 内核数据结构 hlist</div></header><p>linux 内核为创建【用单链表解决冲突的哈希表】设计了专门的数据结构 hlist。</p><p>hlist 整体来说是带头结点的双向链表，头结点的类型为<code>hlist_head</code>, 普通节点
的类型为<code>hlist_node</code>. <strong>为什么要区别两种类型？节约空间</strong>， 因为哈希表的
表项类型可以是<code>hlist_head</code>, 它其实不需要<code>prev</code>指针, 比起一般的结点，一个
哈希表能节约一半的空间。</p><p>所以一个哈希表和头结点的结构可表示为:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>hlist_head</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>hlist_node</span> <span class=o>*</span><span class=n>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>hlist_head</span> <span class=n>table</span><span class=p>[</span><span class=n>TALBE_SZ</span><span class=p>];</span>
</span></span></code></pre></div><h2 id=二象性>二象性</h2><p>任何事物都具有二象性，区分两种类型节约空间的空间，也带了一个问题：
<strong>首个<code>hlist_node</code>结点的<code>prev</code>指向哪呢？</strong></p><p>正常情况下肯定毫不犹豫的指向头结点，即<code>hlist_head</code>，但注意此时类型是
不同的，<code>prev</code>不能同时是<code>struct hlist_head*</code>和<code>struct hlist_node *</code>。</p><p>解决方案有两个，首先可以使首个结点的<code>prev=NULL</code>, 这样虽然避免了类型引发的
问题，也能保证功能正确，但是却破坏了一致性，使得操作的复杂度上升，增加了许多
判断分支。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// delelt a node
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>del_node</span><span class=p>(</span><span class=k>struct</span> <span class=n>hlist_head</span> <span class=o>*</span><span class=n>head</span><span class=p>,</span> <span class=k>struct</span> <span class=n>hlist_node</span> <span class=o>*</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 这个if 本来是不需要的，甚至参数的head 也不需要传，
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 更好的处理方式见解决方案2
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=o>==</span> <span class=n>head</span><span class=o>-&gt;</span><span class=n>first</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>head</span><span class=o>-&gt;</span><span class=n>first</span> <span class=o>=</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span><span class=o>-&gt;</span><span class=n>prev</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>prev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// insert a node
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>add_node_before</span><span class=p>(</span><span class=k>struct</span> <span class=n>hlist_head</span> <span class=o>*</span><span class=n>head</span><span class=p>,</span> <span class=k>struct</span> <span class=n>hlist_node</span> <span class=o>*</span><span class=n>new</span>
</span></span><span class=line><span class=cl>                        <span class=k>struct</span> <span class=n>hlist_node</span> <span class=o>*</span><span class=n>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 这个if 本来是不需要的，参数head也是不需要传递的
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>next</span> <span class=o>==</span> <span class=n>head</span><span class=o>-&gt;</span><span class=n>first</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>new</span><span class=o>-&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>head</span><span class=o>-&gt;</span><span class=n>first</span> <span class=o>=</span> <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>new</span><span class=o>-&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=n>next</span><span class=o>-&gt;</span><span class=n>prev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>new</span><span class=o>-&gt;</span><span class=n>prev</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>new</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>next</span><span class=o>-&gt;</span><span class=n>prev</span> <span class=o>=</span> <span class=n>new</span><span class=p>;</span>
</span></span></code></pre></div><h2 id=更好的解决方案-prev>更好的解决方案: <code>**prev</code></h2><p>改变<code>struct hlist_node</code>的构成，使用二级指针:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>hlist_node</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>hlist_node</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>hlist_node</span> <span class=o>**</span><span class=n>pprev</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>使得每个结点的<code>pprev = &(prev_node->next)</code>, 首先类型是统一的，其次删除和添加
都无需额外的分支了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>del_node</span><span class=p>(</span><span class=k>struct</span> <span class=n>hlist_node</span> <span class=o>*</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>pprev</span><span class=p>)</span> <span class=o>=</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>pprev</span> <span class=o>=</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>pprev</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>add_node</span><span class=p>(</span><span class=k>struct</span> <span class=n>hlist_node</span> <span class=o>*</span><span class=n>new</span><span class=p>,</span> <span class=k>struct</span> <span class=n>hlist_node</span> <span class=o>*</span><span class=n>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>new</span><span class=o>-&gt;</span><span class=n>pprev</span> <span class=o>=</span> <span class=n>next</span><span class=o>-&gt;</span><span class=n>pprev</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=n>new</span><span class=o>-&gt;</span><span class=n>pprev</span><span class=p>)</span> <span class=o>=</span> <span class=n>new</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>new</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>next</span><span class=o>-&gt;</span><span class=n>pprev</span> <span class=o>=</span> <span class=o>&amp;</span><span class=p>(</span><span class=n>new</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Ref:</p><ul><li><a href=https://zhuanlan.zhihu.com/p/360217911><code>**prev</code> 可以提高删除的效率</a></li><li>stackoverflow</li></ul></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2023-05-11T20:51:49, Lastmod: 2023-09-24T18:08:59</p><script src=/js/copy-to-clipboard.js></script></main></div></body></html>