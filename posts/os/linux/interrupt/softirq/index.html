<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/syntax_pastie.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><title>Linux 中断管理: 软中断/tasklet/工作队列</title></head><body><div id=app><div id=sideContainer class=side-container><div class=nav-link-list><div class="a-block nav-link-item"><a href=/posts>最近修改</a></div><div class="a-block nav-link-item"><a href=/categories>分类 Categories</a></div><div class="a-block nav-link-item"><a href=/tags>标签 Tags</a></div><div class="a-block nav-link-item"><a href=/index.xml>RSS Feed</a></div></div></div><div id=extraContainer class=extra-container><div class="a-block nav-link-item" href><div id=fastSearch><input id=searchInput placeholder="Press '/' to focus on me"><ul id=searchResults></ul></div></div><div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e8%bd%af%e4%b8%ad%e6%96%ad aria-label=软中断>软中断</a><ul><li><a href=#%e8%a1%a8%e7%a4%ba-softirq-%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label="表示 softirq 的数据结构">表示 softirq 的数据结构</a></li><li><a href=#softirq-%e7%9a%84%e4%b8%ad%e6%96%ad%e6%b5%81%e7%a8%8b aria-label="softirq 的中断流程">softirq 的中断流程</a></li><li><a href=#ksoftirqd-%e5%86%85%e6%a0%b8%e7%ba%bf%e7%a8%8b aria-label="ksoftirqd 内核线程">ksoftirqd 内核线程</a></li></ul></li><li><a href=#tasklet aria-label=tasklet>tasklet</a><ul><li><a href=#%e8%a1%a8%e7%a4%ba-tasklet-%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label="表示 tasklet 的数据结构">表示 tasklet 的数据结构</a></li><li><a href=#tasklet-%e7%9a%84%e4%b8%ad%e6%96%ad%e6%b5%81%e7%a8%8b aria-label="tasklet 的中断流程">tasklet 的中断流程</a></li></ul></li><li><a href=#%e5%b7%a5%e4%bd%9c%e9%98%9f%e5%88%97 aria-label=工作队列>工作队列</a><ul><li><a href=#%e5%b7%a5%e4%bd%9c%e9%98%9f%e5%88%97-1 aria-label=工作队列>工作队列</a></li></ul></li></ul></div></details></div></div></div><script src=/js/fuse.js></script>
<script src=/js/fastsearch.js></script><main class=container><article><header><div class=post-title>Linux 中断管理: 软中断/tasklet/工作队列</div></header><p>软中断、tasklet、工作队列都是中断上下部分离的具体实现方案。</p><h2 id=软中断>软中断</h2><p>我们可以将某些中断配置为软中断，相当于建立一张 INTID 到软中断的映射表，这样在
中断到来时就能判断是否为软中断。</p><p>这张“表”的建立是静态的，即编译时确定的。key 为 INTID，value 为描述一个软中断
的数据结构，在下面会介绍。</p><blockquote><p><strong>软中断的服务函数必须是可重入的</strong>，即多个 CPU 可以同时执行同一个 softirq
的处理函数，涉及到的全局结构可以用 spinlock 钳制。</p></blockquote><h3 id=表示-softirq-的数据结构>表示 softirq 的数据结构</h3><p><code>struct softirq_action</code>代表一个软中断，系统中所有支持的软中断组成一个数据
<code>softirq_vec[]</code>, 所有的软中断按照优先级来分配下标。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>softirq_action</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 指向softirq的处理函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>action</span><span class=p>)(</span><span class=k>struct</span> <span class=n>softirq_action</span> <span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=softirq-的中断流程>softirq 的中断流程</h3><p>在中断的上部，如果识别到当前中断是一个 softirq， 那么系统会标记一个软中断发生，
即<code>raise_softirq()</code>函数。其做的事情包括:</p><ol><li>标记某个软中断发生，记录的结构是<code>irq_cpustate_t.__softirq_pending</code>
(这个字段使<code>loca_softirq_pending()</code>访问)</li><li>唤醒<code>ksoftirqd</code>内核线程，之后介绍</li></ol><p>光标记不行，那么什么时候执行它们的服务函数呢？</p><p>几个可能的检查点:(1) 中断退出前 (2)<code>ksoftirq</code>被唤醒时</p><p>如果在检查点发现有标记挂起的 softirq(<code>local_softirq_pending()</code> != 0),
内核调用<code>do_softirq()</code>处理它们：</p><ol><li>如何<code>in_interrupt()</code>返回非 0， 直接返回。此时代表要么禁用了 softirq，要么当前是
在中断嵌套的环境下，也可能正在执行<code>do_softirq()</code>时中断嵌套的，而<code>do_softirq()</code>
函数是不能嵌套执行的。</li><li>调用<code>__dosoft_irq()</code>, 对于<code>local_softirq_pending()</code>的每一位都调用其
<code>softirq_vec[nr]->action()</code></li></ol><p>这里有个重要的问题，此时处于中断下部，即开中断的情况，所以在处理 softirq 时会有新的
softirq 到来，这里就有两种策略：</p><ol><li>不断的获取最新的<code>local_softirq_pending()</code>, 直到不再有新的 softirq 产生才返回</li><li>忽略新来的 softirq，使其在下次检查点再被处理</li></ol><p>这两种方案其实各有利弊，首先<strong>第一种方案</strong>，提高了 softirq 的响应速度，但如何 softirq
过多或者处理时间太长就会导致用户态线程已知得不到运行；而<strong>第二种方案</strong>则会增加
softirq 的响应延迟。</p><p>实际上，softirq 的处理函数<code>do_softirq()</code>是采用折中的方案，它会在内部循环检查 10 次
（是可配置的），检查有无新的 softirq 到来。对于那些在循环之后到来的 softirq，那么
唤醒 ksoftirqd 线程来处理剩下的，不延迟用户态的运行。</p><h3 id=ksoftirqd-内核线程>ksoftirqd 内核线程</h3><p>ksoftirqd 是一个内核线程，每个 CPU 都有，它的任务是不断检查是否存在挂起的 softirq， 并
执行其处理函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>for</span> <span class=p>(;;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>set_current_state</span><span class=p>(</span><span class=n>TASK_INTERRUPTABLE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>schedule</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>local_softirq_pending</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>preempt_disable</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>do_softirq</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>preempt_enable</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>ksoftirqd 的优先级较低，这样当<code>do_softirq()</code>循环 10 次还有新的 softirq 时，
唤醒 ksoftirqd 线程不会耽误用户态的执行，但当系统空闲时间，挂起的 softirq 又
会很快得到处理。</p><h2 id=tasklet>tasklet</h2><p>tasklet 是基于其中一个软中断(TASKLET_SOFTIRQ)构建，其关系有点像线程与用户态
线程之间那种嵌套关系。</p><p>tasklet 的分配可以是运行时确定的(例如使用 insmod)增加新的 tasklet。</p><blockquote><p>内核对 tasklet 的服务函数进行了更加严格的控制：<strong>不能在多个 CPU 上同时运行同一个类型的
tasklet 函数(不同类型的 tasklet 可以)。</strong>，这样就使得 tasklet 服务函数不必非得
实现为可重入的， 简化驱动开发者的工作。</p></blockquote><h3 id=表示-tasklet-的数据结构>表示 tasklet 的数据结构</h3><p>描述一个 tasklet 的数据结构为<code>tasklet_struct</code>, 成员包括:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>tasklet_struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 指向下一个tasklet，所有tasklet链表串联
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>tasklet_struct</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>state</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// tasklet 对应的处理函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>func</span><span class=p>)(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// func 中可以使用的数据
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=tasklet-的中断流程>tasklet 的中断流程</h3><p><code>TASKLET_SOFTIRQ</code>的 action 指向遍历所有<code>tasklet_struct</code>的方法，该方法中
执行每个 tasklet 的<code>func()</code>。</p><h2 id=工作队列>工作队列</h2><p>工作队列创建了一个内核线程<code>kworker</code>, 原理与<code>ksoftirqd</code>差不多。</p><p>主要的区别是<code>ksoftirqd</code>运行在中断的上下文，因为其调用了<code>do_softirq()</code>,
而中断上下文中是禁用用户抢占的，也就是说不能发生调度(不影响嵌套中断)。</p><blockquote><p>中断上下文中禁止抢占的原因是<strong>开启了中断嵌套</strong>，代价是必须禁止抢占。
如果同时允许中断嵌套和抢占，那么“嵌套的”中断返回时如果发生了调度，
返回别的高优先级的进程去了，此时初级的中断还未结束。如此时在新进程里
又发生了初级类型同样的中断，就很有可能发生数据不一定或者死锁。</p></blockquote><p>工作队列是运行在进程的上下文中的，也就是一般情况下。此时当然可以发生
抢占，所以工作队列<strong>适用于那种需要中断服务函数需要发生调度的情况</strong>，
比如说调用了<code>sleep()</code>.</p><h3 id=工作队列-1>工作队列</h3></article></body><hr width=100% id=EOF><p style=color:#777>创建于: 2023-05-13T20:51:49, Lastmod: 2023-09-24T18:08:59</p><script src=/js/copy-to-clipboard.js></script></main></div></body></html>